[
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played in an abstract environment involving a sequence of six distinct pancake elements labeled p1 through p6, arranged in an initial order of p5, p3, p6, p1, p4, and p2. The coordinate system is implicit in the ordering of these pancakes, with the sequence representing their positions. There is a single player role, called \"flipper,\" who takes turns performing actions in a fixed turn order that cycles through the six pancakes. Each turn, the flipper may choose to flip one pancake from the set of pancakes currently in play; the legality of an action is determined by whether the chosen pancake is present in the current order. When the flipper flips a specific pancake, the order of pancakes is rearranged according to a pattern where the flipped pancake moves to the front, and the order of pancakes before it is reversed, effectively reordering the sequence based on the position of the flipped pancake. Each flip increments a flip count that starts at zero and increases by one with every flip action taken. The game enforces implicit constraints such as the fixed set of pancakes and their unique positions in the order, with no duplicate pancakes allowed, and all flips must be performed on pancakes currently in the sequence. The game terminates either when the pancake order is restored to the original ascending sequence p1, p2, p3, p4, p5, p6 or when the flip count reaches forty moves, whichever comes first. The scoring system assigns a victory value to the flipper based on the number of flips taken to achieve the sorted order; if the pancakes are sorted in fewer than eight flips, the player scores the maximum of 100 points, with the score decreasing progressively in increments as the flip count increases, reaching zero points if the flip count hits forty without sorting the pancakes. The turn control ensures the player must make a move each turn by flipping a pancake; there is no explicit noop action, so the player cannot skip a move. Overall, the game challenges the single flipper player to reorder the pancakes into the correct sequence efficiently, balancing the strategic choice of which pancake to flip each turn to minimize the total flips required before the terminal conditions end the game.",
    "output": "(role flipper)\n(init (porder p5 p3 p6 p1 p4 p2))\n(init (flipcount s0))\n(pancake p1)\n(pancake p2)\n(pancake p3)\n(pancake p4)\n(pancake p5)\n(pancake p6)\n(succ s0 s1)\n(succ s1 s2)\n(succ s2 s3)\n(succ s3 s4)\n(succ s4 s5)\n(succ s5 s6)\n(succ s6 s7)\n(succ s7 s8)\n(succ s8 s9)\n(succ s9 s10)\n(succ s10 s11)\n(succ s11 s12)\n(succ s12 s13)\n(succ s13 s14)\n(succ s14 s15)\n(succ s15 s16)\n(succ s16 s17)\n(succ s17 s18)\n(succ s18 s19)\n(succ s19 s20)\n(succ s20 s21)\n(succ s21 s22)\n(succ s22 s23)\n(succ s23 s24)\n(succ s24 s25)\n(succ s25 s26)\n(succ s26 s27)\n(succ s27 s28)\n(succ s28 s29)\n(succ s29 s30)\n(succ s30 s31)\n(succ s31 s32)\n(succ s32 s33)\n(succ s33 s34)\n(succ s34 s35)\n(succ s35 s36)\n(succ s36 s37)\n(succ s37 s38)\n(succ s38 s39)\n(succ s39 s40)\n(<= (greater ?a ?b)\n    (succ ?b ?a))\n(<= (greater ?a ?b)\n    (distinct ?a ?b)\n    (succ ?c ?a)\n    (greater ?c ?b))\n(<= (legal flipper (flip ?x))\n    (pancake ?x))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p1))\n    (true (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p2))\n    (true (porder ?ng2 ?ng1 ?ng3 ?ng4 ?ng5 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p3))\n    (true (porder ?ng3 ?ng2 ?ng1 ?ng4 ?ng5 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p4))\n    (true (porder ?ng4 ?ng3 ?ng2 ?ng1 ?ng5 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p5))\n    (true (porder ?ng5 ?ng4 ?ng3 ?ng2 ?ng1 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p6))\n    (true (porder ?ng6 ?ng5 ?ng4 ?ng3 ?ng2 ?ng1)))\n(<= (next (flipcount ?b))\n    (true (flipcount ?v))\n    (succ ?v ?b))\n(<= (goal flipper 100)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount ?x))\n    (greater s8 ?x))\n(<= (goal flipper 90)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s8)))\n(<= (goal flipper 85)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s9)))\n(<= (goal flipper 80)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s10)))\n(<= (goal flipper 75)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s11)))\n(<= (goal flipper 70)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s12)))\n(<= (goal flipper 65)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s13)))\n(<= (goal flipper 60)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s14)))\n(<= (goal flipper 55)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s15)))\n(<= (goal flipper 50)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s16)))\n(<= (goal flipper 45)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s17)))\n(<= (goal flipper 40)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount ?x))\n    (greater ?x s17)\n    (greater s25 ?x))\n(<= (goal flipper 35)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount ?x))\n    (greater ?x s24)\n    (greater s30 ?x))\n(<= (goal flipper 30)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount ?x))\n    (greater ?x s29)\n    (greater s40 ?x))\n(<= (goal flipper 0)\n    (true (flipcount s40)))\n(<= terminal\n    (true (porder p1 p2 p3 p4 p5 p6)))\n(<= terminal\n    (true (flipcount s40)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played in an abstract environment involving two separate sets of blocks arranged on two parallel conceptual tables, each with its own coordinate system defined implicitly by block positions and clear status. The single player role, named \"robot,\" controls the manipulation of blocks in two distinct phases or subgames, referred to as game 1 and game 2, executed sequentially. The initial state sets blocks 'a,' 'b,' and 'c' on both tables, with block 'c' stacked on block 'a' and blocks 'a' and 'b' placed on the table surface; all blocks 'b' and 'c' are initially clear, meaning no block is on top of them. The player \"robot\" alternates between two modes of operation: before the first subgame terminates, the player’s legal moves are restricted to stacking and unstacking actions on the first table (denoted with suffix 1), while after the first subgame ends, the player can perform analogous actions on the second table (denoted with suffix 2). A turn consists of the player performing a single action, which must be legal according to specific conditions: to stack a block x onto a block y, both x and y must be clear and on their respective tables, and x and y must be distinct blocks; to unstack block x from block y, block x must be clear and directly on block y. If the game is over for the first subgame, actions must correspond to the second subgame rules, otherwise they correspond to the first. There is no explicit mention of a noop action, implying the player must always perform a legal stacking or unstacking move when possible. Each action triggers state changes that update the positions of blocks (which block is on which), the clear status of blocks involved, and the presence of blocks on the table. The step counters for each subgame increment with each action taken: for subgame one, the step counter advances from 1 up to 4, at which point the subgame ends and the game transitions to subgame two; for subgame two, the steps similarly progress until four moves have been made, whereupon the entire game terminates. Implicit constraints include the requirement that blocks remain within their respective tables, that stacking only occurs on clear blocks, and that no two blocks can occupy the same position simultaneously. The game ends when the step counter reaches four in the second subgame. Scoring is determined by the arrangement of blocks: the player receives 100 points if blocks 'a' are stacked on 'b' and 'b' on 'c' in both subgames; if only one subgame achieves this arrangement, the player scores 50 points; if neither arrangement is achieved, the score is zero. Thus, victory is achieved by correctly stacking the blocks in the specified order within four moves in each subgame, with the robot controlling all movements sequentially across two phases, each with distinct but structurally similar rules governing block manipulation.",
    "output": "(role robot)\n(init (clear1 b))\n(init (clear1 c))\n(init (on1 c a))\n(init (table1 a))\n(init (table1 b))\n(init (step1 1))\n(init (clear2 b))\n(init (clear2 c))\n(init (on2 c a))\n(init (table2 a))\n(init (table2 b))\n(init (step2 1))\n(<= (legal robot (stack1 ?x ?y))\n    (not game1Over)\n    (legalStack1 ?x ?y))\n(<= (legal robot (unstack1 ?x ?y))\n    (not game1Over)\n    (legalUnstack1 ?x ?y))\n(<= (legal robot (stack2 ?x ?y))\n    game1Over\n    (legalStack2 ?x ?y))\n(<= (legal robot (unstack2 ?x ?y))\n    game1Over\n    (legalUnstack2 ?x ?y))\n(<= (next (on1 ?x ?y))\n    (does robot (stack1 ?x ?y)))\n(<= (next (on1 ?x ?y))\n    (true (on1 ?x ?y))\n    (does robot (unstack1 ?w ?z))\n    (distinct ?x ?w))\n(<= (next (on1 ?x ?y))\n    (true (on1 ?x ?y))\n    (does robot (stack1 ?w ?z))\n    (distinct ?x ?w))\n(<= (next (on1 ?x ?y))\n    (true (on1 ?x ?y))\n    game1Over)\n(<= (next (table1 ?x))\n    (does robot (unstack1 ?x ?y)))\n(<= (next (table1 ?x))\n    (true (table1 ?x))\n    (does robot (unstack1 ?y ?z)))\n(<= (next (table1 ?x))\n    (true (table1 ?x))\n    (does robot (stack1 ?y ?z))\n    (distinct ?x ?y))\n(<= (next (table1 ?x))\n    (true (table1 ?x))\n    game1Over)\n(<= (next (clear1 ?y))\n    (does robot (unstack1 ?x ?y)))\n(<= (next (clear1 ?y))\n    (true (clear1 ?y))\n    (does robot (unstack1 ?x ?z)))\n(<= (next (clear1 ?y))\n    (true (clear1 ?y))\n    (does robot (stack1 ?x ?z))\n    (distinct ?y ?z))\n(<= (next (clear1 ?x))\n    (true (clear1 ?x))\n    game1Over)\n(<= (next (step1 ?y))\n    (not game1Over)\n    (true (step1 ?x))\n    (succ ?x ?y))\n(<= (next (step1 ?x))\n    game1Over\n    (true (step1 ?x)))\n(<= (next (on2 ?x ?y))\n    (does robot (stack2 ?x ?y)))\n(<= (next (on2 ?x ?y))\n    (true (on2 ?x ?y))\n    (does robot (unstack2 ?w ?z))\n    (distinct ?x ?w))\n(<= (next (on2 ?x ?y))\n    (true (on2 ?x ?y))\n    (does robot (stack2 ?w ?z))\n    (distinct ?x ?w))\n(<= (next (on2 ?x ?y))\n    (true (on2 ?x ?y))\n    (not game1Over))\n(<= (next (table2 ?x))\n    (does robot (unstack2 ?x ?y)))\n(<= (next (table2 ?x))\n    (true (table2 ?x))\n    (does robot (unstack2 ?y ?z)))\n(<= (next (table2 ?x))\n    (true (table2 ?x))\n    (does robot (stack2 ?y ?z))\n    (distinct ?x ?y))\n(<= (next (table2 ?x))\n    (true (table2 ?x))\n    (not game1Over))\n(<= (next (clear2 ?y))\n    (does robot (unstack2 ?x ?y)))\n(<= (next (clear2 ?y))\n    (true (clear2 ?y))\n    (does robot (unstack2 ?x ?z)))\n(<= (next (clear2 ?y))\n    (true (clear2 ?y))\n    (does robot (stack2 ?x ?z))\n    (distinct ?y ?z))\n(<= (next (clear2 ?x))\n    (true (clear2 ?x))\n    (not game1Over))\n(<= (next (step2 ?y))\n    game1Over\n    (true (step2 ?x))\n    (succ ?x ?y))\n(<= (next (step2 ?x))\n    (not game1Over)\n    (true (step2 ?x)))\n(<= (next game1OverLock)\n    game1TermCond)\n(<= (next game1OverLock)\n    (true game1OverLock))\n(<= terminal\n    game2TermCond)\n(<= (goal robot 100)\n    goal1-100\n    goal2-100)\n(<= (goal robot 50)\n    goal1-100\n    goal2-0)\n(<= (goal robot 50)\n    goal1-0\n    goal2-100)\n(<= (goal robot 0)\n    goal1-0\n    goal2-0)\n(<= game1Over\n    game1TermCond)\n(<= game1Over\n    (true game1OverLock))\n(<= game1TermCond\n    (true (step1 4)))\n(<= game2TermCond\n    (true (step2 4)))\n(<= goal1-100\n    (true (on1 a b))\n    (true (on1 b c)))\n(<= goal1-0\n    (not (true (on1 a b))))\n(<= goal1-0\n    (not (true (on1 b c))))\n(<= goal2-100\n    (true (on2 a b))\n    (true (on2 b c)))\n(<= goal2-0\n    (not (true (on2 a b))))\n(<= goal2-0\n    (not (true (on2 b c))))\n(<= (legalStack1 ?x ?y)\n    (true (clear1 ?x))\n    (true (table1 ?x))\n    (true (clear1 ?y))\n    (distinct ?x ?y))\n(<= (legalUnstack1 ?x ?y)\n    (true (clear1 ?x))\n    (true (on1 ?x ?y)))\n(<= (legalStack2 ?x ?y)\n    (true (clear2 ?x))\n    (true (table2 ?x))\n    (true (clear2 ?y))\n    (distinct ?x ?y))\n(<= (legalUnstack2 ?x ?y)\n    (true (clear2 ?x))\n    (true (on2 ?x ?y)))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8 by 8 grid with coordinates ranging from 1 to 8 for both the x (horizontal) and y (vertical) axes. There are two players, designated as white and black, who take turns alternately starting with white. Initially, white occupies all cells in the first two rows (y=1 and y=2) across all columns (x=1 to 8), while black occupies all cells in the last two rows (y=7 and y=8) across all columns. On a player’s turn, they may either move one of their pieces or perform a noop if it is not their turn. A move consists of shifting a piece from its current cell to a legally adjacent cell under specific conditions. For white, legal moves involve moving a piece forward one cell vertically (from y to y+1) either straight ahead or diagonally by one column to the left or right, provided the destination cell is empty or not occupied by another white piece; similarly, black moves forward one cell vertically downward (from y to y−1) with the same lateral options, ensuring the destination is not occupied by black. Moves cannot wrap around the board edges, and pieces cannot move onto cells occupied by their own color. Noops are only legal when it is the opponent’s turn to move. After a move, the piece relocates to the new cell, the origin cell becomes empty, and control passes to the other player. The game ends when a white piece reaches the top row (y=8), or black reaches the bottom row (y=1), or when one player no longer has any pieces on the board. Upon termination, the player who achieved these conditions wins and receives a score of 100, while the opponent gets 0. The game enforces constraints such as the board boundaries, distinctness of source and destination cells in moves, and ensures that a cell is either empty or occupied by only one piece at a time, effectively preventing overlap. Thus, the objective is to strategically advance pieces forward toward the opponent’s baseline or eliminate all opposing pieces to secure victory.",
    "output": "(role white)\n(role black)\n(init (cellHolds 1 1 white))\n(init (cellHolds 2 1 white))\n(init (cellHolds 3 1 white))\n(init (cellHolds 4 1 white))\n(init (cellHolds 5 1 white))\n(init (cellHolds 6 1 white))\n(init (cellHolds 7 1 white))\n(init (cellHolds 8 1 white))\n(init (cellHolds 1 2 white))\n(init (cellHolds 2 2 white))\n(init (cellHolds 3 2 white))\n(init (cellHolds 4 2 white))\n(init (cellHolds 5 2 white))\n(init (cellHolds 6 2 white))\n(init (cellHolds 7 2 white))\n(init (cellHolds 8 2 white))\n(init (cellHolds 1 7 black))\n(init (cellHolds 2 7 black))\n(init (cellHolds 3 7 black))\n(init (cellHolds 4 7 black))\n(init (cellHolds 5 7 black))\n(init (cellHolds 6 7 black))\n(init (cellHolds 7 7 black))\n(init (cellHolds 8 7 black))\n(init (cellHolds 1 8 black))\n(init (cellHolds 2 8 black))\n(init (cellHolds 3 8 black))\n(init (cellHolds 4 8 black))\n(init (cellHolds 5 8 black))\n(init (cellHolds 6 8 black))\n(init (cellHolds 7 8 black))\n(init (cellHolds 8 8 black))\n(init (control white))\n(<= (legal white (move ?x ?y1 ?x ?y2))\n    (true (control white))\n    (true (cellHolds ?x ?y1 white))\n    (succ ?y1 ?y2)\n    (cellEmpty ?x ?y2))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cellHolds ?x1 ?y1 white))\n    (succ ?y1 ?y2)\n    (succ ?x1 ?x2)\n    (not (true (cellHolds ?x2 ?y2 white))))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cellHolds ?x1 ?y1 white))\n    (succ ?y1 ?y2)\n    (succ ?x2 ?x1)\n    (not (true (cellHolds ?x2 ?y2 white))))\n(<= (legal black (move ?x ?y1 ?x ?y2))\n    (true (control black))\n    (true (cellHolds ?x ?y1 black))\n    (succ ?y2 ?y1)\n    (cellEmpty ?x ?y2))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cellHolds ?x1 ?y1 black))\n    (succ ?y2 ?y1)\n    (succ ?x1 ?x2)\n    (not (true (cellHolds ?x2 ?y2 black))))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cellHolds ?x1 ?y1 black))\n    (succ ?y2 ?y1)\n    (succ ?x2 ?x1)\n    (not (true (cellHolds ?x2 ?y2 black))))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black noop)\n    (true (control white)))\n(<= (next (cellHolds ?x2 ?y2 ?player))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cellHolds ?x3 ?y3 ?state))\n    (true (cellHolds ?x3 ?y3 ?state))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x3 ?y3)\n    (distinctCell ?x2 ?y2 ?x3 ?y3))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= terminal\n    whiteWin)\n(<= terminal\n    blackWin)\n(<= (goal white 100)\n    whiteWin)\n(<= (goal white 0)\n    (not whiteWin))\n(<= (goal black 100)\n    blackWin)\n(<= (goal black 0)\n    (not blackWin))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (cellEmpty ?x ?y)\n    (cell ?x ?y)\n    (not (true (cellHolds ?x ?y white)))\n    (not (true (cellHolds ?x ?y black))))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= whiteWin\n    (index ?x)\n    (true (cellHolds ?x 8 white)))\n(<= blackWin\n    (index ?x)\n    (true (cellHolds ?x 1 black)))\n(<= whiteWin\n\t(not blackCell))\n(<= blackWin\n\t(not whiteCell))\n(<= whiteCell\n\t(cell ?x ?y)\n\t(true (cellHolds ?x ?y white)))\n(<= blackCell\n\t(cell ?x ?y)\n\t(true (cellHolds ?x ?y black)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(succ 1 2)  (succ 2 3)  (succ 3 4)  (succ 4 5)  (succ 5 6)  (succ 6 7)  (succ 7 8)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a 7-by-7 grid with coordinates ranging from 1 to 7 in both the horizontal (x) and vertical (y) directions, excluding the outermost rows and columns, effectively limiting play to the cells where both coordinates are between 2 and 6 inclusive. There are three players identified by the colors red, yellow, and blue, who take turns in a fixed rotation order: red moves first, followed by yellow, then blue, and the cycle repeats. Initially, red occupies the cell at coordinates (1,4), yellow occupies (4,1), and blue occupies (7,4), with the first turn controlled by red and the step count starting at 1. On each turn, the current player may either perform a move or pass by doing a noop action; however, a noop is only legal if the player is not currently in control or if the player has no legal moves available during their turn. A move consists of selecting one of the player’s own occupied cells and moving it to a target cell according to strict movement rules: moves can be orthogonal (one step horizontally or vertically), diagonal (one step diagonally), or in an L-shaped pattern similar to a knight's move in chess (two steps in one direction and one step perpendicular). Moves onto a target cell are legal if the destination is either occupied by an opponent’s piece (allowing capture) or is an unoccupied open cell within the board boundaries. Capturing involves moving onto a cell occupied by a different player, thereby replacing that piece. The game enforces that moves must remain on the board, which excludes the outermost rows and columns as valid positions for pieces. After a move, the control passes to the next player in the rotation sequence, and the step counter increments by one at each turn. The game automatically updates the board state to reflect the moved piece's new position, removes the piece from its original position, and maintains all other pieces unaffected unless captured. The game terminates when any player forms a line of three of their pieces in a row, column, or diagonal within the central 3-by-3 area bounded by coordinates 3 to 5 in both directions, or when the step counter reaches 31, whichever happens first. The victory condition is met if a player successfully aligns three of their pieces in any such line; that player receives a score of 100, while all other players receive zero. If no player achieves this by step 31, the game ends with all players scoring zero. The coordinate system and adjacency relationships are precisely defined to determine legal moves and winning lines, and all moves must adhere to these constraints without overlapping existing friendly pieces or moving off the playable board area.",
    "output": "(role red)\n(role yellow)\n(role blue)\n(init (control red))\n(init (cell 1 4 red))\n(init (cell 4 1 yellow))\n(init (cell 7 4 blue))\n(init (step 1))\n(<= (legal ?player noop)\n\t(role ?player)\n\t(not (true (control ?player))))\n(<= (legal ?player ?move)\n    (legal2 ?player ?move))\n(<= (hasLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasLegalMove ?player)))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(orthogonal ?x1 ?y1 ?x2 ?y2)\n\t(onboard ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?player2))\n\t(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(diagonal ?x1 ?y1 ?x2 ?y2)\n\t(onboard ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?player2))\n\t(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(ell ?x1 ?y1 ?x2 ?y2)\n\t(opencell ?x2 ?y2))\n(<= (next (control ?p2))\n\t(true (control ?p1))\n\t(rotation ?p1 ?p2))\n(<= (next (cell ?x2 ?y2 ?player))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?piece))\n\t(true (cell ?x ?y ?piece))\n\t(not (camefrom ?x ?y))\n\t(not (wentto ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n\t(spawns ?x ?y ?player))\n(<= (next (step ?t2))\n\t(true (step ?t1))\n\t(stepcount ?t1 ?t2))\n(<= terminal\n\t(role ?player)\n\t(line ?player))\n(<= terminal\n\t(true (step 31)))\n(<= (goal ?player 0)\n\t(role ?player)\n\t(not (line ?player)))\n(<= (goal ?player 100)\n\t(role ?player)\n\t(line ?player))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x1 ?x2)\n\t(index ?y))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x2 ?x1)\n\t(index ?y))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y1 ?y2))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y2 ?y1))\n(<= (opencell ?x ?y)\n\t(onboard ?x ?y)\n\t(not (true (cell ?x ?y red)))\n\t(not (true (cell ?x ?y yellow)))\n\t(not (true (cell ?x ?y blue))))\n(<= (onboard ?x ?y)\n\t(index ?x)\n\t(index ?y)\n\t(distinct ?x 1)\n\t(distinct ?x 7)\n\t(distinct ?y 1)\n\t(distinct ?y 7))\n(<= (camefrom ?x1 ?y1)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (wentto ?x2 ?y2)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (line ?player)\n\t(row ?player))\n(<= (line ?player)\n\t(column ?player))\n(<= (line ?player)\n\t(diag ?player))\n(<= (row ?player)\n\t(true (cell 3 3 ?player))\n\t(true (cell 4 3 ?player))\n\t(true (cell 5 3 ?player)))\n(<= (row ?player)\n\t(true (cell 3 4 ?player))\n\t(true (cell 4 4 ?player))\n\t(true (cell 5 4 ?player)))\n(<= (row ?player)\n\t(true (cell 3 5 ?player))\n\t(true (cell 4 5 ?player))\n\t(true (cell 5 5 ?player)))\n(<= (column ?player)\n\t(true (cell 3 3 ?player))\n\t(true (cell 3 4 ?player))\n\t(true (cell 3 5 ?player)))\n(<= (column ?player)\n\t(true (cell 4 3 ?player))\n\t(true (cell 4 4 ?player))\n\t(true (cell 4 5 ?player)))\n(<= (column ?player)\n\t(true (cell 5 3 ?player))\n\t(true (cell 5 4 ?player))\n\t(true (cell 5 5 ?player)))\n(<= (diag ?player)\n\t(true (cell 3 3 ?player))\n\t(true (cell 4 4 ?player))\n\t(true (cell 5 5 ?player)))\n(<= (diag ?player)\n\t(true (cell 3 5 ?player))\n\t(true (cell 4 4 ?player))\n\t(true (cell 5 3 ?player)))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(plus 1 1 2)\n(plus 1 2 3)\n(plus 1 3 4)\n(plus 1 4 5)\n(plus 1 5 6)\n(plus 1 6 7)\n(plus 2 1 3)\n(plus 2 2 4)\n(plus 2 3 5)\n(plus 2 4 6)\n(plus 2 5 7)\n(rotation red yellow)\n(rotation yellow blue)\n(rotation blue red)\n(spawns 1 4 red)\n(spawns 4 1 yellow)\n(spawns 7 4 blue)\n(stepcount 1 2)\n(stepcount 2 3)\n(stepcount 3 4)\n(stepcount 4 5)\n(stepcount 5 6)\n(stepcount 6 7)\n(stepcount 7 8)\n(stepcount 8 9)\n(stepcount 9 10)\n(stepcount 10 11)\n(stepcount 11 12)\n(stepcount 12 13)\n(stepcount 13 14)\n(stepcount 14 15)\n(stepcount 15 16)\n(stepcount 16 17)\n(stepcount 17 18)\n(stepcount 18 19)\n(stepcount 19 20)\n(stepcount 20 21)\n(stepcount 21 22)\n(stepcount 22 23)\n(stepcount 23 24)\n(stepcount 24 25)\n(stepcount 25 26)\n(stepcount 26 27)\n(stepcount 27 28)\n(stepcount 28 29)\n(stepcount 29 30)\n(stepcount 30 31)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game \"Flipper\" is played within an abstract environment involving eight distinct player roles labeled p1 through p8, arranged initially in the turn order p6, p1, p7, p5, p3, p8, p4, and p2. The turn order is represented as a sequence of these players, and the game state keeps track of this order along with a flip count that begins at zero. On each turn, the single role \"flipper\" may perform one action: flipping one of the pancakes identified as p1 through p8. The legality of an action depends solely on whether the targeted pancake currently exists in the game state. When the \"flipper\" chooses to flip pancake p1, the turn order remains unchanged for the next state. However, flipping any other pancake causes a rotation of the turn order such that the flipped pancake moves to the front of the sequence, effectively permuting the order by placing the flipped pancake first and shifting the preceding pancakes accordingly. Each flip increments the flip count by one. Turns proceed continuously with the \"flipper\" making a choice each time, and there is no explicit noop action; the game requires flipping one pancake each turn. Implicit constraints include the fixed set of eight pancakes and the maintenance of a valid permutation of the eight players as the turn order. The game terminates when either the turn order returns to the original sequence p1 through p8 in ascending order or when the flip count reaches 40. The scoring system assigns a numeric goal value to the \"flipper\" role based on the state of the turn order and the flip count. If the turn order is restored to p1 through p8, the score depends on how many flips have been made: the highest score of 100 is awarded if fewer than six flips have occurred, with gradually decreasing scores as the flip count increases. If the flip count reaches 40, the game ends with a score of zero. Thus, the objective is to restore the original player order in as few flips as possible, balancing the number of moves taken with the final state of the turn order to maximize the score.",
    "output": "(role flipper)\n(init (porder p6 p1 p7 p5 p3 p8 p4 p2))\n(init (flipcount s0))\n(pancake p1)\n(pancake p2)\n(pancake p3)\n(pancake p4)\n(pancake p5)\n(pancake p6)\n(pancake p7)\n(pancake p8)\n(succ s0 s1)\n(succ s1 s2)\n(succ s2 s3)\n(succ s3 s4)\n(succ s4 s5)\n(succ s5 s6)\n(succ s6 s7)\n(succ s7 s8)\n(succ s8 s9)\n(succ s9 s10)\n(succ s10 s11)\n(succ s11 s12)\n(succ s12 s13)\n(succ s13 s14)\n(succ s14 s15)\n(succ s15 s16)\n(succ s16 s17)\n(succ s17 s18)\n(succ s18 s19)\n(succ s19 s20)\n(succ s20 s21)\n(succ s21 s22)\n(succ s22 s23)\n(succ s23 s24)\n(succ s24 s25)\n(succ s25 s26)\n(succ s26 s27)\n(succ s27 s28)\n(succ s28 s29)\n(succ s29 s30)\n(succ s30 s31)\n(succ s31 s32)\n(succ s32 s33)\n(succ s33 s34)\n(succ s34 s35)\n(succ s35 s36)\n(succ s36 s37)\n(succ s37 s38)\n(succ s38 s39)\n(succ s39 s40)\n(<= (greater ?a ?b)\n    (succ ?b ?a))\n(<= (greater ?a ?b)\n    (distinct ?a ?b)\n    (succ ?c ?a)\n    (greater ?c ?b))\n(<= (legal flipper (flip ?x))\n    (pancake ?x))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8))\n    (does flipper (flip p1))\n    (true (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8))\n    (does flipper (flip p2))\n    (true (porder ?ng2 ?ng1 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8))\n    (does flipper (flip p3))\n    (true (porder ?ng3 ?ng2 ?ng1 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8))\n    (does flipper (flip p4))\n    (true (porder ?ng4 ?ng3 ?ng2 ?ng1 ?ng5 ?ng6 ?ng7 ?ng8)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8))\n    (does flipper (flip p5))\n    (true (porder ?ng5 ?ng4 ?ng3 ?ng2 ?ng1 ?ng6 ?ng7 ?ng8)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8))\n    (does flipper (flip p6))\n    (true (porder ?ng6 ?ng5 ?ng4 ?ng3 ?ng2 ?ng1 ?ng7 ?ng8)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8))\n    (does flipper (flip p7))\n    (true (porder ?ng7 ?ng6 ?ng5 ?ng4 ?ng3 ?ng2 ?ng1 ?ng8)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6 ?ng7 ?ng8))\n    (does flipper (flip p8))\n    (true (porder ?ng8 ?ng7 ?ng6 ?ng5 ?ng4 ?ng3 ?ng2 ?ng1)))\n(<= (next (flipcount ?b))\n    (true (flipcount ?v))\n    (succ ?v ?b))\n(<= (goal flipper 100)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount ?x))\n    (greater s6 ?x))\n(<= (goal flipper 90)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount s6)))\n(<= (goal flipper 85)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount s7)))\n(<= (goal flipper 80)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount s8)))\n(<= (goal flipper 75)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount s9)))\n(<= (goal flipper 70)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount s10)))\n(<= (goal flipper 65)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount s11)))\n(<= (goal flipper 60)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount s12)))\n(<= (goal flipper 50)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount ?x))\n    (greater ?x s12)\n    (greater s20 ?x))\n(<= (goal flipper 45)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount ?x))\n    (greater ?x s19)\n    (greater s30 ?x))\n(<= (goal flipper 40)\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8))\n    (true (flipcount ?x))\n    (greater ?x s29)\n    (greater s40 ?x))\n(<= (goal flipper 0)\n    (true (flipcount s40)))\n(<= terminal\n    (true (porder p1 p2 p3 p4 p5 p6 p7 p8)))\n(<= terminal\n    (true (flipcount s40)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 10-by-10 grid where both the horizontal (x) and vertical (y) coordinates range from 1 to 10, establishing a coordinate system with cells indexed from 1 through 10 along each axis. Two players, identified as white and black, participate in the game, with white making the first move followed by black, and turns alternating thereafter. Initially, each player controls four pieces placed at specific coordinates: white occupies cells (4,1), (7,1), (1,4), and (10,4), while black's pieces are at (1,7), (10,7), (4,10), and (7,10). In any turn, the player whose control it is may either perform a move action or pass by doing a noop, though a noop is only legal when it is not that player's turn. A move action involves selecting one of the player's pieces from its current location and moving it like a queen in chess—that is, along any number of unoccupied cells horizontally, vertically, or diagonally—to a new empty cell. After moving the piece, the player optionally shoots an arrow from the piece's new position, also along a queen-like path to another empty cell, which then becomes permanently occupied by an arrow, effectively blocking that cell for both players. The action format is either a move alone, specifying the starting and ending coordinates of the piece with the arrow position identical to the piece's start, or a move with an arrow shot, specifying three coordinate pairs: the piece's start, the piece's destination, and the arrow's target cell. Moves are legal only if the piece belongs to the player in control, the destination cell is empty, the movement path is unobstructed, and, if an arrow is shot, its path is also unobstructed ignoring the piece's original position but considering all other obstructions. The game enforces implicit constraints such as board boundaries, ensuring all moves and arrow shots stay within the 1-to-10 range on both axes; no cell may be occupied simultaneously by a piece or an arrow; and movement paths must be clear of any other pieces or arrows except where specifically ignored in arrow path checks. After a player completes a legal move and optional arrow shot, control passes to the opposing player. The game terminates when the player to move has no legal moves available for any of their pieces, which means none of their pieces can move to any empty cell along queen-like paths. The player who retains the ability to move when the other cannot is declared the winner and scores 100 points, while the losing player scores zero. If both players have legal moves, the game continues. Thus, the objective is to maneuver one’s pieces and strategically block cells with arrows to trap the opponent’s pieces, preventing any legal moves, thereby winning the game.",
    "output": "(role white)\n(role black)\n(init (location  4  1 white))\n(init (location  7  1 white))\n(init (location  1  4 white))\n(init (location 10  4 white))\n(init (location  1  7 black))\n(init (location 10  7 black))\n(init (location  4 10 black))\n(init (location  7 10 black))\n(init (control white))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n    (true (control ?player))\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?x2 ?y2)\n    (emptyCell ?x2 ?y2)\n    (queenMoveIgnoring ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (emptyCell ?x3 ?y3))\n(<= (legal ?player (play ?x1 ?y1 ?x2 ?y2 ?x1 ?y1))\n    (true (control ?player))\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?x2 ?y2)\n    (emptyCell ?x2 ?y2))\n(<= (next (location ?x ?y ?state))\n    (true (location ?x ?y ?state))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n    (distinctCell ?x ?y ?x1 ?y1))\n(<= (next (location ?x2 ?y2 ?player))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)))\n(<= (next (location ?x3 ?y3 arrow))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)))\n(<= (next (control black))\n    (true (control white)))\n(<= (next (control white))\n    (true (control black)))\n(<= terminal\n    (not (legalMove white)))\n(<= terminal\n    (not (legalMove black)))\n(<= (goal white 100)\n    (not (legalMove black)))\n(<= (goal white 0)\n    (legalMove black))\n(<= (goal black 100)\n    (not (legalMove white)))\n(<= (goal black 0)\n    (legalMove white))\n(<= (legalMove ?player)\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?xAny ?yAny)\n    (emptyCell ?xAny ?yAny))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (rookMove ?x1 ?y1 ?x2 ?y2))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (bishopMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (horizontalMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (horizontalMove ?x2 ?y2 ?x1 ?y1))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (verticalMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (verticalMove ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMove ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMove ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMove ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMove ?x2 ?y2 ?x1 ?y1))\n(<= (horizontalMove ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (emptyCell ?x2 ?y)\n    (horizontalMove ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMove ?x1 ?y ?x2 ?y)\n    (++ ?x1 ?x2)\n    (index ?y))\n(<= (verticalMove ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (emptyCell ?x ?y2)\n    (verticalMove ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMove ?x ?y1 ?x ?y2)\n    (++ ?y1 ?y2)\n    (index ?x))\n(<= (diagonalUpMove ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (emptyCell ?x2 ?y2)\n    (diagonalUpMove ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMove ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2))\n(<= (diagonalDownMove ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (emptyCell ?x2 ?y2)\n    (diagonalDownMove ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMove ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1))\n(<= (queenMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (queenMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (emptyCell ?x2 ?y)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMoveIgnoring ?x2 ?y ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (horizontalMoveIgnoring ?x2 ?y ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y ?x2 ?y)\n    (++ ?x1 ?x2)\n    (index ?y)\n    (cell ?xIg ?yIg))\n(<= (verticalMoveIgnoring ?xIg ?yIg ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (emptyCell ?x ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMoveIgnoring ?x ?y2 ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (verticalMoveIgnoring ?x ?y2 ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMoveIgnoring ?xIg ?yIg ?x ?y1 ?x ?y2)\n    (++ ?y1 ?y2)\n    (index ?x)\n    (cell ?xIg ?yIg))\n(<= (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (emptyCell ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMoveIgnoring ?x2 ?y2 ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (diagonalUpMoveIgnoring ?x2 ?y2 ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (cell ?xIg ?yIg))\n(<= (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (emptyCell ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMoveIgnoring ?x2 ?y2 ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (diagonalDownMoveIgnoring ?x2 ?y2 ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (cell ?xIg ?yIg))\n(<= (emptyCell ?x ?y)\n    (cell ?x ?y)\n    (not (true (location ?x ?y white)))\n    (not (true (location ?x ?y black)))\n\t(not (true (location ?x ?y arrow))))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8) (index 9) (index 10)\n(++ 1 2)  (++ 2 3)  (++ 3 4)  (++ 4 5)  (++ 5 6)  (++ 6 7)  (++ 7 8)  (++ 8 9)  (++ 9 10) (++ 10  1)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played between two players called north and south on a circular arrangement of twelve normal pits labeled p1 through p12, each owned by one of the players, with pits p1 to p6 owned by south and p7 to p12 owned by north. In addition to these, there are two scoring pits named pwinnorth and pwinsouth, associated respectively with the north and south players. The pits are organized in a ring where each pit has a designated next pit that cycles through all pits and scoring pits, creating a continuous loop. The initial state places four stones in each normal pit and zero stones in the scoring pits, and the north player has the initial control of the game. Players alternate turns, starting with north, with turn control passing in specific ways depending on the actions taken. On a player's turn, if it is not that player's turn, they may perform a noop action, which is legal whenever the other player has control, or if it is their turn but all their pits are empty and their hand is empty. If it is their turn, the player may perform one of three types of actions: picking up stones from one of their own non-empty pits, putting stones into a pit when holding stones in hand, or clearing stones from a scoring pit under certain conditions. The pick action is legal only if the player has control, their hand is empty, the chosen pit belongs to them and is not a scoring pit, and the opponent has some stones; the put action requires the player to have control, have stones in hand, and place stones into the current pit held in hand; the clear action is permitted when the player has control, the pit is owned by them but not a scoring pit, the opponent's pits are all empty, and the player’s hand is empty. The hand tracks the number of stones a player currently holds, starting empty. Upon picking stones from a pit, the stones are removed from that pit and stored in the player's hand, and the position at which the player is at updates to the next pit in the sequence. When putting stones, one stone is deposited into the current pit, increasing its count by one and decreasing the hand count, with a special rule if the last put stone empties the pit and it is a scoring pit, stones from the opposite pit are captured and added to the scoring pit. Clearing a pit sets its stone count to zero, and if the pit is a scoring pit, it adds stones from another pit as well. The game enforces constraints such as pits must belong to the acting player when picking or clearing, pits cannot be scoring pits for picks and clears except when specified, and the circular order of pits is preserved. The game ends when all pits owned by either player are empty, at which point the goals are calculated by mapping the number of stones in each player's scoring pit to a score, using a predefined mapping that associates stone counts with numerical values. The player with the higher score in their scoring pit wins. Throughout the game, the control passes between players according to the rules defined by the actions taken, with specific conditions governing when control switches or remains, and legal noop actions allow a player to pass their turn when appropriate. The coordinate system is effectively the circular ordering of pits, with each pit's successor defined to create a loop, and the concept of opposite pits pairs pits across the board for capturing mechanics. The game therefore consists of strategic pit selection, stone sowing, capturing, and scoring, played until one side has no stones left on their side of the board, resulting in a final scoring comparison to determine the winner.",
    "output": "(role north)\n(role south)\n(<= (init (pit ?p s4))\n  (normalpit ?p))\n(<= (init (pit ?p s0))\n  (scoringpit ?r ?p))\n(<= (init (hand ?r s0))\n  (role ?r))\n(init (control north))\n(<= (legal ?r noop)\n  (role ?r)\n  (true (control ?r2))\n  (distinct ?r ?r2))\n(<= (legal ?r noop)\n  (true (control ?r))\n  (allempty ?r)\n  (true (hand ?r s0)))\n(<= (legal ?r (clear ?p))\n  (true (control ?r))\n  (owner ?r ?p)\n  (not (true (pit ?p s0)))\n  (role ?r2)\n  (distinct ?r ?r2)\n  (allempty ?r2))\n(<= (legal ?r (pick ?p))\n  (true (control ?r))\n  (true (hand ?r s0))\n  (owner ?r ?p)\n  (not (true (pit ?p s0)))\n  (role ?r2)\n  (distinct ?r ?r2)\n  (not (allempty ?r2)))\n(<= (legal ?r (put ?p))\n  (true (control ?r))\n  (true (at ?p))\n  (true (hand ?r ?n))\n  (distinct ?n s0))\n(<= terminal\n  (allempty north)\n  (allempty south))\n(<= (goal ?r ?score)\n  (scoringpit ?r ?p)\n  (true (pit ?p ?n))\n  (map_to_score ?n ?score))\n(<= (next (control ?r))\n  (does ?r (pick ?p)))\n(<= (next (control ?r))\n  (does ?r (clear ?p)))\n(<= (next (control ?r))\n  (does ?r (put ?p))\n  (true (hand ?r ?n))\n  (distinct ?n s1))\n(<= (next (control ?r))\n  (does ?r (put ?p))\n  (true (hand ?r s1))\n  (scoringpit ?r ?p))\n(<= (next (control ?r2))\n  (does ?r (put ?p))\n  (true (hand ?r s1))\n  (not (scoringpit ?r ?p))\n  (role ?r2)\n  (distinct ?r2 ?r))\n(<= (next (control ?r2))\n  (true (control ?r))\n  (does ?r noop)\n  (role ?r2)\n  (distinct ?r2 ?r))\n(<= (next (hand ?r ?n))\n  (does ?r (pick ?p))\n  (true (pit ?p ?n)))\n(<= (next (hand ?r ?n))\n  (does ?r (put ?p))\n  (true (hand ?r ?n1))\n  (succ ?n ?n1))\n(<= (next (hand ?r ?n))\n  (does ?r noop)\n  (true (hand ?r ?n)))\n(<= (next (hand ?r ?n))\n  (does ?r (clear ?p))\n  (true (hand ?r ?n)))\n(<= (next (at ?p2))\n  (does ?r (pick ?p))\n  (nextpit ?r ?p ?p2))\n(<= (next (at ?p2))\n  (does ?r (put ?p))\n  (true (hand ?r ?n))\n  (distinct ?n s1)\n  (nextpit ?r ?p ?p2))\n(<= (next (pit ?p s0))\n  (does ?r (clear ?p)))\n(<= (next (pit ?p ?n2))\n  (does ?r (clear ?p2))\n  (scoringpit ?r ?p)\n  (true (pit ?p ?n))\n  (true (pit ?p2 ?n1))\n  (plus ?n ?n1 ?n2))\n(<= (next (pit ?p ?n))\n  (true (pit ?p ?n))\n  (does ?r (clear ?p2))\n  (distinct ?p ?p2)\n  (not (scoringpit ?r ?p)))\n(<= (next (pit ?p s0))\n  (does ?r (pick ?p)))\n(<= (next (pit ?p ?n))\n  (does ?r (pick ?p2))\n  (true (pit ?p ?n))\n  (distinct ?p ?p2))\n(<= (next (pit ?p ?n2))\n  (does ?r (put ?p))\n  (not (true (hand ?r s1)))\n  (true (pit ?p ?n))\n  (succ ?n ?n2))\n(<= (next (pit ?p ?n))\n  (does ?r (put ?p2))\n  (true (pit ?p ?n))\n  (distinct ?p ?p2)\n  (not (true (hand ?r s1))))\n(<= (next (pit ?p ?n2))\n  (does ?r (put ?p))\n  (true (hand ?r s1))\n  (not (emptyonlastput ?r ?p ?p))\n  (true (pit ?p ?n))\n  (succ ?n ?n2))\n(<= (next (pit ?p ?n))\n  (does ?r (put ?p2))\n  (true (pit ?p ?n))\n  (distinct ?p ?p2)\n  (true (hand ?r s1))\n  (not (emptyonlastput ?r ?p2 ?p2)))\n(<= (next (pit ?p s0))\n  (does ?r (put ?p2))\n  (true (hand ?r s1))\n  (emptyonlastput ?r ?p2 ?p))\n(<= (next (pit ?p ?n2))\n  (does ?r (put ?p2))\n  (true (hand ?r s1))\n  (scoringpit ?r ?p)\n  (emptyonlastput ?r ?p2 ?p2)\n  (opposite ?p2 ?p3)\n  (true (pit ?p ?n))\n  (true (pit ?p3 ?np3))\n  (plus ?n ?np3 ?n1)\n  (succ ?n1 ?n2))\n(<= (next (pit ?p ?n))\n  (does ?r (put ?p2))\n  (true (hand ?r s1))\n  (true (pit ?p ?n))\n  (distinct ?p ?p2)\n  (not (scoringpit ?r ?p))\n  (not (opposite ?p ?p2))\n  (emptyonlastput ?r ?p2 ?p2))\n(<= (next (pit ?p ?n))\n  (does north noop)\n  (does south noop)\n  (true (pit ?p ?n)))\n(<= (allempty north)\n  (true (pit p7  s0))\n  (true (pit p8  s0))\n  (true (pit p9  s0))\n  (true (pit p10 s0))\n  (true (pit p11 s0))\n  (true (pit p12 s0)))\n(<= (allempty south)\n  (true (pit p1 s0))\n  (true (pit p2 s0))\n  (true (pit p3 s0))\n  (true (pit p4 s0))\n  (true (pit p5 s0))\n  (true (pit p6 s0)))\n(<= (some_not_empty ?r)\n  (owner ?r ?p)\n  (true (pit ?p ?n))\n  (distinct ?n s0))\n(<= (emptyonlastput ?r ?p ?p)\n  (owner ?r ?p)\n  (true (pit ?p s0)))\n(<= (emptyonlastput ?r ?p ?p2)\n  (opposite ?p ?p2)\n  (owner ?r ?p)\n  (true (pit ?p s0)))\n(<= (opposite ?p1 ?p2)\n  (basicopposite ?p1 ?p2))\n(<= (opposite ?p1 ?p2)\n  (basicopposite ?p2 ?p1))\n(<= (plus ?x s0 ?x)\n  (number ?x))\n(<= (plus ?x ?y ?z)\n  (succ ?y2 ?y)\n  (succ ?x ?x2)\n  (plus ?x2 ?y2 ?z))\n(<= (anypit ?p)\n  (normalpit ?p))\n(<= (anypit ?p)\n  (scoringpit ?r ?p))\n(normalpit p1)\n(normalpit p2)\n(normalpit p3)\n(normalpit p4)\n(normalpit p5)\n(normalpit p6)\n(normalpit p7)\n(normalpit p8)\n(normalpit p9)\n(normalpit p10)\n(normalpit p11)\n(normalpit p12)\n(scoringpit north pwinnorth)\n(scoringpit south pwinsouth)\n(owner north p7)\n(owner north p8)\n(owner north p9)\n(owner north p10)\n(owner north p11)\n(owner north p12)\n(owner south p1)\n(owner south p2)\n(owner south p3)\n(owner south p4)\n(owner south p5)\n(owner south p6)\n(basicopposite p1 p12)\n(basicopposite p2 p11)\n(basicopposite p3 p10)\n(basicopposite p4 p9)\n(basicopposite p5 p8)\n(basicopposite p6 p7)\n(nextpit south p1 p2)\n(nextpit south p2 p3)\n(nextpit south p3 p4)\n(nextpit south p4 p5)\n(nextpit south p5 p6)\n(nextpit south p6 pwinsouth)\n(nextpit south pwinsouth p7)\n(nextpit south p7 p8)\n(nextpit south p8 p9)\n(nextpit south p9 p10)\n(nextpit south p10 p11)\n(nextpit south p11 p12)\n(nextpit south p12 p1)\n(nextpit north p1 p2)\n(nextpit north p2 p3)\n(nextpit north p3 p4)\n(nextpit north p4 p5)\n(nextpit north p5 p6)\n(nextpit north p6 p7)\n(nextpit north p7 p8)\n(nextpit north p8 p9)\n(nextpit north p9 p10)\n(nextpit north p10 p11)\n(nextpit north p11 p12)\n(nextpit north p12 pwinnorth)\n(nextpit north pwinnorth p1)\n(map_to_score s0 0)\n(map_to_score s1 0)\n(map_to_score s2 0)\n(map_to_score s3 0)\n(map_to_score s4 0)\n(map_to_score s5 0)\n(map_to_score s6 0)\n(map_to_score s7 0)\n(map_to_score s8 0)\n(map_to_score s9 0)\n(map_to_score s10 0)\n(map_to_score s11 0)\n(map_to_score s12 0)\n(map_to_score s13 0)\n(map_to_score s14 0)\n(map_to_score s15 0)\n(map_to_score s16 0)\n(map_to_score s17 0)\n(map_to_score s18 0)\n(map_to_score s19 0)\n(map_to_score s20 0)\n(map_to_score s21 0)\n(map_to_score s22 0)\n(map_to_score s23 0)\n(map_to_score s24 50)\n(map_to_score s25 88)\n(map_to_score s26 89)\n(map_to_score s27 89)\n(map_to_score s28 90)\n(map_to_score s29 90)\n(map_to_score s30 91)\n(map_to_score s31 91)\n(map_to_score s32 92)\n(map_to_score s33 92)\n(map_to_score s34 93)\n(map_to_score s35 93)\n(map_to_score s36 94)\n(map_to_score s37 94)\n(map_to_score s38 95)\n(map_to_score s39 95)\n(map_to_score s40 96)\n(map_to_score s41 96)\n(map_to_score s42 97)\n(map_to_score s43 97)\n(map_to_score s44 98)\n(map_to_score s45 98)\n(map_to_score s46 99)\n(map_to_score s47 99)\n(map_to_score s48 100)\n(number s0)\n(number s1)\n(number s2)\n(number s3)\n(number s4)\n(number s5)\n(number s6)\n(number s7)\n(number s8)\n(number s9)\n(number s10)\n(number s11)\n(number s12)\n(number s13)\n(number s14)\n(number s15)\n(number s16)\n(number s17)\n(number s18)\n(number s19)\n(number s20)\n(number s21)\n(number s22)\n(number s23)\n(number s24)\n(number s25)\n(number s26)\n(number s27)\n(number s28)\n(number s29)\n(number s30)\n(number s31)\n(number s32)\n(number s33)\n(number s34)\n(number s35)\n(number s36)\n(number s37)\n(number s38)\n(number s39)\n(number s40)\n(number s41)\n(number s42)\n(number s43)\n(number s44)\n(number s45)\n(number s46)\n(number s47)\n(number s48)\n(succ s0 s1)\n(succ s1 s2)\n(succ s2 s3)\n(succ s3 s4)\n(succ s4 s5)\n(succ s5 s6)\n(succ s6 s7)\n(succ s7 s8)\n(succ s8 s9)\n(succ s9 s10)\n(succ s10 s11)\n(succ s11 s12)\n(succ s12 s13)\n(succ s13 s14)\n(succ s14 s15)\n(succ s15 s16)\n(succ s16 s17)\n(succ s17 s18)\n(succ s18 s19)\n(succ s19 s20)\n(succ s20 s21)\n(succ s21 s22)\n(succ s22 s23)\n(succ s23 s24)\n(succ s24 s25)\n(succ s25 s26)\n(succ s26 s27)\n(succ s27 s28)\n(succ s28 s29)\n(succ s29 s30)\n(succ s30 s31)\n(succ s31 s32)\n(succ s32 s33)\n(succ s33 s34)\n(succ s34 s35)\n(succ s35 s36)\n(succ s36 s37)\n(succ s37 s38)\n(succ s38 s39)\n(succ s39 s40)\n(succ s40 s41)\n(succ s41 s42)\n(succ s42 s43)\n(succ s43 s44)\n(succ s44 s45)\n(succ s45 s46)\n(succ s46 s47)\n(succ s47 s48)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 7-by-7 grid with coordinates ranging from 1 to 7 along both the x and y axes, but the outermost rows and columns (i.e., those with x or y equal to 1 or 7) are excluded from valid play positions, effectively creating a 5-by-5 playable area from coordinates 2 to 6. There are three players: red, yellow, and blue, who take turns in a fixed rotation order, starting with red, then yellow, then blue, and repeating cyclically. The initial setup places each player's pieces in the corners of the board within the playable area: red's pawn, checker, and knight occupy cells (1,5), (1,4), and (1,3) respectively; yellow's pieces occupy (3,1), (4,1), and (5,1); and blue's pieces occupy (7,3), (7,4), and (7,5). The game proceeds in discrete steps, starting at step 1, with each player controlling the game during their turn. On a turn, the current player may either perform a legal move or choose to do nothing (noop). The noop action is always legal for any player, allowing passing of the turn without changes. Legal actions include dropping a disc piece onto one of three designated columns (3, 4, or 5) at the lowest available empty cell in that column, moving a pawn orthogonally or diagonally to an empty cell or to capture an opponent's piece diagonally, moving a knight in an L-shaped pattern (similar to a chess knight) to an empty cell or to capture an opponent's piece, moving a checker diagonally to an empty cell, or performing a jump move with a checker to leap over an adjacent opponent's piece in any diagonal direction (upleft, upright, downleft, downright) onto an empty cell immediately beyond. Moves that capture opponent pieces are allowed only if the target cell contains an opponent's piece distinct from the current player. All moves must remain within the bounds of the playable area and cannot move onto occupied cells unless capturing. After a move, the game state updates accordingly: the moving piece relocates to the destination cell, the origin cell becomes empty, and any captured pieces are removed. If a player chooses to drop a disc, it occupies the lowest empty cell in the chosen chute column. The control then passes to the next player in the rotation sequence. The game terminates if any player forms a line of three of their pieces in a row, column, or diagonal within the central 3-by-3 area defined by cells (3,3), (3,4), (3,5), (4,3), (4,4), (4,5), (5,3), (5,4), and (5,5), or if the game reaches step 31 without any player achieving such a line. Victory is awarded to the player who first creates such a line, receiving a score of 100, while all other players score 0. If the game ends due to the step limit without any line formed, all players score 0. The game thus combines positional strategy with piece-specific movement rules, turn-based control, and a capture mechanic, all constrained by the board boundaries and occupancy rules, culminating in a race to form a three-in-a-row line in the central board area.",
    "output": "(role red)\n(role yellow)\n(role blue)\n(init (control red))\n(init (cell 1 5 redpawn))\n(init (cell 1 4 redchecker))\n(init (cell 1 3 redknight))\n(init (cell 3 1 yellowpawn))\n(init (cell 4 1 yellowchecker))\n(init (cell 5 1 yellowknight))\n(init (cell 7 3 bluepawn))\n(init (cell 7 4 bluechecker))\n(init (cell 7 5 blueknight))\n(init (step 1))\n(<= (legal ?player noop)\n(role ?player))\n(<= (legal ?player (drop ?x))\n(true (control ?player))\n(chute ?x)\n(emptycell ?x 6))\n(<= (legal ?player (pawnmove ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?piece))\n(piece ?piece pawn ?player)\n(orthogonal ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(emptycell ?x2 ?y2))\n(<= (legal ?player1 (pawnmove ?x1 ?y1 ?x2 ?y2))\n(true (control ?player1))\n(true (cell ?x1 ?y1 ?piece1))\n(piece ?piece1 pawn ?player1)\n(diagonal ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(true (cell ?x2 ?y2 ?piece2))\n(piece ?piece2 ?ignore ?player2)\n(distinct ?player1 ?player2))\n(<= (legal ?player (knightmove ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?piece))\n(piece ?piece knight ?player)\n(ell ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(emptycell ?x2 ?y2))\n(<= (legal ?player1 (knightmove ?x1 ?y1 ?x2 ?y2))\n(true (control ?player1))\n(true (cell ?x1 ?y1 ?piece1))\n(piece ?piece1 knight ?player1)\n(ell ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(true (cell ?x2 ?y2 ?piece2))\n(piece ?piece2 ?ignore ?player2)\n(distinct ?player1 ?player2))\n(<= (legal ?player (checkermove ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?piece))\n(piece ?piece checker ?player)\n(diagonal ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(emptycell ?x2 ?y2))\n(<= (legal ?player1 (jump ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n(true (control ?player1))\n(true (cell ?x1 ?y1 ?piece1))\n(piece ?piece1 checker ?player1)\n(upright ?x1 ?y1 ?x2 ?y2)\n(true (cell ?x2 ?y2 ?piece2))\n(piece ?piece2 ?ignore ?player2)\n(distinct ?player1 ?player2)\n(upright ?x2 ?y2 ?x3 ?y3)\n(onboard ?x3 ?y3)\n(emptycell ?x3 ?y3))\n(<= (legal ?player1 (jump ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n(true (control ?player1))\n(true (cell ?x1 ?y1 ?piece1))\n(piece ?piece1 checker ?player1)\n(upleft ?x1 ?y1 ?x2 ?y2)\n(true (cell ?x2 ?y2 ?piece2))\n(piece ?piece2 ?ignore ?player2)\n(distinct ?player1 ?player2)\n(upleft ?x2 ?y2 ?x3 ?y3)\n(onboard ?x3 ?y3)\n(emptycell ?x3 ?y3))\n(<= (legal ?player1 (jump ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n(true (control ?player1))\n(true (cell ?x1 ?y1 ?piece1))\n(piece ?piece1 checker ?player1)\n(downright ?x1 ?y1 ?x2 ?y2)\n(true (cell ?x2 ?y2 ?piece2))\n(piece ?piece2 ?ignore ?player2)\n(distinct ?player1 ?player2)\n(downright ?x2 ?y2 ?x3 ?y3)\n(onboard ?x3 ?y3)\n(emptycell ?x3 ?y3))\n(<= (legal ?player1 (jump ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n(true (control ?player1))\n(true (cell ?x1 ?y1 ?piece1))\n(piece ?piece1 checker ?player1)\n(downleft ?x1 ?y1 ?x2 ?y2)\n(true (cell ?x2 ?y2 ?piece2))\n(piece ?piece2 ?ignore ?player2)\n(distinct ?player1 ?player2)\n(downleft ?x2 ?y2 ?x3 ?y3)\n(onboard ?x3 ?y3)\n(emptycell ?x3 ?y3))\n(<= (next (control ?p2))\n(true (control ?p1))\n(rotation ?p1 ?p2))\n(<= (next (cell ?x ?y ?piece))\n(true (control ?player))\n(does ?player noop)\n(true (cell ?x ?y ?piece)))\n(<= (next (cell ?x ?y ?piece))\n(does ?player (drop ?x))\n(lowpoint ?x ?y)\n(piece ?piece disc ?player))\n(<= (next (cell ?x ?y ?piece))\n(does ?player (drop ?ignore))\n(true (cell ?x ?y ?piece)))\n(<= (next (cell ?x2 ?y2 ?piece))\n(does ?player (pawnmove ?x1 ?y1 ?x2 ?y2))\n(piece ?piece pawn ?player))\n(<= (next (cell ?xany ?yany ?piece))\n(does ?player (pawnmove ?x1 ?y1 ?x2 ?y2))\n(distinctcell ?xany ?yany ?x1 ?y1)\n(distinctcell ?xany ?yany ?x2 ?y2)\n(true (cell ?xany ?yany ?piece)))\n(<= (next (cell ?x2 ?y2 ?piece))\n(does ?player (knightmove ?x1 ?y1 ?x2 ?y2))\n(piece ?piece knight ?player))\n(<= (next (cell ?xany ?yany ?piece))\n(does ?player (knightmove ?x1 ?y1 ?x2 ?y2))\n(distinctcell ?xany ?yany ?x1 ?y1)\n(distinctcell ?xany ?yany ?x2 ?y2)\n(true (cell ?xany ?yany ?piece)))\n(<= (next (cell ?x2 ?y2 ?piece))\n(does ?player (checkermove ?x1 ?y1 ?x2 ?y2))\n(piece ?piece checker ?player))\n(<= (next (cell ?xany ?yany ?piece))\n(does ?player (checkermove ?x1 ?y1 ?x2 ?y2))\n(distinctcell ?xany ?yany ?x1 ?y1)\n(distinctcell ?xany ?yany ?x2 ?y2)\n(true (cell ?xany ?yany ?piece)))\n(<= (next (cell ?x3 ?y3 ?piece))\n(does ?player (jump ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n(piece ?piece checker ?player))\n(<= (next (cell ?xany ?yany ?piece))\n(does ?player (jump ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n(distinctcell ?xany ?yany ?x1 ?y1)\n(distinctcell ?xany ?yany ?x2 ?y2)\n(true (cell ?xany ?yany ?piece)))\n(<= (next (cell ?xstart ?ystart ?piece))\n(does ?player (pawnmove ?x1 ?y1 ?x2 ?y2))\n(true (cell ?x2 ?y2 ?piece))\n(start ?piece ?xstart ?ystart))\n(<= (next (cell ?xstart ?ystart ?piece))\n(does ?player (knightmove ?x1 ?y1 ?x2 ?y2))\n(true (cell ?x2 ?y2 ?piece))\n(start ?piece ?xstart ?ystart))\n(<= (next (cell ?xstart ?ystart ?piece))\n(does ?player (jump ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n(true (cell ?x2 ?y2 ?piece))\n(start ?piece ?xstart ?ystart))\n(<= (next (step ?t2))\n(true (step ?t1))\n(stepcount ?t1 ?t2))\n(<= terminal\n(role ?player)\n(line ?player))\n(<= terminal\n(true (step 31)))\n(<= (goal ?player 0)\n(role ?player)\n(not (line ?player)))\n(<= (goal ?player 100)\n(role ?player)\n(line ?player))\n(<= (lowpoint ?x ?y)\n(lowpointfrom ?x 6 ?x ?y))\n(<= (lowpointfrom ?x 2 ?x 2)\n(index ?x))\n(<= (lowpointfrom ?x ?y2 ?x ?y2)\n(index ?x)\n(plus1 ?y1 ?y2)\n(not (emptycell ?x ?y1)))\n(<= (lowpointfrom ?x ?y3 ?x ?y1)\n(index ?x)\n(plus1 ?y2 ?y3)\n(emptycell ?x ?y2)\n(lowpointfrom ?x ?y2 ?x ?y1))\n(<= (orthogonal ?x1 ?y1 ?x2 ?y2)\n(up ?x1 ?y1 ?x2 ?y2))\n(<= (orthogonal ?x1 ?y1 ?x2 ?y2)\n(down ?x1 ?y1 ?x2 ?y2))\n(<= (orthogonal ?x1 ?y1 ?x2 ?y2)\n(left ?x1 ?y1 ?x2 ?y2))\n(<= (orthogonal ?x1 ?y1 ?x2 ?y2)\n(right ?x1 ?y1 ?x2 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(upleft ?x1 ?y1 ?x2 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(upright ?x1 ?y1 ?x2 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(downleft ?x1 ?y1 ?x2 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(downright ?x1 ?y1 ?x2 ?y2))\n(<= (ell ?x1 ?y1 ?x3 ?y3)\n(up ?x1 ?y1 ?x2 ?y2)\n(upright ?x2 ?y2 ?x3 ?y3))\n(<= (ell ?x1 ?y1 ?x3 ?y3)\n(up ?x1 ?y1 ?x2 ?y2)\n(upleft ?x2 ?y2 ?x3 ?y3))\n(<= (ell ?x1 ?y1 ?x3 ?y3)\n(right ?x1 ?y1 ?x2 ?y2)\n(upright ?x2 ?y2 ?x3 ?y3))\n(<= (ell ?x1 ?y1 ?x3 ?y3)\n(right ?x1 ?y1 ?x2 ?y2)\n(downright ?x2 ?y2 ?x3 ?y3))\n(<= (ell ?x1 ?y1 ?x3 ?y3)\n(down ?x1 ?y1 ?x2 ?y2)\n(downright ?x2 ?y2 ?x3 ?y3))\n(<= (ell ?x1 ?y1 ?x3 ?y3)\n(down ?x1 ?y1 ?x2 ?y2)\n(downleft ?x2 ?y2 ?x3 ?y3))\n(<= (ell ?x1 ?y1 ?x3 ?y3)\n(left ?x1 ?y1 ?x2 ?y2)\n(upleft ?x2 ?y2 ?x3 ?y3))\n(<= (ell ?x1 ?y1 ?x3 ?y3)\n(left ?x1 ?y1 ?x2 ?y2)\n(downleft ?x2 ?y2 ?x3 ?y3))\n(<= (left ?x1 ?y ?x2 ?y)\n(plus1 ?x2 ?x1)\n(index ?y))\n(<= (right ?x1 ?y ?x2 ?y)\n(plus1 ?x1 ?x2)\n(index ?y))\n(<= (down ?x ?y1 ?x ?y2)\n(index ?x)\n(plus1 ?y2 ?y1))\n(<= (up ?x ?y1 ?x ?y2)\n(index ?x)\n(plus1 ?y1 ?y2))\n(<= (upleft ?x1 ?y1 ?x2 ?y2)\n(plus1 ?x2 ?x1)\n(plus1 ?y1 ?y2))\n(<= (upright ?x1 ?y1 ?x2 ?y2)\n(plus1 ?x1 ?x2)\n(plus1 ?y1 ?y2))\n(<= (downleft ?x1 ?y1 ?x2 ?y2)\n(plus1 ?x2 ?x1)\n(plus1 ?y2 ?y1))\n(<= (downright ?x1 ?y1 ?x2 ?y2)\n(plus1 ?x1 ?x2)\n(plus1 ?y2 ?y1))\n(<= (controls ?x ?y ?role)\n(true (cell ?x ?y ?piece))\n(piece ?piece ?ignore ?role))\n(<= (onboard ?x ?y)\n(cell ?x ?y)\n(distinct ?x 1)\n(distinct ?x 7)\n(distinct ?y 1)\n(distinct ?y 7))\n(<= (cell ?x ?y)\n(index ?x)\n(index ?y))\n(<= (distinctcell ?x1 ?y1 ?x2 ?y2)\n(cell ?x1 ?y1)\n(cell ?x2 ?y2)\n(distinct ?x1 ?x2))\n(<= (distinctcell ?x1 ?y1 ?x2 ?y2)\n(cell ?x1 ?y1)\n(cell ?x2 ?y2)\n(distinct ?y1 ?y2))\n(<= (emptycell ?x ?y)\n(cell ?x ?y)\n(not (controls ?x ?y red))\n(not (controls ?x ?y yellow))\n(not (controls ?x ?y blue)))\n(<= (line ?player)\n(row ?player))\n(<= (line ?player)\n(column ?player))\n(<= (line ?player)\n(diag ?player))\n(<= (row ?player)\n(controls 3 3 ?player)\n(controls 4 3 ?player)\n(controls 5 3 ?player))\n(<= (row ?player)\n(controls 3 4 ?player)\n(controls 4 4 ?player)\n(controls 5 4 ?player))\n(<= (row ?player)\n(controls 3 5 ?player)\n(controls 4 5 ?player)\n(controls 5 5 ?player))\n(<= (column ?player)\n(controls 3 3 ?player)\n(controls 3 4 ?player)\n(controls 3 5 ?player))\n(<= (column ?player)\n(controls 4 3 ?player)\n(controls 4 4 ?player)\n(controls 4 5 ?player))\n(<= (column ?player)\n(controls 5 3 ?player)\n(controls 5 4 ?player)\n(controls 5 5 ?player))\n(<= (diag ?player)\n(controls 3 3 ?player)\n(controls 4 4 ?player)\n(controls 5 5 ?player))\n(<= (diag ?player)\n(controls 3 5 ?player)\n(controls 4 4 ?player)\n(controls 5 3 ?player))\n(rotation red yellow)\n(rotation yellow blue)\n(rotation blue red)\n(start redpawn 1 5)\n(start redchecker 1 4)\n(start redknight 1 3)\n(start yellowpawn 3 1)\n(start yellowchecker 4 1)\n(start yellowknight 5 1)\n(start bluepawn 7 3)\n(start bluechecker 7 4)\n(start blueknight 7 5)\n(piece reddisc disc red)\n(piece yellowdisc disc yellow)\n(piece bluedisc disc blue)\n(piece redpawn pawn red)\n(piece yellowpawn pawn yellow)\n(piece bluepawn pawn blue)\n(piece redchecker checker red)\n(piece yellowchecker checker yellow)\n(piece bluechecker checker blue)\n(piece redknight knight red)\n(piece yellowknight knight yellow)\n(piece blueknight knight blue)\n(chute 3)\n(chute 4)\n(chute 5)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(plus1 1 2)\n(plus1 2 3)\n(plus1 3 4)\n(plus1 4 5)\n(plus1 5 6)\n(plus1 6 7)\n(stepcount 1 2)\n(stepcount 2 3)\n(stepcount 3 4)\n(stepcount 4 5)\n(stepcount 5 6)\n(stepcount 6 7)\n(stepcount 7 8)\n(stepcount 8 9)\n(stepcount 9 10)\n(stepcount 10 11)\n(stepcount 11 12)\n(stepcount 12 13)\n(stepcount 13 14)\n(stepcount 14 15)\n(stepcount 15 16)\n(stepcount 16 17)\n(stepcount 17 18)\n(stepcount 18 19)\n(stepcount 19 20)\n(stepcount 20 21)\n(stepcount 21 22)\n(stepcount 22 23)\n(stepcount 23 24)\n(stepcount 24 25)\n(stepcount 25 26)\n(stepcount 26 27)\n(stepcount 27 28)\n(stepcount 28 29)\n(stepcount 29 30)\n(stepcount 30 31)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board divided into four quadrants, each with a 3x3 grid of cells arranged in a coordinate system where both x and y indices range from 1 to 3 within each quadrant. These quadrants are positioned so that their local coordinates map onto a global 5x5 grid by offsetting the local coordinates with values of 0 or 3 for x and y, effectively positioning the quadrants to form the larger board. There are two players, designated as red and black, who alternate turns in a fixed sequence starting with red. The initial state grants the red player the right to place a piece first. On each player's turn, they may perform either a placement or a rotation action when it is their control phase, or they must perform a noop action if they do not have placement or rotation control. The control alternates between placing and rotating for each player in the order: red places, red rotates, black places, black rotates, then back to red placing, and so forth. Placement actions involve placing a piece of the player's color onto an empty cell within any quadrant, with the legality requiring that the cell is unoccupied. Rotation actions require the player to select one of the four quadrants and rotate it either clockwise or counterclockwise, with the rotation remapping pieces within the quadrant according to specific coordinate transformations defined by vertical or horizontal flips. A noop action is only legal when the player does not currently have placement or rotation control, effectively passing their turn. After any placement action, the state updates to hold the player's piece at that cell, while all other cells retain their previous state. After a rotation action, the pieces within the rotated quadrant are repositioned according to the rotation direction, while pieces in other quadrants remain unchanged. The board's boundaries and occupancy constraints are enforced implicitly by requiring placements only on empty cells within defined quadrants and indices, and rotations only on valid quadrants and directions. The game terminates when either player forms a line of five consecutive pieces in a row, column, or diagonal on the global 5x5 board, or when no empty cells remain on the board. The detection of a line involves verifying that five contiguous cells along a row, column, or diagonal are all held by the same player, considering the global indexing that maps quadrant-local coordinates to the full board. Scoring is assigned based on the terminal condition: a player who forms such a line while the opponent does not receives 100 points, if neither player has formed a line but the board is full, both players score 50 points, and if both players simultaneously have lines, both receive 50 points. Conversely, a player who loses by the opponent forming a line alone or when the board is still open without any line scores 0 points. This structure ensures a strategic interplay of placing pieces and rotating quadrants to create or block five-in-a-row lines, with the game's state evolving through player actions and automatic updates in piece positions and control phases.",
    "output": "(role red)\n(role black)\n(init (placeControl red))\n(<= (legal ?player (place ?q ?x ?y))\n    (role ?player)\n    (true (placeControl ?player))\n    (cellEmpty ?q ?x ?y))\n(<= (legal ?player (rotate ?q ?dir))\n    (quadrant ?q)\n    (direction ?dir)\n    (role ?player)\n    (true (rotateControl ?player)))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (placeControl ?player)))\n    (not (true (rotateControl ?player))))\n(<= (next (cellHolds ?q ?x ?y ?player))\n    (role ?player)\n    (does ?player (place ?q ?x ?y)))\n(<= (next (cellHolds ?q ?x ?y ?state))\n    (true (cellHolds ?q ?x ?y ?state))\n    (role ?player)\n    (does ?player (place ?qAny ?xAny ?yAny)))\n(<= (next (cellHolds ?q ?x2 ?y2 ?state))\n    (role ?player)\n    (does ?player (rotate ?q ?dir))\n    (true (cellHolds ?q ?x1 ?y1 ?state))\n    (rotation ?dir ?x1 ?y1 ?x2 ?y2))\n(<= (next (cellHolds ?q1 ?x ?y ?state))\n    (role ?player)\n    (does ?player (rotate ?q2 ?dirAny))\n    (true (cellHolds ?q1 ?x ?y ?state))\n    (distinct ?q1 ?q2))\n(<= (next (rotateControl red))\n    (true ( placeControl red)))\n(<= (next ( placeControl red))\n    (true (rotateControl black)))\n(<= (next (rotateControl black))\n    (true ( placeControl black)))\n(<= (next ( placeControl black))\n    (true (rotateControl red)))\n(<= terminal\n    (line red))\n(<= terminal\n    (line black))\n(<= terminal\n    (not boardOpen))\n(<= (goal red 100)\n    (line red)\n    (not (line black)))\n(<= (goal red 50)\n    (not (line red))\n    (not (line black))\n    (not boardOpen))\n(<= (goal red 50)\n\t(line red)\n\t(line black))\n(<= (goal red 0)\n    (line black)\n    (not (line red)))\n(<= (goal red 0)\n    (not (line red))\n    (not (line black))\n    boardOpen)\n(<= (goal black 100)\n    (line black)\n    (not (line red)))\n(<= (goal black 50)\n    (not (line red))\n    (not (line black))\n    (not boardOpen))\n(<= (goal black 50)\n\t(line red)\n\t(line black))\n(<= (goal black 0)\n    (line red)\n    (not (line black)))\n(<= (goal black 0)\n    (not (line red))\n    (not (line black))\n    boardOpen)\n(<= (line ?player)\n    (row ?player))\n(<= (line ?player)\n    (col ?player))\n(<= (line ?player)\n    (diag ?player))\n(<= (row ?player)\n    (role ?player)\n    (true (cellHolds ?q1 ?x1 ?y1 ?player))\n    (globalIndex ?q1 ?x1 ?y1 ?x1G ?yG)\n    (++ ?x1G ?x2G)\n    (true (cellHolds ?q2 ?x2 ?y2 ?player))\n    (globalIndex ?q2 ?x2 ?y2 ?x2G ?yG)\n    (++ ?x2G ?x3G)\n    (true (cellHolds ?q3 ?x3 ?y3 ?player))\n    (globalIndex ?q3 ?x3 ?y3 ?x3G ?yG)\n    (++ ?x3G ?x4G)\n    (true (cellHolds ?q4 ?x4 ?y4 ?player))\n    (globalIndex ?q4 ?x4 ?y4 ?x4G ?yG)\n    (++ ?x4G ?x5G)\n    (true (cellHolds ?q5 ?x5 ?y5 ?player))\n    (globalIndex ?q5 ?x5 ?y5 ?x5G ?yG))\n(<= (col ?player)\n    (role ?player)\n    (true (cellHolds ?q1 ?x1 ?y1 ?player))\n    (globalIndex ?q1 ?x1 ?y1 ?xG ?y1G)\n    (++ ?y1G ?y2G)\n    (true (cellHolds ?q2 ?x2 ?y2 ?player))\n    (globalIndex ?q2 ?x2 ?y2 ?xG ?y2G)\n    (++ ?y2G ?y3G)\n    (true (cellHolds ?q3 ?x3 ?y3 ?player))\n    (globalIndex ?q3 ?x3 ?y3 ?xG ?y3G)\n    (++ ?y3G ?y4G)\n    (true (cellHolds ?q4 ?x4 ?y4 ?player))\n    (globalIndex ?q4 ?x4 ?y4 ?xG ?y4G)\n    (++ ?y4G ?y5G)\n    (true (cellHolds ?q5 ?x5 ?y5 ?player))\n    (globalIndex ?q5 ?x5 ?y5 ?xG ?y5G))\n(<= (diag ?player)\n    (role ?player)\n    (true (cellHolds ?q1 ?x1 ?y1 ?player))\n    (globalIndex ?q1 ?x1 ?y1 ?x1G ?y1G)\n    (++ ?x1G ?x2G)\n    (++ ?y1G ?y2G)\n    (true (cellHolds ?q2 ?x2 ?y2 ?player))\n    (globalIndex ?q2 ?x2 ?y2 ?x2G ?y2G)\n    (++ ?x2G ?x3G)\n    (++ ?y2G ?y3G)\n    (true (cellHolds ?q3 ?x3 ?y3 ?player))\n    (globalIndex ?q3 ?x3 ?y3 ?x3G ?y3G)\n    (++ ?x3G ?x4G)\n    (++ ?y3G ?y4G)\n    (true (cellHolds ?q4 ?x4 ?y4 ?player))\n    (globalIndex ?q4 ?x4 ?y4 ?x4G ?y4G)\n    (++ ?x4G ?x5G)\n    (++ ?y4G ?y5G)\n    (true (cellHolds ?q5 ?x5 ?y5 ?player))\n    (globalIndex ?q5 ?x5 ?y5 ?x5G ?y5G))\n(<= (diag ?player)\n    (role ?player)\n    (true (cellHolds ?q1 ?x1 ?y1 ?player))\n    (globalIndex ?q1 ?x1 ?y1 ?x1G ?y5G)\n    (++ ?x1G ?x2G)\n    (++ ?y4G ?y5G)\n    (true (cellHolds ?q2 ?x2 ?y2 ?player))\n    (globalIndex ?q2 ?x2 ?y2 ?x2G ?y4G)\n    (++ ?x2G ?x3G)\n    (++ ?y3G ?y4G)\n    (true (cellHolds ?q3 ?x3 ?y3 ?player))\n    (globalIndex ?q3 ?x3 ?y3 ?x3G ?y3G)\n    (++ ?x3G ?x4G)\n    (++ ?y2G ?y3G)\n    (true (cellHolds ?q4 ?x4 ?y4 ?player))\n    (globalIndex ?q4 ?x4 ?y4 ?x4G ?y2G)\n    (++ ?x4G ?x5G)\n    (++ ?y1G ?y2G)\n    (true (cellHolds ?q5 ?x5 ?y5 ?player))\n    (globalIndex ?q5 ?x5 ?y5 ?x5G ?y1G))\n(<= (globalIndex 1 ?x ?y ?xG ?yG)\n    (+ 3 ?x ?xG)\n    (+ 3 ?y ?yG))\n(<= (globalIndex 2 ?x ?y ?x ?yG)\n    (index ?x)\n    (+ 3 ?y ?yG))\n(<= (globalIndex 3 ?x ?y ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (globalIndex 4 ?x ?y ?xG ?y)\n    (+ 3 ?x ?xG)\n    (index ?y))\n(<= (rotation clockwise ?x1 ?y1 ?x2 ?y2)\n    (verticalFlip ?y1 ?x1 ?x2 ?y2))\n(<= (rotation counterclockwise ?x1 ?y1 ?x2 ?y2)\n    (horizontalFlip ?y1 ?x1 ?x2 ?y2))\n(<= (horizontalFlip 1 ?y 3 ?y)\n    (index ?y))\n(<= (horizontalFlip 2 ?y 2 ?y)\n    (index ?y))\n(<= (horizontalFlip 3 ?y 1 ?y)\n    (index ?y))\n(<= (verticalFlip ?x 1 ?x 3)\n    (index ?x))\n(<= (verticalFlip ?x 2 ?x 2)\n    (index ?x))\n(<= (verticalFlip ?x 3 ?x 1)\n    (index ?x))\n(<= (cell ?q ?x ?y)\n    (quadrant ?q)\n    (index ?x)\n    (index ?y))\n(<= (cellEmpty ?q ?x ?y)\n    (cell ?q ?x ?y)\n    (not (true (cellHolds ?q ?x ?y red)))\n    (not (true (cellHolds ?q ?x ?y black))))\n(<= boardOpen\n    (cellEmpty ?q ?x ?y))\n(index 1) (index 2) (index 3)\n(quadrant 1) (quadrant 2) (quadrant 3) (quadrant 4)\n(direction clockwise) (direction counterclockwise)\n(++  1 2) (++  2 3) (++  3 4) (++  4 5) (++  5 6)\n(+ 3 1 4) (+ 3 2 5) (+ 3 3 6)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a grid defined by six indices numbered from 1 through 6, creating a coordinate system where positions are referenced by pairs of these indices. Two players participate, designated as xplayer and oplayer, who alternate turns in a fixed sequence starting with xplayer. The initial state has both players with zero boxes claimed and control assigned to xplayer. On their turn, the player in control must draw a line between two adjacent points on the grid that are not yet connected by a line; these lines can be either vertical or horizontal and must connect indices that are consecutive in the predefined order. The legality of a draw action depends on the control of the player and the absence of an existing line between the specified coordinates. If a player is not in control, their only legal action is to do nothing (noop). Each drawn line updates the game state by marking that line as present. When a drawn line completes the four sides of a box, that box is considered formed and attributed to the player who completed it. The player's box count increases accordingly, which can be one or two boxes if multiple boxes are formed simultaneously. If any box is formed during a turn, the player retains control and takes another turn; otherwise, control passes to the opposing player. The game enforces implicit constraints such as board boundaries by limiting lines to those connecting adjacent indices and prevents overlapping lines by disallowing drawing lines where one already exists. The game ends when there are no undrawn lines left, signifying that all possible connections have been made. Victory is determined by comparing the number of boxes each player has claimed: the player with the greater count wins, while a tie results in a win for oplayer. Scores are assigned accordingly, granting 100 points for a win and zero for a loss. Throughout, the game maintains a logical sequence for indices to assess adjacency and progression, ensuring consistent and valid moves within the grid structure.",
    "output": "(role xplayer)\n(role oplayer)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(next_index 1 2)\n(next_index 2 3)\n(next_index 3 4)\n(next_index 4 5)\n(next_index 5 6)\n(init (box_count xplayer 0))\n(init (box_count oplayer 0))\n(init (control xplayer))\n(<= (undrawn ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(next_index ?y1 ?y2)\n\t(not (true (line ?x ?y1 ?x ?y2))))\n(<= (undrawn ?x1 ?y ?x2 ?y)\n\t(next_index ?x1 ?x2)\n\t(index ?y)\n\t(not (true (line ?x1 ?y ?x2 ?y))))\n(<= any_undrawn\n\t(undrawn ?x1 ?y1 ?x2 ?y2))\n(<= (legal ?player (draw ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(undrawn ?x1 ?y1 ?x2 ?y2))\n(<= (next (line ?x1 ?y1 ?x2 ?y2))\n\t(does ?player (draw ?x1 ?y1 ?x2 ?y2)))\n(<= (next (line ?x1 ?y1 ?x2 ?y2))\n\t(true (line ?x1 ?y1 ?x2 ?y2)))\n(<= (legal ?player noop)\n\t(role ?player)\n\t(not (true (control ?player))))\n(<= (v_drawn ?x ?y1 ?x ?y2)\n\t(does ?player (draw ?x ?y1 ?x ?y2)))\n(<= (h_drawn ?x1 ?y ?x2 ?y)\n\t(does ?player (draw ?x1 ?y ?x2 ?y)))\n(<= (box_formed ?x1 ?y1)\n\t(v_drawn ?x1 ?y1 ?x1 ?y2)\n\t(true (line ?x1 ?y2 ?x2 ?y2))\n\t(true (line ?x1 ?y1 ?x2 ?y1))\n\t(true (line ?x2 ?y1 ?x2 ?y2)))\n(<= (box_formed ?x1 ?y1)\n\t(v_drawn ?x2 ?y1 ?x2 ?y2)\n\t(true (line ?x1 ?y1 ?x2 ?y1))\n\t(true (line ?x1 ?y1 ?x1 ?y2))\n\t(true (line ?x1 ?y2 ?x2 ?y2)))\n(<= (box_formed ?x1 ?y1)\n\t(h_drawn ?x1 ?y1 ?x2 ?y1)\n\t(true (line ?x2 ?y1 ?x2 ?y2))\n\t(true (line ?x1 ?y1 ?x1 ?y2))\n\t(true (line ?x1 ?y2 ?x2 ?y2)))\n(<= (box_formed ?x1 ?y1)\n\t(h_drawn ?x1 ?y2 ?x2 ?y2)\n\t(true (line ?x1 ?y1 ?x1 ?y2))\n\t(true (line ?x1 ?y1 ?x2 ?y1))\n\t(true (line ?x2 ?y1 ?x2 ?y2)))\n(<= any_box_formed\n\t(box_formed ?x ?y))\n(<= two_boxes_formed\n\t(box_formed ?x1 ?y1)\n\t(box_formed ?x2 ?y2)\n\t(or (distinct ?x1 ?x2)\n\t\t(distinct ?y1 ?y2)))\n(<= (next (box_count ?player ?n))\n\t(true (box_count ?player ?n))\n\t(not (true (control ?player))))\n(<= (next (box_count ?player ?n))\n\t(true (box_count ?player ?n))\n\t(true (control ?player))\n\t(not any_box_formed))\n(<= (next (box_count ?player ?np1))\n\t(true (box_count ?player ?n))\n\t(true (control ?player))\n\tany_box_formed\n\t(not two_boxes_formed)\n\t(succ ?n ?np1))\n(<= (next (box_count ?player ?np2))\n\t(true (box_count ?player ?n))\n\t(true (control ?player))\n\ttwo_boxes_formed\n\t(succ ?n ?np1)\n\t(succ ?np1 ?np2))\n(<= (next (control ?player))\n\t(true (control ?player))\n\tany_box_formed)\n(<= (next (control xplayer))\n\t(true (control oplayer))\n\t(not any_box_formed))\n(<= (next (control oplayer))\n\t(true (control xplayer))\n\t(not any_box_formed))\n(<= (next (box ?x ?y x))\n\t(box_formed ?x ?y)\n\t(true (control xplayer)))\n(<= (next (box ?x ?y o))\n\t(box_formed ?x ?y)\n\t(true (control oplayer)))\n(<= (next (box ?x ?y ?mark))\n\t(true (box ?x ?y ?mark)))\n(<= terminal\n\t(not any_undrawn))\n(<= x_wins\n\t(true (box_count xplayer ?xscore))\n\t(true (box_count oplayer ?oscore))\n\t(gt ?xscore ?oscore))\n(<= o_wins\n\t(true (box_count xplayer ?xscore))\n\t(true (box_count oplayer ?oscore))\n\t(gt ?oscore ?xscore))\n(<= o_wins\n\t(true (box_count xplayer ?tied))\n\t(true (box_count oplayer ?tied)))\n(<= (goal xplayer 100)\n\tx_wins)\n(<= (goal xplayer 0)\n\t(not x_wins))\n(<= (goal oplayer 100)\n\to_wins)\n(<= (goal oplayer 0)\n\t(not o_wins))\n(<= (gt ?h ?l)\n\t(succ ?l ?h))\n(<= (gt ?h ?l)\n\t(succ ?m ?h)\n\t(gt ?m ?l)\n\t(succ ?l ?lp1))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8x8 board with coordinates ranging from 1 to 8 on both the x (columns) and y (rows) axes, where positions are indexed from 1 through 8 in each dimension. There are two players, identified by the roles black and red, who take turns alternately. The initial board setup places four pieces in the center of the board: black pieces are at coordinates (4,4) and (5,5), while red pieces occupy (4,5) and (5,4). Black starts the game with control of the turn. On a player's turn, they may either make a move or choose to perform a no-operation (noop). A noop is legal when it is not that player's turn or when the player has no legal moves available. A move consists of placing a piece of the player's color on an empty cell that is adjacent to at least one opponent's piece in some direction and where, continuing in that direction, there exists a contiguous line of one or more opponent pieces followed by a piece of the player's own color. Directions on the board include the eight compass points—north, south, east, west, northeast, northwest, southeast, and southwest—each corresponding to specific coordinate offsets. After a move, all opponent pieces in all directions that are bracketed between the newly placed piece and another piece of the current player's color are flipped to the current player's color. This flipping occurs recursively along each direction, effectively converting all captured opponent pieces. The control of the turn switches to the opposing player after each move or noop. Implicit constraints include the board boundaries which restrict moves and flips to cells within the 1-to-8 range for both coordinates, and that pieces can only be placed on empty cells. The game ends when neither player has any legal moves available. At this terminal state, the player with the greater number of pieces on the board is declared the winner; if one player has more pieces than the other, that player receives a goal value of 100, the other 0, and a draw yields both players a goal value of 50. Thus, the objective is to maximize one's total piece count by the time no further moves can be made.",
    "output": "(role black)\n(role red)\n(opponent black red)\n(opponent red black)\n(init (cell 4 4 black))\n(init (cell 4 5 red))\n(init (cell 5 4 red))\n(init (cell 5 5 black))\n(init (control black))\n(oppDir nw se)\n(oppDir ne sw)\n(oppDir se nw)\n(oppDir sw ne)\n(oppDir n s)\n(oppDir e w)\n(oppDir s n)\n(oppDir w e)\n(dir n 0 p1)\n(dir s 0 n1)\n(dir e p1 0)\n(dir w n1 0)\n(dir nw n1 p1)\n(dir ne p1 p1)\n(dir se p1 n1)\n(dir sw n1 n1)\n(<= (hasOtherColorInDir ?x1 ?y1 ?dir)\n    (true (cell ?x1 ?y1 ?color))\n    (opponent ?color ?otherColor)\n    (nextCellInDir ?x1 ?y1 ?dir ?x2 ?y2)\n    (true (cell ?x2 ?y2 ?otherColor)))\n(<= (hasOtherColorInDir ?x1 ?y1 ?dir)\n    (true (cell ?x1 ?y1 ?color))\n    (nextCellInDir ?x1 ?y1 ?dir ?x2 ?y2)\n    (true (cell ?x2 ?y2 ?color))\n    (hasOtherColorInDir ?x2 ?y2 ?dir))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?anyColor)))\n(<= (empty ?x ?y)\n    (index ?x)\n    (index ?y)\n    (not (occupied ?x ?y)))\n(<= (playerCanMoveAt ?color ?x ?y)\n\t(empty ?x ?y)\n\t(opponent ?color ?otherColor)\n\t(nextCellInDir ?x ?y ?dir ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?otherColor))\n\t(hasOtherColorInDir ?x2 ?y2 ?dir))\n(<= (playerCanMove ?player)\n    (playerCanMoveAt ?player ?anyX ?anyY))\n(<= (legal ?player noop)\n    (true (control ?opponent))\n    (opponent ?player ?opponent))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (playerCanMove ?player)))\n(<= (legal ?player (move ?x ?y))\n    (true (control ?player))\n    (playerCanMoveAt ?player ?x ?y))\n(<= (next (control ?nextPlayer))\n    (true (control ?curPlayer))\n    (opponent ?curPlayer ?nextPlayer))\n(<= (affected ?x2 ?y2 ?dir ?otherColor)\n    (does ?player (move ?x1 ?y1))\n    (opponent ?player ?otherColor)\n    (nextCellInDir ?x1 ?y1 ?dir ?x2 ?y2)\n    (hasOtherColorInDir ?x2 ?y2 ?dir)\n    (true (cell ?x2 ?y2 ?otherColor)))\n(<= (affected ?x2 ?y2 ?dir ?color)\n    (hasOtherColorInDir ?x2 ?y2 ?dir)\n    (oppDir ?dir ?oppDir)\n    (nextCellInDir ?x2 ?y2 ?oppDir ?x1 ?y1)\n    (affected ?x1 ?y1 ?dir ?color)\n    (true (cell ?x2 ?y2 ?color)))\n(<= (affectedCell ?x ?y)\n    (affected ?x ?y ?anyDir ?anyColor))\n(<= (next (cell ?x ?y ?color))\n    (true (cell ?x ?y ?color))\n    (not (affectedCell ?x ?y)))\n(<= (next (cell ?x ?y ?color))\n    (does ?color (move ?x ?y)))\n(<= (next (cell ?x ?y ?color))\n    (does ?color (move ?anyX ?anyY))\n    (affectedCell ?x ?y))\n(<= terminal\n    (not (playerCanMove black))\n    (not (playerCanMove red)))\n(<= (pieceCount 1 1 ?color 1)\n    (true (cell 1 1 ?color)))\n(<= (pieceCount 1 1 ?color 0)\n    (role ?color)\n    (not (true (cell 1 1 ?color))))\n(<= (pieceCount ?x ?yp1 ?color ?np1)\n    (add ?y p1 ?yp1)\n    (pieceCount ?x ?y ?color ?n)\n    (succ ?n ?np1)\n    (true (cell ?x ?yp1 ?color)))\n(<= (pieceCount ?x ?yp1 ?color ?n)\n    (add ?y p1 ?yp1)\n    (pieceCount ?x ?y ?color ?n)\n    (not (true (cell ?x ?yp1 ?color))))\n(<= (pieceCount ?xp1 1 ?color ?np1)\n    (add ?x p1 ?xp1)\n    (pieceCount ?x 8 ?color ?n)\n    (succ ?n ?np1)\n    (true (cell ?xp1 1 ?color)))\n(<= (pieceCount ?xp1 1 ?color ?n)\n    (add ?x p1 ?xp1)\n    (pieceCount ?x 8 ?color ?n)\n    (not (true (cell ?xp1 1 ?color))))\n(<= (totalCount ?player ?n)\n    (pieceCount 8 8 ?player ?n))\n(<= (winner black)\n    (totalCount black ?blackCount)\n    (totalCount red ?redCount)\n    (lessThan ?redCount ?blackCount))\n(<= (winner red)\n    (totalCount black ?blackCount)\n    (totalCount red ?redCount)\n    (lessThan ?blackCount ?redCount))\n(<= (goal ?player 0)\n    (winner ?player))\n(<= (goal ?player 100)\n    (winner ?opponent)\n    (opponent ?player ?opponent))\n(<= (goal ?player 50)\n\t(role ?player)\n\t(not (winner black))\n\t(not (winner red)))\n(<= (nextCellInDir ?x1 ?y1 ?dir ?x2 ?y2)\n    (index ?x1)\n    (index ?y1)\n    (dir ?dir ?xDelta ?yDelta)\n    (add ?x1 ?xDelta ?x2)\n    (add ?y1 ?yDelta ?y2))\n(add 1 p1 2)\n(add 2 p1 3)\n(add 3 p1 4)\n(add 4 p1 5)\n(add 5 p1 6)\n(add 6 p1 7)\n(add 7 p1 8)\n(add 1 0 1)\n(add 2 0 2)\n(add 3 0 3)\n(add 4 0 4)\n(add 5 0 5)\n(add 6 0 6)\n(add 7 0 7)\n(add 8 0 8)\n(add 8 n1 7)\n(add 7 n1 6)\n(add 6 n1 5)\n(add 5 n1 4)\n(add 4 n1 3)\n(add 3 n1 2)\n(add 2 n1 1)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(<= (lessThan ?x ?z)\n    (succ ?x ?y)\n    (lessThan ?y ?z))\n(<= (lessThan ?x ?y)\n    (succ ?x ?y))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set in a discrete two-dimensional coordinate system with positions defined by integer x and y coordinates, where the map wraps around horizontally and vertically according to a predefined modular arithmetic mapping that cycles coordinates between 1 and 20. The player controls a single ship that has an initial position at coordinates (10, 10) and an initial heading facing north, with a northward speed of 3 and an eastward speed of 2. The game proceeds in discrete time steps starting from step 1, incrementing by one each turn until a maximum of 50 steps is reached, which triggers a timeout terminal condition. The single player role, named \"ship,\" acts in every turn and may choose one of three legal actions: \"thrust,\" which adjusts the ship’s speed in the direction it is currently facing; \"turn clockwise,\" which rotates the ship's heading 90 degrees clockwise without changing its speed; or \"turn counterclockwise,\" which rotates the ship's heading 90 degrees counterclockwise, also without changing speed. These actions are legal on every turn, and there is no explicit no-operation (noop) action; however, the player may choose to \"thrust\" or \"turn\" as desired. When the ship performs a thrust action, its speed components are updated by incrementing or decrementing the speed along the north or east dimension depending on its current heading: thrusting north increases north-speed, thrusting south decreases north-speed, thrusting east increases east-speed, and thrusting west decreases east-speed, with speeds bounded between -3 and 3. Turning actions do not alter the speed but rotate the heading among the four cardinal directions: north, east, south, and west, cycling appropriately clockwise or counterclockwise. After the heading and speeds are updated, the ship's position is updated by adding the current east-speed to the x-coordinate and the north-speed to the y-coordinate, with all coordinates mapped back into the range from 1 to 20 by the modular map function, effectively creating a toroidal board. The game terminates if the ship is stopped, defined as having zero speed in both north and east directions, or if the step count reaches 50, triggering the timeout terminal condition. The goal is linked to whether the ship is stopped and whether it is located at a specific coordinate identified as the planet at position (15, 5). If the ship is stopped at this planet location, the player scores 100 points; if stopped elsewhere, the score is 50 points; and if the ship is not stopped, the score is 0. Thus, the player aims to maneuver the ship through thrusts and turns to arrive at and stop on the planet's coordinates before time runs out to maximize the score. The ship's movement respects the wrap-around map boundaries, and no occupancy conflicts or multiple players exist, so no additional constraints on movement legality beyond those implied by heading and speed apply.",
    "output": "(role ship)\n(init (x 10))\n(init (y 10))\n(init (heading north))\n(init (north-speed 3))\n(init (east-speed 2))\n(init (step 1))\n(legal ship thrust)\n(legal ship (turn clock))\n(legal ship (turn counter))\n(<= (next (heading ?h))\n    (true (heading ?h))\n    (does ship thrust))\n(<= (next (heading west))\n    (true (heading north))\n    (does ship (turn counter)))\n(<= (next (heading south))\n    (true (heading west))\n    (does ship (turn counter)))\n(<= (next (heading east))\n    (true (heading south))\n    (does ship (turn counter)))\n(<= (next (heading north))\n    (true (heading east))\n    (does ship (turn counter)))\n(<= (next (heading east))\n    (true (heading north))\n    (does ship (turn clock)))\n(<= (next (heading south))\n    (true (heading east))\n    (does ship (turn clock)))\n(<= (next (heading west))\n    (true (heading south))\n    (does ship (turn clock)))\n(<= (next (heading north))\n    (true (heading west))\n    (does ship (turn clock)))\n(<= (next (north-speed ?s))\n    (true (north-speed ?s))\n    (does ship (turn clock)))\n(<= (next (north-speed ?s))\n    (true (north-speed ?s))\n    (does ship (turn counter)))\n(<= (next (north-speed ?s))\n    (true (north-speed ?s))\n    (true (heading east)))\n(<= (next (north-speed ?s))\n    (true (north-speed ?s))\n    (true (heading west)))\n(<= (next (north-speed ?s2))\n    (true (north-speed ?s1))\n    (true (heading north))\n    (does ship thrust)\n    (speed+ ?s1 ?s2))\n(<= (next (north-speed ?s2))\n    (true (north-speed ?s1))\n    (true (heading south))\n    (does ship thrust)\n    (speed- ?s1 ?s2))\n(<= (next (east-speed ?s))\n    (true (east-speed ?s))\n    (does ship (turn clock)))\n(<= (next (east-speed ?s))\n    (true (east-speed ?s))\n    (does ship (turn counter)))\n(<= (next (east-speed ?s))\n    (true (east-speed ?s))\n    (true (heading north)))\n(<= (next (east-speed ?s))\n    (true (east-speed ?s))\n    (true (heading south)))\n(<= (next (east-speed ?s2))\n    (true (east-speed ?s1))\n    (true (heading east))\n    (does ship thrust)\n    (speed+ ?s1 ?s2))\n(<= (next (east-speed ?s2))\n    (true (east-speed ?s1))\n    (true (heading west))\n    (does ship thrust)\n    (speed- ?s1 ?s2))\n(<= (next (x ?new))\n    (true (x ?old))\n    (true (east-speed ?s))\n    (map+ ?old ?s ?new))\n(<= (next (y ?new))\n    (true (y ?old))\n    (true (north-speed ?s))\n    (map+ ?old ?s ?new))\n(<= (next (step ?n++))\n    (true (step ?n))\n    (succ ?n ?n++))\n(<= terminal\n    stopped)\n(<= terminal\n    timeout)\n(<= (goal ship 100)\n    stopped\n    atplanet)\n(<= (goal ship 50)\n    stopped\n    (not atplanet))\n(<= (goal ship 0)\n    (not stopped))\n(<= stopped\n    (true (north-speed 0))\n    (true (east-speed 0)))\n(<= atplanet\n    (true (x 15))\n    (true (y 5)))\n(<= timeout\n    (true (step 50)))\n(map+ 20 -3 17)\n(map+ 20 -2 18)\n(map+ 20 -1 19)\n(map+ 20 0 20)\n(map+ 20 1 1)\n(map+ 20 2 2)\n(map+ 20 3 3)\n(map+ 19 -3 16)\n(map+ 19 -2 17)\n(map+ 19 -1 18)\n(map+ 19 0 19)\n(map+ 19 1 20)\n(map+ 19 2 1)\n(map+ 19 3 2)\n(map+ 18 -3 15)\n(map+ 18 -2 16)\n(map+ 18 -1 17)\n(map+ 18 0 18)\n(map+ 18 1 19)\n(map+ 18 2 20)\n(map+ 18 3 1)\n(map+ 17 -3 14)\n(map+ 17 -2 15)\n(map+ 17 -1 16)\n(map+ 17 0 17)\n(map+ 17 1 18)\n(map+ 17 2 19)\n(map+ 17 3 20)\n(map+ 16 -3 13)\n(map+ 16 -2 14)\n(map+ 16 -1 15)\n(map+ 16 0 16)\n(map+ 16 1 17)\n(map+ 16 2 18)\n(map+ 16 3 19)\n(map+ 15 -3 12)\n(map+ 15 -2 13)\n(map+ 15 -1 14)\n(map+ 15 0 15)\n(map+ 15 1 16)\n(map+ 15 2 17)\n(map+ 15 3 18)\n(map+ 14 -3 11)\n(map+ 14 -2 12)\n(map+ 14 -1 13)\n(map+ 14 0 14)\n(map+ 14 1 15)\n(map+ 14 2 16)\n(map+ 14 3 17)\n(map+ 13 -3 10)\n(map+ 13 -2 11)\n(map+ 13 -1 12)\n(map+ 13 0 13)\n(map+ 13 1 14)\n(map+ 13 2 15)\n(map+ 13 3 16)\n(map+ 12 -3 9)\n(map+ 12 -2 10)\n(map+ 12 -1 11)\n(map+ 12 0 12)\n(map+ 12 1 13)\n(map+ 12 2 14)\n(map+ 12 3 15)\n(map+ 11 -3 8)\n(map+ 11 -2 9)\n(map+ 11 -1 10)\n(map+ 11 0 11)\n(map+ 11 1 12)\n(map+ 11 2 13)\n(map+ 11 3 14)\n(map+ 10 -3 7)\n(map+ 10 -2 8)\n(map+ 10 -1 9)\n(map+ 10 0 10)\n(map+ 10 1 11)\n(map+ 10 2 12)\n(map+ 10 3 13)\n(map+ 9 -3 6)\n(map+ 9 -2 7)\n(map+ 9 -1 8)\n(map+ 9 0 9)\n(map+ 9 1 10)\n(map+ 9 2 11)\n(map+ 9 3 12)\n(map+ 8 -3 5)\n(map+ 8 -2 6)\n(map+ 8 -1 7)\n(map+ 8 0 8)\n(map+ 8 1 9)\n(map+ 8 2 10)\n(map+ 8 3 11)\n(map+ 7 -3 4)\n(map+ 7 -2 5)\n(map+ 7 -1 6)\n(map+ 7 0 7)\n(map+ 7 1 8)\n(map+ 7 2 9)\n(map+ 7 3 10)\n(map+ 6 -3 3)\n(map+ 6 -2 4)\n(map+ 6 -1 5)\n(map+ 6 0 6)\n(map+ 6 1 7)\n(map+ 6 2 8)\n(map+ 6 3 9)\n(map+ 5 -3 2)\n(map+ 5 -2 3)\n(map+ 5 -1 4)\n(map+ 5 0 5)\n(map+ 5 1 6)\n(map+ 5 2 7)\n(map+ 5 3 8)\n(map+ 4 -3 1)\n(map+ 4 -2 2)\n(map+ 4 -1 3)\n(map+ 4 0 4)\n(map+ 4 1 5)\n(map+ 4 2 6)\n(map+ 4 3 7)\n(map+ 3 -3 20)\n(map+ 3 -2 1)\n(map+ 3 -1 2)\n(map+ 3 0 3)\n(map+ 3 1 4)\n(map+ 3 2 5)\n(map+ 3 3 6)\n(map+ 2 -3 19)\n(map+ 2 -2 20)\n(map+ 2 -1 1)\n(map+ 2 0 2)\n(map+ 2 1 3)\n(map+ 2 2 4)\n(map+ 2 3 5)\n(map+ 1 -3 18)\n(map+ 1 -2 19)\n(map+ 1 -1 20)\n(map+ 1 0 1)\n(map+ 1 1 2)\n(map+ 1 2 3)\n(map+ 1 3 4)\n(speed+ -3 -2)\n(speed+ -2 -1)\n(speed+ -1 0)\n(speed+ 0 1)\n(speed+ 1 2)\n(speed+ 2 3)\n(speed+ 3 3)\n(speed- 3 2)\n(speed- 2 1)\n(speed- 1 0)\n(speed- 0 -1)\n(speed- -1 -2)\n(speed- -2 -3)\n(speed- -3 -3)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 grid defined by files labeled from 'a' to 'h' for columns and ranks numbered from 1 to 8 for rows, forming a coordinate system where each cell is identified by a file and rank pair. There are two players, Black and White, who alternate turns starting with Black having control initially. The initial state places Black's pieces along the second and seventh ranks from files b through g, and White's pieces along the a and h files from ranks 2 to 7, respectively. On a player's turn, they may either perform a move or pass by issuing a noop action if they have no legal moves; a player not in control may only perform noop actions. A legal move consists of selecting one of the player's pieces on the board and moving it in a straight line along one of the eight compass directions (north, northeast, east, southeast, south, southwest, west, northwest) for a distance equal to the length of a contiguous line of pieces aligned in that direction including the starting piece. Movement is legal if the destination cell is either empty or occupied by an opponent's piece; pieces cannot jump over opponent pieces or empty spaces except as allowed by contiguous lines of the player's own pieces. Pieces move by sliding in the chosen direction, and the affected cells are updated accordingly, with the piece vacating its original cell and occupying the target cell. Turns alternate control between players with each move or noop, and each turn increments a step counter. Implicit constraints include board boundaries which confine movement within files a to h and ranks 1 to 8, and adjacency defined by cells next to each other in any of the eight directions. The game ends when either player has all their pieces connected in a single cluster, meaning every piece is reachable from every other piece through adjacent pieces of the same player, or when 50 steps have elapsed. The victory condition awards 100 points to a player who achieves full connectivity of their pieces while the opponent does not; if both players have fully connected pieces or neither does by the end, the score is a draw of 50 points for each player. Thus, the objective is to maneuver pieces to form a single connected group while preventing the opponent from doing the same, within the turn limit.",
    "output": "(role black)\n(role white)\n(init (cell b 1 black))\n(init (cell c 1 black))\n(init (cell d 1 black))\n(init (cell e 1 black))\n(init (cell f 1 black))\n(init (cell g 1 black))\n(init (cell b 8 black))\n(init (cell c 8 black))\n(init (cell d 8 black))\n(init (cell e 8 black))\n(init (cell f 8 black))\n(init (cell g 8 black))\n(init (cell a 2 white))\n(init (cell a 3 white))\n(init (cell a 4 white))\n(init (cell a 5 white))\n(init (cell a 6 white))\n(init (cell a 7 white))\n(init (cell h 2 white))\n(init (cell h 3 white))\n(init (cell h 4 white))\n(init (cell h 5 white))\n(init (cell h 6 white))\n(init (cell h 7 white))\n(init (control black))\n(init (step 0))\n(<= (startingPointOfLine ?x ?y ?dir ?startX ?startY)\n    (oppositeDir ?dir ?oppDir)\n    (nextCellInDir ?oppDir ?x ?y ?x2 ?y2)\n    (startingPointOfLine ?x2 ?y2 ?dir ?startX ?startY))\n(<= (canGoFurther ?x ?y ?dir)\n    (nextCellInDir ?dir ?x ?y ?x2 ?y2))\n(<= (startingPointOfLine ?x ?y ?dir ?x ?y)\n    (file ?x)\n    (rank ?y)\n    (oppositeDir ?dir ?oppDir)\n    (not (canGoFurther ?x ?y ?oppDir)))\n(<= (partialLineCount ?startX ?startY ?dir 0 ?startX ?startY)\n    (startingPointOfLine ?startX ?startY ?dir ?startX ?startY)\n    (empty ?startX ?startY))\n(<= (partialLineCount ?startX ?startY ?dir 1 ?startX ?startY)\n    (startingPointOfLine ?startX ?startY ?dir ?startX ?startY)\n    (true (cell ?startX ?startY ?anyPlayer)))\n(<= (partialLineCount ?startX ?startY ?dir ?n ?x2 ?y2)\n    (partialLineCount ?startX ?startY ?dir ?n ?x1 ?y1)\n    (nextCellInDir ?dir ?x1 ?y1 ?x2 ?y2)\n    (empty ?x2 ?y2))\n(<= (partialLineCount ?startX ?startY ?dir ?np1 ?x2 ?y2)\n    (partialLineCount ?startX ?startY ?dir ?n ?x1 ?y1)\n    (nextCellInDir ?dir ?x1 ?y1 ?x2 ?y2)\n    (true (cell ?x2 ?y2 ?anyPlayer))\n    (succ8 ?n ?np1))\n(<= (moveLength ?x ?y ?dir ?length)\n    (startingPointOfLine ?x ?y ?dir ?startX ?startY)\n    (lineCount ?startX ?startY ?dir ?length))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player ?move)\n    (true (control ?player))\n    (legalMove ?player ?move))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (anyLegalMove ?player)))\n(<= (anyLegalMove ?player)\n    (legalMove ?player ?move))\n(<= (legalMove ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 ?player))\n    (dir ?dir)\n    (moveLength ?x1 ?y1 ?dir ?length)\n    (canMoveNSpacesInDir ?player ?x1 ?y1 ?dir ?length ?x2 ?y2))\n(<= (canMoveNSpacesInDir ?player ?x1 ?y1 ?dir 1 ?x2 ?y2)\n    (nextCellInDir ?dir ?x1 ?y1 ?x2 ?y2)\n    (role ?player)\n    (empty ?x2 ?y2))\n(<= (canMoveNSpacesInDir ?player ?x1 ?y1 ?dir 1 ?x2 ?y2)\n    (nextCellInDir ?dir ?x1 ?y1 ?x2 ?y2)\n    (opponent ?player ?opponent)\n    (true (cell ?x2 ?y2 ?opponent)))\n(<= (canMoveNSpacesInDir ?player ?x1 ?y1 ?dir ?np1 ?x3 ?y3)\n    (succ8 ?n ?np1)\n    (distinct ?np1 1)\n    (nextCellInDir ?dir ?x1 ?y1 ?x2 ?y2)\n    (or (empty ?x2 ?y2)\n        (true (cell ?x2 ?y2 ?player)))\n    (canMoveNSpacesInDir ?player ?x2 ?y2 ?dir ?n ?x3 ?y3))\n(<= (empty ?x ?y)\n    (file ?x)\n    (rank ?y)\n    (not (true (cell ?x ?y white)))\n    (not (true (cell ?x ?y black))))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= (next (step ?np1))\n    (true (step ?n))\n    (succ ?n ?np1))\n(<= (next (cell ?x ?y ?player))\n    (true (cell ?x ?y ?player))\n    (not (affected ?x ?y)))\n(<= (affected ?x1 ?y1)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (affected ?x2 ?y2)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x2 ?y2 ?player))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (notAllConnected ?player)\n    (true (cell ?x1 ?y1 ?player))\n    (true (cell ?x2 ?y2 ?player))\n    (or (distinct ?x1 ?x2)\n        (distinct ?y1 ?y2))\n    (not (connected ?player ?x1 ?y1 ?x2 ?y2)))\n(<= (connected ?player ?x1 ?y1 ?x2 ?y2)\n    (true (cell ?x1 ?y1 ?player))\n    (adjacent ?x1 ?y1 ?x2 ?y2)\n    (true (cell ?x2 ?y2 ?player)))\n(<= (connected ?player ?x1 ?y1 ?x3 ?y3)\n    (connected ?player ?x1 ?y1 ?x2 ?y2)\n    (adjacent ?x2 ?y2 ?x3 ?y3)\n    (true (cell ?x3 ?y3 ?player)))\n(<= (allConnected ?player)\n    (role ?player)\n    (not (notAllConnected ?player)))\n(<= terminal\n    (allConnected ?player))\n(<= terminal\n    (true (step 50)))\n(<= (goal ?player 100)\n    (allConnected ?player)\n    (opponent ?player ?opponent)\n    (notAllConnected ?opponent))\n(<= (goal ?player 0)\n    (notAllConnected ?player)\n    (opponent ?player ?opponent)\n    (allConnected ?opponent))\n(<= (goal ?player 50)\n    (allConnected ?player)\n    (opponent ?player ?opponent)\n    (allConnected ?opponent))\n(<= (goal ?player 50)\n    (notAllConnected ?player)\n    (opponent ?player ?opponent)\n    (notAllConnected ?opponent))\n(opponent white black)\n(opponent black white)\n(file a)\n(file b)\n(file c)\n(file d)\n(file e)\n(file f)\n(file g)\n(file h)\n(rank 1)\n(rank 2)\n(rank 3)\n(rank 4)\n(rank 5)\n(rank 6)\n(rank 7)\n(rank 8)\n(nextFile a b)\n(nextFile b c)\n(nextFile c d)\n(nextFile d e)\n(nextFile e f)\n(nextFile f g)\n(nextFile g h)\n(nextRank 1 2)\n(nextRank 2 3)\n(nextRank 3 4)\n(nextRank 4 5)\n(nextRank 5 6)\n(nextRank 6 7)\n(nextRank 7 8)\n(dir n)\n(dir ne)\n(dir e)\n(dir se)\n(dir s)\n(dir sw)\n(dir w)\n(dir nw)\n(oppositeDir n s)\n(oppositeDir ne sw)\n(oppositeDir e w)\n(oppositeDir se nw)\n(oppositeDir s n)\n(oppositeDir sw ne)\n(oppositeDir w e)\n(oppositeDir nw se)\n(<= (nextCellInDir n ?x ?y1 ?x ?y2)\n    (file ?x)\n    (nextRank ?y1 ?y2))\n(<= (nextCellInDir ne ?x1 ?y1 ?x2 ?y2)\n    (nextFile ?x1 ?x2)\n    (nextRank ?y1 ?y2))\n(<= (nextCellInDir e ?x1 ?y ?x2 ?y)\n    (nextFile ?x1 ?x2)\n    (rank ?y))\n(<= (nextCellInDir se ?x1 ?y1 ?x2 ?y2)\n    (nextFile ?x1 ?x2)\n    (nextRank ?y2 ?y1))\n(<= (nextCellInDir s ?x ?y1 ?x ?y2)\n    (file ?x)\n    (nextRank ?y2 ?y1))\n(<= (nextCellInDir sw ?x1 ?y1 ?x2 ?y2)\n    (nextFile ?x2 ?x1)\n    (nextRank ?y2 ?y1))\n(<= (nextCellInDir w ?x1 ?y ?x2 ?y)\n    (nextFile ?x2 ?x1)\n    (rank ?y))\n(<= (nextCellInDir nw ?x1 ?y1 ?x2 ?y2)\n    (nextFile ?x2 ?x1)\n    (nextRank ?y1 ?y2))\n(<= (adjacent ?x1 ?y1 ?x2 ?y2)\n    (nextCellInDir ?dir ?x1 ?y1 ?x2 ?y2))\n(succ8 0 1)\n(succ8 1 2)\n(succ8 2 3)\n(succ8 3 4)\n(succ8 4 5)\n(succ8 5 6)\n(succ8 6 7)\n(succ8 7 8)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(<= (straightLine ?dir ?x1 ?y1 ?x2 ?y2)\n    (nextCellInDir ?dir ?x1 ?y1 ?x2 ?y2))\n(<= (straightLine ?dir ?x1 ?y1 ?x3 ?y3)\n    (nextCellInDir ?dir ?x1 ?y1 ?x2 ?y2)\n    (straightLine ?dir ?x2 ?y2 ?x3 ?y3))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board consisting of multiple specified locations arranged in a coordinate system labeled with letters a through f and numbers 1 through 6, such as a3, c5, and f4. There are two players, named red and teal, who alternate turns, with red taking the first move as indicated by the control variable initially set to red. The initial board state places red pieces on locations a3, a4, b3, and b4, while teal pieces occupy c1, c2, d1, and d2; the remaining specified locations start blank. On each turn, the player in control may either move a piece or perform a noop action. A move consists of specifying a source location occupied by the player's piece and a target location that is blank and reachable based on predefined adjacency relations unique to each player’s movement paths. Moves are legal only if the source contains the player's piece and the destination is reachable according to a chain of adjacent positions defined by player-specific \"car\" relations, ensuring moves correspond to valid steps along these paths. The noop action is legal either if it is the opponent's turn (allowing a player to pass) or if the current player has no movable pieces, determined by the inability to legally move any of their four pieces. Upon a move, the piece is transferred from the source to the destination cell, leaving the source blank, while all other cells remain unchanged; performing noop actions leaves the board state unaltered. Control alternates between red and teal after each turn, and the game advances a step counter incrementing from 1 up to a maximum of 40. The game terminates when 40 steps have occurred or when one player has achieved a winning condition defined as occupying all four of their designated goal cells, which are e3, e4, f3, and f4 for red, and c5, c6, d5, and d6 for teal. Scoring is based on how many of these target cells a player controls at termination or when a player first occupies all four, with a maximum score of 100 awarded for complete control of these cells. Partial control yields descending scores of 75, 50, 25, or 0 depending on the number of goal cells occupied. If a player first achieves full control, they become the \"first\" and gain maximum points, while the opponent scores less accordingly. The game enforces implicit constraints such as the board boundaries represented by the predefined locations, the occupancy of cells by only one piece or blank, and movement restricted to adjacency relations unique to each player, which simulate paths pieces can traverse. These rules ensure that pieces cannot move arbitrarily but must follow a sequence of steps through permitted adjacent cells. Overall, the game challenges players to strategically move their pieces along these paths to dominate key target locations within a limited number of turns, with victory determined by relative control of these cells and timely occupation.",
    "output": "(role red)\n(role teal)\n(init (cell a3 red))\n(init (cell a4 red))\n(init (cell b3 red))\n(init (cell b4 red))\n(init (cell c1 teal))\n(init (cell c2 teal))\n(init (cell c3 blank))\n(init (cell c4 blank))\n(init (cell c5 blank))\n(init (cell c6 blank))\n(init (cell d1 teal))\n(init (cell d2 teal))\n(init (cell d3 blank))\n(init (cell d4 blank))\n(init (cell d5 blank))\n(init (cell d6 blank))\n(init (cell e3 blank))\n(init (cell e4 blank))\n(init (cell f3 blank))\n(init (cell f4 blank))\n(init (control red))\n(init (first nobody))\n(init (step 1))\n(<= (next (cell ?e ?player))\n    (does ?player (move ?b ?e)))\n(<= (next (cell ?b blank))\n    (does ?player (move ?b ?e)))\n(<= (next (cell ?x ?z))\n    (true (cell ?x ?z))\n    (does ?player (move ?b ?e))\n    (distinct ?x ?b)\n    (distinct ?x ?e))\n(<= (next (cell ?x ?z))\n    (true (cell ?x ?z))\n    (does red noop)\n    (does teal noop))\n(<= (next (control teal))\n    (true (control red)))\n(<= (next (control red))\n    (true (control teal)))\n(<= (next (first red))\n    (stones red all)\n    (not (stones teal all)))\n(<= (next (first teal))\n    (stones teal all)\n    (not (stones red all)))\n(<= (next (first ?player))\n    (role ?player)\n    (true (first ?player)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (succ ?x ?y))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(location a3)\n(location a4)\n(location b3)\n(location b4)\n(location c1)\n(location c2)\n(location c3)\n(location c4)\n(location c5)\n(location c6)\n(location d1)\n(location d2)\n(location d3)\n(location d4)\n(location d5)\n(location d6)\n(location e3)\n(location e4)\n(location f3)\n(location f4)\n(<= (legal ?player (move ?b ?e))\n    (true (control ?player))\n    (movable ?player ?b ?e))\n(<= (legal ?player noop)\n    (true (control ?player2))\n    (distinct ?player ?player2)\n    (role ?player))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (true (cell ?b1 ?player))\n    (stuck ?b1 ?player)\n    (true (cell ?b2 ?player))\n    (distinct ?b1 ?b2)\n    (stuck ?b2 ?player)\n    (true (cell ?b3 ?player))\n    (distinct ?b2 ?b3)\n    (distinct ?b3 ?b1)\n    (stuck ?b3 ?player)\n    (true (cell ?b4 ?player))\n    (distinct ?b1 ?b4)\n    (distinct ?b2 ?b4)\n    (distinct ?b3 ?b4)\n    (stuck ?b4 ?player))\n(<= (stuck ?b ?player)\n    (not (movableplayer ?player ?b))\n    (role ?player)\n    (location ?b))\n(<= (movableplayer ?player ?b)\n    (movable ?player ?b ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (true (cell ?c ?p1))\n    (distinct ?p1 blank)\n    (car ?player ?c ?x)\n    (true (cell ?x blank))\n    (car ?player ?x ?d)\n    (true (cell ?d ?p2))\n    (distinct ?p2 blank)\n    (car ?player ?d ?e)\n    (true (cell ?e blank)))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (true (cell ?c ?p))\n    (distinct ?p blank)\n    (car ?player ?c ?e)\n    (true (cell ?e blank)))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?e)\n    (true (cell ?e blank)))\n(<= (car red ?b ?e)\n    (carred ?b ?e))\n(<= (car teal ?b ?e)\n    (carteal ?b ?e))\n(carred a3 b3)\n(carred a4 b4)\n(carred b3 c3)\n(carred b4 c4)\n(carred c1 d1)\n(carred c2 d2)\n(carred c3 d3)\n(carred c4 d4)\n(carred c5 d5)\n(carred c6 d6)\n(carred d3 e3)\n(carred d4 e4)\n(carred e3 f3)\n(carred e4 f4)\n(carteal a3 a4)\n(carteal b3 b4)\n(carteal c1 c2)\n(carteal c2 c3)\n(carteal c3 c4)\n(carteal c4 c5)\n(carteal c5 c6)\n(carteal d1 d2)\n(carteal d2 d3)\n(carteal d3 d4)\n(carteal d4 d5)\n(carteal d5 d6)\n(carteal e3 e4)\n(carteal f3 f4)\n(<= (goal ?player 100)\n    (true (first ?player)))\n(<= (goal ?player 25)\n    (stones ?player all)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 15)\n    (stones ?player 75)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 10)\n    (stones ?player 50)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 5)\n    (stones ?player 25)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 0)\n    (stones ?player 0)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 100)\n    (true (step 40))\n    (stones ?player all)\n    (not finished))\n(<= (goal ?player 75)\n    (true (step 40))\n    (stones ?player 75)\n    (not finished))\n(<= (goal ?player 50)\n    (true (step 40))\n    (stones ?player 50)\n    (not finished))\n(<= (goal ?player 25)\n    (true (step 40))\n    (stones ?player 25)\n    (not finished))\n(<= (goal ?player 0)\n    (true (step 40))\n    (stones ?player 0)\n    (not finished))\n(<= finished\n    (true (first ?player)))\n(<= (stones red ?payoff)\n    (count e3 e4 f3 f4 red ?payoff))\n(<= (stones teal ?payoff)\n    (count c5 d5 c6 d6 teal ?payoff))\n(<= (count ?x ?y ?z ?w ?player all)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player))\n    (true (cell ?w ?player)))\n(<= (count ?x ?y ?z ?w ?player 75)\n    (true (cell ?x ?player))\n    (devoid ?y ?player)\n    (true (cell ?z ?player))\n    (true (cell ?w ?player)))\n(<= (count ?x ?y ?z ?w ?player 75)\n    (devoid ?x ?player)\n    (true (cell ?y ?player))\n    (true (cell ?z ?player))\n    (true (cell ?w ?player)))\n(<= (count ?x ?y ?z ?w ?player 50)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player))\n    (devoid ?w ?player))\n(<= (count ?x ?y ?z ?w ?player 50)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?w ?player))\n    (devoid ?z ?player))\n(<= (count ?x ?y ?z ?w ?player 25)\n    (devoid ?x ?player)\n    (devoid ?y ?player)\n    (true (cell ?z ?player))\n    (true (cell ?w ?player)))\n(<= (count ?x ?y ?z ?w ?player 0)\n    (devoid ?x ?player)\n    (devoid ?z ?player)\n    (location ?y)\n    (location ?w))\n(<= (count ?x ?y ?z ?w ?player 0)\n    (devoid ?y ?player)\n    (devoid ?z ?player)\n    (location ?x)\n    (location ?w))\n(<= (count ?x ?y ?z ?w ?player 0)\n    (devoid ?x ?player)\n    (devoid ?w ?player)\n    (location ?y)\n    (location ?z))\n(<= (count ?x ?y ?z ?w ?player 0)\n    (devoid ?y ?player)\n    (devoid ?w ?player)\n    (location ?x)\n    (location ?z))\n(<= (count ?x ?y ?z ?w ?player 0)\n    (devoid ?z ?player)\n    (devoid ?w ?player)\n    (location ?x)\n    (location ?y))\n(<= (devoid ?x ?player)\n    (true (cell ?x ?person))\n    (role ?person)\n    (distinct ?person ?player)\n    (role ?player))\n(<= (devoid ?x ?player)\n    (true (cell ?x blank))\n    (role ?player))\n(<= terminal\n    (true (step 40)))\n(<= terminal\n    (true (first ?player))\n    (stones ?player2 all)\n    (distinct ?player ?player2))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 6-by-6 board with rows and columns numbered from 1 to 6, arranged in a cyclic order where each number succeeds another in a circular fashion (e.g., 1 succeeds 6 and 2 succeeds 1). There are two players, designated as red and blue, each controlling different roles: red controls a \"snake\" and blue controls an \"assembler.\" The initial state places the blue player at coordinates (3,4) and the red player at (4,3), with both these positions initially marked. Each player starts with a score of zero and seven available marks to place. The game proceeds in turns alternating control between the snake and assembler roles, with the snake and assembler roles themselves alternating control between the red and blue players. The control alternates so that first the red player controls the snake, then the blue player controls the assembler, then control switches, continuing in this fashion. A \"step\" counter increments each turn, starting at zero, and the game ends automatically if this step count reaches 40.\n\nOn a player's turn, they must perform an action legal for their current role and control. The assembler player can move up, down, left, or right by one row or column, provided the move keeps them within the board boundaries as defined by the cyclic successor relations among rows and columns. Additionally, the assembler can perform a \"shift\" action in any direction (up, down, left, or right) on the board's rows or columns, which cyclically shifts the marked positions accordingly. The assembler may also place a \"mark\" at their current position on the board if they have remaining marks to place (greater than zero). The snake player can move one cell up, down, left, or right only if the destination cell is unoccupied by any player or obstacle, remains on the board, and does not cause a collision with the other player's occupied cells. The snake's position is represented by \"cells,\" and moves are allowed only into empty cells adjacent in one of the four cardinal directions. If the snake attempts an illegal move such as moving off-board, into an occupied cell, or causing a collision, it results in an error state for that player.\n\nEach action updates the game state accordingly: the assembler's movement updates their position on the board; shifts cyclically move marked cells in the chosen row or column, and any marks influenced by these shifts are updated to new positions. Placing a mark adds a marked cell at the assembler's current location and decreases their remaining marks count by one. The snake's moves update the cells it occupies on the board, moving to the adjacent open cell in the chosen direction. The game enforces occupancy constraints: no two players can occupy the same cell, and the snake cannot move into a cell marked as empty or off the board.\n\nScores are updated each turn based on the player's position relative to marked cells. Specifically, if a player occupies a row or column that contains marked cells, their score increases by one for each such alignment, with a double increment if both row and column conditions are met and the player is not currently on a marked cell. The maximum score caps at 50 points.\n\nThe game terminates either when the step limit of 40 is reached or if an error occurs for either player, such as the snake crashing into itself or the other player, moving off the board, or making an illegal move. Upon termination due to an error, the player who erred receives a lower score, and the other player is awarded higher points accordingly. If the game ends due to reaching the step limit, the final scores reflect the accumulated points from marks and positions on the board.\n\nThus, the game is a turn-based contest on a cyclic 6-by-6 board, where two players alternate controlling a snake and an assembler, making moves constrained by adjacency, occupancy, and board boundaries. Players place marks and shift rows or columns to influence scoring, while the snake maneuvers carefully to avoid illegal moves or collisions. The objective is to maximize one's score by strategic movement and marking before the game ends either by step limit or error, with victory determined by the final scores assigned under these conditions.",
    "output": "(role red)\n(role blue)\n(init (control_snake red))\n(init (control_assem blue))\n(init (score blue 0))\n(init (score red 0))\n(init (at blue 3 4))\n(init (at red 4 3))\n(init (marks_remain red 7))\n(init (marks_remain blue 7))\n(init (marked 4 3))\n(init (marked 3 4))\n(init (step 0))\n(score_col 1)\n(score_col 2)\n(score_col 3)\n(score_row 1)\n(score_row 2)\n(score_row 3)\n(row 1)\n(row 2)\n(row 3)\n(row 4)\n(row 5)\n(row 6)\n(col 1)\n(col 2)\n(col 3)\n(col 4)\n(col 5)\n(col 6)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(board_succ 1 2)\n(board_succ 2 3)\n(board_succ 3 4)\n(board_succ 4 5)\n(board_succ 5 6)\n(board_succ 6 1)\n(game_end 40)\n(<= (has_move_assem_up ?p ?u)\n    (true (at ?p ?i ?j))\n    (row ?u)\n    (succ ?u ?i))\n(<= (has_move_assem_down ?p ?u)\n    (true (at ?p ?i ?j))\n    (row ?u)\n    (succ ?i ?u))\n(<= (has_move_assem_right ?p ?v)\n    (true (at ?p ?i ?j))\n    (col ?v)\n    (succ ?j ?v))\n(<= (has_move_assem_left ?p ?v)\n    (true (at ?p ?i ?j))\n    (col ?v)\n    (succ ?v ?j))\n(<= (has_shift_up ?p ?j)\n    (true (at ?p ?i ?j))\n    (true (control_assem ?p)))\n(<= (has_shift_down ?p ?j)\n    (true (at ?p ?i ?j))\n    (true (control_assem ?p)))\n(<= (has_shift_left ?p ?i)\n    (true (at ?p ?i ?j))\n    (true (control_assem ?p)))\n(<= (has_shift_right ?p ?i)\n    (true (at ?p ?i ?j))\n    (true (control_assem ?p)))\n(<= (legal ?p move_assem_up)\n    (row ?u)\n    (has_move_assem_up ?p ?u))\n(<= (legal ?p move_assem_down)\n    (row ?u)\n    (has_move_assem_down ?p ?u))\n(<= (legal ?p move_assem_right)\n    (col ?v)\n    (has_move_assem_right ?p ?v))\n(<= (legal ?p move_assem_left)\n    (col ?v)\n    (has_move_assem_left ?p ?v))\n(<= (legal ?p (shift_up ?j))\n    (col ?j)\n    (has_shift_up ?p ?j))\n(<= (legal ?p (shift_down ?j))\n    (col ?j)\n    (has_shift_down ?p ?j))\n(<= (legal ?p (shift_left ?i))\n    (row ?i)\n    (has_shift_left ?p ?i))\n(<= (legal ?p (shift_right ?i))\n    (row ?i)\n    (has_shift_right ?p ?i))\n(<= (legal ?p mark)\n    (true (control_assem ?p))\n    (not (true (marks_remain ?p 0))))\n(<= (does_move_assem ?p)\n    (does ?p move_assem_up))\n(<= (does_move_assem ?p)\n    (does ?p move_assem_down))\n(<= (does_move_assem ?p)\n    (does ?p move_assem_left))\n(<= (does_move_assem ?p)\n    (does ?p move_assem_right))\n(<= (next (at ?p ?u ?j))\n    (true (at ?p ?i ?j))\n    (has_move_assem_up ?p ?u)\n    (does ?p move_assem_up))\n(<= (next (at ?p ?u ?j))\n    (true (at ?p ?i ?j))\n    (has_move_assem_down ?p ?u)\n    (does ?p move_assem_down))\n(<= (next (at ?p ?i ?v))\n    (true (at ?p ?i ?j))\n    (has_move_assem_right ?p ?v)\n    (does ?p move_assem_right))\n(<= (next (at ?p ?i ?v))\n    (true (at ?p ?i ?j))\n    (has_move_assem_left ?p ?v)\n    (does ?p move_assem_left))\n(<= (next (at ?p ?i ?j))\n    (true (at ?p ?i ?j))\n    (not (does_move_assem ?p)))\n(<= (influenced ?i ?j)\n    (role ?p)\n    (row ?i)\n    (col ?j)\n    (does ?p (shift_up ?j)))\n(<= (influenced ?i ?j)\n    (role ?p)\n    (row ?i)\n    (col ?j)\n    (does ?p (shift_down ?j)))\n(<= (influenced ?i ?j)\n    (role ?p)\n    (row ?i)\n    (col ?j)\n    (does ?p (shift_left ?i)))\n(<= (influenced ?i ?j)\n    (role ?p)\n    (row ?i)\n    (col ?j)\n    (does ?p (shift_right ?i)))\n(<= (next_marked ?i ?j)\n    (true (marked ?i ?j))\n    (not (influenced ?i ?j)))\n(<= (next_marked ?i ?j)\n    (true (marked ?u ?j))\n    (board_succ ?i ?u)\n    (does ?p (shift_up ?j)))\n(<= (next_marked ?i ?j)\n    (true (marked ?u ?j))\n    (board_succ ?u ?i)\n    (does ?p (shift_down ?j)))\n(<= (next_marked ?i ?j)\n    (true (marked ?i ?v))\n    (board_succ ?j ?v)\n    (does ?p (shift_left ?i)))\n(<= (next_marked ?i ?j)\n    (true (marked ?i ?v))\n    (board_succ ?v ?j)\n    (does ?p (shift_right ?i)))\n(<= (next (marked ?i ?j))\n    (true (at ?p ?i ?j))\n    (does ?p mark))\n(<= (next (marked ?i ?j))\n    (next_marked ?i ?j))\n(<= (next (step ?s))\n    (true (step ?u))\n    (succ ?u ?s))\n(<= (next (control_assem red))\n    (true (control_assem blue)))\n(<= (next (control_assem blue))\n    (true (control_assem red)))\n(<= (next (control_snake red))\n    (true (control_snake blue)))\n(<= (next (control_snake blue))\n    (true (control_snake red)))\n(<= (next (marks_remain ?p ?c))\n    (true (marks_remain ?p ?c))\n    (not (does ?p mark)))\n(<= (next (marks_remain ?p ?c))\n    (true (marks_remain ?p ?o))\n    (does ?p mark)\n    (succ ?c ?o))\n(<= (collect_row blue)\n    (score_col ?j)\n    (true (at blue ?i ?v))\n    (true (marked ?i ?j)))\n(<= (collect_col blue)\n    (score_col ?j)\n    (true (at blue ?u ?j))\n    (true (marked ?i ?j)))\n(<= (collect_row red)\n    (score_row ?i)\n    (true (at red ?i ?v))\n    (true (marked ?i ?j)))\n(<= (collect_col red)\n    (score_row ?i)\n    (true (at red ?u ?j))\n    (true (marked ?i ?j)))\n(<= (on_mark ?p)\n    (true (at ?p ?i ?j))\n    (true (marked ?i ?j)))\n(<= (double_increment ?p)\n    (collect_row ?p)\n    (collect_col ?p)\n    (not (on_mark ?p)))\n(<= (increment ?p)\n    (collect_row ?p)\n    (not (double_increment ?p)))\n(<= (increment ?p)\n    (collect_col ?p)\n    (not (double_increment ?p)))\n(<= (next (score ?p ?s))\n    (true (score ?p ?o))\n    (increment ?p)\n    (succ ?o ?s)\n    (not (true (score ?p 50))))\n(<= (next (score ?p ?s))\n    (true (score ?p ?m))\n    (double_increment ?p)\n    (succ ?m ?o)\n    (succ ?o ?s)\n    (not (true (score ?p 50)))\n    (not (true (score ?p 49))))\n(<= (next (score ?p 50))\n    (true (score ?p 49))\n    (double_increment ?p))\n(<= (next (score ?p ?s))\n    (true (score ?p ?s))\n    (not (increment ?p))\n    (not (double_increment ?p)))\n(<= (next (score ?p 50))\n    (true (score ?p 50)))\n(<= (goal_assem ?p ?s)\n    (true (score ?p ?s)))\n(<= terminal_assem\n    (game_end ?s)\n    (true (step ?s)))\n(init (cell 3 3 red))\n(init (cell 4 4 blue))\n(<= (legal ?p move_snake_down)\n    (role ?p)\n    (true (control_snake ?p)))\n(<= (legal ?p move_snake_up)\n    (role ?p)\n    (true (control_snake ?p)))\n(<= (legal ?p move_snake_left)\n    (role ?p)\n    (true (control_snake ?p)))\n(<= (legal ?p move_snake_right)\n    (role ?p)\n    (true (control_snake ?p)))\n(<= (snake_up_open ?a ?y ?p)\n    (role ?p)\n    (true (cell ?x ?y ?p))\n    (succ ?a ?x)\n    (not (true (cell ?a ?y f))))\n(<= (snake_down_open ?a ?y ?p)\n    (role ?p)\n    (true (cell ?x ?y ?p))\n    (succ ?x ?a)\n    (not (true (cell ?a ?y f))))\n(<= (snake_right_open ?x ?b ?p)\n    (role ?p)\n    (true (cell ?x ?y ?p))\n    (succ ?y ?b)\n    (not (true (cell ?x ?b f))))\n(<= (snake_left_open ?x ?b ?p)\n    (role ?p)\n    (true (cell ?x ?y ?p))\n    (succ ?b ?y)\n    (not (true (cell ?x ?b f))))\n(<= (snake_move_open ?p)\n    (snake_up_open ?x ?y ?p))\n(<= (snake_move_open ?p)\n    (snake_down_open ?x ?y ?p))\n(<= (snake_move_open ?p)\n    (snake_right_open ?x ?y ?p))\n(<= (snake_move_open ?p)\n    (snake_left_open ?x ?y ?p))\n(<= (move_snake ?p)\n    (does ?p move_snake_down))\n(<= (move_snake ?p)\n    (does ?p move_snake_up))\n(<= (move_snake ?p)\n    (does ?p move_snake_left))\n(<= (move_snake ?p)\n    (does ?p move_snake_right))\n(<= (next_cell ?a ?y ?p)\n    (role ?p)\n    (does ?p move_snake_up)\n    (true (cell ?x ?y ?p))\n    (succ ?a ?x))\n(<= (next_cell ?a ?y ?p)\n    (role ?p)\n    (does ?p move_snake_down)\n    (true (cell ?x ?y ?p))\n    (succ ?x ?a))\n(<= (next_cell ?x ?b ?p)\n    (role ?p)\n    (does ?p move_snake_right)\n    (true (cell ?x ?y ?p))\n    (succ ?y ?b))\n(<= (next_cell ?x ?b ?p)\n    (role ?p)\n    (does ?p move_snake_left)\n    (true (cell ?x ?y ?p))\n    (succ ?b ?y))\n(<= (next_cell ?x ?y ?p)\n    (role ?p)\n    (not (move_snake ?p))\n    (true (cell ?x ?y ?p)))\n(<= (next (cell ?x ?y ?p))\n    (next_cell ?x ?y ?p))\n(<= (next (cell ?x ?y f))\n    (true (cell ?x ?y f)))\n(<= (next (cell ?x ?y f))\n    (role ?p)\n    (true (cell ?x ?y ?p))\n    (true (control_snake ?p))\n    (move_snake ?p))\n(<= (on_board ?p)\n    (role ?p)\n    (index ?x)\n    (index ?y)\n    (true (cell ?x ?y ?p)))\n(<= crash\n    (true (cell ?x ?y blue))\n    (true (cell ?x ?y red)))\n(<= (error ?p)\n    (role ?p)\n    (true (cell ?x ?y ?p))\n    (true (cell ?x ?y f)))\n(<= (error ?p)\n    (role ?p)\n    (not (snake_move_open ?p)))\n(<= (error ?p)\n    (role ?p)\n    (not (on_board ?p)))\n(<= (error ?p)\n    (role ?p)\n    crash)\n(<= (goal_snake red 0)\n    (not (error blue))\n    (error red))\n(<= (goal_snake red 100)\n    (error blue)\n    (not (error red)))\n(<= (goal_snake red 50)\n    (error blue)\n    (error red))\n(<= (goal_snake blue 100)\n    (not (error blue))\n    (error red))\n(<= (goal_snake blue 0)\n    (error blue)\n    (not (error red)))\n(<= (goal_snake blue 50)\n    (error blue)\n    (error red))\n(<= terminal_snake\n    (role ?p)\n    (error ?p))\n(<= (goal red 100)\n    (goal_snake red 100)\n    terminal_snake\n    (not terminal_assem))\n(<= (goal red 50)\n    (goal_snake red 50)\n    terminal_snake\n    (not terminal_assem))\n(<= (goal red 0)\n    (goal_snake red 0)\n    terminal_snake\n    (not terminal_assem))\n(<= (goal blue 100)\n    (goal_snake blue 100)\n    terminal_snake\n    (not terminal_assem))\n(<= (goal blue 50)\n    (goal_snake blue 50)\n    terminal_snake\n    (not terminal_assem))\n(<= (goal blue 0)\n    (goal_snake blue 0)\n    terminal_snake\n    (not terminal_assem))\n(<= (goal red ?s)\n    (goal_assem red ?s)\n    terminal_assem)\n(<= (goal blue ?s)\n    (goal_assem blue ?s)\n    terminal_assem)\n(<= terminal\n    terminal_snake)\n(<= terminal\n    terminal_assem)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid defined by coordinates where columns range from 1 to 7 and rows range from 0 to 6, with an initial setup consisting of the bottom row (row 0) filled with dirt cells and the cells above (rows 1 through 6) initially containing blank spaces. There are two players, white and red, who alternate turns starting with white having the control at the beginning. On a player’s turn, they may perform an action called \"drop\" by selecting a column number between 1 and 7. The drop action places the player’s piece into the lowest available blank cell in that column, immediately above the highest filled cell, causing the piece to occupy that position. If it is not a player's turn, that player may only perform the noop action, which does nothing and simply passes the turn back to the opponent. Moves are legal only if the chosen column contains at least one blank cell above a filled cell, ensuring pieces stack from the bottom up, and the control alternates after each move. The game enforces implicit constraints including the board boundaries (columns 1 to 7 and rows 0 to 6), occupancy where each cell can only hold one piece or dirt, and the vertical stacking rule where pieces must occupy the lowest available position in their column. The game proceeds until a terminal condition is met, which occurs when either player forms a consecutive line of four pieces horizontally, vertically, or diagonally, or when the board has no blank cells left (no open moves). Victory is awarded to the player who first achieves a four-in-a-row line, scoring 100 points, while the opponent scores zero. If the board fills without any player achieving such a line, both players score 50 points. If the game is still ongoing with open moves and no winner yet, both players have a provisional score of 70 points. This setup and ruleset correspond to a classic connect-four style game where players alternate dropping pieces into columns aiming to line up four consecutively.",
    "output": "(role white)\n(role red)\n(init (cell 1 0 dirt))\n(init (cell 2 0 dirt))\n(init (cell 3 0 dirt))\n(init (cell 4 0 dirt))\n(init (cell 5 0 dirt))\n(init (cell 6 0 dirt))\n(init (cell 7 0 dirt))\n(init (cell 1 1 b))\n(init (cell 1 2 b))\n(init (cell 1 3 b))\n(init (cell 1 4 b))\n(init (cell 1 5 b))\n(init (cell 1 6 b))\n(init (cell 2 1 b))\n(init (cell 2 2 b))\n(init (cell 2 3 b))\n(init (cell 2 4 b))\n(init (cell 2 5 b))\n(init (cell 2 6 b))\n(init (cell 3 1 b))\n(init (cell 3 2 b))\n(init (cell 3 3 b))\n(init (cell 3 4 b))\n(init (cell 3 5 b))\n(init (cell 3 6 b))\n(init (cell 4 1 b))\n(init (cell 4 2 b))\n(init (cell 4 3 b))\n(init (cell 4 4 b))\n(init (cell 4 5 b))\n(init (cell 4 6 b))\n(init (cell 5 1 b))\n(init (cell 5 2 b))\n(init (cell 5 3 b))\n(init (cell 5 4 b))\n(init (cell 5 5 b))\n(init (cell 5 6 b))\n(init (cell 6 1 b))\n(init (cell 6 2 b))\n(init (cell 6 3 b))\n(init (cell 6 4 b))\n(init (cell 6 5 b))\n(init (cell 6 6 b))\n(init (cell 7 1 b))\n(init (cell 7 2 b))\n(init (cell 7 3 b))\n(init (cell 7 4 b))\n(init (cell 7 5 b))\n(init (cell 7 6 b))\n(init (control white))\n(<= (empty ?c ?h)\n(true (cell ?c ?h b)))\n(<= (filled ?c ?h)\n(true (cell ?c ?h dirt)))\n(<= (filled ?c ?h)\n(true (cell ?c ?h w)))\n(<= (filled ?c ?h)\n(true (cell ?c ?h r)))\n(<= (next (cell ?c ?h2 w))\n(does white (drop ?c))\n(true (cell ?c ?h2 b))\n(filled ?c ?h1)\n(succ ?h1 ?h2))\n(<= (next (cell ?c ?h2 r))\n(does red (drop ?c))\n(true (cell ?c ?h2 b))\n(filled ?c ?h1)\n(succ ?h1 ?h2))\n(<= (next (cell ?x ?y ?z))\n(true (cell ?x ?y ?z))\n(distinct ?z b))\n(<= (next (cell ?c2 ?y b))\n(does ?w (drop ?c1))\n(true (cell ?c2 ?y b))\n(distinct ?c1 ?c2))\n(<= (next (cell ?c ?y2 b))\n(true (cell ?c ?y1 b))\n(distinct ?y1 6)\n(succ ?y1 ?y2))\n(<= (next (control white))\n(true (control red)))\n(<= (next (control red))\n(true (control white)))\n(<= (row ?z) (true (cell ?x1 ?y ?z))\n(distinct ?z b)\n(distinct ?z dirt)\n(succ ?x1 ?x2)\n(true (cell ?x2 ?y ?z))\n(succ ?x2 ?x3)\n(true (cell ?x3 ?y ?z))\n(succ ?x3 ?x4)\n(true (cell ?x4 ?y ?z))\n)\n(<= (column ?z) (true (cell ?x ?y1 ?z))\n(distinct ?z b)\n(succ ?y1 ?y2)\n(true (cell ?x ?y2 ?z))\n(succ ?y2 ?y3)\n(true (cell ?x ?y3 ?z))\n(succ ?y3 ?y4)\n(true (cell ?x ?y4 ?z))\n)\n(<= (diag ?z) (true (cell ?x1 ?y1 ?z))\n(distinct ?z b)\n(succ ?x1 ?x2)\n(succ ?y1 ?y2)\n(true (cell ?x2 ?y2 ?z))\n(succ ?x2 ?x3)\n(succ ?y2 ?y3)\n(true (cell ?x3 ?y3 ?z))\n(succ ?x3 ?x4)\n(succ ?y3 ?y4)\n(true (cell ?x4 ?y4 ?z))\n)\n(<= (diag ?z) (true (cell ?x1 ?y1 ?z))\n(distinct ?z b)\n(succ ?x1 ?x2)\n(succ ?y2 ?y1)\n(true (cell ?x2 ?y2 ?z))\n(succ ?x2 ?x3)\n(succ ?y3 ?y2)\n(true (cell ?x3 ?y3 ?z))\n(succ ?x3 ?x4)\n(succ ?y4 ?y3)\n(true (cell ?x4 ?y4 ?z))\n)\n(<= (line ?x) (row ?x))\n(<= (line ?x) (column ?x))\n(<= (line ?x) (diag ?x))\n(<= open\n(empty ?c ?h))\n(<= terminal\n(line r))\n(<= terminal\n(line w))\n(<= terminal\n(not open))\n(<= (legal ?w (drop ?c))\n(true (cell ?c ?y2 b))\n(filled ?c ?y1)\n(succ ?y1 ?y2)\n(true (control ?w)))\n(<= (legal white noop)\n(true (control red)))\n(<= (legal red noop)\n(true (control white)))\n(<= (goal white 100)\n(line w))\n(<= (goal white 50)\n(not (line r))\n(not (line w))\n(not open))\n(<= (goal white 0)\n(line r))\n(<= (goal red 100)\n(line r))\n(<= (goal red 50)\n(not (line r))\n(not (line w))\n(not open))\n(<= (goal red 0)\n(line w))\n(<= (goal ?w 70)\n(role ?w)\n(not (line r))\n(not (line w))\nopen)\n(<= (lte 0 ?x)\n(number ?x))\n(<= (lte ?x ?x)\n(number ?x))\n(<= (lte ?x ?z)\n(succ ?y ?z)\n(lte ?x ?y))\n(<= (lte ?x ?y)\n(succ ?x ?y))\n(number 0)\n(number 1)\n(number 2)\n(number 3)\n(number 4)\n(number 5)\n(number 6)\n(number 7)\n(number 8)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on an 8-by-8 grid where each cell is identified by coordinates ranging from 1 to 8 for both x (columns) and y (rows). The board cells are distinguished by \"even squares,\" defined as those whose x and y coordinates are either both odd or both even. There are two players named black and red, who alternate turns beginning with black. Initially, each player starts with twelve pawns: black pawns occupy the first three rows on the board's bottom side, placed on alternating squares starting at (1,1), (3,1), (5,1), (7,1) for the first row, similarly for the next two rows; red pawns are arranged similarly on the top three rows (rows 6 to 8) in a mirrored fashion. The game state tracks the location of each pawn, the number of captures for each player starting at zero, which player's turn it is (black to start), and a step counter beginning at one.\n\nPlayers take turns controlling their own pawns by either moving or jumping. On their turn, a player may perform one action: move, jump, or noop. A noop action is allowed only when it is not that player's turn, effectively meaning a player can only act when they have control. Moves involve moving a pawn diagonally forward by one square onto an empty cell. For black pawns, this means moving one square diagonally upward (increasing y coordinate by 1 and x coordinate by ±1), and for red pawns, moving diagonally downward (decreasing y coordinate by 1 and changing x coordinate by ±1). Jumps are special moves where a pawn leaps over an opponent's adjacent pawn onto the empty cell immediately beyond it in the same diagonal direction. For black pawns, jumps are performed diagonally upward over red pawns; for red pawns, jumps are diagonally downward over black pawns. Jumps require that the intermediate cell between the start and landing positions is occupied by an opponent pawn, and the landing cell is empty. A move or jump is legal only if it is the current player's turn, the pawn being moved or jumped belongs to that player, the destination cell is empty, and no jump is currently available for the player (moves are only allowed if no jumps are possible). If the player has any jump moves available, they must choose a jump instead of a move. Each action is described by the player specifying coordinates for the start and end cells.\n\nUpon performing a move or jump, the pawn's location updates to the destination cell. For jumps, the captured opponent pawn situated between the start and landing cells is removed from the board, and the player's capture count increments by one. The control switches to the other player after each action, and the step counter increments by one. Pawns cannot move outside the board boundaries; all coordinates must be between 1 and 8. Two pawns cannot occupy the same cell simultaneously. The game ends if either player has no pawns left on the board, or if the player whose turn it is cannot make any moves or jumps, or if 100 steps have been reached. At termination, the players’ scores are calculated based on the number of opponent pawns they have captured, mapped to a scoring scale where each capture corresponds to a certain point value from zero to one hundred. The player with the higher score wins. This game thus models a simplified version of checkers or draughts, emphasizing diagonal moves and compulsory capturing through jumps.",
    "output": "(role black)\n(role red)\n(init (location 1 1 blackPawn))\n(init (location 3 1 blackPawn))\n(init (location 5 1 blackPawn))\n(init (location 7 1 blackPawn))\n(init (location 2 2 blackPawn))\n(init (location 4 2 blackPawn))\n(init (location 6 2 blackPawn))\n(init (location 8 2 blackPawn))\n(init (location 1 3 blackPawn))\n(init (location 3 3 blackPawn))\n(init (location 5 3 blackPawn))\n(init (location 7 3 blackPawn))\n(init (location 2 6 redPawn))\n(init (location 4 6 redPawn))\n(init (location 6 6 redPawn))\n(init (location 8 6 redPawn))\n(init (location 1 7 redPawn))\n(init (location 3 7 redPawn))\n(init (location 5 7 redPawn))\n(init (location 7 7 redPawn))\n(init (location 2 8 redPawn))\n(init (location 4 8 redPawn))\n(init (location 6 8 redPawn))\n(init (location 8 8 redPawn))\n(init (captureCount black 0))\n(init (captureCount red 0))\n(init (control black))\n(init (step 1))\n(<= (legal ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (control ?player))\n\t(not (hasJump ?player))\n\t(cellOccupiedBy ?x1 ?y1 ?player)\n\t(validMove ?x1 ?y1 ?x2 ?y2)\n\t(cellEmpty ?x2 ?y2))\n(<= (legal ?player (jump ?x1 ?y1 ?x2 ?y2))\n    (true (control ?player))\n\t(cellOccupiedBy ?x1 ?y1 ?player)\n    (validJump ?x1 ?y1 ?x2 ?y2)\n\t(cellEmpty ?x2 ?y2))\n(<= (legal ?player noop)\n    (role ?player)\n\t(not (true (control ?player))))\n(<= (next (location ?x2 ?y2 ?piece))\n    (does black (move ?x1 ?y1 ?x2 ?y2))\n\t(true (location ?x1 ?y1 ?piece)))\n(<= (next (location ?x2 ?y2 ?piece))\n    (does black (jump ?x1 ?y1 ?x2 ?y2))\n\t(true (location ?x1 ?y1 ?piece)))\n(<= (next (location ?x2 ?y2 ?piece))\n    (does red (move ?x1 ?y1 ?x2 ?y2))\n\t(true (location ?x1 ?y1 ?piece)))\n(<= (next (location ?x2 ?y2 ?piece))\n    (does red (jump ?x1 ?y1 ?x2 ?y2))\n\t(true (location ?x1 ?y1 ?piece)))\n(<= (next (location ?x ?y ?piece))\n    (true (location ?x ?y ?piece))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(distinctCell ?x ?y ?x1 ?y1)\n\t(distinctCell ?x ?y ?x2 ?y2))\n(<= (next (location ?x ?y ?piece))\n    (true (location ?x ?y ?piece))\n\t(does ?player (jump ?x1 ?y1 ?x2 ?y2))\n\t(distinctCell ?x ?y ?x1 ?y1)\n\t(distinctCell ?x ?y ?x2 ?y2)\n\t(not (cellBetween ?x1 ?y1 ?x2 ?y2 ?x ?y)))\n(<= (next (captureCount ?player ?count))\n    (true (captureCount ?player ?count))\n    (not (true (control ?player))))\n(<= (next (captureCount ?player ?count))\n    (true (captureCount ?player ?count))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (captureCount ?player ?count2))\n    (true (captureCount ?player ?count1))\n    (does ?player (jump ?x1 ?y1 ?x2 ?y2))\n    (countPlus ?count1 ?count2))\n(<= (next (control black))\n    (true (control red)))\n(<= (next (control red))\n    (true (control black)))\n(<= (next (step ?tNext))\n    (true (step ?tCurrent))\n    (pp ?tCurrent ?tNext))\n(<= terminal\n    (role ?player)\n    (not (hasPiece ?player)))\n(<= terminal\n    (true (control ?player))\n    (not (hasMove ?player))\n    (not (hasJump ?player)))\n(<= terminal\n    (true (step 100)))\n(<= (goal ?player ?goal)\n    (true (captureCount ?player ?count))\n    (scoreMap ?count ?goal))\n(<= (validMove ?x1 ?y1 ?x2 ?y2)\n    (true (location ?x1 ?y1 blackPawn))\n    (blackPawnMove ?x1 ?y1 ?x2 ?y2))\n(<= (validMove ?x1 ?y1 ?x2 ?y2)\n    (true (location ?x1 ?y1 redPawn))\n    (redPawnMove ?x1 ?y1 ?x2 ?y2))\n(<= (validJump ?x1 ?y1 ?x2 ?y2)\n    (true (location ?x1 ?y1 blackPawn))\n    (blackPawnJump ?x1 ?y1 ?x2 ?y2))\n(<= (validJump ?x1 ?y1 ?x2 ?y2)\n    (true (location ?x1 ?y1 redPawn))\n    (redPawnJump ?x1 ?y1 ?x2 ?y2))\n(<= (blackPawnMove ?x1 ?y1 ?x2 ?y2)\n    (plus 1 ?x1 ?x2)\n    (plus 1 ?y1 ?y2))\n(<= (blackPawnMove ?x1 ?y1 ?x2 ?y2)\n    (plus 1 ?x2 ?x1)\n    (plus 1 ?y1 ?y2))\n(<= (redPawnMove ?x1 ?y1 ?x2 ?y2)\n    (plus 1 ?x1 ?x2)\n    (plus 1 ?y2 ?y1))\n(<= (redPawnMove ?x1 ?y1 ?x2 ?y2)\n    (plus 1 ?x2 ?x1)\n    (plus 1 ?y2 ?y1))\n(<= (blackPawnJump ?x1 ?y1 ?x3 ?y3)\n    (plus 1 ?x1 ?x2)\n    (plus 1 ?x2 ?x3)\n    (plus 1 ?y1 ?y2)\n    (plus 1 ?y2 ?y3)\n    (cellOccupiedBy ?x2 ?y2 red))\n(<= (blackPawnJump ?x1 ?y1 ?x3 ?y3)\n    (plus 1 ?x3 ?x2)\n    (plus 1 ?x2 ?x1)\n    (plus 1 ?y1 ?y2)\n    (plus 1 ?y2 ?y3)\n    (cellOccupiedBy ?x2 ?y2 red))\n(<= (redPawnJump ?x1 ?y1 ?x3 ?y3)\n    (plus 1 ?x1 ?x2)\n    (plus 1 ?x2 ?x3)\n    (plus 1 ?y3 ?y2)\n    (plus 1 ?y2 ?y1)\n    (cellOccupiedBy ?x2 ?y2 black))\n(<= (redPawnJump ?x1 ?y1 ?x3 ?y3)\n    (plus 1 ?x3 ?x2)\n    (plus 1 ?x2 ?x1)\n    (plus 1 ?y3 ?y2)\n    (plus 1 ?y2 ?y1)\n    (cellOccupiedBy ?x2 ?y2 black))\n(<= (hasPiece ?player)\n    (true (location ?x ?y ?piece))\n    (owns ?piece ?player))\n(<= (hasJump ?player)\n\t(cellOccupiedBy ?x1 ?y1 ?player)\n    (validJump ?x1 ?y1 ?x2 ?y2)\n\t(cellEmpty ?x2 ?y2))\n(<= (hasMove ?player)\n\t(cellOccupiedBy ?x1 ?y1 ?player)\n\t(validMove ?x1 ?y1 ?x2 ?y2)\n\t(cellEmpty ?x2 ?y2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= (cellBetween ?x1 ?y1 ?x3 ?y3 ?x2 ?y2)\n    (between ?x1 ?x2 ?x3)\n    (between ?y1 ?y2 ?y3))\n(<= (cellOccupiedBy ?x ?y ?player)\n    (true (location ?x ?y ?piece))\n    (owns ?piece ?player))\n(<= (cellEmpty ?x ?y)\n    (cell ?x ?y)\n    (not (cellOccupiedBy ?x ?y black))\n    (not (cellOccupiedBy ?x ?y red)))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(plus 1 1 2) (plus 1 2 3) (plus 1 3 4) (plus 1 4 5) (plus 1 5 6) (plus 1 6 7) (plus 1 7 8) (plus 1 8 1)\n(between 1 2 3) (between 2 3 4) (between 3 4 5) (between 4 5 6) (between 5 6 7) (between 6 7 8) (between 7 8 1) (between 8 1 2)\n(between 3 2 1) (between 4 3 2) (between 5 4 3) (between 6 5 4) (between 7 6 5) (between 8 7 6) (between 1 8 7) (between 2 1 8)\n(countPlus  0  1) (countPlus  1  2) (countPlus  2  3) (countPlus  3  4)\n(countPlus  4  5) (countPlus  5  6) (countPlus  6  7) (countPlus  7  8)\n(countPlus  8  9) (countPlus  9 10) (countPlus 10 11) (countPlus 11 12)\n           (pp  1  2) (pp  2  3) (pp  3  4) (pp  4  5) (pp  5  6) (pp  6  7) (pp  7  8) (pp  8  9) (pp  9  10)\n(pp 10 11) (pp 11 12) (pp 12 13) (pp 13 14) (pp 14 15) (pp 15 16) (pp 16 17) (pp 17 18) (pp 18 19) (pp 19  20)\n(pp 20 21) (pp 21 22) (pp 22 23) (pp 23 24) (pp 24 25) (pp 25 26) (pp 26 27) (pp 27 28) (pp 28 29) (pp 29  30)\n(pp 30 31) (pp 31 32) (pp 32 33) (pp 33 34) (pp 34 35) (pp 35 36) (pp 36 37) (pp 37 38) (pp 38 39) (pp 39  40)\n(pp 40 41) (pp 41 42) (pp 42 43) (pp 43 44) (pp 44 45) (pp 45 46) (pp 46 47) (pp 47 48) (pp 48 49) (pp 49  50)\n(pp 50 51) (pp 51 52) (pp 52 53) (pp 53 54) (pp 54 55) (pp 55 56) (pp 56 57) (pp 57 58) (pp 58 59) (pp 59  60)\n(pp 60 61) (pp 61 62) (pp 62 63) (pp 63 64) (pp 64 65) (pp 65 66) (pp 66 67) (pp 67 68) (pp 68 69) (pp 69  70)\n(pp 70 71) (pp 71 72) (pp 72 73) (pp 73 74) (pp 74 75) (pp 75 76) (pp 76 77) (pp 77 78) (pp 78 79) (pp 79  80)\n(pp 80 81) (pp 81 82) (pp 82 83) (pp 83 84) (pp 84 85) (pp 85 86) (pp 86 87) (pp 87 88) (pp 88 89) (pp 89  90)\n(pp 90 91) (pp 91 92) (pp 92 93) (pp 93 94) (pp 94 95) (pp 95 96) (pp 96 97) (pp 97 98) (pp 98 99) (pp 99 100)\n(scoreMap  0    0)\n(scoreMap  1    8)\n(scoreMap  2   16)\n(scoreMap  3   24)\n(scoreMap  4   32)\n(scoreMap  5   40)\n(scoreMap  6   48)\n(scoreMap  7   56)\n(scoreMap  8   64)\n(scoreMap  9   72)\n(scoreMap 10   80)\n(scoreMap 11   90)\n(scoreMap 12  100)\n(owns blackPawn black)\n(owns redPawn red)\n(odd 1) (even 2) (odd 3) (even 4) (odd 5) (even 6) (odd 7) (even 8)\n(<= (evenSquare ?x ?y)\n    (odd ?x)\n    (odd ?y))\n(<= (evenSquare ?x ?y)\n    (even ?x)\n    (even ?y))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a board defined by coordinates where the first coordinate z ranges from 0 to 20, inclusive, and the second and third coordinates x and y take values 1 or 2, forming a grid of cells identified by (z, x, y). Each cell can hold an integer state value from 0 to 4, where all cells are initially set to 0. The only player role in the game is the robot, which takes turns sequentially, and the game proceeds in discrete steps starting from step 0. On each turn, the robot must perform an action called \"press\" specifying a triple of indices (z, x, y); this action is legal only if the z coordinate matches the current seriesGame value and x and y are within the index set {1, 2}. When the robot presses a cell, the state of that cell is immediately set to 4 on the next state update. Subsequently, on each following step, cell states automatically decrement by one until they reach 0 again, representing a countdown effect from 4 down to 0. The seriesGame value changes at specific step intervals—specifically at steps 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, and 80—incrementing by one at each of these milestones, thereby controlling which z coordinate is currently active and thus which cells can be pressed legally. The board enforces implicit constraints such that actions are only valid when targeting cells within the defined coordinate ranges; pressing outside these boundaries is not allowed. The game terminates automatically at step 84. A winning condition is defined by the presence of a \"won\" state for any z coordinate between 10 and 19, inclusive; this \"won\" condition is triggered when all four cells at coordinates (z, 1, 1), (z, 1, 2), (z, 2, 1), and (z, 2, 2) are simultaneously in a nonzero state (indicating they are \"on\"). The robot's goal is to achieve this winning configuration before the game ends. Upon termination, if the robot has successfully won a game, it scores 100 points; otherwise, it scores zero. There are no explicit noop moves specified, so the robot must act each turn with a valid press action corresponding to the current seriesGame value, and the game state progresses deterministically based on these actions and the automatic countdown of cell states. Thus, the game challenges the robot to strategically activate all four cells in a given z layer within the limited time frames defined by the step count increments before step 84 ends the game.",
    "output": "(role robot)\n(init (cell 0 1 1 0))\n(init (cell 0 1 2 0))\n(init (cell 0 2 1 0))\n(init (cell 0 2 2 0))\n(init (cell 1 1 1 0))\n(init (cell 1 1 2 0))\n(init (cell 1 2 1 0))\n(init (cell 1 2 2 0))\n(init (cell 2 1 1 0))\n(init (cell 2 1 2 0))\n(init (cell 2 2 1 0))\n(init (cell 2 2 2 0))\n(init (cell 3 1 1 0))\n(init (cell 3 1 2 0))\n(init (cell 3 2 1 0))\n(init (cell 3 2 2 0))\n(init (cell 4 1 1 0))\n(init (cell 4 1 2 0))\n(init (cell 4 2 1 0))\n(init (cell 4 2 2 0))\n(init (cell 5 1 1 0))\n(init (cell 5 1 2 0))\n(init (cell 5 2 1 0))\n(init (cell 5 2 2 0))\n(init (cell 6 1 1 0))\n(init (cell 6 1 2 0))\n(init (cell 6 2 1 0))\n(init (cell 6 2 2 0))\n(init (cell 7 1 1 0))\n(init (cell 7 1 2 0))\n(init (cell 7 2 1 0))\n(init (cell 7 2 2 0))\n(init (cell 8 1 1 0))\n(init (cell 8 1 2 0))\n(init (cell 8 2 1 0))\n(init (cell 8 2 2 0))\n(init (cell 9 1 1 0))\n(init (cell 9 1 2 0))\n(init (cell 9 2 1 0))\n(init (cell 9 2 2 0))\n(init (cell 10 1 1 0))\n(init (cell 10 1 2 0))\n(init (cell 10 2 1 0))\n(init (cell 10 2 2 0))\n(init (cell 11 1 1 0))\n(init (cell 11 1 2 0))\n(init (cell 11 2 1 0))\n(init (cell 11 2 2 0))\n(init (cell 12 1 1 0))\n(init (cell 12 1 2 0))\n(init (cell 12 2 1 0))\n(init (cell 12 2 2 0))\n(init (cell 13 1 1 0))\n(init (cell 13 1 2 0))\n(init (cell 13 2 1 0))\n(init (cell 13 2 2 0))\n(init (cell 14 1 1 0))\n(init (cell 14 1 2 0))\n(init (cell 14 2 1 0))\n(init (cell 14 2 2 0))\n(init (cell 15 1 1 0))\n(init (cell 15 1 2 0))\n(init (cell 15 2 1 0))\n(init (cell 15 2 2 0))\n(init (cell 16 1 1 0))\n(init (cell 16 1 2 0))\n(init (cell 16 2 1 0))\n(init (cell 16 2 2 0))\n(init (cell 17 1 1 0))\n(init (cell 17 1 2 0))\n(init (cell 17 2 1 0))\n(init (cell 17 2 2 0))\n(init (cell 18 1 1 0))\n(init (cell 18 1 2 0))\n(init (cell 18 2 1 0))\n(init (cell 18 2 2 0))\n(init (cell 19 1 1 0))\n(init (cell 19 1 2 0))\n(init (cell 19 2 1 0))\n(init (cell 19 2 2 0))\n(init (step 0))\n(init (seriesGame 0))\n(<= (legal robot (press ?z ?x ?y))\n\t(index ?x)\n\t(index ?y)\n\t(true (seriesGame ?z)))\n(<= (next (cell ?z ?x ?y 4))\n\t(does robot (press ?z ?x ?y)))\n(<= (next (cell ?z ?x ?y 3))\n\t(true (cell ?z ?x ?y 4)))\n(<= (next (cell ?z ?x ?y 2))\n\t(true (cell ?z ?x ?y 3)))\n(<= (next (cell ?z ?x ?y 1))\n\t(true (cell ?z ?x ?y 2)))\n(<= (next (cell ?z ?x ?y 0))\n\t(true (cell ?z ?x ?y 1)))\n(<= (next (cell ?z ?x ?y 0))\n\t(true (cell ?z ?x ?y 0)))\n(<= (next (won ?z))\n    (true (won ?z)))\n(<= (next (step ?x))\n    (true (step ?y))\n    (successor ?y ?x))\n(<= (next (seriesGame 1))\n    (true (step 4)))\n(<= (next (seriesGame 2))\n    (true (step 8)))\n(<= (next (seriesGame 3))\n    (true (step 12)))\n(<= (next (seriesGame 4))\n    (true (step 16)))\n(<= (next (seriesGame 5))\n    (true (step 20)))\n(<= (next (seriesGame 6))\n    (true (step 24)))\n(<= (next (seriesGame 7))\n    (true (step 28)))\n(<= (next (seriesGame 8))\n    (true (step 32)))\n(<= (next (seriesGame 9))\n    (true (step 36)))\n(<= (next (seriesGame 10))\n    (true (step 40)))\n(<= (next (seriesGame 11))\n    (true (step 44)))\n(<= (next (seriesGame 12))\n    (true (step 48)))\n(<= (next (seriesGame 13))\n    (true (step 52)))\n(<= (next (seriesGame 14))\n    (true (step 56)))\n(<= (next (seriesGame 15))\n    (true (step 60)))\n(<= (next (seriesGame 16))\n    (true (step 64)))\n(<= (next (seriesGame 17))\n    (true (step 68)))\n(<= (next (seriesGame 18))\n    (true (step 72)))\n(<= (next (seriesGame 19))\n    (true (step 76)))\n(<= (next (seriesGame 20))\n    (true (step 80)))\n(<= (next (seriesGame ?x))\n    (true (seriesGame ?x))\n    (not (true (step 4)))\n    (not (true (step 8)))\n    (not (true (step 12)))\n    (not (true (step 16)))\n    (not (true (step 20)))\n    (not (true (step 24)))\n    (not (true (step 28)))\n    (not (true (step 32)))\n    (not (true (step 36)))\n    (not (true (step 40)))\n    (not (true (step 44)))\n    (not (true (step 48)))\n    (not (true (step 52)))\n    (not (true (step 56)))\n    (not (true (step 60)))\n    (not (true (step 64)))\n    (not (true (step 68)))\n    (not (true (step 72)))\n    (not (true (step 76)))\n    (not (true (step 80))))\n(<= (next (won ?z))\n    (lightsOn ?z))\n(<= terminal\n    (true (step 84)))\n(<= (goal robot 100)\n\twonAGame)\n(<= (goal robot 0)\n    (not wonAGame))\n(<= wonAGame\n    (true (won 10)))\n(<= wonAGame\n    (true (won 11)))\n(<= wonAGame\n    (true (won 12)))\n(<= wonAGame\n    (true (won 13)))\n(<= wonAGame\n    (true (won 14)))\n(<= wonAGame\n    (true (won 15)))\n(<= wonAGame\n    (true (won 16)))\n(<= wonAGame\n    (true (won 17)))\n(<= wonAGame\n    (true (won 18)))\n(<= wonAGame\n    (true (won 19)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 1)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 2)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 3)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 4)))\n(<= (lightsOn ?z)\n\t(on ?z 1 1)\n\t(on ?z 1 2)\n\t(on ?z 2 1)\n\t(on ?z 2 2))\n(index 1) (index 2)\n  (successor 0 1)\n  (successor 1 2)\n  (successor 2 3)\n  (successor 3 4)\n  (successor 4 5)\n  (successor 5 6)\n  (successor 6 7)\n  (successor 7 8)\n  (successor 8 9)\n  (successor 9 10)\n  (successor 10 11)\n  (successor 11 12)\n  (successor 12 13)\n  (successor 13 14)\n  (successor 14 15)\n  (successor 15 16)\n  (successor 16 17)\n  (successor 17 18)\n  (successor 18 19)\n  (successor 19 20)\n  (successor 20 21)\n  (successor 21 22)\n  (successor 22 23)\n  (successor 23 24)\n  (successor 24 25)\n  (successor 25 26)\n  (successor 26 27)\n  (successor 27 28)\n  (successor 28 29)\n  (successor 29 30)\n  (successor 30 31)\n  (successor 31 32)\n  (successor 32 33)\n  (successor 33 34)\n  (successor 34 35)\n  (successor 35 36)\n  (successor 36 37)\n  (successor 37 38)\n  (successor 38 39)\n  (successor 39 40)\n  (successor 40 41)\n  (successor 41 42)\n  (successor 42 43)\n  (successor 43 44)\n  (successor 44 45)\n  (successor 45 46)\n  (successor 46 47)\n  (successor 47 48)\n  (successor 48 49)\n  (successor 49 50)\n  (successor 50 51)\n  (successor 51 52)\n  (successor 52 53)\n  (successor 53 54)\n  (successor 54 55)\n  (successor 55 56)\n  (successor 56 57)\n  (successor 57 58)\n  (successor 58 59)\n  (successor 59 60)\n  (successor 60 61)\n  (successor 61 62)\n  (successor 62 63)\n  (successor 63 64)\n  (successor 64 65)\n  (successor 65 66)\n  (successor 66 67)\n  (successor 67 68)\n  (successor 68 69)\n  (successor 69 70)\n  (successor 70 71)\n  (successor 71 72)\n  (successor 72 73)\n  (successor 73 74)\n  (successor 74 75)\n  (successor 75 76)\n  (successor 76 77)\n  (successor 77 78)\n  (successor 78 79)\n  (successor 79 80)\n  (successor 80 81)\n  (successor 81 82)\n  (successor 82 83)\n  (successor 83 84)\n  (successor 84 85)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board consisting of three concentric squares labeled as inner, middle, and outer, each having eight positions identified by directional coordinates: north (n), northeast (ne), east (e), southeast (se), south (s), southwest (sw), west (w), and northwest (nw). These positions form the pits where stones can be placed or moved. The coordinate system is thus a combination of the square label and the direction, such as \"outer n\" or \"middle se.\" Two players participate, designated as white and black, taking alternate turns with white moving first. Initially, each player has nine stones in their reserve (heap), and all pits on the board are empty. The game state also keeps track of the current step number, starting at zero, and which player has control to act.\n\nDuring a turn, the player in control may perform one of several actions or choose to do nothing (noop) under certain conditions. Actions include placing a stone from their heap onto an empty pit, moving a stone they already have on the board to an adjacent empty pit, or removing an opponent's stone from the board if a mill has just been formed. Placing is only legal if the player has stones remaining in their heap and the target pit is empty, and moving is allowed only if the player has no stones left in their heap, the stone to move belongs to them, and the destination pit is empty and adjacent to the origin pit. However, if a player has exactly three stones remaining on the board, they are allowed to move a stone to any empty pit without adjacency restrictions. Noop moves are legal when it is the opponent's turn, or when a mill has been formed but there are no opponent stones eligible for removal, or when the player has no legal moves left and no stones to place.\n\nAfter a player places a stone, their heap count decreases by one, and the pit at the specified coordinates becomes occupied by their stone. When moving a stone, the origin pit becomes empty, and the destination pit is occupied by the player's stone. Removing an opponent's stone frees the corresponding pit. The turn control switches to the other player unless the current player has just formed a mill, in which case they maintain control to remove an opponent's stone. The step counter increments by one after each move. A mill is defined as three stones of the same player aligned either along the same square at consecutive directions or along the same direction across all three squares, with special treatment for corner directions. Stones that form part of a mill cannot be removed by the opponent.\n\nThe game concludes either when a player has fewer than three stones on the board, when both players have no stones left in their heaps, or when 60 steps have elapsed. The scoring system awards 100 points to a player who reduces the opponent to fewer than three stones, 75 points if they have more stones than the opponent but neither is below three, 25 points if they have fewer stones but both have at least three, and zero points if they themselves fall below three. If the game ends by reaching the step limit without a decisive stone count difference, both players receive 50 points. The objective is to strategically place and move stones to form mills, remove opponent stones, and maintain at least three stones on the board while preventing the opponent from doing the same.",
    "output": "(role white)\n(role black)\n(init (heap white 9))\n(init (heap black 9))\n(init (step 0))\n(init (control white))\n(init (pit outer n empty))\n(init (pit outer ne empty))\n(init (pit outer e empty))\n(init (pit outer se empty))\n(init (pit outer s empty))\n(init (pit outer sw empty))\n(init (pit outer w empty))\n(init (pit outer nw empty))\n(init (pit middle n empty))\n(init (pit middle ne empty))\n(init (pit middle e empty))\n(init (pit middle se empty))\n(init (pit middle s empty))\n(init (pit middle sw empty))\n(init (pit middle w empty))\n(init (pit middle nw empty))\n(init (pit inner n empty))\n(init (pit inner ne empty))\n(init (pit inner e empty))\n(init (pit inner se empty))\n(init (pit inner s empty))\n(init (pit inner sw empty))\n(init (pit inner w empty))\n(init (pit inner nw empty))\n(<= terminal\n\t(true (heap white 0))\n\t(true (heap black 0))\n\t(count ?w ?b)\n\t(or (smaller ?w 3) (smaller ?b 3)))\n(<= terminal\n\t(true (step 60)))\n(<= (goal white 100)\n\t(count ?w ?b)\n\t(smaller ?b 3))\n(<= (goal white 75)\n\t(count ?w ?b)\n\t(not (smaller ?b 3))\n\t(smaller ?b ?w))\n(<= (goal white 25)\n\t(count ?w ?b)\n\t(not (smaller ?w 3))\n\t(smaller ?w ?b))\n(<= (goal white 0)\n\t(count ?w ?b)\n\t(smaller ?w 3))\n(<= (goal ?p 50)\n\t(count ?w ?w)\n\t(role ?p))\n(<= (goal black 100)\n\t(count ?w ?b)\n\t(smaller ?w 3))\n(<= (goal black 75)\n\t(count ?w ?b)\n\t(not (smaller ?w 3))\n\t(smaller ?w ?b))\n(<= (goal black 25)\n\t(count ?w ?b)\n\t(not (smaller ?b 3))\n\t(smaller ?b ?w))\n(<= (goal black 0)\n\t(count ?w ?b)\n\t(smaller ?b 3))\n(<= (legal ?p noop)\n\t(true (control ?p2))\n\t(distinct ?p2 ?p)\n\t(role ?p))\n(<= (legal ?p noop)\n\t(true (control ?p))\n\t(true made_a_mill)\n\t(not exists_stone_to_remove))\n(<= (legal ?p noop)\n\t(true (control ?p))\n\t(not (true made_a_mill))\n\t(true (heap ?p 0))\n\t(not exists_legal_move))\n(<= (legal ?p (place ?x ?y))\n\t(true (control ?p))\n\t(not (true made_a_mill))\n\t(true (heap ?p ?n))\n\t(distinct ?n 0)\n\t(true (pit ?x ?y empty)))\n(<= (legal ?p (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?p))\n\t(not (true made_a_mill))\n\t(true (heap ?p 0))\n\t(true (pit ?x1 ?y1 ?p))\n\t(true (pit ?x2 ?y2 empty))\n\t(adjacent ?x1 ?y1 ?x2 ?y2))\n(<= (legal ?p (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?p))\n\t(not (true made_a_mill))\n\t(true (heap ?p 0))\n\t(true (pit ?x1 ?y1 ?p))\n\t(true (pit ?x2 ?y2 empty))\n\t(count_role ?p 3)\n\t(or (distinct ?x1 ?x2) (distinct ?y1 ?y2)))\n(<= (legal ?p (remove ?x ?y))\n\t(true (control ?p))\n\t(true made_a_mill)\n\t(true (pit ?x ?y ?p2))\n\t(role ?p2)\n\t(distinct ?p2 ?p)\n\t(not (in_a_mill ?p2 ?x ?y)))\n(<= (next (step ?n2))\n\t(true (step ?n))\n\t(succ ?n ?n2))\n(<= (next (heap ?p ?n))\n\t(does ?p (place ?x ?y))\n\t(true (heap ?p ?n2))\n\t(succ ?n ?n2))\n(<= (next (heap ?p ?n))\n\t(true (heap ?p ?n))\n\t(not (places ?p)))\n(<= (next (pit ?x ?y ?p))\n\t(does ?p (place ?x ?y)))\n(<= (next (pit ?x ?y ?p))\n\t(does ?p (move ?x1 ?y1 ?x ?y)))\n(<= (next (pit ?x ?y empty))\n\t(does ?p (remove ?x ?y)))\n(<= (next (pit ?x ?y empty))\n\t(does ?p (move ?x ?y ?x1 ?y1)))\n(<= (next (pit ?x ?y ?c))\n\t(true (pit ?x ?y ?c))\n\t(or (does ?p (place ?x1 ?y1)) (does ?p (remove ?x1 ?y1)))\n\t(or (distinct ?x ?x1) (distinct ?y ?y1)))\n(<= (next (pit ?x ?y ?c))\n\t(true (pit ?x ?y ?c))\n\t(does ?p (move ?x2 ?y2 ?x1 ?y1))\n\t(or (distinct ?x ?x1) (distinct ?y ?y1))\n\t(or (distinct ?x ?x2) (distinct ?y ?y2)))\n(<= (next (pit ?x ?y ?c))\n\t(true (pit ?x ?y ?c))\n\t(does white noop)\n\t(does black noop))\n(<= (next (control ?p))\n\t(true (control ?p))\n\t(makes_a_mill ?p))\n(<= (next (control ?p2))\n\t(true (control ?p1))\n\t(role ?p2)\n\t(distinct ?p2 ?p1)\n\t(not (makes_a_mill ?p1)))\n(<= (next made_a_mill)\n\t(true (control ?p))\n\t(makes_a_mill ?p))\n(<= (places ?p)\n\t(does ?p (place ?x ?y)))\n(<= exists_stone_to_remove\n\t(true (control ?p))\n\t(role ?p2)\n\t(distinct ?p2 ?p)\n\t(true (pit ?x ?y ?p2))\n\t(not (in_a_mill ?p2 ?x ?y)))\n(<= exists_legal_move\n\t(true (control ?p))\n\t(true (pit ?x1 ?y1 ?p))\n\t(true (pit ?x2 ?y2 empty))\n\t(adjacent ?x1 ?y1 ?x2 ?y2))\n(<= exists_legal_move\n\t(true (control ?p))\n\t(true (pit ?x1 ?y1 ?p))\n\t(true (pit ?x2 ?y2 empty))\n\t(count_role ?p 3)\n\t(or (distinct ?x1 ?x2) (distinct ?y1 ?y2)))\n(<= (count_role white ?n)\n\t(count ?n ?n1))\n(<= (count_role black ?n)\n\t(count ?n1 ?n))\n(<= (count ?w ?b)\n\t(count_loop inner ne 0 0 ?w ?b))\n(<= (count_loop outer n ?w1 ?b1 ?w ?b)\n\t(count_one outer n ?w1 ?b1 ?w ?b))\n(<= (count_loop ?x1 ?y1 ?w1 ?b1 ?w ?b)\n\t(count_one ?x1 ?y1 ?w1 ?b1 ?w2 ?b2)\n\t(next_pit ?x1 ?y1 ?x2 ?y2)\n\t(count_loop ?x2 ?y2 ?w2 ?b2 ?w ?b))\n(<= (count_one ?x ?y ?w1 ?b ?w ?b)\n\t(true (pit ?x ?y white))\n\t(succ ?w1 ?w)\n\t(number ?b))\n(<= (count_one ?x ?y ?w ?b1 ?w ?b)\n\t(true (pit ?x ?y black))\n\t(succ ?b1 ?b)\n\t(number ?w))\n(<= (count_one ?x ?y ?w ?b ?w ?b)\n\t(true (pit ?x ?y empty))\n\t(number ?b)\n\t(number ?w))\n(<= (next_pit ?x1 n ?x2 ne)\n\t(next_square ?x1 ?x2))\n(<= (next_pit ?x ?y1 ?x ?y2)\n\t(distinct ?y1 n)\n\t(next_dir ?y1 ?y2)\n\t(square ?x))\n(<= (makes_a_mill ?p)\n\t(does ?p (place ?x ?y))\n\t(or (mill ?x ?y ?x2 ?y2 ?x3 ?y3) (mill ?x2 ?y2 ?x ?y ?x3 ?y3) (mill ?x2 ?y2 ?x3 ?y3 ?x ?y))\n\t(true (pit ?x2 ?y2 ?p))\n\t(true (pit ?x3 ?y3 ?p)))\n(<= (makes_a_mill ?p)\n\t(does ?p (move ?x1 ?y1 ?x ?y))\n\t(or (mill ?x ?y ?x2 ?y2 ?x3 ?y3) (mill ?x2 ?y2 ?x ?y ?x3 ?y3) (mill ?x2 ?y2 ?x3 ?y3 ?x ?y))\n\t(true (pit ?x2 ?y2 ?p))\n\t(true (pit ?x3 ?y3 ?p))\n\t(or (distinct ?x2 ?x1) (distinct ?y2 ?y1))\n\t(or (distinct ?x3 ?x1) (distinct ?y3 ?y1)))\n(<= (in_a_mill ?p ?x ?y)\n\t(or (mill ?x ?y ?x2 ?y2 ?x3 ?y3) (mill ?x2 ?y2 ?x ?y ?x3 ?y3) (mill ?x2 ?y2 ?x3 ?y3 ?x ?y))\n\t(true (pit ?x ?y ?p))\n\t(true (pit ?x2 ?y2 ?p))\n\t(true (pit ?x3 ?y3 ?p)))\n(<= (mill ?x ?y1 ?x ?y2 ?x ?y3)\n\t(square ?x)\n\t(corner ?y1)\n\t(next_dir ?y1 ?y2)\n\t(next_dir ?y2 ?y3))\n(<= (mill inner ?y middle ?y outer ?y)\n\t(direction ?y)\n\t(not (corner ?y)))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(<= (smaller ?x ?y)\n\t(succ ?x ?y))\n(<= (smaller ?x ?y)\n\t(succ ?x ?z)\n\t(smaller ?z ?y))\n(<= (adjacent ?x1 ?y ?x2 ?y)\n\t(not (corner ?y))\n\t(adj_squares ?x1 ?x2)\n\t(direction ?y))\n(<= (adjacent ?x ?y1 ?x ?y2)\n\t(adj_directions ?y1 ?y2)\n\t(square ?x))\n(<= (adj_squares ?s1 ?s2)\n\t(next_square ?s1 ?s2))\n(<= (adj_squares ?s1 ?s2)\n\t(next_square ?s2 ?s1))\n(square inner)\n(square middle)\n(square outer)\n(next_square inner middle)\n(next_square middle outer)\n(<= (adj_directions ?d1 ?d2)\n\t(next_dir ?d1 ?d2))\n(<= (adj_directions ?d1 ?d2)\n\t(next_dir ?d2 ?d1))\n(<= (direction ?y)\n\t(next_dir ?y ?foo))\n(next_dir n ne)\n(next_dir ne e)\n(next_dir e se)\n(next_dir se s)\n(next_dir s sw)\n(next_dir sw w)\n(next_dir w nw)\n(next_dir nw n)\n(corner ne)\n(corner se)\n(corner sw)\n(corner nw)\n(number 0)\n(number 1)\n(number 2)\n(number 3)\n(number 4)\n(number 5)\n(number 6)\n(number 7)\n(number 8)\n(number 9)\n(number 10)\n(number 11)\n(number 12)\n(number 13)\n(number 14)\n(number 15)\n(number 16)\n(number 17)\n(number 18)\n(number 19)\n(number 20)\n(number 21)\n(number 22)\n(number 23)\n(number 24)\n(number 25)\n(number 26)\n(number 27)\n(number 28)\n(number 29)\n(number 30)\n(number 31)\n(number 32)\n(number 33)\n(number 34)\n(number 35)\n(number 36)\n(number 37)\n(number 38)\n(number 39)\n(number 40)\n(number 41)\n(number 42)\n(number 43)\n(number 44)\n(number 45)\n(number 46)\n(number 47)\n(number 48)\n(number 49)\n(number 50)\n(number 51)\n(number 52)\n(number 53)\n(number 54)\n(number 55)\n(number 56)\n(number 57)\n(number 58)\n(number 59)\n(number 60)\n(number 61)\n(number 62)\n(number 63)\n(number 64)\n(number 65)\n(number 66)\n(number 67)\n(number 68)\n(number 69)\n(number 70)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is structured as a turn-based guessing game involving two players, identified as player1 and player2, who alternate turns in a fixed order beginning with player1. The environment consists of a numeric range from 0 to 100 inclusive, which serves as the valid domain for guesses; this range is implicitly defined by successor relationships establishing the integers and by the predicate that specifies guessable numbers as those less than or equal to 100. At the start of the game, no guesses have been made by either player. On each turn, the active player must choose a legal action by guessing a number within the allowable range. The action format consists of the player role followed by the guess action with the chosen number, such as \"guess n,\" where n is any number between 0 and 100 inclusive. This action is legal only if the number guessed falls within the permitted range and the role corresponds to a player in the game. When a player makes a guess, the game state updates to record that player's guessed number. The game does not explicitly provide a no-operation or noop action, implying that skipping a turn is not allowed; players must guess on their turn. The game terminates immediately after both players have made their guesses. At termination, the game calculates the sum of the two guesses and then determines two-thirds of this total, with some tolerance for rounding up or down by one unit. Each player's closeness score is computed as the absolute difference between their guessed number and this two-thirds average value. The player whose guess is closest to the two-thirds average is deemed the winner and receives a goal score of 100, while the other player receives a score of zero. In the event both players are equally closest, both receive a score of 50. Implicit constraints include the board boundaries that restrict guesses to the integers between 0 and 100 inclusive, and the requirement that each player makes exactly one guess. The primary victory condition is to be the player whose guess is closest to two-thirds of the sum of both guesses, with scoring accordingly assigned to reflect this outcome.",
    "output": "(role player1)\n(role player2)\n(<= (legal ?player (guess ?number))\n    (role ?player)\n    (guessableNumber ?number))\n(<= (next (guessed ?player ?number))\n    (does ?player (guess ?number)))\n(<= (total ?number)\n    (true (guessed player1 ?n1))\n    (true (guessed player2 ?n2))\n    (sum ?n1 ?n2 ?number))\n(<= (twoThirdsAverage ?out)\n    (total ?total)\n    (times3 ?out ?total))\n(<= (twoThirdsAverage ?out)\n    (total ?total)\n    (succ ?total ?tp1)\n    (times3 ?out ?tp1))\n(<= (twoThirdsAverage ?out)\n    (total ?total)\n    (succ ?tm1 ?total)\n    (times3 ?out ?tm1))\n(<= (closeness ?player ?score)\n    (true (guessed ?player ?guess))\n    (twoThirdsAverage ?result)\n    (absDiff ?result ?guess ?score))\n(<= (notClosest ?player)\n    (closeness ?player ?score)\n    (closeness ?otherPlayer ?lowerScore)\n    (distinct ?player ?otherPlayer)\n    (lt ?lowerScore ?score))\n(<= (closest ?player)\n    (role ?player)\n    (not (notClosest ?player)))\n(<= (goal player1 100)\n    (closest player1)\n    (notClosest player2))\n(<= (goal player2 100)\n    (notClosest player1)\n    (closest player2))\n(<= (goal ?player 50)\n    (role ?player)\n    (closest player1)\n    (closest player2))\n(<= (goal ?player 0)\n    (notClosest ?player))\n(<= terminal\n    (true (guessed ?player ?number)))\n(<= (absDiff ?x ?x 0)\n    (anyNumber ?x))\n(<= (absDiff ?x ?y ?z)\n    (lt ?y ?x)\n    (succ ?xm1 ?x)\n    (absDiff ?xm1 ?y ?zm1)\n    (succ ?zm1 ?z))\n(<= (absDiff ?x ?y ?z)\n    (lt ?x ?y)\n    (succ ?ym1 ?y)\n    (absDiff ?x ?ym1 ?zm1)\n    (succ ?zm1 ?z))\n(<= (sum ?x 0 ?x)\n    (anyNumber ?x))\n(<= (sum ?x ?y ?z)\n    (succ ?ym1 ?y)\n    (sum ?x ?ym1 ?zm1)\n    (succ ?zm1 ?z))\n(times3 0 0)\n(<= (times3 ?x ?y)\n    (succ ?ym1 ?y)\n    (succ ?ym2 ?ym1)\n    (succ ?ym3 ?ym2)\n    (times3 ?xm1 ?ym3)\n    (succ ?xm1 ?x))\n(<= (lt ?x ?y)\n    (lte ?x ?y)\n    (distinct ?x ?y))\n(<= (lte ?x ?x)\n    (anyNumber ?x))\n(<= (lte ?x ?y)\n    (succ ?ym1 ?y)\n    (lte ?x ?ym1))\n(anyNumber 0)\n(<= (anyNumber ?n)\n    (succ ?m ?n))\n(<= (guessableNumber ?number)\n    (lte ?number 100))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)\n(succ 100 101)\n(succ 101 102)\n(succ 102 103)\n(succ 103 104)\n(succ 104 105)\n(succ 105 106)\n(succ 106 107)\n(succ 107 108)\n(succ 108 109)\n(succ 109 110)\n(succ 110 111)\n(succ 111 112)\n(succ 112 113)\n(succ 113 114)\n(succ 114 115)\n(succ 115 116)\n(succ 116 117)\n(succ 117 118)\n(succ 118 119)\n(succ 119 120)\n(succ 120 121)\n(succ 121 122)\n(succ 122 123)\n(succ 123 124)\n(succ 124 125)\n(succ 125 126)\n(succ 126 127)\n(succ 127 128)\n(succ 128 129)\n(succ 129 130)\n(succ 130 131)\n(succ 131 132)\n(succ 132 133)\n(succ 133 134)\n(succ 134 135)\n(succ 135 136)\n(succ 136 137)\n(succ 137 138)\n(succ 138 139)\n(succ 139 140)\n(succ 140 141)\n(succ 141 142)\n(succ 142 143)\n(succ 143 144)\n(succ 144 145)\n(succ 145 146)\n(succ 146 147)\n(succ 147 148)\n(succ 148 149)\n(succ 149 150)\n(succ 150 151)\n(succ 151 152)\n(succ 152 153)\n(succ 153 154)\n(succ 154 155)\n(succ 155 156)\n(succ 156 157)\n(succ 157 158)\n(succ 158 159)\n(succ 159 160)\n(succ 160 161)\n(succ 161 162)\n(succ 162 163)\n(succ 163 164)\n(succ 164 165)\n(succ 165 166)\n(succ 166 167)\n(succ 167 168)\n(succ 168 169)\n(succ 169 170)\n(succ 170 171)\n(succ 171 172)\n(succ 172 173)\n(succ 173 174)\n(succ 174 175)\n(succ 175 176)\n(succ 176 177)\n(succ 177 178)\n(succ 178 179)\n(succ 179 180)\n(succ 180 181)\n(succ 181 182)\n(succ 182 183)\n(succ 183 184)\n(succ 184 185)\n(succ 185 186)\n(succ 186 187)\n(succ 187 188)\n(succ 188 189)\n(succ 189 190)\n(succ 190 191)\n(succ 191 192)\n(succ 192 193)\n(succ 193 194)\n(succ 194 195)\n(succ 195 196)\n(succ 196 197)\n(succ 197 198)\n(succ 198 199)\n(succ 199 200)\n(succ 200 201)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a 10-by-10 grid defined by coordinates where both columns and rows are indexed from 1 to 10; this grid serves as the environment in which the single player, named \"robot,\" operates. The robot's role is to mark cells on the board, with turns taken sequentially by this sole player. Initially, no cells are marked, and the robot may choose any unmarked cell within the board boundaries to mark on its turn; the legality of marking an action is contingent upon the target cell being within the valid coordinate range and not already marked. The player’s actions are specified by indicating the column and row to mark, and when the robot executes a mark action on a particular cell, that cell’s state changes to marked in the next game state, while all previously marked cells remain marked. The game implicitly forbids marking outside the 10-by-10 grid and prohibits marking a cell that is already marked, ensuring no occupancy conflicts or out-of-bounds moves occur. Although the rules do not explicitly define a noop action, the robot can effectively pass a turn by simply not marking any new cell, as marking is the only legal action defined. The game automatically tracks groups of consecutive marked cells in each row and column, comparing these against predefined allowed group sizes specified for each row and column. Terminal conditions occur when any row or column violates these constraints—specifically, if a group of marked cells in a row or column is larger than any allowed size or if the number of groups of marked cells does not match the prescribed count for that row or column. The game ends when no such violations exist, indicating a correct marking pattern. Victory is determined by achieving a state with no invalid rows or columns, in which case the robot scores 100 points; if any invalid grouping remains, the robot scores zero. Thus, the objective is to successfully mark cells to form groups in rows and columns that exactly match the specified sizes and counts, respecting board boundaries and marking constraints, until the puzzle is correctly solved, at which point the game terminates with a perfect score for the robot.",
    "output": "(role robot)\n(row 1 1 1) (row 1 2 1)\n(row 2 1 5)\n(row 3 1 1) (row 3 2 2) (row 3 3 1)\n(row 4 1 6) (row 4 2 1)\n(row 5 1 7) (row 5 2 1)\n(row 6 1 4) (row 6 2 2) (row 6 3 1)\n(row 7 1 2) (row 7 2 3) (row 7 3 1)\n(row 8 1 3) (row 8 2 1)\n(row 9 1 5)\n(row 10 1 6)\n(col 1 1 3)\n(col 2 1 5)\n(col 3 1 2) (col 3 2 3)\n(col 4 1 5)\n(col 5 1 5) (col 5 2 1)\n(col 6 1 1) (col 6 2 7)\n(col 7 1 1) (col 7 2 7)\n(col 8 1 1) (col 8 1 4)\n(col 9 1 3) (col 9 2 2)\n(col 10 1 4)\n(<= (legal robot (mark ?col ?row))\n    (index ?col)\n    (index ?row)\n    (not (true (marked ?col ?row))))\n(<= (next (marked ?col ?row))\n    (does robot (mark ?col ?row)))\n(<= (next (marked ?col ?row))\n    (true (marked ?col ?row)))\n(<= (curRow ?row 0 1 0)\n    (index ?row))\n(<= (curRow ?row ?next ?group 0)\n    (succ ?cur ?next)\n    (not (true (marked ?next ?row)))\n    (curRow ?row ?cur ?group 0))\n(<= (curRow ?row ?next ?nextGroup 0)\n    (succ ?cur ?next)\n    (not (true (marked ?next ?row)))\n    (succ ?group ?nextGroup)\n    (curRow ?row ?cur ?group ?count)\n    (index ?count))\n(<= (curRow ?row ?next ?group ?countp1)\n    (succ ?cur ?next)\n    (true (marked ?next ?row))\n    (succ ?count ?countp1)\n    (curRow ?row ?cur ?group ?count))\n(<= (rowGroupCount ?row ?group ?count)\n    (curRow ?row ?cur ?group ?count)\n    (distinct ?count 0)\n    (succ ?cur ?next)\n    (not (true (marked ?next ?row))))\n(<= (curCol ?col 0 1 0)\n    (index ?col))\n(<= (curCol ?col ?next ?group 0)\n    (succ ?cur ?next)\n    (not (true (marked ?col ?next)))\n    (curCol ?col ?cur ?group 0))\n(<= (curCol ?col ?next ?nextGroup 0)\n    (succ ?cur ?next)\n    (not (true (marked ?col ?next)))\n    (succ ?group ?nextGroup)\n    (curCol ?col ?cur ?group ?count)\n    (index ?count))\n(<= (curCol ?col ?next ?group ?countp1)\n    (succ ?cur ?next)\n    (true (marked ?col ?next))\n    (succ ?count ?countp1)\n    (curCol ?col ?cur ?group ?count))\n(<= (colGroupCount ?col ?group ?count)\n    (curCol ?col ?cur ?group ?count)\n    (distinct ?count 0)\n    (succ ?cur ?next)\n    (not (true (marked ?col ?next))))\n(<= (rowAtLeastSize ?row ?size)\n    (someSizeInRow ?row ?startingPoint ?foundSize)\n    (lte ?size ?foundSize))\n(<= (someSizeInRow ?row 0 0)\n    (index ?row))\n(<= (someSizeInRow ?row ?xp1 0)\n    (index ?row)\n    (index ?xp1)\n    (not (true (marked ?xp1 ?row))))\n(<= (someSizeInRow ?row ?xp1 ?np1)\n    (true (marked ?xp1 ?row))\n    (succ ?x ?xp1)\n    (succ ?n ?np1)\n    (someSizeInRow ?row ?x ?n))\n(<= (colAtLeastSize ?col ?size)\n    (someSizeInCol ?col ?startingPoint ?foundSize)\n    (lte ?size ?foundSize))\n(<= (someSizeInCol ?col 0 0)\n    (index ?col))\n(<= (someSizeInCol ?col ?yp1 0)\n    (index ?col)\n    (index ?yp1)\n    (not (true (marked ?col ?yp1))))\n(<= (someSizeInCol ?col ?yp1 ?np1)\n    (true (marked ?col ?yp1))\n    (succ ?y ?yp1)\n    (succ ?n ?np1)\n    (someSizeInCol ?col ?y ?n))\n(<= (allowedSizeInRow ?row ?size)\n    (row ?row ?anyGroup ?size))\n(<= (allowedSizeInRow ?row ?size)\n    (row ?row ?anyGroup ?largerSize)\n    (lessThan ?size ?largerSize))\n(<= (allowedSizeInCol ?col ?size)\n    (col ?col ?anyGroup ?size))\n(<= (allowedSizeInCol ?col ?size)\n    (col ?col ?anyGroup ?largerSize)\n    (lessThan ?size ?largerSize))\n(<= (tooBigSizeForRow ?row ?size)\n    (allowedSizeInRow ?row ?smaller)\n    (succ ?smaller ?size)\n    (not (allowedSizeInRow ?row ?size)))\n(<= (tooBigSizeForCol ?col ?size)\n    (allowedSizeInCol ?col ?smaller)\n    (succ ?smaller ?size)\n    (not (allowedSizeInCol ?col ?size)))\n(<= (curGroupsInRow ?row ?groupCount)\n    (highestIndex ?end)\n    (curGroupsInRowPartial ?row ?end ?groupCount))\n(<= (curGroupsInRowPartial ?row 0 0)\n    (index ?row))\n(<= (curGroupsInRowPartial ?row ?xp1 ?n)\n    (succ ?x ?xp1)\n    (curGroupsInRowPartial ?row ?x ?n)\n    (or (true (marked ?x ?row))\n        (not (true (marked ?xp1 ?row)))))\n(<= (curGroupsInRowPartial ?row ?xp1 ?np1)\n    (succ ?x ?xp1)\n    (curGroupsInRowPartial ?row ?x ?n)\n    (succ ?n ?np1)\n    (not (true (marked ?x ?row)))\n    (true (marked ?xp1 ?row)))\n(<= (curGroupsInCol ?col ?groupCount)\n    (highestIndex ?end)\n    (curGroupsInColPartial ?col ?end ?groupCount))\n(<= (curGroupsInColPartial ?col 0 0)\n    (index ?col))\n(<= (curGroupsInColPartial ?col ?yp1 ?n)\n    (succ ?y ?yp1)\n    (curGroupsInColPartial ?col ?y ?n)\n    (or (true (marked ?col ?y))\n        (not (true (marked ?col ?yp1)))))\n(<= (curGroupsInColPartial ?col ?yp1 ?np1)\n    (succ ?y ?yp1)\n    (curGroupsInColPartial ?col ?y ?n)\n    (succ ?n ?np1)\n    (not (true (marked ?col ?y)))\n    (true (marked ?col ?yp1)))\n(<= terminal\n    (tooBigSizeForRow ?row ?size)\n    (rowAtLeastSize ?row ?size))\n(<= terminal\n    (tooBigSizeForCol ?col ?size)\n    (colAtLeastSize ?col ?size))\n(<= terminal\n    (not anyRowBad)\n    (not anyColBad))\n(<= (goal robot 100)\n    (not anyRowBad)\n    (not anyColBad))\n(<= (goal robot 0)\n    anyRowBad)\n(<= (goal robot 0)\n    anyColBad)\n(<= anyRowBad\n    (row ?row ?group ?count)\n    (not (rowGroupCount ?row ?group ?count)))\n(<= anyColBad\n    (col ?col ?group ?count)\n    (not (colGroupCount ?col ?group ?count)))\n(<= anyRowBad\n    (numGroupsInRow ?row ?groupCount)\n    (curGroupsInRow ?row ?curCount)\n    (distinct ?groupCount ?curCount))\n(<= anyColBad\n    (numGroupsInCol ?col ?groupCount)\n    (curGroupsInCol ?col ?curCount)\n    (distinct ?groupCount ?curCount))\n(<= (numGroupsInRow ?row ?groupNum)\n    (anyGroupInRow ?row ?groupNum)\n    (succ ?groupNum ?oneMore)\n    (not (anyGroupInRow ?row ?oneMore)))\n(<= (anyGroupInRow ?row ?group)\n    (row ?row ?group ?count))\n(<= (numGroupsInCol ?col ?groupNum)\n    (anyGroupInCol ?col ?groupNum)\n    (succ ?groupNum ?oneMore)\n    (not (anyGroupInCol ?col ?oneMore)))\n(<= (anyGroupInCol ?col ?group)\n    (col ?col ?group ?count))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(highestIndex 10)\n(<= (lessThan ?x ?y)\n    (succ ?x ?y))\n(<= (lessThan ?x ?z)\n    (succ ?y ?z)\n    (lessThan ?x ?y))\n(<= (lte ?x ?y)\n    (lessThan ?x ?y))\n(<= (lte ?x ?x)\n    (index ?x))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board defined by a coordinate system where cells are identified by a pair consisting of a letter from A to G and a number, with each letter corresponding to a row length varying from 4 to 7 cells; valid cells are those within these defined lengths and the coordinates follow adjacency relationships that include horizontal, vertical, and diagonal connections as specified by the connected predicate. There are two players, player1 and player2, assigned colors red and blue respectively at the start, with red controlling the first move. The initial state sets red as the controlling color and flags the first turn as special, called the pie turn. Players alternate turns, with control passing between red and blue according to whether certain adjacency conditions are met after a move; specifically, if a move results in two or more adjacent opposing pieces, control remains with the same player, otherwise control switches to the opponent. On the first turn only, player2 has a special choice to swap colors with player1 or not, a mechanism known as the pie rule designed to balance the game; if player2 chooses to swap, colors are exchanged, otherwise colors remain the same. Actions are either a move, which places a piece of the player's color on an empty valid cell, the swap or doNotSwap action available only to player2 at the pie turn, or a noop action, which is permitted only when the player does not currently control the turn. Moves must be legal in that the targeted cell is empty and it is the player's turn to control their color, with the exception that no moves are allowed during the pie turn phase. Upon a move, the board state updates to mark the cell as occupied by the player's color and increments that player's piece count; the move can also trigger evaluation of adjacent opposing pieces to determine control for the next turn. The game enforces implicit constraints such as occupancy conflicts where a cell cannot be occupied by more than one piece, and boundaries defined by the valid cells on the board. Noops serve to pass the turn when a player is not in control, ensuring proper turn sequencing. The game terminates when a player places their nineteenth piece on the board, immediately winning the game. Victory is awarded fully to the player who achieves this piece count first, while the opponent scores zero. The scoring system thus hinges solely on the piece count reaching nineteen for a player, with no other scoring conditions. In summary, this game involves strategic placement of pieces on a hexagonal-like grid, alternating turns with a pie rule on the first move to balance initial advantage, and ends when one player successfully places nineteen pieces, signifying their win.",
    "output": "(role player1)\n(role player2)\n(init (control red))\n(init isFirstTurn)\n(init (isColor player1 red))\n(init (isColor player2 blue))\n(init (pieceCount red 0))\n(init (pieceCount blue 0))\n(<= (legal ?player noop)\n    (role ?player)\n    (true (isColor ?player ?color))\n    (not (true (control ?color))))\n(<= (legal ?player (move ?x ?n))\n    (true (isColor ?player ?color))\n    (true (control ?color))\n    (not (true isPieTurn))\n    (empty ?x ?n))\n(<= (legal player2 swap)\n    (true isPieTurn))\n(<= (legal player2 doNotSwap)\n    (true isPieTurn))\n(<= (next isPieTurn)\n    (true isFirstTurn))\n(<= (next (isColor ?role ?color))\n    (not (true isPieTurn))\n    (true (isColor ?role ?color)))\n(<= (next (isColor ?role ?color))\n    (does player2 swap)\n    (true (isColor ?role ?oppColor))\n    (opponent ?oppColor ?color))\n(<= (next (isColor ?role ?color))\n    (does player2 doNotSwap)\n    (true (isColor ?role ?color)))\n(<= (next (cell ?x ?n ?color))\n    (true (cell ?x ?n ?color)))\n(<= (next (cell ?x ?n ?color))\n    (does ?role (move ?x ?n))\n    (true (isColor ?role ?color)))\n(<= (adjacentOpposingPiece ?x2 ?n2)\n    (does ?role (move ?x ?n))\n    (true (isColor ?role ?color))\n    (opponent ?color ?opp)\n    (connected ?x ?n ?x2 ?n2)\n    (true (cell ?x2 ?n2 ?opp)))\n(<= twoAdjacentOpposingPieces\n    (adjacentOpposingPiece ?x1 ?n1)\n    (adjacentOpposingPiece ?x2 ?n2)\n    (or (distinct ?x1 ?x2)\n        (distinct ?n1 ?n2)))\n(<= (next (control ?player))\n    (not (true isPieTurn))\n    (true (control ?player))\n    twoAdjacentOpposingPieces)\n(<= (next (control ?opponent))\n    (not (true isPieTurn))\n    (true (control ?player))\n    (not twoAdjacentOpposingPieces)\n    (opponent ?player ?opponent))\n(<= (next (control blue))\n    (true isPieTurn))\n(<= (next (pieceCount ?color ?n))\n    (true (pieceCount ?color ?n))\n    (not (piecePlayed ?color)))\n(<= (next (pieceCount ?color ?np1))\n    (true (pieceCount ?color ?n))\n    (piecePlayed ?color)\n    (succ ?n ?np1))\n(<= (piecePlayed ?color)\n    (does ?player (move ?x ?n))\n    (true (isColor ?player ?color)))\n(<= terminal\n    (won ?player))\n(<= (goal ?player 100)\n    (won ?player))\n(<= (goal ?player 0)\n    (role ?player)\n    (not (won ?player)))\n(<= (won ?player)\n    (true (isColor ?player ?color))\n    (true (pieceCount ?color 19)))\n(<= (empty ?x ?n)\n    (validCell ?x ?n)\n    (not (true (cell ?x ?n red)))\n    (not (true (cell ?x ?n blue))))\n(<= (validCell ?x ?n)\n    (length ?x ?len)\n    (lte 1 ?n)\n    (lte ?n ?len))\n(color red)\n(color blue)\n(opponent red blue)\n(opponent blue red)\n(length 1 4)\n(length 2 5)\n(length 3 6)\n(length 4 7)\n(length 5 6)\n(length 6 5)\n(length 7 4)\n(<= (connected ?x ?n1 ?x ?n2)\n    (diff1 ?n1 ?n2)\n    (validCell ?x ?n1)\n    (validCell ?x ?n2))\n(<= (connected ?x1 ?n ?x2 ?n)\n    (diff1 ?x1 ?x2)\n    (validCell ?x1 ?n)\n    (validCell ?x2 ?n))\n(<= (connected ?x1 ?n1 ?x2 ?n2)\n    (diff1 ?x1 ?x2)\n    (greaterLength ?x2 ?x1)\n    (succ ?n1 ?n2))\n(<= (connected ?x1 ?n1 ?x2 ?n2)\n    (diff1 ?x1 ?x2)\n    (greaterLength ?x1 ?x2)\n    (succ ?n2 ?n1))\n(<= (greaterLength ?x2 ?x1)\n    (length ?x1 ?l1)\n    (length ?x2 ?l2)\n    (lt ?l1 ?l2))\n(<= (diff1 ?m ?n)\n    (succ ?m ?n))\n(<= (diff1 ?n ?m)\n    (succ ?m ?n))\n(<= (lt ?x ?y)\n    (succ ?x ?y))\n(<= (lt ?x ?z)\n    (succ ?y ?z)\n    (lt ?x ?y))\n(<= (lte ?m ?m)\n    (succ ?m ?n))\n(<= (lte ?x ?y)\n    (lt ?x ?y))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on two separate 3-by-3 grids, each with cells identified by coordinates (m, n) where both m and n range from 1 to 3. The coordinate system labels rows from 1 to 3 and columns from 1 to 3 in each grid. Two players, named xplayer and oplayer, alternate turns, with xplayer starting first as indicated by the initial control. On each turn, the player in control can legally place their mark on any unoccupied cell (denoted by 'b' for blank) on the grid they are allowed to mark on during that turn. Specifically, xplayer marks cells on the first grid using the action mark1, and oplayer marks cells on the first grid similarly; on the subsequent grid, xplayer uses mark2 and oplayer does likewise, alternating control after each move. A player’s move consists of specifying the coordinates of the cell they wish to mark, and it is only legal if the cell is currently blank, it is that player’s turn, and the game is not in a terminal state. If it is not a player's turn, the only legal action they may take is noop, effectively passing control to the other player without changing the board state. After a player marks a cell, that cell's state updates to that player’s symbol (x or o) on the relevant grid, while all other cells retain their previous state. The control alternates strictly between xplayer and oplayer after each move. The game tracks winning conditions by checking for any full row, column, or diagonal of identical marks on either grid. Terminal conditions are met if either player has completed such a line on the first grid (terminal1) or the second grid (terminal2), or if there are no blank cells remaining on the first grid (no open1) or the second grid (no open2), combined with the absence of winning lines. Scoring depends on the presence or absence of winning lines on both boards and whether open cells remain, with players receiving values of 0, 25, 50, 75, or 100 points based on complex conditions comparing lines of x and o on both grids and the availability of moves. These scores determine the winner. Implicit constraints ensure moves must be within the 3x3 grid boundaries, cells cannot be occupied more than once, and players cannot place marks out of turn or on already occupied cells. The game ends when a player achieves a winning line on either board or when no further moves can be made on the boards without a winner, at which point the final scores adjudicate victory.",
    "output": "(role xplayer)\n(role oplayer)\n(init (cell1 1 1 b))\n(init (cell1 1 2 b))\n(init (cell1 1 3 b))\n(init (cell1 2 1 b))\n(init (cell1 2 2 b))\n(init (cell1 2 3 b))\n(init (cell1 3 1 b))\n(init (cell1 3 2 b))\n(init (cell1 3 3 b))\n(init (control xplayer))\n(<= (next (cell1 ?m ?n ?x))\n(does ?p (mark2 ?x2 ?y2))\n(true (cell1 ?m ?n ?x)))\n(<= (next (cell1 ?m ?n x))\n(does xplayer (mark1 ?m ?n))\n(true (cell1 ?m ?n b)))\n(<= (next (cell1 ?m ?n o))\n(does oplayer (mark1 ?m ?n))\n(true (cell1 ?m ?n b)))\n(<= (next (cell1 ?m ?n ?w))\n(true (cell1 ?m ?n ?w))\n(distinct ?w b))\n(<= (next (cell1 ?m ?n b))\n(does ?w (mark1 ?j ?k))\n(true (cell1 ?m ?n b))\n(or (distinct ?m ?j) (distinct ?n ?k)))\n(<= (next (control xplayer))\n(true (control oplayer)))\n(<= (next (control oplayer))\n(true (control xplayer)))\n(<= (row1 ?m ?x)\n(true (cell1 ?m 1 ?x))\n(true (cell1 ?m 2 ?x))\n(true (cell1 ?m 3 ?x)))\n(<= (column1 ?n ?x)\n(true (cell1 1 ?n ?x))\n(true (cell1 2 ?n ?x))\n(true (cell1 3 ?n ?x)))\n(<= (diagonal1 ?x)\n(true (cell1 1 1 ?x))\n(true (cell1 2 2 ?x))\n(true (cell1 3 3 ?x)))\n(<= (diagonal1 ?x)\n(true (cell1 1 3 ?x))\n(true (cell1 2 2 ?x))\n(true (cell1 3 1 ?x)))\n(<= (line1 ?x) (row1 ?m ?x))\n(<= (line1 ?x) (column1 ?m ?x))\n(<= (line1 ?x) (diagonal1 ?x))\n(<= open1\n(true (cell1 ?m ?n b)))\n(<= (legal ?w (mark1 ?x ?y))\n(true (cell1 ?x ?y b))\n(true (control ?w))\n(not terminal1))\n(<= (legal xplayer noop)\n(true (control oplayer)))\n(<= (legal oplayer noop)\n(true (control xplayer)))\n(<= (goal xplayer 100)\n(line1 x)\n(line2 x))\n(<= (goal xplayer 75)\n(not (line1 x))\n(not (line1 o))\n(not open1)\n(line2 x))\n(<= (goal xplayer 75)\n(line1 x)\n(not (line2 x))\n(not (line2 o))\n(not open2))\n(<= (goal xplayer 50)\n(not (line1 x))\n(not (line1 o))\n(not open1)\n(not (line2 x))\n(not (line2 o))\n(not open2))\n(<= (goal xplayer 50)\n(line1 x)\n(line2 o))\n(<= (goal xplayer 50)\n(line2 x)\n(line1 o))\n(<= (goal xplayer 25)\n(not (line1 x))\n(not (line1 o))\n(not open1)\n(line2 o))\n(<= (goal xplayer 25)\n(line1 o)\n(not (line2 x))\n(not (line2 o))\n(not open2))\n(<= (goal xplayer 0)\n(line1 o)\n(line2 o))\n(<= (goal oplayer 100)\n(line1 o)\n(line2 o))\n(<= (goal oplayer 75)\n(not (line1 x))\n(not (line1 o))\n(not open1)\n(line2 o))\n(<= (goal oplayer 75)\n(line1 o)\n(not (line2 x))\n(not (line2 o))\n(not open2))\n(<= (goal oplayer 50)\n(line1 o)\n(line2 x))\n(<= (goal oplayer 50)\n(line1 x)\n(line2 o))\n(<= (goal oplayer 50)\n(not (line1 x))\n(not (line1 o))\n(not open1)\n(not (line2 x))\n(not (line2 o))\n(not open2))\n(<= (goal oplayer 25)\n(not (line1 x))\n(not (line1 o))\n(not open1)\n(line2 x))\n(<= (goal oplayer 25)\n(line1 x)\n(not (line2 x))\n(not (line2 o))\n(not open2))\n(<= (goal oplayer 0)\n(line1 x)\n(line2 x))\n(<= terminal\nterminal1\nterminal2)\n(<= terminal1\n(line1 x))\n(<= terminal1\n(line1 o))\n(<= terminal1\n(not open1))\n(<= terminal2\n(line2 x))\n(<= terminal2\n(line2 o))\n(<= terminal2\n(not open2))\n(init (cell2 1 1 b))\n(init (cell2 1 2 b))\n(init (cell2 1 3 b))\n(init (cell2 2 1 b))\n(init (cell2 2 2 b))\n(init (cell2 2 3 b))\n(init (cell2 3 1 b))\n(init (cell2 3 2 b))\n(init (cell2 3 3 b))\n(<= (next (cell2 ?m ?n ?x))\n(does ?p (mark1 ?x1 ?y1))\n(true (cell2 ?m ?n ?x)))\n(<= (next (cell2 ?m ?n x))\n(does xplayer (mark2 ?m ?n))\n(true (cell2 ?m ?n b)))\n(<= (next (cell2 ?m ?n o))\n(does oplayer (mark2 ?m ?n))\n(true (cell2 ?m ?n b)))\n(<= (next (cell2 ?m ?n ?w))\n(true (cell2 ?m ?n ?w))\n(distinct ?w b))\n(<= (next (cell2 ?m ?n b))\n(does ?w (mark2 ?j ?k))\n(true (cell2 ?m ?n b))\n(or (distinct ?m ?j) (distinct ?n ?k)))\n(<= (row2 ?m ?x)\n(true (cell2 ?m 1 ?x))\n(true (cell2 ?m 2 ?x))\n(true (cell2 ?m 3 ?x)))\n(<= (column2 ?n ?x)\n(true (cell2 1 ?n ?x))\n(true (cell2 2 ?n ?x))\n(true (cell2 3 ?n ?x)))\n(<= (diagonal2 ?x)\n(true (cell2 1 1 ?x))\n(true (cell2 2 2 ?x))\n(true (cell2 3 3 ?x)))\n(<= (diagonal2 ?x)\n(true (cell2 1 3 ?x))\n(true (cell2 2 2 ?x))\n(true (cell2 3 1 ?x)))\n(<= (line2 ?x) (row2 ?m ?x))\n(<= (line2 ?x) (column2 ?m ?x))\n(<= (line2 ?x) (diagonal2 ?x))\n(<= open2\n(true (cell2 ?m ?n b)))\n(<= (legal ?w (mark2 ?x ?y))\n(true (cell2 ?x ?y b))\n(true (control ?w))\n(not terminal2))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a three-dimensional cubic lattice with coordinates ranging from 0 to 7 along each of the x, y, and z axes, forming an 8x8x8 grid. The environment consists of cubes initially placed at ground level (z = 0) in a triangular formation where each layer extends one unit further along the x and y axes, starting from (0,0,0) up to (7,7,0). Three players participate, each assigned the roles yellow, red, and green, who take turns in a fixed cyclical order: yellow moves first, followed by red, then green, and back to yellow. At the start, the player yellow has control, and each player possesses 28 cubes to place within the grid. On a player's turn, they may perform either a \"put\" action, specifying coordinates (x, y, z) where they wish to place one of their cubes, or a \"noop\" action, which passes their turn without placing a cube but is only permitted when it is not their turn to move.\n\nA \"put\" action is legal if the player has control and the targeted cube position is open for placement according to two conditions: either the cube lies directly above a fully formed cubic structure comprised of that player's previously placed cubes—meaning that the positions immediately below it along the x, y, and z axes are all occupied by cubes of the same player—or if no other player currently has any open cubic positions at that coordinate, allowing placement at the ground level or other valid positions. The game enforces that players can only place cubes atop existing cubes that form a complete cube underneath, ensuring stable stacking in the three-dimensional space. Occupancy conflicts are prevented by disallowing placement on already filled positions, and coordinates must remain within the board boundaries from 0 to 7 in each dimension.\n\nWhen a player places a cube, their cube count decreases by one, and the game's state updates to reflect the newly filled cube position with that player's color. Control typically passes to the next player with remaining cubes unless certain conditions prevent this, such as when the current player has no cubes left or other players have open cubic positions, in which case control remains unchanged. The \"noop\" action acts as a mechanism for players to skip their move when it is not their turn, ensuring orderly turn progression.\n\nThe game terminates when the last possible cube position at coordinates (7,7,7) becomes filled, marking the completion of the cubic lattice. Scoring is based on ownership of the cube at this terminal position: if a player occupies the last cube and no other players have open cubic positions at that location, they receive a full score of 100 points; if other players have open cubic positions at that coordinate, the occupying player scores 50 points; all other players receive zero points at the game's end. Thus, victory is determined by the strategic placement of cubes to control the topmost position of the cubic structure while preventing opponents from maintaining open positions above it.",
    "output": "(role yellow)\n(role red)\n(role green)\n(nextplayer yellow red)\n(nextplayer red green)\n(nextplayer green yellow)\n(init (control yellow))\n(init (cubes yellow 28))\n(init (cubes red 28))\n(init (cubes green 28))\n(init (cube 0 0 0 ground))\n(init (cube 1 0 0 ground))\n(init (cube 1 1 0 ground))\n(init (cube 2 0 0 ground))\n(init (cube 2 1 0 ground))\n(init (cube 2 2 0 ground))\n(init (cube 3 0 0 ground))\n(init (cube 3 1 0 ground))\n(init (cube 3 2 0 ground))\n(init (cube 3 3 0 ground))\n(init (cube 4 0 0 ground))\n(init (cube 4 1 0 ground))\n(init (cube 4 2 0 ground))\n(init (cube 4 3 0 ground))\n(init (cube 4 4 0 ground))\n(init (cube 5 0 0 ground))\n(init (cube 5 1 0 ground))\n(init (cube 5 2 0 ground))\n(init (cube 5 3 0 ground))\n(init (cube 5 4 0 ground))\n(init (cube 5 5 0 ground))\n(init (cube 6 0 0 ground))\n(init (cube 6 1 0 ground))\n(init (cube 6 2 0 ground))\n(init (cube 6 3 0 ground))\n(init (cube 6 4 0 ground))\n(init (cube 6 5 0 ground))\n(init (cube 6 6 0 ground))\n(init (cube 7 0 0 ground))\n(init (cube 7 1 0 ground))\n(init (cube 7 2 0 ground))\n(init (cube 7 3 0 ground))\n(init (cube 7 4 0 ground))\n(init (cube 7 5 0 ground))\n(init (cube 7 6 0 ground))\n(init (cube 7 7 0 ground))\n(lastcube 7 7 7)\n(<= (legal ?player (put ?x ?y ?z))\n(true (control ?player))\n(other_players_open_cubicup ?player ?x ?y ?z))\n(<= (legal ?player (put ?x ?y ?z))\n(true (control ?player))\n(not (any_other_players_open_cubicup ?player))\n(filled ?xp ?yp ?zp)\n(succ ?xp ?x)\n(filled ?x ?yp ?zp)\n(succ ?yp ?y)\n(filled ?x ?y ?zp)\n(succ ?zp ?z)\n(not (filled ?x ?y ?z)))\n(<= (legal ?player noop)\n(role ?player)\n(not (true (control ?player))))\n(<= (cubicup ?player ?x ?y ?z)\n(role ?player)\n(true (cube ?xp ?yp ?zp ?player))\n(succ ?xp ?x)\n(true (cube ?x ?yp ?zp ?player))\n(succ ?yp ?y)\n(true (cube ?x ?y ?zp ?player))\n(succ ?zp ?z))\n(<= (other_players_open_cubicup ?player ?x ?y ?z)\n(other_players_cubicup ?player ?x ?y ?z)\n(not (filled ?x ?y ?z)))\n(<= (any_other_players_open_cubicup ?player)\n(other_players_open_cubicup ?player ?x ?y ?z))\n(<= (other_players_cubicup ?player ?x ?y ?z)\n(cubicup ?player2 ?x ?y ?z)\n(role ?player)\n(distinct ?player ?player2))\n(<= dont_change_control\n(true (control ?player))\n(not (true (cubes ?player 1)))\n(any_other_players_open_cubicup ?player))\n(<= dont_change_control\n(not exists_other_player_with_cubes))\n(<= exists_other_player_with_cubes\n(true (control ?player))\n(true (cubes ?player2 ?n))\n(distinct ?n 0)\n(distinct ?player2 ?player))\n(<= (next (control ?player))\n(true (control ?player))\ndont_change_control)\n(<= (next (control ?nextplayer))\n(not dont_change_control)\n(true (control ?player))\n(true (cubes ?nextplayer ?n))\n(distinct ?n 0)\n(nextplayer ?player ?player1)\n(nextplayer_with_cubes ?player1 ?nextplayer))\n(<= (nextplayer_with_cubes ?player ?player)\n(true (cubes ?player ?n))\n(distinct ?n 0))\n(<= (nextplayer_with_cubes ?player ?nextplayer)\n(true (cubes ?player 0))\n(nextplayer ?player ?player1)\n(nextplayer_with_cubes ?player1 ?nextplayer))\n(<= (next (cube ?x ?y ?z ?color))\n(true (cube ?x ?y ?z ?color)))\n(<= (next (cube ?x ?y ?z ?player))\n(does ?player (put ?x ?y ?z)))\n(<= (next (cubes ?player ?n))\n(true (cubes ?player ?n))\n(not (true (control ?player))))\n(<= (next (cubes ?player ?n))\n(true (cubes ?player ?n1))\n(true (control ?player))\n(succ ?n ?n1))\n(<= (goal ?player 100)\n(lastcube ?x ?y ?z)\n(true (cube ?x ?y ?z ?player))\n(not (other_players_cubicup ?player ?x ?y ?z)))\n(<= (goal ?w 50)\n(role ?w)\n(lastcube ?x ?y ?z)\n(true (cube ?x ?y ?z ?player1))\n(other_players_cubicup ?player1 ?x ?y ?z))\n(<= (goal ?player2 0)\n(lastcube ?x ?y ?z)\n(true (cube ?x ?y ?z ?player))\n(not (other_players_cubicup ?player ?x ?y ?z))\n(role ?player2)\n(distinct ?player ?player2))\n(<= terminal\n(lastcube ?x ?y ?z)\n(filled ?x ?y ?z))\n(<= (filled ?x ?y ?z)\n(true (cube ?x ?y ?z ?color)))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place in an environment consisting of three pillars named pillar1, pillar2, and pillar3, with seven discs of increasing size labeled disc1 through disc7. The coordinate system is hierarchical, where discs can be stacked on top of each other or on pillars, forming towers. Initially, all seven discs are stacked in decreasing size order on pillar1, with disc7 at the bottom and disc1 at the top, while pillar2 and pillar3 are empty and clear. The single player, referred to as \"player,\" takes turns making moves; the turn progression is tracked by a step counter starting at s0 and incrementing sequentially up to s127, after which the game terminates. On each turn, the player may choose to perform a single legal action or no action (a noop). Legal actions consist of moving a clear (uncovered) disc onto a clear target, which can be a pillar or a larger disc, with the condition that the disc being moved must be smaller than the destination object. The action format is expressed as putting one disc onto another object, and legality requires both the source disc and the destination to be clear and that the source disc is strictly smaller in size than the target. After an action, the game state updates so that the moved disc is now on the new object, the previously occupied position of the moved disc becomes clear, and the destination is no longer clear because it now supports the moved disc. If no disc is moved, the state remains unchanged except for the step counter incrementing. The game enforces implicit constraints such as the stacking order reflecting size hierarchy—no disc may be placed on a smaller disc—and only one disc may occupy a position at a time, preventing overlaps. The game ends either when the step counter reaches s127 or when the player achieves a tower of discs on pillar3. The height of the tower is measured by counting the number of discs stacked in proper order on pillar3, starting from zero. The player's score depends on the tower height achieved on pillar3 at the end of the game: a full tower of all seven discs yields the maximum score of 100, with partial towers scoring progressively less, down to zero if the tower is shorter than four discs. Thus, victory is defined by successfully relocating the entire stack from pillar1 to pillar3 in the proper order within the allotted steps, maximizing the score accordingly.",
    "output": "(role player)\n(init (on disc7 pillar1))\n(init (on disc6 disc7))\n(init (on disc5 disc6))\n(init (on disc4 disc5))\n(init (on disc3 disc4))\n(init (on disc2 disc3))\n(init (on disc1 disc2))\n(init (clear disc1))\n(init (clear pillar2))\n(init (clear pillar3))\n(init (step s0))\n(<= (legal player (puton ?x ?y))\n    (true (clear ?x))\n    (true (clear ?y))\n    (smallerdisc ?x ?y))\n(<= (next (step ?y))\n    (true (step ?x))\n    (successor ?x ?y))\n(<= (next (on ?x ?y))\n    (does player (puton ?x ?y)))\n(<= (next (on ?x ?y))\n    (true (on ?x ?y))\n    (not (put_on_any ?x)))\n(<= (next (clear ?y))\n    (true (on ?x ?y))\n\t(put_on_any ?x))\n(<= (next (clear ?y))\n    (true (clear ?y))\n    (not (put_any_on ?y)))\n(<= (put_on_any ?x)\n    (does player (puton ?x ?y)))\n(<= (put_any_on ?y)\n    (does player (puton ?x ?y)))\n(<= (goal player 100)\n    (tower pillar3 s7))\n(<= (goal player 80)\n    (tower pillar3 s6))\n(<= (goal player 60)\n    (tower pillar3 s5))\n(<= (goal player 40)\n    (tower pillar3 s4))\n(<= (goal player 0)\n    (tower pillar3 ?height)\n    (smaller ?height s4))\n(<= terminal\n    (true (step s127)))\n(<= (tower ?x s0)\n    (true (clear ?x)))\n(<= (tower ?x ?height)\n    (true (on ?y ?x))\n    (disc_or_pillar ?y)\n    (tower ?y ?height1)\n    (successor ?height1 ?height))\n(pillar pillar1)\n(pillar pillar2)\n(pillar pillar3)\n(nextsize disc1 disc2)\n(nextsize disc2 disc3)\n(nextsize disc3 disc4)\n(nextsize disc4 disc5)\n(nextsize disc5 disc6)\n(nextsize disc6 disc7)\n(disc_or_pillar disc1)\n(disc_or_pillar disc2)\n(disc_or_pillar disc3)\n(disc_or_pillar disc4)\n(disc_or_pillar disc5)\n(disc_or_pillar disc6)\n(disc_or_pillar disc7)\n(<= (disc_or_pillar ?p)\n\t(pillar ?p))\n(<= (nextsize disc7 ?pillar)\n    (pillar ?pillar))\n(<= (smallerdisc ?a ?b)\n    (nextsize ?a ?b))\n(<= (smallerdisc ?a ?b)\n    (nextsize ?a ?c)\n    (smallerdisc ?c ?b))\n(successor s0 s1)\n(successor s1 s2)\n(successor s2 s3)\n(successor s3 s4)\n(successor s4 s5)\n(successor s5 s6)\n(successor s6 s7)\n(successor s7 s8)\n(successor s8 s9)\n(successor s9 s10)\n(successor s10 s11)\n(successor s11 s12)\n(successor s12 s13)\n(successor s13 s14)\n(successor s14 s15)\n(successor s15 s16)\n(successor s16 s17)\n(successor s17 s18)\n(successor s18 s19)\n(successor s19 s20)\n(successor s20 s21)\n(successor s21 s22)\n(successor s22 s23)\n(successor s23 s24)\n(successor s24 s25)\n(successor s25 s26)\n(successor s26 s27)\n(successor s27 s28)\n(successor s28 s29)\n(successor s29 s30)\n(successor s30 s31)\n(successor s31 s32)\n(successor s32 s33)\n(successor s33 s34)\n(successor s34 s35)\n(successor s35 s36)\n(successor s36 s37)\n(successor s37 s38)\n(successor s38 s39)\n(successor s39 s40)\n(successor s40 s41)\n(successor s41 s42)\n(successor s42 s43)\n(successor s43 s44)\n(successor s44 s45)\n(successor s45 s46)\n(successor s46 s47)\n(successor s47 s48)\n(successor s48 s49)\n(successor s49 s50)\n(successor s50 s51)\n(successor s51 s52)\n(successor s52 s53)\n(successor s53 s54)\n(successor s54 s55)\n(successor s55 s56)\n(successor s56 s57)\n(successor s57 s58)\n(successor s58 s59)\n(successor s59 s60)\n(successor s60 s61)\n(successor s61 s62)\n(successor s62 s63)\n(successor s63 s64)\n(successor s64 s65)\n(successor s65 s66)\n(successor s66 s67)\n(successor s67 s68)\n(successor s68 s69)\n(successor s69 s70)\n(successor s70 s71)\n(successor s71 s72)\n(successor s72 s73)\n(successor s73 s74)\n(successor s74 s75)\n(successor s75 s76)\n(successor s76 s77)\n(successor s77 s78)\n(successor s78 s79)\n(successor s79 s80)\n(successor s80 s81)\n(successor s81 s82)\n(successor s82 s83)\n(successor s83 s84)\n(successor s84 s85)\n(successor s85 s86)\n(successor s86 s87)\n(successor s87 s88)\n(successor s88 s89)\n(successor s89 s90)\n(successor s90 s91)\n(successor s91 s92)\n(successor s92 s93)\n(successor s93 s94)\n(successor s94 s95)\n(successor s95 s96)\n(successor s96 s97)\n(successor s97 s98)\n(successor s98 s99)\n(successor s99 s100)\n(successor s100 s101)\n(successor s101 s102)\n(successor s102 s103)\n(successor s103 s104)\n(successor s104 s105)\n(successor s105 s106)\n(successor s106 s107)\n(successor s107 s108)\n(successor s108 s109)\n(successor s109 s110)\n(successor s110 s111)\n(successor s111 s112)\n(successor s112 s113)\n(successor s113 s114)\n(successor s114 s115)\n(successor s115 s116)\n(successor s116 s117)\n(successor s117 s118)\n(successor s118 s119)\n(successor s119 s120)\n(successor s120 s121)\n(successor s121 s122)\n(successor s122 s123)\n(successor s123 s124)\n(successor s124 s125)\n(successor s125 s126)\n(successor s126 s127)\n(<= (smaller ?x ?y)\n    (successor ?x ?y))\n(<= (smaller ?x ?y)\n    (successor ?x ?z)\n    (smaller ?z ?y))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid with coordinates ranging from 1 to 6 for both the x (horizontal) and y (vertical) axes, establishing a two-dimensional board environment. There are two player roles: white and black, who alternate turns with white moving first, followed by black, and so forth. The initial setup places white pieces along the first and second rows (y = 1 and y = 2) covering all columns from 1 to 6, while black pieces occupy the fifth and sixth rows (y = 5 and y = 6) across all columns. Additionally, there are designated hole cells at positions (2,3), (3,4), (4,3), and (5,4) which are impassable and cannot be occupied by any piece. On a player's turn, they may perform a move action or a noop; the noop action is only legal for the player who does not currently have control, effectively passing the turn when the opponent is to move. Moves consist of relocating one of the player's pieces forward one row in the direction of the opponent's side, either directly forward in the same column or diagonally forward to an adjacent column, as long as the destination cell is within the board boundaries, is not occupied by any piece (friendly or enemy), and is not a hole cell. Specifically, white pieces move from lower to higher y-coordinates, advancing one row forward either vertically or diagonally left or right by one column, while black pieces move from higher to lower y-coordinates with similar lateral moves. The legality of a move requires the piece to currently occupy the starting cell and the destination cell to be unoccupied and free of holes. Executing a move updates the board state by relocating the piece from its original position to the new position, marking the starting cell as vacated and the destination cell as occupied by the moving player. Control switches to the opposing player after each move. The game ends under terminal conditions when either player achieves victory by having any of their pieces reach the opponent's home row — white wins if any white piece reaches y = 6, and black wins if any black piece reaches y = 1. Additionally, a player wins if it is the opponent's turn and that opponent has no legal moves available. The scoring reflects these outcomes, awarding 100 points to the winner and 0 points to the loser. Throughout the game, pieces cannot move onto or through hole cells, cannot move outside the 6x6 board, and cannot occupy the same cell simultaneously. These constraints ensure a clear progression toward victory by advancing pieces forward while avoiding obstacles and blocked paths.",
    "output": "(role white)\n(role black)\n(<= (init (cell ?x ?y hole))\n    (holeCell ?x ?y))\n(holeCell 2 3)\n(holeCell 3 4)\n(holeCell 4 3)\n(holeCell 5 4)\n(init (cell 1 1 white))\n(init (cell 2 1 white))\n(init (cell 3 1 white))\n(init (cell 4 1 white))\n(init (cell 5 1 white))\n(init (cell 6 1 white))\n(init (cell 1 2 white))\n(init (cell 2 2 white))\n(init (cell 3 2 white))\n(init (cell 4 2 white))\n(init (cell 5 2 white))\n(init (cell 6 2 white))\n(init (cell 1 5 black))\n(init (cell 2 5 black))\n(init (cell 3 5 black))\n(init (cell 4 5 black))\n(init (cell 5 5 black))\n(init (cell 6 5 black))\n(init (cell 1 6 black))\n(init (cell 2 6 black))\n(init (cell 3 6 black))\n(init (cell 4 6 black))\n(init (cell 5 6 black))\n(init (cell 6 6 black))\n(init (control white))\n(<= (legal ?player ?move)\n    (legal2 ?player ?move))\n(<= (hasAnyLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (legal2 white (move ?x ?y1 ?x ?y2))\n    (true (control white))\n    (true (cell ?x ?y1 white))\n    (plusplus ?y1 ?y2)\n    (not (true (cell ?x ?y2 white)))\n    (not (true (cell ?x ?y2 black)))\n    (not (true (cell ?x ?y2 hole))))\n(<= (legal2 white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cell ?x1 ?y1 white))\n    (plusplus ?y1 ?y2)\n    (plusplus ?x1 ?x2)\n    (not (true (cell ?x2 ?y2 white)))\n    (not (true (cell ?x2 ?y2 hole))))\n(<= (legal2 white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cell ?x1 ?y1 white))\n    (plusplus ?y1 ?y2)\n    (plusplus ?x2 ?x1)\n    (not (true (cell ?x2 ?y2 white)))\n    (not (true (cell ?x2 ?y2 hole))))\n(<= (legal2 black (move ?x ?y1 ?x ?y2))\n    (true (control black))\n    (true (cell ?x ?y1 black))\n    (plusplus ?y2 ?y1)\n    (not (true (cell ?x ?y2 white)))\n    (not (true (cell ?x ?y2 black)))\n    (not (true (cell ?x ?y2 hole))))\n(<= (legal2 black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cell ?x1 ?y1 black))\n    (plusplus ?y2 ?y1)\n    (plusplus ?x1 ?x2)\n    (not (true (cell ?x2 ?y2 black)))\n    (not (true (cell ?x2 ?y2 hole))))\n(<= (legal2 black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cell ?x1 ?y1 black))\n    (plusplus ?y2 ?y1)\n    (plusplus ?x2 ?x1)\n    (not (true (cell ?x2 ?y2 black)))\n    (not (true (cell ?x2 ?y2 hole))))\n(<= (legal2 white noop)\n    (true (control black)))\n(<= (legal2 black noop)\n    (true (control white)))\n(<= (next (cell ?x2 ?y2 ?player))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?state))\n    (true (cell ?x ?y ?state))\n    (not (cameFrom ?x ?y))\n    (not (wentTo ?x ?y)))\n(<= (next (cell ?x ?y hole))\n\t(true (cell ?x ?y hole)))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= terminal\n    whiteWin)\n(<= terminal\n    blackWin)\n(<= (goal white 100)\n    whiteWin)\n(<= (goal white 0)\n    (not whiteWin))\n(<= (goal black 100)\n    blackWin)\n(<= (goal black 0)\n    (not blackWin))\n(<= (cameFrom ?x1 ?y1)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (wentTo ?x2 ?y2)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= whiteWin\n    (index ?x)\n    (true (cell ?x 6 white)))\n(<= blackWin\n    (index ?x)\n    (true (cell ?x 1 black)))\n(<= whiteWin\n    (true (control black))\n    (not (hasAnyLegalMove black)))\n(<= blackWin\n    (true (control white))\n    (not (hasAnyLegalMove white)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6)\n(plusplus 1 2)  (plusplus 2 3)  (plusplus 3 4)  (plusplus 4 5)  (plusplus 5 6)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a three-dimensional grid composed of 27 cells arranged in a 3x3x3 format, each cell identified by four coordinates: three indices ranging from 1 to 3 that specify the position within the layers and sublayers, and an additional dimension to distinguish between different segments of the board. The coordinate system uses these four integers to precisely locate each cell. There is a single player role named \"robot\" who takes turns marking the cells. The initial state of the game is defined with some cells already filled with digits from 1 to 9, while others are marked as blank (denoted by 'b'). On each turn, the robot player can perform a marking action specified by the command to mark a particular cell at coordinates (i, j, k, l) with a digit value x. However, such an action is only legal if the targeted cell is currently blank and if placing the digit x does not violate the Sudoku-like constraints: the digit must not already exist in the same row, column, or 3x3 square segment identified by the coordinates. The row constraint checks all cells sharing the same second and third coordinate pair, the column constraint considers cells sharing the first two coordinates, and the square constraint refers to cells grouped within the same sub-cube in the 3D structure. If the robot performs a marking action, the state updates by replacing the blank cell with the chosen digit; all other cells retain their previous values unless directly affected by the action. No explicit no-operation (noop) action is defined, implying that the robot must always attempt a valid marking if possible. The game automatically ends (terminal condition) when there are no more playable moves, meaning no blank cells remain or no legal digit placements are possible. The scoring is binary: the robot scores 100 points if the board is completely and validly filled with digits, indicating successful completion, or 0 points if there are still open blank cells. Thus, the game challenges the robot to fill all blank cells with digits following Sudoku rules extended into a 3D grid until no moves remain, achieving a perfect solution for maximum points.",
    "output": "(role robot)\n  (init (cell 1 1 1 1 b))\n  (init (cell 1 1 1 2 b))\n  (init (cell 1 1 1 3 5))\n  (init (cell 1 1 2 1 4))\n  (init (cell 1 1 2 2 b))\n  (init (cell 1 1 2 3 1))\n  (init (cell 1 1 3 1 6))\n  (init (cell 1 1 3 2 b))\n  (init (cell 1 1 3 3 b))\n  (init (cell 1 2 1 1 b))\n  (init (cell 1 2 1 2 b))\n  (init (cell 1 2 1 3 b))\n  (init (cell 1 2 2 1 b))\n  (init (cell 1 2 2 2 6))\n  (init (cell 1 2 2 3 b))\n  (init (cell 1 2 3 1 b))\n  (init (cell 1 2 3 2 b))\n  (init (cell 1 2 3 3 b))\n  (init (cell 1 3 1 1 b))\n  (init (cell 1 3 1 2 9))\n  (init (cell 1 3 1 3 4))\n  (init (cell 1 3 2 1 b))\n  (init (cell 1 3 2 2 b))\n  (init (cell 1 3 2 3 7))\n  (init (cell 1 3 3 1 b))\n  (init (cell 1 3 3 2 2))\n  (init (cell 1 3 3 3 b))\n  (init (cell 2 1 1 1 3))\n  (init (cell 2 1 1 2 7))\n  (init (cell 2 1 1 3 b))\n  (init (cell 2 1 2 1 b))\n  (init (cell 2 1 2 2 2))\n  (init (cell 2 1 2 3 b))\n  (init (cell 2 1 3 1 b))\n  (init (cell 2 1 3 2 4))\n  (init (cell 2 1 3 3 b))\n  (init (cell 2 2 1 1 b))\n  (init (cell 2 2 1 2 b))\n  (init (cell 2 2 1 3 b))\n  (init (cell 2 2 2 1 b))\n  (init (cell 2 2 2 2 1))\n  (init (cell 2 2 2 3 b))\n  (init (cell 2 2 3 1 b))\n  (init (cell 2 2 3 2 b))\n  (init (cell 2 2 3 3 b))\n  (init (cell 2 3 1 1 b))\n  (init (cell 2 3 1 2 1))\n  (init (cell 2 3 1 3 b))\n  (init (cell 2 3 2 1 b))\n  (init (cell 2 3 2 2 4))\n  (init (cell 2 3 2 3 b))\n  (init (cell 2 3 3 1 b))\n  (init (cell 2 3 3 2 5))\n  (init (cell 2 3 3 3 6))\n  (init (cell 3 1 1 1 b))\n  (init (cell 3 1 1 2 5))\n  (init (cell 3 1 1 3 b))\n  (init (cell 3 1 2 1 8))\n  (init (cell 3 1 2 2 b))\n  (init (cell 3 1 2 3 b))\n  (init (cell 3 1 3 1 2))\n  (init (cell 3 1 3 2 6))\n  (init (cell 3 1 3 3 b))\n  (init (cell 3 2 1 1 b))\n  (init (cell 3 2 1 2 b))\n  (init (cell 3 2 1 3 b))\n  (init (cell 3 2 2 1 b))\n  (init (cell 3 2 2 2 9))\n  (init (cell 3 2 2 3 b))\n  (init (cell 3 2 3 1 b))\n  (init (cell 3 2 3 2 b))\n  (init (cell 3 2 3 3 b))\n  (init (cell 3 3 1 1 b))\n  (init (cell 3 3 1 2 b))\n  (init (cell 3 3 1 3 2))\n  (init (cell 3 3 2 1 3))\n  (init (cell 3 3 2 2 b))\n  (init (cell 3 3 2 3 6))\n  (init (cell 3 3 3 1 9))\n  (init (cell 3 3 3 2 b))\n  (init (cell 3 3 3 3 b))\n  (<= (legal robot (mark ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l b))\n      (digit ?x)\n      (not (row ?k ?l ?x))\n      (not (col ?i ?j ?x))\n      (not (square ?i ?k ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 3 ?k ?l ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 3 ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?i ?j ?k ?l ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?s ?i))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?t ?j))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?u ?k))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?v ?l))\n  (<= (goal robot 100) (not open))\n  (<= (goal robot 0) open)\n  (<= terminal (not playable))\n  (<= (filler ?x) (digit ?x))\n  (filler b)\n  (<= open (true (cell ?i ?j ?k ?l b)))\n  (<= playable (legal robot (mark ?i ?j ?k ?l ?x)))\n  (index 1)\n  (index 2)\n  (index 3)\n  (digit 1)\n  (digit 2)\n  (digit 3)\n  (digit 4)\n  (digit 5)\n  (digit 6)\n  (digit 7)\n  (digit 8)\n  (digit 9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a complex multi-level board represented by four coordinates, each ranging from 1 to 3, establishing a hierarchical three-by-three grid system within a three-by-three grid, effectively creating sub-boards within a larger board. There are two players, named xPlayer and oPlayer, who alternate turns starting with xPlayer initially in control. On a player's turn, they may either perform a move or pass by executing a noop action, but a noop is only legal when it is the other player's turn to act, enforcing strict turn-taking discipline. Each move consists of placing the player's mark, either an 'x' or an 'o', into an empty cell specified by the four coordinates, which must be unoccupied by any mark; moves are constrained to cells that are within the current sub-board in play or, if the current sub-board is closed (fully occupied), any empty cell on the board. The first move of the game is restricted to any empty cell since no current sub-board is designated at the start. When a player places a mark at coordinates (i, j, k, l), this cell becomes marked with their symbol, and the current sub-board updates to the smaller board indexed by (k, l), determining the next active sub-board for the opponent's move. The game enforces that moves cannot be made outside of the designated sub-board unless it is closed, preventing placement in full sub-boards. The game ends when there is a line of three marks belonging to the same player in any row, column, or diagonal on any of the sub-boards or when no empty cells remain, signifying a fully occupied board with no winner. A line is defined as three consecutive marks of the same player either horizontally, vertically, or diagonally within a sub-board or the overarching board structure. Scoring assigns 100 points to a player who achieves such a line, 0 points to the opponent, and 50 points to both players if the board is full with no winner, representing a draw. The game state progresses by switching control to the other player after each move. Implicit constraints include the boundaries that limit indices to the set {1, 2, 3} for each coordinate, the prohibition of marking already occupied cells, and the requirement that moves adhere to the current sub-board unless it is closed. Throughout, the system maintains the marks placed on the board and tracks the current sub-board for the following move, effectively creating a layered Tic-Tac-Toe variant with nested boards and strategic sub-board targeting.",
    "output": "(role xPlayer)\n(role oPlayer)\n(init (control xPlayer))\n(<= (legal xPlayer noop)\n (true (control oPlayer)))\n(<= (legal xPlayer (play ?i ?j ?k ?l x))\n (true (control xPlayer))\n firstMove\n (emptyCell ?i ?j ?k ?l))\n(<= (legal xPlayer (play ?i ?j ?k ?l x))\n (true (control xPlayer))\n (true (currentBoard ?i ?j))\n (emptyCell ?i ?j ?k ?l))\n(<= (legal xPlayer (play ?i ?j ?k ?l x))\n (true (control xPlayer))\n currentBoardClosed\n (emptyCell ?i ?j ?k ?l))\n(<= (legal oPlayer noop)\n (true (control xPlayer)))\n(<= (legal oPlayer (play ?i ?j ?k ?l o))\n (true (control oPlayer))\n firstMove\n (emptyCell ?i ?j ?k ?l))\n(<= (legal oPlayer (play ?i ?j ?k ?l o))\n (true (control oPlayer))\n (true (currentBoard ?i ?j))\n (emptyCell ?i ?j ?k ?l))\n(<= (legal oPlayer (play ?i ?j ?k ?l o))\n (true (control oPlayer))\n currentBoardClosed\n (emptyCell ?i ?j ?k ?l))\n(<= (next (mark ?i ?j ?k ?l ?mark))\n (role ?player)\n (does ?player (play ?i ?j ?k ?l ?mark)))\n(<= (next (mark ?i ?j ?k ?l ?mark))\n (true (mark ?i ?j ?k ?l ?mark)))\n(<= (next (control xPlayer))\n (true (control oPlayer)))\n(<= (next (control oPlayer))\n (true (control xPlayer)))\n(<= (next (currentBoard ?k ?l))\n (role ?player)\n (does ?player (play ?i ?j ?k ?l ?mark)))\n(<= terminal\n (line x))\n(<= terminal\n (line o))\n(<= terminal\n (not open))\n(<= (goal xPlayer 0)\n (not (line x))\n (not (line o))\n open)\n(<= (goal xPlayer 100)\n (line x))\n(<= (goal xPlayer 50)\n (not (line x))\n (not (line o))\n (not open))\n(<= (goal xPlayer 0)\n (line o))\n(<= (goal oPlayer 0)\n (not (line x))\n (not (line o))\n open)\n(<= (goal oPlayer 100)\n (line o))\n(<= (goal oPlayer 50)\n (not (line x))\n (not (line o))\n (not open))\n(<= (goal oPlayer 0)\n (line x))\n(<= (row ?i ?j ?k ?mark)\n (true (mark ?i ?j ?k 1 ?mark))\n (true (mark ?i ?j ?k 2 ?mark))\n (true (mark ?i ?j ?k 3 ?mark)))\n(<= (col ?i ?j ?k ?mark)\n (true (mark ?i ?j 1 ?k ?mark))\n (true (mark ?i ?j 2 ?k ?mark))\n (true (mark ?i ?j 3 ?k ?mark)))\n(<= (diag ?i ?j ?mark)\n (true (mark ?i ?j 1 1 ?mark))\n (true (mark ?i ?j 2 2 ?mark))\n (true (mark ?i ?j 3 3 ?mark)))\n(<= (diag ?i ?j ?mark)\n (true (mark ?i ?j 1 3 ?mark))\n (true (mark ?i ?j 2 2 ?mark))\n (true (mark ?i ?j 3 1 ?mark)))\n(<= (line ?mark)\n (index ?i)\n (index ?j)\n (index ?k)\n (row ?i ?j ?k ?mark))\n(<= (line ?mark)\n (index ?i)\n (index ?j)\n (index ?k)\n (col ?i ?j ?k ?mark))\n(<= (line ?mark)\n (index ?i)\n (index ?j)\n (diag ?i ?j ?mark))\n(<= (emptyCell ?i ?j ?k ?l)\n (index ?i)\n (index ?j)\n (index ?k)\n (index ?l)\n (not (true (mark ?i ?j ?k ?l x)))\n (not (true (mark ?i ?j ?k ?l o))))\n(<= open (emptyCell ?i ?j ?k ?l))\n(<= currentBoardClosed\n (true (currentBoard ?i ?j))\n (not (emptyCell ?i ?j 1 1))\n (not (emptyCell ?i ?j 1 2))\n (not (emptyCell ?i ?j 1 3))\n (not (emptyCell ?i ?j 2 1))\n (not (emptyCell ?i ?j 2 2))\n (not (emptyCell ?i ?j 2 3))\n (not (emptyCell ?i ?j 3 1))\n (not (emptyCell ?i ?j 3 2))\n (not (emptyCell ?i ?j 3 3)))\n(<= firstMove\n (not (true (currentBoard 1 1)))\n (not (true (currentBoard 1 2)))\n (not (true (currentBoard 1 3)))\n (not (true (currentBoard 2 1)))\n (not (true (currentBoard 2 2)))\n (not (true (currentBoard 2 3)))\n (not (true (currentBoard 3 1)))\n (not (true (currentBoard 3 2)))\n (not (true (currentBoard 3 3))))\n(index 1) (index 2) (index 3)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a 5-by-5 grid with coordinates from 1 to 5 for both rows and columns, where each cell can be either occupied by a living entity or be barren. The single player role, called \"robot,\" acts in turns, and the game starts at step zero with an initial configuration of cells marked as either occupied or barren according to a predefined layout. On each turn, the robot may perform exactly one action: a kill action targeting a specific cell identified by its row and column coordinates. Such a kill action is legal only if the targeted cell is currently occupied by a living entity. If the robot does not perform any kill action, it effectively performs a no-operation for that turn, and the game state advances by one step regardless. After each action, the game state updates automatically according to specific rules that count the number of occupied neighboring cells for each cell—neighbors include all adjacent cells horizontally, vertically, and diagonally—and determine whether cells become occupied or barren in the next step based on these counts and whether a kill action was performed on them. Cells that were killed become barren in the next state, while others may survive or change status depending on their neighbors, following constraints that forbid cells from having exactly two, three, four, or five occupied neighbors to remain barren or occupied, accordingly. The board boundaries are implicitly enforced by the grid size; any neighbor counting respects these limits, and no cell can be outside the 1-to-5 range in either coordinate. Multiple occupancy is impossible, as each cell can hold only one state at a time. The game terminates either when the board becomes completely clear of occupied cells or when 30 steps have elapsed. The player's score depends on the number of occupied cells remaining at termination, with higher scores awarded for fewer occupied cells: a perfect score of 100 is given if no occupied cells remain, scaling down to zero as the count of living occupied cells increases beyond certain thresholds. The robot’s objective is thus to strategically choose kill actions each turn to reduce occupied cells effectively before the game ends automatically due to clearing or step limit.",
    "output": "(role robot)\n(init (cell 1 1 o))\n(init (cell 1 2 o))\n(init (cell 1 3 o))\n(init (cell 1 4 b))\n(init (cell 1 5 o))\n(init (cell 2 1 o))\n(init (cell 2 2 b))\n(init (cell 2 3 b))\n(init (cell 2 4 b))\n(init (cell 2 5 b))\n(init (cell 3 1 b))\n(init (cell 3 2 b))\n(init (cell 3 3 b))\n(init (cell 3 4 o))\n(init (cell 3 5 o))\n(init (cell 4 1 b))\n(init (cell 4 2 o))\n(init (cell 4 3 o))\n(init (cell 4 4 b))\n(init (cell 4 5 o))\n(init (cell 5 1 o))\n(init (cell 5 2 b))\n(init (cell 5 3 o))\n(init (cell 5 4 b))\n(init (cell 5 5 o))\n(init (step 0))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(<= (smaller ?x ?y)\n    (succ ?x ?y))\n(<= (smaller ?x ?z)\n    (succ ?y ?z)\n    (smaller ?x ?y))\n(<= (number ?x)\n    (succ ?x ?y))\n(<= (number ?y)\n    (succ ?x ?y))\n(rcsucc 1 2)\n(rcsucc 2 3)\n(rcsucc 3 4)\n(rcsucc 4 5)\n(rcsucc 5 1)\n(rcpred 1 5)\n(rcpred 2 1)\n(rcpred 3 2)\n(rcpred 4 3)\n(rcpred 5 4)\n(<= (legal robot (kill ?x ?y))\n    (true (cell ?x ?y o)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (succ ?x ?y))\n(<= (next (cell ?x ?y b))\n    (does robot (kill ?x ?y)))\n(<= (next (cell ?x ?y b))\n    (true (cell ?x ?y ?c))\n    (not (does robot (kill ?x ?y)))\n    (countneighbours ?x ?y 0 ?n)\n    (distinct ?n 2)\n    (distinct ?n 3)\n    (distinct ?n 4)\n    (distinct ?n 5))\n(<= (next (cell ?x ?y o))\n    (true (cell ?x ?y ?c))\n    (not (does robot (kill ?x ?y)))\n    (countneighbours ?x ?y 0 3))\n(<= (next (cell ?x ?y o))\n    (true (cell ?x ?y ?c))\n    (not (does robot (kill ?x ?y)))\n    (countneighbours ?x ?y 0 4))\n(<= (next (cell ?x ?y o))\n    (true (cell ?x ?y ?c))\n    (not (does robot (kill ?x ?y)))\n    (countneighbours ?x ?y 0 5))\n(<= (next (cell ?x ?y o))\n    (true (cell ?x ?y o))\n    (not (does robot (kill ?x ?y)))\n    (countneighbours ?x ?y 0 2))\n(<= (next (cell ?x ?y b))\n    (true (cell ?x ?y b))\n    (not (does robot (kill ?x ?y)))\n    (countneighbours ?x ?y 0 2))\n(<= (countneighbours ?x ?y ?n ?s)\n    (rcpred ?x ?xp)\n    (rcpred ?y ?yp)\n    (rcsucc ?x ?xs)\n    (rcsucc ?y ?ys)\n    (countifalive ?xp ?yp ?n ?c1)\n    (countifalive ?x ?yp ?c1 ?c2)\n    (countifalive ?xs ?yp ?c2 ?c3)\n    (countifalive ?xp ?y ?c3 ?c4)\n    (countifalive ?xs ?y ?c4 ?c5)\n    (countifalive ?xs ?ys ?c5 ?c6)\n    (countifalive ?x ?ys ?c6 ?c7)\n    (countifalive ?xp ?ys ?c7 ?s))\n(<= (countifalive ?x ?y ?i ?o)\n    (true (cell ?x ?y o))\n    (succ ?i ?o))\n(<= (countifalive ?x ?y ?i ?i)\n    (true (cell ?x ?y ?c))\n    (distinct ?c o)\n    (number ?i))\n(<= any_occupied\n    (true (cell ?x ?y o)))\n(<= clear\n    (not any_occupied))\n(<= terminal\n    clear)\n(<= terminal\n    (true (step 30)))\n(<= (goal robot 100)\n    (countalive 1 1 0 0))\n(<= (goal robot 80)\n    (countalive 1 1 0 ?n)\n    (distinct ?n 0)\n    (smaller ?n 6))\n(<= (goal robot 60)\n    (countalive 1 1 0 ?n)\n    (smaller 5 ?n)\n    (smaller ?n 11))\n(<= (goal robot 40)\n    (countalive 1 1 0 ?n)\n    (smaller 10 ?n)\n    (smaller ?n 16))\n(<= (goal robot 20)\n    (countalive 1 1 0 ?n)\n    (smaller 15 ?n)\n    (smaller ?n 21))\n(<= (goal robot 0)\n    (countalive 1 1 0 ?n)\n    (smaller 20 ?n))\n(<= (countalive 5 5 ?n1 ?n)\n    (countifalive 5 5 ?n1 ?n))\n(<= (countalive ?x 5 ?n1 ?n)\n    (rcsucc ?x ?x1)\n    (distinct ?x 5)\n    (countifalive ?x 5 ?n1 ?n2)\n    (countalive ?x1 1 ?n2 ?n))\n(<= (countalive ?x ?y ?n1 ?n)\n    (rcsucc ?y ?y1)\n    (distinct ?y 5)\n    (countifalive ?x ?y ?n1 ?n2)\n    (countalive ?x ?y1 ?n2 ?n))\n(<= (index ?x)\n    (rcsucc ?x ?y))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a square grid board with coordinates ranging from 1 to 14 in both the x (horizontal) and y (vertical) directions, where positions beyond 14 are considered invalid. Two players participate in the game, identified by the colors purple and orange, with purple starting in control initially. The turn order alternates strictly between the two players, such that after one player completes their move, control passes to the opposing player. Each player owns a fixed set of uniquely indexed pieces numbered from 1 to 21, each defined by a specific arrangement of cells relative to a reference point, and the initial board state places an orange piece on cell (7,8) and a purple piece on cell (8,7). On a player's turn, they may either choose to place one of their owned pieces onto the board or perform a no-operation (noop) action; however, noop is only legal for players who do not currently hold control of the turn, effectively preventing a player from passing when it is their move. Placing a piece involves specifying the piece index and the reference coordinates (x,y) where the piece's shape will be anchored, and such placement is legal only if it respects several constraints: all cells of the piece must lie within the valid board boundaries, none of the piece’s cells may collide with cells already occupied by that player's pieces, the placement must have at least one cell diagonally adjacent (corner touching) to any existing cell owned by the player, and crucially, no cell of the placed piece may be directly adjacent by side (side touching) to any cell owned by the player. When a move is made, the board state updates by marking the newly occupied cells with the player's color, and ownership records are updated to reflect that the placed piece is now used and no longer available for future placement by that player. The game automatically advances control to the opponent after a move is executed. If at the start of a player's turn they have no legal moves available, the game immediately terminates. The scoring system awards a victory score of 100 to the opponent of the player unable to move, while the player who cannot move receives a score of 0. Thus, the objective is to strategically place pieces to maintain the ability to move while preventing the opponent from doing so. The coordinate system, piece definitions, and adjacency rules collectively enforce spatial constraints that govern legal placements and interactions between pieces on the board throughout the game.",
    "output": "(role purple)\n(role orange)\n(init (cell 7 8 orange))\n(init (cell 8 7 purple))\n(init (control purple))\n(opponent orange purple)\n(opponent purple orange)\n(<= (next (control ?colorn))\n    (true (control ?colorp))\n    (opponent ?colorn ?colorp))\n(<= (init (owns ?color ?num))\n    (role ?color)\n    (pieceIndex ?num))\n(<= (hasLegalMove ?color)\n    (legal ?color ?move))\n(<= terminal\n    (true (control ?color))\n    (not (hasLegalMove ?color)))\n(<= (goal ?color 0)\n    (true (control ?color))\n    (not (hasLegalMove ?color)))\n(<= (goal ?colorx 100)\n    (opponent ?color ?colorx)\n    (true (control ?color))\n    (not (hasLegalMove ?color)))\n(<= (legal ?color noop)\n    (role ?color)\n    (not (true (control ?color))))\n(<= (next (cell ?x ?y ?color))\n    (true (cell ?x ?y ?color)))\n(<= (next (cell ?x ?y ?color))\n    (does ?color (place ?num ?rx ?ry))\n    (piece ?num ?dx ?dy)\n    (sum ?rx ?dx ?x)\n    (sum ?ry ?dy ?y))\n(<= (next (owns ?color ?num))\n    (true (owns ?color ?num))\n    (not (justUsedPiece ?color ?num)))\n(<= (justUsedPiece ?color ?num)\n    (board ?x)\n    (board ?y)\n    (does ?color (place ?num ?x ?y)))\n(<= (legal ?color (place ?num ?x ?y))\n    (true (control ?color))\n    (true (owns ?color ?num))\n    (board ?x)\n    (board ?y)\n    (not (collision ?num ?x ?y))\n    (not (offBoardX ?num ?x))\n    (not (offBoardY ?num ?y))\n    (cornerTouching ?num ?x ?y ?color)\n    (not (sideTouching ?num ?x ?y ?color)))\n(<= (collision ?num ?x ?y)\n    (piece ?num ?dx ?dy)\n    (sum ?x ?dx ?cx)\n    (sum ?y ?dy ?cy)\n    (role ?color)\n    (true (cell ?cx ?cy ?color)))\n(<= (offBoardX ?num ?x)\n    (board ?x)\n    (piece ?num ?dx ?dy)\n    (sum ?x ?dx ?cx)\n    (invalid ?cx))\n(<= (offBoardY ?num ?y)\n    (board ?y)\n    (piece ?num ?dx ?dy)\n    (sum ?y ?dy ?cy)\n    (invalid ?cy))\n(<= (cornerTouching ?num ?x ?y ?color)\n    (piece ?num ?dx ?dy)\n    (diagNeighbor ?qx ?qy)\n    (sum ?x ?dx ?zx)\n    (sum ?y ?dy ?zy)\n    (sum ?zx ?qx ?nx)\n    (sum ?zy ?qy ?ny)\n    (true (cell ?nx ?ny ?color)))\n(<= (sideTouching ?num ?x ?y ?color)\n    (piece ?num ?dx ?dy)\n    (sideNeighbor ?qx ?qy)\n    (sum ?x ?dx ?zx)\n    (sum ?y ?dy ?zy)\n    (sum ?zx ?qx ?nx)\n    (sum ?zy ?qy ?ny)\n    (true (cell ?nx ?ny ?color)))\n(diagNeighbor 1 1)\n(diagNeighbor 1 -1)\n(diagNeighbor -1 1)\n(diagNeighbor -1 -1)\n(sideNeighbor 0 1)\n(sideNeighbor 1 0)\n(sideNeighbor 0 -1)\n(sideNeighbor -1 0)\n(pieceIndex 1)\n(pieceIndex 2)\n(pieceIndex 3)\n(pieceIndex 4)\n(pieceIndex 5)\n(pieceIndex 6)\n(pieceIndex 7)\n(pieceIndex 8)\n(pieceIndex 9)\n(pieceIndex 10)\n(pieceIndex 11)\n(pieceIndex 12)\n(pieceIndex 13)\n(pieceIndex 14)\n(pieceIndex 15)\n(pieceIndex 16)\n(pieceIndex 17)\n(pieceIndex 18)\n(pieceIndex 19)\n(pieceIndex 20)\n(pieceIndex 21)\n(piece 1 0 0)\n(piece 1 0 1)\n(piece 1 1 0)\n(piece 1 1 1)\n(piece 2 0 1)\n(piece 2 1 1)\n(piece 2 2 1)\n(piece 2 2 0)\n(piece 3 0 0)\n(piece 3 1 0)\n(piece 3 1 1)\n(piece 3 1 2)\n(piece 3 1 3)\n(piece 4 0 0)\n(piece 5 0 0)\n(piece 5 0 1)\n(piece 6 1 0)\n(piece 6 1 1)\n(piece 6 0 1)\n(piece 7 0 0)\n(piece 7 1 0)\n(piece 7 2 0)\n(piece 8 0 0)\n(piece 8 0 1)\n(piece 8 0 2)\n(piece 8 1 1)\n(piece 9 0 0)\n(piece 9 0 1)\n(piece 9 0 2)\n(piece 9 0 3)\n(piece 10 0 0)\n(piece 10 1 0)\n(piece 10 1 1)\n(piece 10 2 1)\n(piece 11 0 0)\n(piece 11 0 1)\n(piece 11 0 2)\n(piece 11 1 1)\n(piece 11 2 1)\n(piece 12 0 0)\n(piece 12 0 1)\n(piece 12 0 2)\n(piece 12 1 0)\n(piece 12 2 0)\n(piece 13 0 0)\n(piece 13 0 1)\n(piece 13 1 1)\n(piece 13 1 2)\n(piece 13 2 2)\n(piece 14 2 0)\n(piece 14 2 1)\n(piece 14 1 1)\n(piece 14 0 1)\n(piece 14 0 2)\n(piece 15 0 0)\n(piece 15 1 0)\n(piece 15 2 0)\n(piece 15 3 0)\n(piece 15 4 0)\n(piece 16 0 1)\n(piece 16 1 0)\n(piece 16 1 1)\n(piece 16 0 2)\n(piece 16 1 2)\n(piece 17 0 0)\n(piece 17 1 0)\n(piece 17 1 1)\n(piece 17 2 1)\n(piece 17 3 1)\n(piece 18 0 0)\n(piece 18 1 1)\n(piece 18 0 2)\n(piece 18 1 0)\n(piece 18 1 2)\n(piece 19 0 1)\n(piece 19 1 0)\n(piece 19 1 1)\n(piece 19 2 1)\n(piece 19 0 2)\n(piece 20 0 1)\n(piece 20 1 0)\n(piece 20 1 1)\n(piece 20 1 2)\n(piece 20 2 1)\n(piece 21 0 0)\n(piece 21 1 0)\n(piece 21 2 0)\n(piece 21 3 0)\n(piece 21 1 1)\n(board 1)\n(board 2)\n(board 3)\n(board 4)\n(board 5)\n(board 6)\n(board 7)\n(board 8)\n(board 9)\n(board 10)\n(board 11)\n(board 12)\n(board 13)\n(board 14)\n(invalid 15)\n(invalid 16)\n(invalid 17)\n(invalid 18)\n(invalid 19)\n(invalid 20)\n(<= (sum ?x 0 ?x) (board ?x))\n(<= (sum ?x 1 ?z)\n    (succ ?x ?z))\n(<= (sum ?x 2 ?z)\n    (succ ?x ?y)\n    (succ ?y ?z))\n(<= (sum ?x 3 ?z)\n    (succ ?x ?a)\n    (succ ?a ?b)\n    (succ ?b ?z))\n(<= (sum ?x 4 ?z)\n    (succ ?x ?a)\n    (succ ?a ?b)\n    (succ ?b ?c)\n    (succ ?c ?z))\n(<= (sum ?z -1 ?x)\n    (succ ?x ?z))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a board consisting of a set of uniquely indexed cells arranged in a specific pattern defined by indices a1 through i1, forming rows of varying lengths and a coordinate system based on these indices. There are three players with roles named red, green, and blue, who take turns in a fixed cyclic order: red moves first, then green, followed by blue, and then back to red. The initial state places red's pieces in cells a1, b1, and b2; blue's pieces in f1, g1, and g2; and green's pieces in f6, g6, and g7, with red having initial control of the turn and the step counter set to 1. Each turn, the player in control may make a move action or perform a no-operation (noop). A move action consists of specifying a source cell occupied by one of the player's pieces and a destination cell to move into, formatted as move b e, where b and e are cell indices. Moves are legal only if the player currently has control and the move satisfies specific movement rules based on a complex adjacency structure defined by \"car\" and \"cdr\" relations for each player, which describe allowable paths on the board. These relations encode connections between cells in terms of directional edges, and legal moves require that the source cell is occupied by the player's piece, and the destination cell is empty, following a path of occupied and empty intermediate cells according to the move patterns defined, including straight and jump moves over occupied cells. The player may also choose noop at any time, which is always legal and results in no change of piece positions. When a move is executed, the piece moves from the source cell to the destination cell, and the source cell becomes empty in the next state, while any other cells not affected by the move retain their current occupancy. Control passes automatically to the next player in the sequence after each turn, and the step count increments by one. The game's spatial constraints include that pieces must remain within the defined board cells, cannot move into occupied cells, and must follow the complex adjacency and movement rules specific to each player’s movement graph. The game ends either when the step count reaches 60 or when any player achieves a scoring condition of 100 stones. Scoring is calculated based on particular triads of cells assigned to each player: for red, the cells h1, h2, and i1; for green, c1, c2, and d1; and for blue, c6, c7, and d6. Each player’s score depends on the occupancy of their three associated cells, with full control of all three cells awarding 100 points, two occupied cells granting 50 points, one occupied cell giving 25 points, and none yielding zero. The game terminates immediately if any player reaches the maximum score of 100 stones, declaring that player the winner, or after 60 steps if no player has achieved this, concluding the game.",
    "output": "(role red)\n(role green)\n(role blue)\n(index a1)\n(index b1) (index b2)\n(index c1) (index c2) (index c3) (index c4) (index c5) (index c6) (index c7)\n(index d1) (index d2) (index d3) (index d4) (index d5) (index d6)\n(index e1) (index e2) (index e3) (index e4) (index e5)\n(index f1) (index f2) (index f3) (index f4) (index f5) (index f6)\n(index g1) (index g2) (index g3) (index g4) (index g5) (index g6) (index g7)\n(index h1) (index h2)\n(index i1)\n(init (cell a1 red))\n(init (cell b1 red))\n(init (cell b2 red))\n(init (cell f1 blue))\n(init (cell f6 green))\n(init (cell g1 blue))\n(init (cell g2 blue))\n(init (cell g6 green))\n(init (cell g7 green))\n(init (control red))\n(init (step 1))\n(<= (next (cell ?e ?player))\n    (does ?player (move ?b ?e)))\n(<= (next (cell ?x ?z))\n    (true (cell ?x ?z))\n    (not (affected ?x)))\n(<= (affected ?x)\n    (does ?player (move ?x ?z)))\n(<= (next (control green))\n    (true (control red)))\n(<= (next (control blue))\n    (true (control green)))\n(<= (next (control red))\n    (true (control blue)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (succ ?x ?y))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(<= (legal ?player (move ?b ?e))\n    (true (control ?player))\n    (movable ?player ?b ?e))\n(<= (legal ?player noop)\n    (role ?player))\n(<= (occupied ?c)\n    (true (cell ?c ?p)))\n(<= (empty ?c)\n    (index ?c)\n    (not (occupied ?c)))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?e)\n    (empty ?e))\n(<= (car red ?b ?e)\n    (carred ?b ?e))\n(<= (car green ?b ?e)\n    (carmagenta ?e ?b))\n(<= (car blue ?b ?e)\n    (caryellow ?e ?b))\n(<= (cdr red ?b ?e)\n    (cdrred ?b ?e))\n(<= (cdr green ?b ?e)\n    (cdrmagenta ?e ?b))\n(<= (cdr blue ?b ?e)\n    (cdryellow ?e ?b))\n(carmagenta c1 d1)\n(carmagenta d1 e1)\n(carmagenta c2 d2)\n(carmagenta e1 f2)\n(carmagenta d2 e2)\n(carmagenta c3 d3)\n(carmagenta f2 g3)\n(carmagenta e2 f3)\n(carmagenta d3 e3)\n(carmagenta c4 d4)\n(carmagenta f3 g4)\n(carmagenta e3 f4)\n(carmagenta d4 e4)\n(carmagenta c5 d5)\n(carmagenta f4 g5)\n(carmagenta e4 f5)\n(carmagenta d5 e5)\n(carmagenta f5 g6)\n(carmagenta e5 f6)\n(carmagenta f6 g7)\n(cdrmagenta c1 c2)\n(cdrmagenta d1 d2)\n(cdrmagenta c2 c3)\n(cdrmagenta e1 e2)\n(cdrmagenta d2 d3)\n(cdrmagenta c3 c4)\n(cdrmagenta f2 f3)\n(cdrmagenta e2 e3)\n(cdrmagenta d3 d4)\n(cdrmagenta c4 c5)\n(cdrmagenta g3 g4)\n(cdrmagenta f3 f4)\n(cdrmagenta e3 e4)\n(cdrmagenta d4 d5)\n(cdrmagenta g4 g5)\n(cdrmagenta f4 f5)\n(cdrmagenta e4 e5)\n(cdrmagenta g5 g6)\n(cdrmagenta f5 f6)\n(cdrmagenta g6 g7)\n(carred a1 b1)\n(carred b1 c3)\n(carred b2 c4)\n(carred c3 d2)\n(carred c4 d3)\n(carred c5 d4)\n(carred d2 e1)\n(carred d3 e2)\n(carred d4 e3)\n(carred d5 e4)\n(carred e2 f2)\n(carred e3 f3)\n(carred e4 f4)\n(carred e5 f5)\n(carred f3 g3)\n(carred f4 g4)\n(carred f5 g5)\n(carred g4 h1)\n(carred g5 h2)\n(carred h2 i1)\n(cdrred a1 b2)\n(cdrred b1 c4)\n(cdrred b2 c5)\n(cdrred c3 d3)\n(cdrred c4 d4)\n(cdrred c5 d5)\n(cdrred d2 e2)\n(cdrred d3 e3)\n(cdrred d4 e4)\n(cdrred d5 e5)\n(cdrred e1 f2)\n(cdrred e2 f3)\n(cdrred e3 f4)\n(cdrred e4 f5)\n(cdrred f2 g3)\n(cdrred f3 g4)\n(cdrred f4 g5)\n(cdrred g3 h1)\n(cdrred g4 h2)\n(cdrred h1 i1)\n(caryellow c7 c6)\n(caryellow c6 c5)\n(caryellow d6 d5)\n(caryellow c5 c4)\n(caryellow d5 d4)\n(caryellow e5 e4)\n(caryellow c4 c3)\n(caryellow d4 d3)\n(caryellow e4 e3)\n(caryellow f5 f4)\n(caryellow g5 g4)\n(caryellow d3 d2)\n(caryellow e3 e2)\n(caryellow f4 f3)\n(caryellow e2 e1)\n(caryellow f3 f2)\n(caryellow g4 g3)\n(caryellow f2 f1)\n(caryellow g3 g2)\n(caryellow g2 g1)\n(cdryellow c7 d6)\n(cdryellow c6 d5)\n(cdryellow d6 e5)\n(cdryellow c5 d4)\n(cdryellow d5 e4)\n(cdryellow e5 f5)\n(cdryellow c4 d3)\n(cdryellow d4 e3)\n(cdryellow e4 f4)\n(cdryellow f5 g5)\n(cdryellow c3 d2)\n(cdryellow d3 e2)\n(cdryellow e3 f3)\n(cdryellow f4 g4)\n(cdryellow d2 e1)\n(cdryellow e2 f2)\n(cdryellow f3 g3)\n(cdryellow e1 f1)\n(cdryellow f2 g2)\n(cdryellow f1 g1)\n(<= (goal ?player ?payoff)\n    (stones ?player ?payoff))\n(toCount red h1 h2 i1)\n(toCount green c1 c2 d1)\n(toCount blue c6 c7 d6)\n(<= (stones ?player 100)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 0)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= terminal\n    (true (step 60)))\n(<= terminal\n    (stones ?player 100))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 4-by-4 grid with rows and columns numbered from 1 to 4, where each cell can hold either a blank or a number from 1 to 4. There is a single player role called \"robot,\" who takes turns alone. The initial state has certain cells blank and one cell at position (2,2) containing the number 2, while all other cells start blank. On each turn, the robot may perform an action consisting of placing a number n into a blank cell at coordinates (row, col), or alternatively choose to quit. The action \"place row col n\" is legal only if the targeted cell is currently blank and placing the number n there does not violate any illegal conditions. Illegal conditions arise if the same number n already exists in the same row or column, or if any specified \"greater than\" constraints between cells are violated; these constraints impose that one cell's number must be greater than another's, both horizontally and vertically, as defined initially. If the robot chooses to place a number, the state updates by filling that cell with the number, while all other cells remain the same; if the robot quits, the state transitions to a finished condition. The game automatically detects terminal states either when the board is completely filled with no blank cells remaining or when the finished condition is reached by quitting. The robot's turn sequence is controlled solely by its own actions, with no other players or phases. The scoring is binary: the robot scores 100 if the board is completely filled without blanks, indicating successful placement without illegalities, or 0 if there are any blanks remaining at the end. The coordinate system implicitly constrains moves to the 4x4 grid, and occupancy constraints prevent placing numbers in non-blank cells. The robot's goal is to fill the board respecting the uniqueness of numbers per row and column and the given inequalities between specific cells, achieving a fully filled grid or choosing to quit to end the game.",
    "output": "(role robot)\n(init (cell 1 1 blank))\n(init (cell 1 2 blank))\n(init (cell 1 3 blank))\n(init (cell 1 4 blank))\n(init (cell 2 1 blank))\n(init (cell 2 2 2))\n(init (cell 2 3 blank))\n(init (cell 2 4 blank))\n(init (cell 3 1 blank))\n(init (cell 3 2 blank))\n(init (cell 3 3 blank))\n(init (cell 3 4 blank))\n(init (cell 4 1 blank))\n(init (cell 4 2 blank))\n(init (cell 4 3 blank))\n(init (cell 4 4 blank))\n(<= (legal robot (place ?row ?col ?n))\n    (true (cell ?row ?col blank))\n    (number ?n)\n    (not (illegal ?row ?col ?n)))\n(<= (illegal ?row ?col ?n)\n    (number ?row)\n    (true (cell ?row2 ?col ?n)))\n(<= (illegal ?row ?col ?n)\n    (number ?col)\n    (true (cell ?row ?col2 ?n)))\n(<= (illegal ?row ?col ?n)\n    (gt_constraint ?row ?col ?row2 ?col2)\n    (true (cell ?row2 ?col2 ?n2))\n    (gt ?n2 ?n))\n(<= (illegal ?row ?col ?n)\n    (gt_constraint ?row2 ?col2 ?row ?col)\n    (true (cell ?row2 ?col2 ?n2))\n    (gt ?n ?n2))\n(legal robot quit)\n(<= (next (cell ?row ?col ?n))\n    (true (cell ?row ?col ?n))\n    (number ?n))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot (place ?row2 ?col2 ?n))\n    (distinct ?row ?row2))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot (place ?row2 ?col2 ?n))\n    (distinct ?col ?col2))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot quit))\n(<= (next (cell ?row ?col ?n))\n    (does robot (place ?row ?col ?n)))\n(<= (next finished)\n    (does robot quit))\n(<= terminal\n    filled)\n(<= filled\n    (not anyblank))\n(<= anyblank\n    (true (cell ?row ?col blank)))\n(<= terminal\n    (true finished))\n(<= (goal robot 0)\n    (true (cell ?row ?col blank)))\n(<= (goal robot 100)\n    (not (goal robot 0)))\n(<= (number ?n)\n    (succ ?n ?m))\n(<= (number ?m)\n    (succ ?n ?m))\n(<= (gt ?n1 ?n2)\n    (succ ?n2 ?n1))\n(<= (gt ?n1 ?n3)\n    (succ ?n2 ?n1)\n    (gt ?n2 ?n3))\n(<= (init (cell_gt_right ?row ?col1))\n    (succ ?col1 ?col2)\n    (gt_constraint ?row ?col1 ?row ?col2))\n(<= (init (cell_lt_right ?row ?col1))\n    (succ ?col1 ?col2)\n    (gt_constraint ?row ?col2 ?row ?col1))\n(<= (init (cell_gt_below ?row1 ?col))\n    (succ ?row1 ?row2)\n    (gt_constraint ?row1 ?col ?row2 ?col))\n(<= (init (cell_lt_below ?row1 ?col))\n    (succ ?row1 ?row2)\n    (gt_constraint ?row2 ?col ?row1 ?col))\n(<= (next (cell_gt_right ?row ?col))\n    (true (cell_gt_right ?row ?col)))\n(<= (next (cell_lt_right ?row ?col))\n    (true (cell_lt_right ?row ?col)))\n(<= (next (cell_gt_below ?row ?col))\n    (true (cell_gt_below ?row ?col)))\n(<= (next (cell_lt_below ?row ?col))\n    (true (cell_lt_below ?row ?col)))\n(succ  1  2)\n(succ  2  3)\n(succ  3  4)\n(gt_constraint 1 2 1 1)\n(gt_constraint 1 3 1 2)\n(gt_constraint 3 4 2 4)\n(gt_constraint 4 3 4 2)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a grid defined by columns labeled from 'a' through 'i' and rows numbered from 1 to 9, creating a coordinate system where each cell is identified by a column and a row. Two players participate, designated as white and black, who alternate turns with white taking the first move. Initially, all cells are empty except for two pawns: the white pawn is positioned at column 'a' row 5, and the black pawn at column 'i' row 5. The game state also includes walls placed between cells along vertical boundaries between adjacent columns and rows; initially, all walls are set to 'none', indicating no obstacles, and each player starts with four walls they can place during the game. On a player's turn, they may either move their pawn or place a wall, or choose to do nothing by issuing a noop action. The noop is always a legal action and results in no changes to the board state except passing the turn to the opponent. A move action involves moving the player's pawn from its current cell to an adjacent cell either vertically or horizontally, subject to movement rules: the destination cell must be empty, and there must be no walls blocking the path between the source and destination cells. Specifically, pawns can move only along adjacent cells in the same column or between adjacent columns if the walls between them are absent. The place action allows a player to place a wall on a segment between two adjacent rows along a boundary between two adjacent columns, reducing their remaining walls by one; however, walls can only be placed where no wall currently exists and must be placed on two consecutive row boundaries simultaneously, ensuring that the wall occupies a valid continuous portion of the board. After any action, the game state updates accordingly: pawn positions change with moves, walls update with placements, and control switches to the other player. The game implicitly enforces boundaries of the board so that pawns and walls cannot be placed outside the defined 9-row by 9-column grid, and no two pawns may occupy the same cell. The game proceeds up to a maximum of 30 steps; reaching this step count ends the game in a draw with equal scoring unless a player achieves the victory condition first. Victory is achieved if the white pawn reaches any cell in the rightmost column 'i' or if the black pawn reaches any cell in the leftmost column 'a'. Upon such a condition, the player who reached the opposing side wins with a score of 100, while the opponent scores 0. If neither player reaches the opposite side by step 31, the game terminates with both players scoring 50, representing a draw. Thus, the game combines strategic pawn movement and wall placement on a grid with alternating turns, bounded movement constrained by walls, and a race to reach the opponent’s starting side within a fixed number of turns.",
    "output": "(role white)\n(role black)\n(init (cell a 1 b))\n(init (cell a 2 b))\n(init (cell a 3 b))\n(init (cell a 4 b))\n(init (cell a 5 wp))\n(init (cell a 6 b))\n(init (cell a 7 b))\n(init (cell a 8 b))\n(init (cell a 9 b))\n(init (cell b 1 b))\n(init (cell b 2 b))\n(init (cell b 3 b))\n(init (cell b 4 b))\n(init (cell b 5 b))\n(init (cell b 6 b))\n(init (cell b 7 b))\n(init (cell b 8 b))\n(init (cell b 9 b))\n(init (cell c 1 b))\n(init (cell c 2 b))\n(init (cell c 3 b))\n(init (cell c 4 b))\n(init (cell c 5 b))\n(init (cell c 6 b))\n(init (cell c 7 b))\n(init (cell c 8 b))\n(init (cell c 9 b))\n(init (cell d 1 b))\n(init (cell d 2 b))\n(init (cell d 3 b))\n(init (cell d 4 b))\n(init (cell d 5 b))\n(init (cell d 6 b))\n(init (cell d 7 b))\n(init (cell d 8 b))\n(init (cell d 9 b))\n(init (cell e 1 b))\n(init (cell e 2 b))\n(init (cell e 3 b))\n(init (cell e 4 b))\n(init (cell e 5 b))\n(init (cell e 6 b))\n(init (cell e 7 b))\n(init (cell e 8 b))\n(init (cell e 9 b))\n(init (cell f 1 b))\n(init (cell f 2 b))\n(init (cell f 3 b))\n(init (cell f 4 b))\n(init (cell f 5 b))\n(init (cell f 6 b))\n(init (cell f 7 b))\n(init (cell f 8 b))\n(init (cell f 9 b))\n(init (cell g 1 b))\n(init (cell g 2 b))\n(init (cell g 3 b))\n(init (cell g 4 b))\n(init (cell g 5 b))\n(init (cell g 6 b))\n(init (cell g 7 b))\n(init (cell g 8 b))\n(init (cell g 9 b))\n(init (cell h 1 b))\n(init (cell h 2 b))\n(init (cell h 3 b))\n(init (cell h 4 b))\n(init (cell h 5 b))\n(init (cell h 6 b))\n(init (cell h 7 b))\n(init (cell h 8 b))\n(init (cell h 9 b))\n(init (cell i 1 b))\n(init (cell i 2 b))\n(init (cell i 3 b))\n(init (cell i 4 b))\n(init (cell i 5 bp))\n(init (cell i 6 b))\n(init (cell i 7 b))\n(init (cell i 8 b))\n(init (cell i 9 b))\n(init (wall a b 1 2 none))\n(init (wall a b 2 3 none))\n(init (wall a b 3 4 none))\n(init (wall a b 4 5 none))\n(init (wall a b 5 6 none))\n(init (wall a b 6 7 none))\n(init (wall a b 7 8 none))\n(init (wall a b 8 9 none))\n(init (wall b c 1 2 none))\n(init (wall b c 2 3 none))\n(init (wall b c 3 4 none))\n(init (wall b c 4 5 none))\n(init (wall b c 5 6 none))\n(init (wall b c 6 7 none))\n(init (wall b c 7 8 none))\n(init (wall b c 8 9 none))\n(init (wall c d 1 2 none))\n(init (wall c d 2 3 none))\n(init (wall c d 3 4 none))\n(init (wall c d 4 5 none))\n(init (wall c d 5 6 none))\n(init (wall c d 6 7 none))\n(init (wall c d 7 8 none))\n(init (wall c d 8 9 none))\n(init (wall d e 1 2 none))\n(init (wall d e 2 3 none))\n(init (wall d e 3 4 none))\n(init (wall d e 4 5 none))\n(init (wall d e 5 6 none))\n(init (wall d e 6 7 none))\n(init (wall d e 7 8 none))\n(init (wall d e 8 9 none))\n(init (wall e f 1 2 none))\n(init (wall e f 2 3 none))\n(init (wall e f 3 4 none))\n(init (wall e f 4 5 none))\n(init (wall e f 5 6 none))\n(init (wall e f 6 7 none))\n(init (wall e f 7 8 none))\n(init (wall e f 8 9 none))\n(init (wall f g 1 2 none))\n(init (wall f g 2 3 none))\n(init (wall f g 3 4 none))\n(init (wall f g 4 5 none))\n(init (wall f g 5 6 none))\n(init (wall f g 6 7 none))\n(init (wall f g 7 8 none))\n(init (wall f g 8 9 none))\n(init (wall g h 1 2 none))\n(init (wall g h 2 3 none))\n(init (wall g h 3 4 none))\n(init (wall g h 4 5 none))\n(init (wall g h 5 6 none))\n(init (wall g h 6 7 none))\n(init (wall g h 7 8 none))\n(init (wall g h 8 9 none))\n(init (wall h i 1 2 none))\n(init (wall h i 2 3 none))\n(init (wall h i 3 4 none))\n(init (wall h i 4 5 none))\n(init (wall h i 5 6 none))\n(init (wall h i 6 7 none))\n(init (wall h i 7 8 none))\n(init (wall h i 8 9 none))\n(init (walls white 4))\n(init (walls black 4))\n(init (control white))\n(init (step 1))\n(<= (next (cell ?x ?y ?q))\n(true (cell ?x ?y ?q))\n(does ?player (place ?x1 ?x2 ?y1 ?y2)))\n(<= (next (cell ?x ?y ?q))\n(true (cell ?x ?y ?q))\n(true (control ?player))\n(does ?player noop))\n(<= (next (cell ?x ?y ?p))\n(does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?u ?v b))\n(does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?w ?z b))\n(does ?player (move ?p ?u ?v ?x ?y))\n(true (cell ?w ?z b))\n(or (distinct ?w ?x) (distinct ?z ?y)))\n(<= (next (cell ?w ?z ?q))\n(does ?player (move ?p ?u ?v ?x ?y))\n(true (cell ?w ?z ?q))\n(distinct ?p ?q)\n(distinct ?q b))\n(<= (next (wall ?x1 ?x2 ?y1 ?y2 ?value))\n(true (wall ?x1 ?x2 ?y1 ?y2 ?value))\n(true (control ?player))\n(does ?player noop))\n(<= (next (wall ?x1 ?x2 ?y1 ?y2 ?z))\n(does ?player (move ?p ?u ?v ?x ?y))\n(true (wall ?x1 ?x2 ?y1 ?y2 ?z)))\n(<= (next (wall ?x1 ?x2 ?y1 ?y2 ?wall))\n(does ?player (place ?u ?v ?x ?y))\n(true (wall ?x1 ?x2 ?y1 ?y2 ?wall))\n(distinct ?wall none))\n(<= (next (wall ?x1 ?x2 ?y1 ?y2 none))\n(does ?player (place ?u ?v ?x ?y))\n(true (wall ?x1 ?x2 ?y1 ?y2 none))\n(or (distinct ?x1 ?u) (distinct ?x2 ?v) (distinct ?y1 ?x) (distinct ?y2 ?y)))\n(<= (next (wall ?x1 ?x2 ?y1 ?y2 ?player))\n(does ?player (place ?x1 ?x2 ?y1 ?y2))\n(true (wall ?x1 ?x2 ?y1 ?y2 none)))\n(<= (next (control white))\n(true (control black)))\n(<= (next (control black))\n(true (control white)))\n(<= (next (walls ?player ?num))\n(does ?p1 (move ?p ?x ?y ?u ?v))\n(true (walls ?player ?num)))\n(<= (next (walls ?player ?num))\n(does ?p1 (place ?x1 ?x2 ?y1 ?y2))\n(true (walls ?player ?num))\n(distinct ?player ?p1))\n(<= (next (walls ?player ?n))\n(does ?player (place ?x1 ?x2 ?y1 ?y2))\n(true (walls ?player ?m))\n(succ ?n ?m))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(<= (greater ?a ?b)\n(succ ?b ?a))\n(<= (greater ?a ?b)\n(distinct ?a ?b)\n(succ ?c ?a)\n(greater ?c ?b))\n(coordinate 1)\n(coordinate 2)\n(coordinate 3)\n(coordinate 4)\n(coordinate 5)\n(coordinate 6)\n(coordinate 7)\n(coordinate 8)\n(coordinate 9)\n(coordinate a)\n(coordinate b)\n(coordinate c)\n(coordinate d)\n(coordinate e)\n(coordinate f)\n(coordinate g)\n(coordinate h)\n(coordinate i)\n(<= (legal ?player (place ?c1 ?c2 1 2))\n(true (control ?player))\n(true (walls ?player ?n))\n(greater ?n 0)\n(true (wall ?c1 ?c2 1 2 none))\n(true (wall ?c1 ?c2 2 3 none)))\n(<= (legal ?player (place ?c1 ?c2 8 9))\n(true (control ?player))\n(true (walls ?player ?n))\n(greater ?n 0)\n(true (wall ?c1 ?c2 8 9 none))\n(true (wall ?c1 ?c2 7 8 none)))\n(<= (legal ?player (place ?c1 ?c2 ?r1 ?r2))\n(true (control ?player))\n(true (walls ?player ?n))\n(greater ?n 0)\n(true (wall ?c1 ?c2 ?r1 ?r2 none))\n(adjacent ?r2 ?r3)\n(true (wall ?c1 ?c2 ?r2 ?r3 none))\n(adjacent ?r0 ?r1)\n(true (wall ?c1 ?c2 ?r2 ?r3 none)))\n(<= (legal white (move wp ?u ?v ?x ?y))\n(true (control white))\n(true (cell ?u ?v wp))\n(pawnmove ?u ?v ?x ?y)\n(true (cell ?x ?y b)))\n(<= (legal black (move bp ?u ?v ?x ?y))\n(true (control black))\n(true (cell ?u ?v bp))\n(pawnmove ?u ?v ?x ?y)\n(true (cell ?x ?y b)))\n(<= (legal ?player noop)\n(role ?player))\n(<= (pawnmove ?c ?r1 ?c ?r2)\n(adjacent ?r1 ?r2)\n(coordinate ?c))\n(<= (pawnmove ?c ?r1 ?c ?r2)\n(adjacent ?r2 ?r1)\n(coordinate ?c))\n(<= (pawnmove ?c1 1 ?c2 1)\n(nextcolumn ?c1 ?c2)\n(true (wall ?c1 ?c2 1 2 none)))\n(<= (pawnmove ?c1 1 ?c2 1)\n(nextcolumn ?c2 ?c1)\n(true (wall ?c2 ?c1 1 2 none)))\n(<= (pawnmove ?c1 9 ?c2 9)\n(nextcolumn ?c1 ?c2)\n(true (wall ?c1 ?c2 8 9 none)))\n(<= (pawnmove ?c1 9 ?c2 9)\n(nextcolumn ?c2 ?c1)\n(true (wall ?c2 ?c1 8 9 none)))\n(<= (pawnmove ?c1 ?r ?c2 ?r)\n(nextcolumn ?c1 ?c2)\n(adjacent ?r ?rn)\n(adjacent ?rp ?r)\n(true (wall ?c1 ?c2 ?r ?rn none))\n(true (wall ?c1 ?c2 ?rp ?r none)))\n(<= (pawnmove ?c1 ?r ?c2 ?r)\n(nextcolumn ?c2 ?c1)\n(adjacent ?r ?rn)\n(adjacent ?rp ?r)\n(true (wall ?c2 ?c1 ?r ?rn none))\n(true (wall ?c2 ?c1 ?rp ?r none)))\n(adjacent 1 2)\n(adjacent 2 3)\n(adjacent 3 4)\n(adjacent 4 5)\n(adjacent 5 6)\n(adjacent 6 7)\n(adjacent 7 8)\n(adjacent 8 9)\n(nextcolumn a b)\n(nextcolumn b c)\n(nextcolumn c d)\n(nextcolumn d e)\n(nextcolumn e f)\n(nextcolumn f g)\n(nextcolumn g h)\n(nextcolumn h i)\n(<= (goal white 100)\n(true (cell i ?x wp)))\n(<= (goal white 0)\n(true (cell a ?x bp)))\n(<= (goal black 100)\n(true (cell a ?x bp)))\n(<= (goal black 0)\n(true (cell i ?x wp)))\n(<= (goal ?role 50)\n(true (step 31))\n(true (cell ?c1 ?r1 bp))\n(true (cell ?c2 ?r2 wp))\n(distinct ?c1 a)\n(distinct ?c2 i)\n(role ?role))\n(<= terminal\n(true (step 31)))\n(<= terminal\n(goal ?role 100))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a 5-by-5 grid with coordinates defined by integers from 1 to 5 along both rows and columns, where each cell can be referenced by a column-row pair within this bounded index range. There is a single player role called \"robot,\" who takes all turns sequentially. Initially, no cells on the board are marked. On each turn, the robot may choose to mark exactly one unmarked cell by specifying its column and row coordinates, with the action represented as (mark ?col ?row). This marking action is legal only if the chosen coordinates are within the grid boundaries and the cell is currently unmarked. If no legal markings are available or desired, the robot may effectively perform a no-operation by not marking any cell. Each action updates the game state by marking the chosen cell while preserving all previously marked cells. The game enforces implicit constraints such that marked groups of contiguous cells in any row or column must correspond to predefined group sizes specified for that row or column; these groups are sequences of marked cells separated by unmarked cells or board edges. The game automatically computes and tracks these contiguous marked groups along rows and columns, ensuring that the number and size of these groups match the allowed patterns. The game terminates when either a row or column has a marked group exceeding the allowed size or when the count of marked groups in a row or column differs from the expected group count, or when all rows and columns satisfy their group size and count constraints perfectly. Victory is achieved if, upon termination, none of the rows or columns violate these group size or count conditions, awarding the robot a score of 100; otherwise, the score is zero. Thus, the robot must mark cells to form continuous groups that comply precisely with the given row and column group specifications, avoiding marking patterns that create groups too large or too few or too many groups than allowed, within the fixed 5x5 grid environment.",
    "output": "(role robot)\n(row 1 1 3)\n(row 2 1 1)\n(row 3 1 1) (row 3 2 3)\n(row 4 1 1) (row 4 2 1)\n(row 5 1 3)\n(col 1 1 3)\n(col 2 1 1) (col 2 2 1)\n(col 3 1 1) (col 3 2 1) (col 3 3 1)\n(col 4 1 1) (col 4 2 1) (col 4 3 1)\n(col 5 1 2)\n(<= (legal robot (mark ?col ?row))\n    (index ?col)\n    (index ?row)\n    (not (true (marked ?col ?row))))\n(<= (next (marked ?col ?row))\n    (does robot (mark ?col ?row)))\n(<= (next (marked ?col ?row))\n    (true (marked ?col ?row)))\n(<= (curRow ?row 0 1 0)\n    (index ?row))\n(<= (curRow ?row ?next ?group 0)\n    (succ ?cur ?next)\n    (not (true (marked ?next ?row)))\n    (curRow ?row ?cur ?group 0))\n(<= (curRow ?row ?next ?nextGroup 0)\n    (succ ?cur ?next)\n    (not (true (marked ?next ?row)))\n    (succ ?group ?nextGroup)\n    (curRow ?row ?cur ?group ?count)\n    (index ?count))\n(<= (curRow ?row ?next ?group ?countp1)\n    (succ ?cur ?next)\n    (true (marked ?next ?row))\n    (succ ?count ?countp1)\n    (curRow ?row ?cur ?group ?count))\n(<= (rowGroupCount ?row ?group ?count)\n    (curRow ?row ?cur ?group ?count)\n    (distinct ?count 0)\n    (succ ?cur ?next)\n    (not (true (marked ?next ?row))))\n(<= (curCol ?col 0 1 0)\n    (index ?col))\n(<= (curCol ?col ?next ?group 0)\n    (succ ?cur ?next)\n    (not (true (marked ?col ?next)))\n    (curCol ?col ?cur ?group 0))\n(<= (curCol ?col ?next ?nextGroup 0)\n    (succ ?cur ?next)\n    (not (true (marked ?col ?next)))\n    (succ ?group ?nextGroup)\n    (curCol ?col ?cur ?group ?count)\n    (index ?count))\n(<= (curCol ?col ?next ?group ?countp1)\n    (succ ?cur ?next)\n    (true (marked ?col ?next))\n    (succ ?count ?countp1)\n    (curCol ?col ?cur ?group ?count))\n(<= (colGroupCount ?col ?group ?count)\n    (curCol ?col ?cur ?group ?count)\n    (distinct ?count 0)\n    (succ ?cur ?next)\n    (not (true (marked ?col ?next))))\n(<= (rowAtLeastSize ?row ?size)\n    (someSizeInRow ?row ?startingPoint ?foundSize)\n    (lte ?size ?foundSize))\n(<= (someSizeInRow ?row 0 0)\n    (index ?row))\n(<= (someSizeInRow ?row ?xp1 0)\n    (index ?row)\n    (index ?xp1)\n    (not (true (marked ?xp1 ?row))))\n(<= (someSizeInRow ?row ?xp1 ?np1)\n    (true (marked ?xp1 ?row))\n    (succ ?x ?xp1)\n    (succ ?n ?np1)\n    (someSizeInRow ?row ?x ?n))\n(<= (colAtLeastSize ?col ?size)\n    (someSizeInCol ?col ?startingPoint ?foundSize)\n    (lte ?size ?foundSize))\n(<= (someSizeInCol ?col 0 0)\n    (index ?col))\n(<= (someSizeInCol ?col ?yp1 0)\n    (index ?col)\n    (index ?yp1)\n    (not (true (marked ?col ?yp1))))\n(<= (someSizeInCol ?col ?yp1 ?np1)\n    (true (marked ?col ?yp1))\n    (succ ?y ?yp1)\n    (succ ?n ?np1)\n    (someSizeInCol ?col ?y ?n))\n(<= (allowedSizeInRow ?row ?size)\n    (row ?row ?anyGroup ?size))\n(<= (allowedSizeInRow ?row ?size)\n    (row ?row ?anyGroup ?largerSize)\n    (lessThan ?size ?largerSize))\n(<= (allowedSizeInCol ?col ?size)\n    (col ?col ?anyGroup ?size))\n(<= (allowedSizeInCol ?col ?size)\n    (col ?col ?anyGroup ?largerSize)\n    (lessThan ?size ?largerSize))\n(<= (tooBigSizeForRow ?row ?size)\n    (allowedSizeInRow ?row ?smaller)\n    (succ ?smaller ?size)\n    (not (allowedSizeInRow ?row ?size)))\n(<= (tooBigSizeForCol ?col ?size)\n    (allowedSizeInCol ?col ?smaller)\n    (succ ?smaller ?size)\n    (not (allowedSizeInCol ?col ?size)))\n(<= (curGroupsInRow ?row ?groupCount)\n    (highestIndex ?end)\n    (curGroupsInRowPartial ?row ?end ?groupCount))\n(<= (curGroupsInRowPartial ?row 0 0)\n    (index ?row))\n(<= (curGroupsInRowPartial ?row ?xp1 ?n)\n    (succ ?x ?xp1)\n    (curGroupsInRowPartial ?row ?x ?n)\n    (or (true (marked ?x ?row))\n        (not (true (marked ?xp1 ?row)))))\n(<= (curGroupsInRowPartial ?row ?xp1 ?np1)\n    (succ ?x ?xp1)\n    (curGroupsInRowPartial ?row ?x ?n)\n    (succ ?n ?np1)\n    (not (true (marked ?x ?row)))\n    (true (marked ?xp1 ?row)))\n(<= (curGroupsInCol ?col ?groupCount)\n    (highestIndex ?end)\n    (curGroupsInColPartial ?col ?end ?groupCount))\n(<= (curGroupsInColPartial ?col 0 0)\n    (index ?col))\n(<= (curGroupsInColPartial ?col ?yp1 ?n)\n    (succ ?y ?yp1)\n    (curGroupsInColPartial ?col ?y ?n)\n    (or (true (marked ?col ?y))\n        (not (true (marked ?col ?yp1)))))\n(<= (curGroupsInColPartial ?col ?yp1 ?np1)\n    (succ ?y ?yp1)\n    (curGroupsInColPartial ?col ?y ?n)\n    (succ ?n ?np1)\n    (not (true (marked ?col ?y)))\n    (true (marked ?col ?yp1)))\n(<= terminal\n    (tooBigSizeForRow ?row ?size)\n    (rowAtLeastSize ?row ?size))\n(<= terminal\n    (tooBigSizeForCol ?col ?size)\n    (colAtLeastSize ?col ?size))\n(<= terminal\n    (not anyRowBad)\n    (not anyColBad))\n(<= (goal robot 100)\n    (not anyRowBad)\n    (not anyColBad))\n(<= (goal robot 0)\n    anyRowBad)\n(<= (goal robot 0)\n    anyColBad)\n(<= anyRowBad\n    (row ?row ?group ?count)\n    (not (rowGroupCount ?row ?group ?count)))\n(<= anyColBad\n    (col ?col ?group ?count)\n    (not (colGroupCount ?col ?group ?count)))\n(<= anyRowBad\n    (numGroupsInRow ?row ?groupCount)\n    (curGroupsInRow ?row ?curCount)\n    (distinct ?groupCount ?curCount))\n(<= anyColBad\n    (numGroupsInCol ?col ?groupCount)\n    (curGroupsInCol ?col ?curCount)\n    (distinct ?groupCount ?curCount))\n(<= (numGroupsInRow ?row ?groupNum)\n    (anyGroupInRow ?row ?groupNum)\n    (succ ?groupNum ?oneMore)\n    (not (anyGroupInRow ?row ?oneMore)))\n(<= (anyGroupInRow ?row ?group)\n    (row ?row ?group ?count))\n(<= (numGroupsInCol ?col ?groupNum)\n    (anyGroupInCol ?col ?groupNum)\n    (succ ?groupNum ?oneMore)\n    (not (anyGroupInCol ?col ?oneMore)))\n(<= (anyGroupInCol ?col ?group)\n    (col ?col ?group ?count))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(highestIndex 5)\n(<= (lessThan ?x ?y)\n    (succ ?x ?y))\n(<= (lessThan ?x ?z)\n    (succ ?y ?z)\n    (lessThan ?x ?y))\n(<= (lte ?x ?y)\n    (lessThan ?x ?y))\n(<= (lte ?x ?x)\n    (index ?x))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board defined by a coordinate system consisting of files labeled from 'a' to 'j' and ranks numbered from 1 to 10, establishing a grid of 10 columns and 10 rows. Each cell on this board can be occupied by either a white or black piece, with the initial placement determined by predefined sets of files and ranks assigned to each player; white pieces occupy cells in files a, c, e, g, and i combined with ranks 1, 3, 5, 7, and 9, while black pieces occupy files b, d, f, h, and j with ranks 2, 4, 6, 8, and 10, resulting in an interlaced starting pattern. Two players, white and black, alternate turns with white moving first as the player in control at the start. On their turn, a player may perform a move action or, if it is not their turn, perform a no-operation (noop). Moves are specified by indicating the coordinates of the piece to be moved (source x1,y1) and the target cell (destination x2,y2). A move is legal if the player is in control and the move either captures an opponent's piece located along a valid diagonal path (one of four diagonal directions: northeast, southeast, southwest, northwest), or, if the moving piece currently does not threaten any opposing piece, it may move to an empty cell along such a diagonal line provided that the empty cell is itself threatened by an opponent's piece, ensuring a form of positional tension. The board enforces constraints such that moves must remain within the boundaries defined by the initial files and ranks, and movement is restricted to diagonally adjacent cells or extended diagonals through empty spaces, as determined by successive adjacent cells in valid diagonal directions. Occupancy conflicts are prevented by disallowing moves onto cells already occupied unless capturing an opponent's piece. After a move, the piece is relocated to the target cell, and the source cell is vacated; control switches to the opposing player automatically. The game terminates when a player has no pieces remaining on the board, which is detected by the absence of any cells occupied by that player's pieces. Victory is awarded to the player who still has pieces on the board, scoring 100 points, while the defeated player scores zero. This setup encourages strategic diagonal movement and capturing across a 10x10 board with alternating moves and careful positioning to threaten opponent pieces and control critical empty spaces.",
    "output": "(role white)\n(role black)\n(initFile white a)\n(initFile black b)\n(initFile white c)\n(initFile black d)\n(initFile white e)\n(initFile black f)\n(initFile white g)\n(initFile black h)\n(initFile white i)\n(initFile black j)\n(initRank white 1)\n(initRank black 2)\n(initRank white 3)\n(initRank black 4)\n(initRank white 5)\n(initRank black 6)\n(initRank white 7)\n(initRank black 8)\n(initRank white 9)\n(initRank black 10)\n(<= (init (cell ?x ?y ?color))\n    (initFile ?color ?x)\n    (initRank ?color ?y))\n(init (control white))\n(<= (threatensEmptySpace ?color ?x1 ?y1 ?x2 ?y2 ?dir)\n    (true (cell ?x1 ?y1 ?color))\n    (nextCellInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2)))\n(<= (threatensEmptySpace ?color ?x1 ?y1 ?x3 ?y3 ?dir)\n    (threatensEmptySpace ?color ?x1 ?y1 ?x2 ?y2 ?dir)\n    (nextCellInDir ?x2 ?y2 ?x3 ?y3 ?dir)\n    (not (occupied ?x3 ?y3)))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?color)))\n(<= (threatensOpposingPiece ?color ?x1 ?y1 ?x2 ?y2 ?dir)\n    (true (cell ?x1 ?y1 ?color))\n    (nextCellInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (opponent ?color ?opp)\n    (true (cell ?x2 ?y2 ?opp)))\n(<= (threatensOpposingPiece ?color ?x1 ?y1 ?x3 ?y3 ?dir)\n    (threatensEmptySpace ?color ?x1 ?y1 ?x2 ?y2 ?dir)\n    (nextCellInDir ?x2 ?y2 ?x3 ?y3 ?dir)\n    (opponent ?color ?opp)\n    (true (cell ?x3 ?y3 ?opp)))\n(<= (threatensAnyOpposingPiece ?x1 ?y1)\n    (threatensOpposingPiece ?color ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (legal ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (control ?player))\n    (threatensOpposingPiece ?player ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (legal ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (control ?player))\n    (true (cell ?x1 ?y1 ?player))\n    (not (threatensAnyOpposingPiece ?x1 ?y1))\n    (threatensEmptySpace ?player ?x1 ?y1 ?x2 ?y2 ?dir)\n    (opponent ?player ?opp)\n    (isEmptySpaceThreatenedByPlayer ?opp ?x2 ?y2))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player))))\n(<= (isEmptySpaceThreatenedByPlayer ?player ?x2 ?y2)\n    (threatensEmptySpace ?player ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (next (control black))\n    (true (control white)))\n(<= (next (control white))\n    (true (control black)))\n(<= (affected ?x1 ?y1)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (affected ?x2 ?y2)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?color))\n    (true (cell ?x ?y ?color))\n    (not (affected ?x ?y)))\n(<= (next (cell ?x2 ?y2 ?color))\n    (does ?color (move ?x1 ?y1 ?x2 ?y2)))\n(<= (anyPiecesOfColor ?color)\n    (true (cell ?x ?y ?color)))\n(<= terminal\n    (role ?color)\n    (not (anyPiecesOfColor ?color)))\n(<= (goal ?color 100)\n    (anyPiecesOfColor ?color))\n(<= (goal ?color 0)\n    (role ?color)\n    (not (anyPiecesOfColor ?color)))\n(opponent white black)\n(opponent black white)\n(<= (nextCellInDir ?x1 ?y1 ?x2 ?y2 ne)\n    (nextFile ?x1 ?x2)\n    (nextRank ?y1 ?y2))\n(<= (nextCellInDir ?x1 ?y1 ?x2 ?y2 se)\n    (nextFile ?x2 ?x1)\n    (nextRank ?y1 ?y2))\n(<= (nextCellInDir ?x1 ?y1 ?x2 ?y2 sw)\n    (nextFile ?x2 ?x1)\n    (nextRank ?y2 ?y1))\n(<= (nextCellInDir ?x1 ?y1 ?x2 ?y2 nw)\n    (nextFile ?x1 ?x2)\n    (nextRank ?y2 ?y1))\n(nextFile a b)\n(nextFile b c)\n(nextFile c d)\n(nextFile d e)\n(nextFile e f)\n(nextFile f g)\n(nextFile g h)\n(nextFile h i)\n(nextFile i j)\n(nextRank 1 2)\n(nextRank 2 3)\n(nextRank 3 4)\n(nextRank 4 5)\n(nextRank 5 6)\n(nextRank 6 7)\n(nextRank 7 8)\n(nextRank 8 9)\n(nextRank 9 10)\n(<= (legalCell ?x ?y)\n    (initFile ?color ?x)\n    (initRank ?color ?y))\n(<= (validDiagonal ?x1 ?y1 ?x2 ?y2 ?dir)\n    (legalCell ?x1 ?y1)\n    (nextCellInDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (validDiagonal ?x1 ?y1 ?x3 ?y3 ?dir)\n    (validDiagonal ?x1 ?y1 ?x2 ?y2 ?dir)\n    (nextCellInDir ?x2 ?y2 ?x3 ?y3 ?dir))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game takes place on a 10 by 10 grid, with coordinates defined by indices from 1 to 10 along both the x and y axes. Two players, designated as white and black, participate and alternate turns in a fixed sequence starting with white. Initially, each player has four pieces placed on the board: white occupies the cells at positions (1,4), (4,1), (7,1), and (10,4), while black occupies (1,7), (4,10), (7,10), and (10,7). The game proceeds in alternating phases where a player first makes a move action followed by a fire action before yielding control to their opponent; thus, a full turn for a player consists of a move phase and then a fire phase. On their move phase, a player may either move one of their pieces along an unblocked straight path in any of the eight compass directions (north, northeast, east, southeast, south, southwest, west, northwest) to an unoccupied cell, or choose to take no action if it is not their turn. The movement must be along a continuous open path without passing over occupied cells, and only one piece may occupy a cell at any time. After moving, in the fire phase, the player must select a target cell along a clear line of sight from the piece's new position, again moving in any of the eight compass directions without obstruction, to fire an arrow that occupies that cell and permanently blocks it for the remainder of the game. The firing action is only legal if it follows the player's move and targets an unoccupied, reachable cell along an open path. If it is not a player’s turn to move or fire, they may issue a noop (no operation) action. The game state updates accordingly: pieces move to new positions, cells vacated by moved pieces become empty, and fired arrows mark cells as permanently occupied and unusable. The game ends when the current player has no legal move actions available on their move phase, indicating no possible moves for any of their pieces. Victory is determined by the player who made the last successful move and fire sequence before the opponent loses all legal moves; the player to move last receives a score of 100, while the opponent receives 0. Implicit constraints include that no piece or arrow may occupy the same cell, moves and fires must remain within the board boundaries, and movement and firing paths must be strictly linear along defined compass directions without jumping over occupied squares.",
    "output": "(role white)\n(role black)\n(init (cell 1 4 white))\n(init (cell 4 1 white))\n(init (cell 7 1 white))\n(init (cell 10 4 white))\n(init (cell 1 7 black))\n(init (cell 4 10 black))\n(init (cell 7 10 black))\n(init (cell 10 7 black))\n(init (turn white move))\n(<= (legal white noop)\n    (true (turn black ?any)))\n(<= (legal black noop)\n    (true (turn white ?any)))\n(<= (legal ?player ?move)\n    (legalMove ?player ?move))\n(<= (legalMove ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (turn ?player move))\n    (true (cell ?x1 ?y1 ?player))\n    (dir ?dir)\n    (openPath ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (legalMove ?player (fire ?x2 ?y2))\n    (true (turn ?player fire))\n    (true (justMoved ?x1 ?y1))\n    (dir ?dir)\n    (openPath ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (openPath ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2)))\n(<= (openPath ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2))\n    (openPath ?x2 ?y2 ?x3 ?y3 ?dir))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?any)))\n(<= (next (turn ?player fire))\n    (true (turn ?player move)))\n(<= (next (turn ?opponent move))\n    (true (turn ?player fire))\n    (opponent ?player ?opponent))\n(<= (next (cell ?x2 ?y2 ?player))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?player))\n    (true (cell ?x ?y ?player))\n    (not (vacated ?x ?y)))\n(<= (vacated ?x1 ?y1)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (justMoved ?x2 ?y2))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y arrow))\n    (does ?player (fire ?x ?y)))\n(<= terminal\n    (true (turn ?player ?any))\n    (not (anyLegalMove ?player)))\n(<= (anyLegalMove ?player)\n    (legal ?player ?move))\n(<= (goal ?player 0)\n    (true (turn ?player ?any)))\n(<= (goal ?player 100)\n    (true (turn ?opponent ?any))\n    (opponent ?opponent ?player))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(nextIndex 1 2)\n(nextIndex 2 3)\n(nextIndex 3 4)\n(nextIndex 4 5)\n(nextIndex 5 6)\n(nextIndex 6 7)\n(nextIndex 7 8)\n(nextIndex 8 9)\n(nextIndex 9 10)\n(opponent white black)\n(opponent black white)\n(dir n)\n(dir ne)\n(dir e)\n(dir se)\n(dir s)\n(dir sw)\n(dir w)\n(dir nw)\n(<= (oneInDir ?x ?y1 ?x ?y2 n)\n    (index ?x)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x1 ?y1 ?x2 ?y2 ne)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x1 ?y ?x2 ?y e)\n    (nextIndex ?x1 ?x2)\n    (index ?y))\n(<= (oneInDir ?x1 ?y2 ?x2 ?y1 se)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x ?y2 ?x ?y1 s)\n    (index ?x)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x2 ?y2 ?x1 ?y1 sw)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x2 ?y ?x1 ?y w)\n    (nextIndex ?x1 ?x2)\n    (index ?y))\n(<= (oneInDir ?x2 ?y1 ?x1 ?y2 nw)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (dir ?dir)\n    (queenMoveDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (queenMoveDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (queenMoveDir ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (queenMoveDir ?x2 ?y2 ?x3 ?y3 ?dir))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 grid labeled with coordinates from 1 to 8 along both the x (horizontal) and y (vertical) axes, forming a square board. Certain cells on the board, specifically those at coordinates (3,3), (3,6), (6,3), and (6,6), are designated as off-limits and cannot be occupied or played upon. There are two players, named black and red, who alternate turns in the sequence black first, then red, and so forth. The initial configuration places black pieces at positions (4,4) and (5,5), while red pieces start at (4,5) and (5,4), with black having the first move as indicated by control. During each turn, the player in control may choose to place a piece on the board by marking a cell specified by x and y coordinates; such a move is legal only if the targeted cell is open (unoccupied and not off-limits) and results in flipping at least one of the opponent's pieces according to the game's flipping rules. If the player has no legal moves available, they must perform a noop (no operation) action, effectively passing the turn. Additionally, if it is the opponent’s turn and the current player has no moves, the current player may also do a noop. The flipping mechanism involves capturing the opponent’s pieces that lie in a straight line between the newly placed piece and another of the current player's pieces, in any of the eight possible directions: north, south, east, west, northeast, northwest, southeast, or southwest. When a player places a piece, all opponent pieces enclosed by this new piece and existing pieces of the current player along these directions are flipped to the current player’s color. The control of the turn alternates after every move or noop action. The game ends when neither player has any legal moves remaining. Scoring is determined by tallying the number of pieces each player has on the board at the end of the game. The player with the higher count receives a full score of 100, the loser receives 0, and in case of a tie, both players receive a score of 50. If the game is not yet over, both players have a score of zero. The board boundaries limit play to the 1 through 8 range on both axes; moves outside this range or on off-limits cells are invalid. The occupancy constraint ensures that pieces may only be placed on empty, non-off-limits cells. No explicit moves other than placing a piece or a noop are allowed. The game state updates after every action by adding the newly placed piece, flipping the appropriate opponent pieces, and switching control to the other player. Thus, the game models a strategic contest of territory control and piece flipping on a bounded square board with restricted cells, alternating turns, and well-defined legal move and scoring conditions.",
    "output": "(role black)\n(role red)\n(init (cell 4 4 black))\n(init (cell 4 5 red))\n(init (cell 5 4 red))\n(init (cell 5 5 black))\n(init (cellOffLimits 3 3))\n(init (cellOffLimits 3 6))\n(init (cellOffLimits 6 3))\n(init (cellOffLimits 6 6))\n(init (control black))\n(<= (legal ?player (mark ?x ?y))\n    (true (control ?player))\n    (hasLegalMoveAt ?player ?x ?y))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasAnyLegalMove ?player)))\n(<= (legal ?player noop)\n    (opponent ?player ?opponent)\n    (true (control ?opponent)))\n(<= (next (cell ?x ?y ?player))\n    (does ?player (mark ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n    (true (cell ?x ?y ?player))\n    (opponent ?player ?opponent)\n    (does ?opponent noop))\n(<= (next (cell ?xP ?yP ?player))\n    (true (cell ?xP ?yP ?player))\n    (opponent ?player ?opponent)\n    (does ?opponent (mark ?xO ?yO))\n    (not (playWillFlip ?opponent ?xO ?yO ?player ?xP ?yP)))\n(<= (next (cell ?xP ?yP ?opponent))\n    (true (cell ?xP ?yP ?player))\n    (opponent ?player ?opponent)\n    (does ?opponent (mark ?xO ?yO))\n    (playWillFlip ?opponent ?xO ?yO ?player ?xP ?yP))\n(<= (next (control black))\n    (true (control red)))\n(<= (next (control red))\n    (true (control black)))\n(<= (next (cellOffLimits ?x ?y))\n    (true (cellOffLimits ?x ?y)))\n(<= terminal\n    gameOver)\n(<= (goal black 0)\n    (not gameOver))\n(<= (goal black 100)\n    gameOver\n    (tally ?black ?red)\n    (lessThan ?red ?black))\n(<= (goal black 50)\n    gameOver\n    (tally ?tied ?tied))\n(<= (goal black 0)\n    gameOver\n    (tally ?black ?red)\n    (lessThan ?black ?red))\n(<= (goal red 0)\n    (not gameOver))\n(<= (goal red 100)\n    gameOver\n    (tally ?black ?red)\n    (lessThan ?black ?red))\n(<= (goal red 50)\n    gameOver\n    (tally ?tied ?tied))\n(<= (goal red 0)\n    gameOver\n    (tally ?black ?red)\n    (lessThan ?red ?black))\n(<= (cellOpen ?x ?y)\n    (index ?x)\n    (index ?y)\n    (not (true (cell ?x ?y black)))\n    (not (true (cell ?x ?y red))))\n(<= (nextCell N ?x ?y1 ?x ?y2)\n    (index ?x)\n    (indexpp ?y1 ?y2))\n(<= (nextCell S ?x ?y1 ?x ?y2)\n    (index ?x)\n    (indexpp ?y2 ?y1))\n(<= (nextCell E ?x1 ?y ?x2 ?y)\n    (indexpp ?x1 ?x2)\n    (index ?y))\n(<= (nextCell W ?x1 ?y ?x2 ?y)\n    (indexpp ?x2 ?x1)\n    (index ?y))\n(<= (nextCell NE ?x1 ?y1 ?x2 ?y2)\n    (indexpp ?x1 ?x2)\n    (indexpp ?y1 ?y2))\n(<= (nextCell NW ?x1 ?y1 ?x2 ?y2)\n    (indexpp ?x2 ?x1)\n    (indexpp ?y1 ?y2))\n(<= (nextCell SE ?x1 ?y1 ?x2 ?y2)\n    (indexpp ?x1 ?x2)\n    (indexpp ?y2 ?y1))\n(<= (nextCell SW ?x1 ?y1 ?x2 ?y2)\n    (indexpp ?x2 ?x1)\n    (indexpp ?y2 ?y1))\n(<= (openPieceString ?player ?x0 ?y0 ?dir ?xF ?yF)\n    (true (cell ?x0 ?y0 ?player))\n    (nextCell ?dir ?x0 ?y0 ?xNext ?yNext)\n    (openPieceString ?player ?xNext ?yNext ?dir ?xF ?yF))\n(<= (openPieceString ?player ?x0 ?y0 ?dir ?xF ?yF)\n    (true (cell ?x0 ?y0 ?player))\n    (nextCell ?dir ?x0 ?y0 ?xF ?yF))\n(<= (closedPieceString ?player ?x0 ?y0 ?dir ?xF ?yF)\n    (true (cell ?x0 ?y0 ?player))\n    (nextCell ?dir ?x0 ?y0 ?xNext ?yNext)\n    (closedPieceString ?player ?xNext ?yNext ?dir ?xF ?yF))\n(<= (closedPieceString ?player ?x0 ?y0 ?dir ?xF ?yF)\n    (true (cell ?x0 ?y0 ?player))\n    (nextCell ?dir ?x0 ?y0 ?xF ?yF)\n    (opponent ?player ?opponent)\n    (true (cell ?xF ?yF ?opponent)))\n(<= (playWillFlip ?player ?xP ?yP ?opponent ?xO ?yO)\n    (role ?player)\n    (openPieceString ?opponent ?xO ?yO ?dir ?xP ?yP)\n    (opposite ?dir ?oppDir)\n    (closedPieceString ?opponent ?xO ?yO ?oppDir ?xAny ?yAny))\n(<= (hasLegalMoveAt ?player ?xP ?yP)\n    (cellOpen ?xP ?yP)\n    (not (true (cellOffLimits ?xP ?yP)))\n    (opponent ?player ?opponent)\n    (true (cell ?xO ?yO ?opponent))\n    (playWillFlip ?player ?xP ?yP ?opponent ?xO ?yO))\n(<= (hasAnyLegalMove ?player)\n    (hasLegalMoveAt ?player ?x ?y))\n(<= (tally ?black ?red)\n    (pieceCount 1 1 ?black ?red))\n(<= (pieceCount ?x ?y ?blackCountpp ?redCount)\n\t(index ?y)\n    (distinct ?y 8)\n    (indexpp ?y ?ypp)\n    (true (cell ?x ?y black))\n    (pieceCount ?x ?ypp ?blackCount ?redCount)\n    (pp ?blackCount ?blackCountpp))\n(<= (pieceCount ?x ?y ?blackCount ?redCountpp)\n\t(index ?y)\n    (distinct ?y 8)\n    (indexpp ?y ?ypp)\n    (true (cell ?x ?y red))\n    (pieceCount ?x ?ypp ?blackCount ?redCount)\n    (pp ?redCount ?redCountpp))\n(<= (pieceCount ?x ?y ?blackCount ?redCount)\n\t(index ?y)\n    (distinct ?y 8)\n    (indexpp ?y ?ypp)\n    (cellOpen ?x ?y)\n    (pieceCount ?x ?ypp ?blackCount ?redCount))\n(<= (pieceCount ?x 8 ?blackCountpp ?redCount)\n\t(index ?x)\n    (distinct ?x 8)\n    (indexpp ?x ?xpp)\n    (true (cell ?x 8 black))\n    (pieceCount ?xpp 1 ?blackCount ?redCount)\n    (pp ?blackCount ?blackCountpp))\n(<= (pieceCount ?x 8 ?blackCount ?redCountpp)\n\t(index ?x)\n    (distinct ?x 8)\n    (indexpp ?x ?xpp)\n    (true (cell ?x 8 red))\n    (pieceCount ?xpp 1 ?blackCount ?redCount)\n    (pp ?redCount ?redCountpp))\n(<= (pieceCount ?x 8 ?blackCount ?redCount)\n\t(index ?x)\n    (distinct ?x 8)\n    (indexpp ?x ?xpp)\n    (cellOpen ?x 8)\n    (pieceCount ?xpp 1 ?blackCount ?redCount))\n(<= (pieceCount 8 8 1 0)\n    (true (cell 8 8 black)))\n(<= (pieceCount 8 8 0 1)\n    (true (cell 8 8 red)))\n(<= (pieceCount 8 8 0 0)\n    (cellOpen 8 8))\n(<= (lessThan ?x ?y)\n    (pp ?x ?xpp)\n    (lessThan ?xpp ?y))\n(<= (lessThan ?x ?y)\n    (pp ?x ?y))\n(<= gameOver\n    (not (hasAnyLegalMove black))\n    (not (hasAnyLegalMove red)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(indexpp 1 2) (indexpp 2 3) (indexpp 3 4) (indexpp 4 5) (indexpp 5 6) (indexpp 6 7) (indexpp 7 8)\n(opponent red black)\n(opponent black red)\n(direction  N)  (direction S) (direction  E) (direction  W)\n(direction NE) (direction NW) (direction SE) (direction SW)\n(opposite  N  S) (opposite  S  N) (opposite  E  W) (opposite  W  E)\n(opposite NE SW) (opposite SW NE) (opposite NW SE) (opposite SE NW)\n(int  0) (int  1) (int  2) (int  3) (int  4) (int  5) (int  6) (int  7) (int  8) (int  9)\n(int 10) (int 11) (int 12) (int 13) (int 14) (int 15) (int 16) (int 17) (int 18) (int 19)\n(int 20) (int 21) (int 22) (int 23) (int 24) (int 25) (int 26) (int 27) (int 28) (int 29)\n(int 30) (int 31) (int 32) (int 33) (int 34) (int 35) (int 36) (int 37) (int 38) (int 39)\n(int 40) (int 41) (int 42) (int 43) (int 44) (int 45) (int 46) (int 47) (int 48) (int 49)\n(int 50) (int 51) (int 52) (int 53) (int 54) (int 55) (int 56) (int 57) (int 58) (int 59)\n(int 60) (int 61) (int 62) (int 63) (int 64)\n(pp  0  1) (pp  1  2) (pp  2  3) (pp  3  4) (pp  4  5) (pp  5  6) (pp  6  7) (pp  7  8) (pp  8  9) (pp  9 10)\n(pp 10 11) (pp 11 12) (pp 12 13) (pp 13 14) (pp 14 15) (pp 15 16) (pp 16 17) (pp 17 18) (pp 18 19) (pp 19 20)\n(pp 20 21) (pp 21 22) (pp 22 23) (pp 23 24) (pp 24 25) (pp 25 26) (pp 26 27) (pp 27 28) (pp 28 29) (pp 29 30)\n(pp 30 31) (pp 31 32) (pp 32 33) (pp 33 34) (pp 34 35) (pp 35 36) (pp 36 37) (pp 37 38) (pp 38 39) (pp 39 40)\n(pp 40 41) (pp 41 42) (pp 42 43) (pp 43 44) (pp 44 45) (pp 45 46) (pp 46 47) (pp 47 48) (pp 48 49) (pp 49 50)\n(pp 50 51) (pp 51 52) (pp 52 53) (pp 53 54) (pp 54 55) (pp 55 56) (pp 56 57) (pp 57 58) (pp 58 59) (pp 59 60)\n(pp 60 61) (pp 61 62) (pp 62 63) (pp 63 64)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played in a vertical coordinate system where blocks are positioned at discrete heights along three columns labeled 1, 2, and 3 on the horizontal axis. The vertical positions range from 1 at the bottom to 30 at the top, with each block's y-coordinate decreasing as it moves downwards. There are two roles: \"random\" and \"player,\" which take turns sequentially, with the random role acting first by placing blocks and the player responding by attempting to catch them. The initial state starts with zero blocks dropped and zero blocks caught. On the random role's turn, it may place a new block into any of the three columns at the top position (y=30), provided fewer than 30 blocks have been dropped so far; once 30 blocks have been dropped, random must take a noop action, effectively passing the turn without placing a block. The player's legal actions consist of playing a catch attempt in any of the three columns. An action by random placing a block in a column causes that block to appear at height 30 in that column during the next state, and increments the count of blocks dropped by one. Each turn advances all existing blocks down one position, decreasing their y-coordinate by one. When the player attempts to catch a block in a particular column, the catch is successful only if there is a block exactly at position y=1 in that column; a successful catch increases the count of blocks caught. The game enforces boundaries such that blocks cannot exist below y=1, and only one block can occupy a given column at any given height. The game terminates after 30 blocks have been dropped and there are no blocks remaining at the bottom row in any of the three columns. Upon termination, the player's score is determined by the number of blocks caught, mapped through a predefined scoring table that assigns increasing point values up to 100 for catching all 30 blocks. The goal for the random role is fixed at 100 points, while the player aims to maximize their score according to the number of catches. This setup creates a turn-based dynamic where blocks continuously descend, the random role introduces new blocks until the quota is met, and the player must time their catch actions precisely at the bottom row to maximize their score before the game concludes.",
    "output": "(role random)\n(role player)\n(init (blocksDropped 0))\n(init (blocksCaught  0))\n(<= (legal random (place 1))\n    (not (true (blocksDropped 30))))\n(<= (legal random (place 2))\n    (not (true (blocksDropped 30))))\n(<= (legal random (place 3))\n    (not (true (blocksDropped 30))))\n(<= (legal random noop)\n    (true (blocksDropped 30)))\n(legal player (play 1))\n(legal player (play 2))\n(legal player (play 3))\n(<= (next (block 1 30))\n    (does random (place 1)))\n(<= (next (block 2 30))\n    (does random (place 2)))\n(<= (next (block 3 30))\n    (does random (place 3)))\n(<= (next (blocksDropped ?nplusplus))\n    blockDropped\n    (true (blocksDropped ?n))\n    (plusplus ?n ?nplusplus))\n(<= (next (blocksDropped ?n))\n    (true (blocksDropped ?n))\n    (not blockDropped))\n(<= (next (blocksCaught ?nplusplus))\n\tblockCaught\n    (true (blocksCaught ?n))\n    (plusplus ?n ?nplusplus))\n(<= (next (blocksCaught ?n))\n    (true (blocksCaught ?n))\n    (not blockCaught))\n(<= (next (block ?x ?yminusminus))\n    (true (block ?x ?y))\n    (minusminus ?y ?yminusminus))\n(<= terminal\n    (true (blocksDropped 30))\n    (not (true (block 1 1)))\n    (not (true (block 2 1)))\n    (not (true (block 3 1))))\n(goal random 100)\n(<= (goal player ?goal)\n    (true (blocksCaught ?n))\n    (scoreMap ?n ?goal))\n(<= blockDropped\n    (does random (place 1)))\n(<= blockDropped\n    (does random (place 2)))\n(<= blockDropped\n    (does random (place 3)))\n(<= blockCaught\n    (does player (play 1))\n    (true (block 1 1)))\n(<= blockCaught\n    (does player (play 2))\n    (true (block 2 1)))\n(<= blockCaught\n    (does player (play 3))\n    (true (block 3 1)))\n(plusplus  0  1) (plusplus  1  2) (plusplus  2  3) (plusplus  3  4) (plusplus  4  5) (plusplus  5  6) (plusplus  6  7) (plusplus  7  8) (plusplus  8  9) (plusplus  9 10)\n(plusplus 10 11) (plusplus 11 12) (plusplus 12 13) (plusplus 13 14) (plusplus 14 15) (plusplus 15 16) (plusplus 16 17) (plusplus 17 18) (plusplus 18 19) (plusplus 19 20)\n(plusplus 20 21) (plusplus 21 22) (plusplus 22 23) (plusplus 23 24) (plusplus 24 25) (plusplus 25 26) (plusplus 26 27) (plusplus 27 28) (plusplus 28 29) (plusplus 29 30)\n(minusminus 30 29) (minusminus 29 28) (minusminus 28 27) (minusminus 27 26) (minusminus 26 25) (minusminus 25 24) (minusminus 24 23) (minusminus 23 22) (minusminus 22 21) (minusminus 21 20)\n(minusminus 20 19) (minusminus 19 18) (minusminus 18 17) (minusminus 17 16) (minusminus 16 15) (minusminus 15 14) (minusminus 14 13) (minusminus 13 12) (minusminus 12 11) (minusminus 11 10)\n(minusminus 10  9) (minusminus  9  8) (minusminus  8  7) (minusminus  7  6) (minusminus  6  5) (minusminus  5  4) (minusminus  4  3) (minusminus  3  2) (minusminus  2  1)\n(scoreMap  0   0)\n(scoreMap  1   3)\n(scoreMap  2   6)\n(scoreMap  3   9)\n(scoreMap  4  12)\n(scoreMap  5  15)\n(scoreMap  6  18)\n(scoreMap  7  21)\n(scoreMap  8  24)\n(scoreMap  9  27)\n(scoreMap 10  30)\n(scoreMap 11  33)\n(scoreMap 12  36)\n(scoreMap 13  39)\n(scoreMap 14  42)\n(scoreMap 15  45)\n(scoreMap 16  48)\n(scoreMap 17  51)\n(scoreMap 18  54)\n(scoreMap 19  57)\n(scoreMap 20  60)\n(scoreMap 21  63)\n(scoreMap 22  66)\n(scoreMap 23  69)\n(scoreMap 24  72)\n(scoreMap 25  75)\n(scoreMap 26  80)\n(scoreMap 27  85)\n(scoreMap 28  90)\n(scoreMap 29  95)\n(scoreMap 30 100)\n(x 1)\n(x 2)\n(x 3)\n(<= (y ?n)\n    (plusplus ?m ?n))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a rectangular grid defined by rows numbered from 1 to 5 and columns numbered from 1 to 6, establishing a coordinate system where positions are identified by an (x, y) pair, with x indicating the column and y indicating the row. There is a single player role called \"robot,\" who takes turns sequentially, and the game begins with an initial state where a piece identified as a \"knight\" is positioned at cell (1, 1) and several cells are designated as \"holes.\" The game keeps track of the number of moves made, starting at zero. On each turn, the robot may perform exactly one action or pass by performing a no-operation, though the rules provided focus on the move action. Each action by the robot consists of moving the knight from one cell to another, represented as a move from coordinates (x1, y1) to (x2, y2). A move is legal only if the knight currently occupies the starting cell (x1, y1) and the move corresponds to a valid knight's move pattern from chess: this means the move must be either two steps in one axis and one step in the other, in any direction, ensuring the destination cell is reachable by such an L-shaped jump. Moves must stay within the boundaries of the board, implicitly constrained by the defined rows and columns, and the destination cell can be a hole or any other cell on the board. Upon performing a move, the knight relocates to the destination cell (x2, y2), the origin cell loses the knight, and the hole at the destination cell is filled—effectively removing the hole from that position. The move count increments by one after each move. The game ends (i.e., reaches a terminal state) once the knight occupies a cell and that cell is also a hole, meaning the knight has moved onto a hole cell. The scoring system assigns points based on the number of moves made, with a predefined score map where the score increases incrementally with each move count, reaching up to 100 points at 30 moves. The robot's goal is to maximize this score, which is determined by the current move count according to this mapping. Thus, the player maneuvers the knight around the board, moving in legal knight steps onto holes, filling them as the game progresses, and accumulating points until the game ends when the knight lands on a hole cell, signifying the conclusion of gameplay.",
    "output": "(role robot)\n(row 1)\n(row 2)\n(row 3)\n(row 4)\n(row 5)\n(col 1)\n(col 2)\n(col 3)\n(col 4)\n(col 5)\n(col 6)\n(piece knight)\n(piece hole)\n(init (moveCount 0))\n(init (cell 1 1 knight))\n(<= (next (moveCount ?newCount))\n\t(true (moveCount ?oldCount))\n\t(plus 1 count ?oldCount ?newCount))\n(<= (next (cell ?x ?y hole))\n\t(true (cell ?x ?y hole)))\n(<= (next (cell ?x1 ?y1 hole))\n\t(does robot (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x2 ?y2 knight))\n\t(does robot (move ?x1 ?y1 ?x2 ?y2)))\n(<= (legal robot (move ?x1 ?y1 ?x2 ?y2))\n\t(true (cell ?x1 ?y1 knight))\n\t(knightMove ?x1 ?y1 ?x2 ?y2))\n(<= (goal robot ?goal)\n\t(true (moveCount ?count))\n\t(scoreMap ?count ?goal))\n(<= terminal\n\t(true (cell ?x ?y knight))\n\t(true (cell ?x ?y hole)))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 x ?x1 ?x2)\n\t(plus 2 y ?y1 ?y2))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 x ?x1 ?x2)\n\t(plus 2 y ?y2 ?y1))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 x ?x2 ?x1)\n\t(plus 2 y ?y1 ?y2))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 x ?x2 ?x1)\n\t(plus 2 y ?y2 ?y1))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 x ?x1 ?x2)\n\t(plus 1 y ?y1 ?y2))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 x ?x1 ?x2)\n\t(plus 1 y ?y2 ?y1))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 x ?x2 ?x1)\n\t(plus 1 y ?y1 ?y2))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 x ?x2 ?x1)\n\t(plus 1 y ?y2 ?y1))\n(plus 1 count  0  1)\n(plus 1 count  1  2)\n(plus 1 count  2  3)\n(plus 1 count  3  4)\n(plus 1 count  4  5)\n(plus 1 count  5  6)\n(plus 1 count  6  7)\n(plus 1 count  7  8)\n(plus 1 count  8  9)\n(plus 1 count  9 10)\n(plus 1 count 10 11)\n(plus 1 count 11 12)\n(plus 1 count 12 13)\n(plus 1 count 13 14)\n(plus 1 count 14 15)\n(plus 1 count 15 16)\n(plus 1 count 16 17)\n(plus 1 count 17 18)\n(plus 1 count 18 19)\n(plus 1 count 19 20)\n(plus 1 count 20 21)\n(plus 1 count 21 22)\n(plus 1 count 22 23)\n(plus 1 count 23 24)\n(plus 1 count 24 25)\n(plus 1 count 25 26)\n(plus 1 count 26 27)\n(plus 1 count 27 28)\n(plus 1 count 28 29)\n(plus 1 count 29 30)\n(plus 1     x  1  2)\n(plus 1     x  2  3)\n(plus 1     x  3  4)\n(plus 1     x  4  5)\n(plus 1     x  5  6)\n(plus 1     y  1  2)\n(plus 1     y  2  3)\n(plus 1     y  3  4)\n(plus 1     y  4  5)\n(plus 2     x  1  3)\n(plus 2     x  2  4)\n(plus 2     x  3  5)\n(plus 2     x  4  6)\n(plus 2     y  1  3)\n(plus 2     y  2  4)\n(plus 2     y  3  5)\n(scoreMap  0   0)\n(scoreMap  1   3)\n(scoreMap  2   6)\n(scoreMap  3   9)\n(scoreMap  4  12)\n(scoreMap  5  15)\n(scoreMap  6  18)\n(scoreMap  7  21)\n(scoreMap  8  24)\n(scoreMap  9  27)\n(scoreMap 10  30)\n(scoreMap 11  33)\n(scoreMap 12  36)\n(scoreMap 13  39)\n(scoreMap 14  42)\n(scoreMap 15  45)\n(scoreMap 16  48)\n(scoreMap 17  51)\n(scoreMap 18  54)\n(scoreMap 19  57)\n(scoreMap 20  60)\n(scoreMap 21  63)\n(scoreMap 22  66)\n(scoreMap 23  69)\n(scoreMap 24  72)\n(scoreMap 25  75)\n(scoreMap 26  80)\n(scoreMap 27  85)\n(scoreMap 28  90)\n(scoreMap 29  96)\n(scoreMap 30 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a four-by-four grid with coordinates ranging from 1 to 4 along both the x (columns) and y (rows) axes, where each cell can either be empty or contain a unique piece identified by a four-bit binary code. There are two players, white and black, who alternate turns in a fixed sequence: white first has the control to select a piece from a common pool of available pieces, then white places the selected piece onto an empty cell of the board; control then passes to black, who similarly selects a piece and places it, and so on, switching between selection and placement phases within each player’s turn cycle. The initial state of the game features all sixteen cells empty and all sixteen distinct pieces available in the pool, with white starting by selecting a piece. On a player’s turn, if it is their selection phase, they must choose a piece that remains in the pool; if it is their placement phase, they must place the previously selected piece onto a currently empty cell. No action is allowed outside of these phases, and when a player is not in either selection or placement control, they may only perform a no-operation (noop). Selecting a piece removes it from the pool and marks it as currently selected, while placing a piece updates the targeted cell to contain that piece and frees the selection for the next player; all other cells remain unchanged. The game enforces board boundaries strictly—only cells within the 1-to-4 range on both axes are valid—and prohibits placing a piece onto an occupied cell. Cells are considered distinct if either their x or y coordinates differ. The game ends when either a \"line\" is formed or no empty cells remain on the board. A \"line\" is defined as a row, column, or diagonal in which all four cells contain pieces sharing the same bit value at a certain bit position across their binary codes, effectively creating a uniform bit pattern along that line. Victory conditions depend on whether a line has been formed and which player placed the last piece: if a line exists and the player who did not place last gets 100 points, while the last player scores zero; if no line exists and the board is full (no empty cells), both players receive 50 points; if no line exists and the board still has empty cells, both players score zero. Thus, the game’s objective is to avoid creating a uniform bit-patterned line with your last move, as that yields zero points for the last player and a perfect score for the opponent, incentivizing strategic selection and placement of pieces to control the board state and prevent the opponent’s victory.",
    "output": "(role white)\n(role black)\n(piece p0000)\n(piece p0001)\n(piece p0010)\n(piece p0011)\n(piece p0100)\n(piece p0101)\n(piece p0110)\n(piece p0111)\n(piece p1000)\n(piece p1001)\n(piece p1010)\n(piece p1011)\n(piece p1100)\n(piece p1101)\n(piece p1110)\n(piece p1111)\n(init (cell 1 1 empty))\n(init (cell 1 2 empty))\n(init (cell 1 3 empty))\n(init (cell 1 4 empty))\n(init (cell 2 1 empty))\n(init (cell 2 2 empty))\n(init (cell 2 3 empty))\n(init (cell 2 4 empty))\n(init (cell 3 1 empty))\n(init (cell 3 2 empty))\n(init (cell 3 3 empty))\n(init (cell 3 4 empty))\n(init (cell 4 1 empty))\n(init (cell 4 2 empty))\n(init (cell 4 3 empty))\n(init (cell 4 4 empty))\n(<= (init (pool ?piece)) (piece ?piece))\n(init (selectControl white))\n(<= (legal ?player (select ?piece))\n    (role ?player)\n\t(true (selectControl ?player))\n\t(true (pool ?piece)))\n(<= (legal ?player (place ?piece ?x ?y))\n    (role ?player)\n\t(true (placeControl ?player))\n\t(true (selected ?piece))\n\t(true (cell ?x ?y empty)))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (selectControl ?player)))\n    (not (true (placeControl ?player))))\n(<= (next (pool ?piece))\n    (true (pool ?piece))\n\t(not (does white (select ?piece)))\n    (not (does black (select ?piece))))\n(<= (next (selected ?piece))\n    (role ?player)\n    (does ?player (select ?piece)))\n(<= (next (cell ?x ?y ?state))\n    (true (cell ?x ?y ?state))\n    (role ?player)\n\t(does ?player (select ?piece)))\n(<= (next (cell ?x1 ?y1 ?state))\n    (true (cell ?x1 ?y1 ?state))\n    (role ?player)\n\t(does ?player (place ?piece ?x2 ?y2))\n\t(distinctCell ?x1 ?y1 ?x2 ?y2))\n(<= (next (cell ?x ?y ?piece))\n    (does ?player (place ?piece ?x ?y)))\n(<= (next (selectControl white))\n    (true (placeControl white)))\n(<= (next (placeControl white))\n    (true (selectControl black)))\n(<= (next (selectControl black))\n    (true (placeControl black)))\n(<= (next (placeControl black))\n    (true (selectControl white)))\n(<= terminal\n    line)\n(<= terminal\n    (not boardOpen))\n(<= (goal white 0)\n    line\n\t(placedLast white))\n(<= (goal white 50)\n    (not line)\n\t(not boardOpen))\n(<= (goal white 0)\n    (not line)\n\tboardOpen)\n(<= (goal white 100)\n    line\n\t(placedLast black))\n(<= (goal black 0)\n    line\n\t(placedLast black))\n(<= (goal black 50)\n    (not line)\n\t(not boardOpen))\n(<= (goal black 0)\n    (not line)\n\tboardOpen)\n(<= (goal black 100)\n    line\n\t(placedLast white))\n(<= (placedLast ?player)\n    (true (selectControl ?player)))\n(<= boardOpen\n    (true (cell ?x ?y empty)))\n(<= line\n    row)\n(<= line\n    column)\n(<= line\n    diagonal)\n(<= row\n    (index ?y)\n    (true (cell 1 ?y ?p1))\n\t(true (cell 2 ?y ?p2))\n\t(true (cell 3 ?y ?p3))\n\t(true (cell 4 ?y ?p4))\n\t(set ?p1 ?p2 ?p3 ?p4))\n(<= column\n    (index ?x)\n    (true (cell ?x 1 ?p1))\n\t(true (cell ?x 2 ?p2))\n\t(true (cell ?x 3 ?p3))\n\t(true (cell ?x 4 ?p4))\n\t(set ?p1 ?p2 ?p3 ?p4))\n(<= diagonal\n    (true (cell 1 1 ?p1))\n\t(true (cell 2 2 ?p2))\n\t(true (cell 3 3 ?p3))\n\t(true (cell 4 4 ?p4))\n\t(set ?p1 ?p2 ?p3 ?p4))\n(<= diagonal\n    (true (cell 1 4 ?p1))\n\t(true (cell 2 3 ?p2))\n\t(true (cell 3 2 ?p3))\n\t(true (cell 4 1 ?p4))\n\t(set ?p1 ?p2 ?p3 ?p4))\n(<= (set ?p1 ?p2 ?p3 ?p4)\n    (bit ?bit)\n\t(index ?n)\n    (bitNIs ?n ?p1 ?bit)\n\t(bitNIs ?n ?p2 ?bit)\n\t(bitNIs ?n ?p3 ?bit)\n\t(bitNIs ?n ?p4 ?bit))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n\t(index ?x1)\n\t(index ?y1)\n\t(index ?x2)\n\t(index ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n\t(index ?x1)\n\t(index ?y1)\n\t(index ?x2)\n\t(index ?y2)\n    (distinct ?y1 ?y2))\n(bit 0) (bit 1)\n(index 1) (index 2) (index 3) (index 4)\n(bitNIs 4 p0000 0) (bitNIs 3 p0000 0) (bitNIs 2 p0000 0) (bitNIs 1 p0000 0)\n(bitNIs 4 p0001 0) (bitNIs 3 p0001 0) (bitNIs 2 p0001 0) (bitNIs 1 p0001 1)\n(bitNIs 4 p0010 0) (bitNIs 3 p0010 0) (bitNIs 2 p0010 1) (bitNIs 1 p0010 0)\n(bitNIs 4 p0011 0) (bitNIs 3 p0011 0) (bitNIs 2 p0011 1) (bitNIs 1 p0011 1)\n(bitNIs 4 p0100 0) (bitNIs 3 p0100 1) (bitNIs 2 p0100 0) (bitNIs 1 p0100 0)\n(bitNIs 4 p0101 0) (bitNIs 3 p0101 1) (bitNIs 2 p0101 0) (bitNIs 1 p0101 1)\n(bitNIs 4 p0110 0) (bitNIs 3 p0110 1) (bitNIs 2 p0110 1) (bitNIs 1 p0110 0)\n(bitNIs 4 p0111 0) (bitNIs 3 p0111 1) (bitNIs 2 p0111 1) (bitNIs 1 p0111 1)\n(bitNIs 4 p1000 1) (bitNIs 3 p1000 0) (bitNIs 2 p1000 0) (bitNIs 1 p1000 0)\n(bitNIs 4 p1001 1) (bitNIs 3 p1001 0) (bitNIs 2 p1001 0) (bitNIs 1 p1001 1)\n(bitNIs 4 p1010 1) (bitNIs 3 p1010 0) (bitNIs 2 p1010 1) (bitNIs 1 p1010 0)\n(bitNIs 4 p1011 1) (bitNIs 3 p1011 0) (bitNIs 2 p1011 1) (bitNIs 1 p1011 1)\n(bitNIs 4 p1100 1) (bitNIs 3 p1100 1) (bitNIs 2 p1100 0) (bitNIs 1 p1100 0)\n(bitNIs 4 p1101 1) (bitNIs 3 p1101 1) (bitNIs 2 p1101 0) (bitNIs 1 p1101 1)\n(bitNIs 4 p1110 1) (bitNIs 3 p1110 1) (bitNIs 2 p1110 1) (bitNIs 1 p1110 0)\n(bitNIs 4 p1111 1) (bitNIs 3 p1111 1) (bitNIs 2 p1111 1) (bitNIs 1 p1111 1)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a two-dimensional grid with coordinates ranging from 1 to 8 along the horizontal axis (x-coordinate) and from 1 to 8 along the vertical axis (y-coordinate). There are two players, designated as \"x\" and \"o,\" who alternate turns beginning with player x having the initial control. The initial setup places all of player o’s pieces on the entire seventh row and all of player x’s pieces on the entire second row, with no other pieces on the board. On a player's turn, they may either perform a move or capture action if legal moves are available; otherwise, they must execute a noop action, which is allowed only if the player is not currently in control or if they have no legal moves. The move actions for player x consist of moving a piece forward vertically one space from y to y+1, provided the target cell is unoccupied; additionally, player x can perform a special two-step forward move from row 2 to row 4 if both intermediate cells are unoccupied. Player o moves similarly but in the opposite vertical direction, moving pieces from y to y-1, with a special two-step move from row 7 to row 5 when the intermediate cells are free. Capture actions involve moving a piece diagonally forward by one cell, within one column to the left or right and one row forward (up for player x, down for player o), capturing an opponent’s piece occupying that cell. Moves and captures are only legal if the destination cells are within the board boundaries, unoccupied (for moves), or occupied by an opponent’s piece (for captures). After a move or capture, the piece’s position updates, and the player who moved relinquishes control to the opponent. The game prevents overlapping pieces by enforcing that no two pieces can occupy the same cell simultaneously. The game ends under two conditions: if either player has a piece reach the opponent’s baseline row (row 8 for x, row 1 for o), or if one player loses all their pieces. Additionally, the game terminates if neither player can make any legal moves. Victory is awarded to player x if they either have a piece on row 8 or player o has no remaining pieces, and to player o if they have a piece on row 1 or player x has no remaining pieces. In these cases, the victorious player receives a score of 100 points, and the defeated player receives zero points. If the game ends due to no legal moves for either player without a winner, both players receive a score of 50 points. This structure ensures a straightforward advancement and capture mechanism on an 8x8 board, with victory achieved by advancing pieces to the opponent’s baseline, eliminating all opponent pieces, or when neither player can continue moving.",
    "output": "(role x)\n(role o)\n(init (cell 1 7 o))\n(init (cell 2 7 o))\n(init (cell 3 7 o))\n(init (cell 4 7 o))\n(init (cell 5 7 o))\n(init (cell 6 7 o))\n(init (cell 7 7 o))\n(init (cell 8 7 o))\n(init (cell 1 2 x))\n(init (cell 2 2 x))\n(init (cell 3 2 x))\n(init (cell 4 2 x))\n(init (cell 5 2 x))\n(init (cell 6 2 x))\n(init (cell 7 2 x))\n(init (cell 8 2 x))\n(init (control x))\n(<= (legal ?p noop)\n    (role ?p)\n    (not (true (control ?p))))\n(<= (legal ?p ?move)\n    (true (control ?p))\n    (can_move ?p ?move))\n(<= (legal ?p noop)\n    (role ?p)\n    (not (can_move_somewhere ?p)))\n(<= (can_move x (move ?x ?y1 ?x ?y2))\n    (true (cell ?x ?y1 x))\n    (succ ?y1 ?y2)\n    (not (occupied ?x ?y2)))\n(<= (occupied ?x ?y)\n    (role ?r)\n    (true (cell ?x ?y ?r)))\n(<= (can_move o (move ?x ?y1 ?x ?y2))\n    (true (cell ?x ?y1 o))\n    (succ ?y2 ?y1)\n    (not (occupied ?x ?y2)))\n(<= (can_move x (move ?x 2 ?x 4))\n    (true (cell ?x 2 x))\n    (not (occupied ?x 3))\n    (not (occupied ?x 4)))\n(<= (can_move o (move ?x 7 ?x 5))\n    (true (cell ?x 7 o))\n    (not (occupied ?x 6))\n    (not (occupied ?x 5)))\n(<= (can_move x (capture ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 x))\n    (true (cell ?x2 ?y2 o))\n    (succ ?y1 ?y2)\n    (or (succ ?x1 ?x2)\n        (succ ?x2 ?x1)))\n(<= (can_move o (capture ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 o))\n    (true (cell ?x2 ?y2 x))\n    (succ ?y2 ?y1)\n    (or (succ ?x1 ?x2)\n        (succ ?x2 ?x1)))\n(<= (next (cell ?x ?y ?p))\n    (true (cell ?x ?y ?p))\n    (not (changes ?x ?y)))\n(<= (next (cell ?x ?y ?p))\n    (does ?p (move ?any_x ?any_y ?x ?y)))\n(<= (next (cell ?x ?y ?p))\n    (does ?p (capture ?any_x ?any_y ?x ?y)))\n(<= (changes ?x ?y)\n    (does ?r (move ?x ?y ?any_x ?any_y)))\n(<= (changes ?x ?y)\n    (does ?r (capture ?x ?y ?any_x ?any_y)))\n(<= (changes ?x ?y)\n    (does ?r (capture ?any_x ?any_y ?x ?y)))\n(<= (next (control o))\n    (true (control x)))\n(<= (next (control x))\n    (true (control o)))\n(<= (goal x 100)\n    xwins)\n(<= (goal o 100)\n    owins)\n(<= (has_pieces ?p)\n    (true (cell ?x ?y ?p)))\n(<= (goal ?p 50)\n    (role ?p)\n    (not (can_move_somewhere x))\n    (not (can_move_somewhere o))\n    (not xwins)\n    (not owins))\n(<= (goal x 0)\n    owins)\n(<= (goal o 0)\n    xwins)\n(<= xwins\n    (true (cell ?any_x 8 x)))\n(<= xwins\n    (not (has_pieces o)))\n(<= owins\n    (true (cell ?any_x 1 o)))\n(<= owins\n    (not (has_pieces x)))\n(<= terminal\n    (goal ?role 100))\n(<= terminal\n    (not (can_move_somewhere x))\n    (not (can_move_somewhere o)))\n(<= (can_move_somewhere ?p)\n    (can_move ?p ?m))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on two separate 4-by-4 grids, each defined by coordinates where the first number represents the column from 1 to 4 and the second number the row from 1 to 4, with cells identified accordingly. There are two player roles: the crosser and the blocker, who alternate turns throughout the game. Initially, all cells on both boards are marked as blank. The game proceeds in two phases, controlled by a condition called game1Over; before this condition is met, players place marks on the first board, and afterward, they place marks on the second board. On each turn, a player must mark exactly one blank cell on the current board with their respective symbol—\"crosser\" or \"blocker\"—and the chosen cell must not already be occupied. The blocker’s moves mark cells as blocked, while the crosser’s moves mark cells as crossed, and both players’ moves occur simultaneously in the state update, with the constraint that they cannot mark the same cell in the same turn. Cells retain their markings indefinitely once placed unless the game state changes boards after the first phase ends. The first phase terminates when either the crosser forms a continuous sequence of four crosser-marked cells in the first column through contiguous rows on the first board, or when there are no blank cells left on that board, locking the game state and triggering the second phase on the second board. The second phase ends under similar conditions on the second board. Continuity between cells is defined by a \"cont\" relationship linking adjacent cells along rows or columns. The blocker wins points by preventing the crosser from creating such a continuous bridge of crossed cells on either board and by filling cells to block potential crossings; the crosser wins points by successfully creating these continuous bridges on both boards. Specifically, if the crosser achieves a bridge on a board, they score maximum points for that board while the blocker scores zero, and vice versa if no bridge is formed and the board is fully blocked. The overall game ends when the second phase’s terminal condition is met, and the final scores reflect the combined results from both boards, determining the winner. Players have no option to pass or perform no-operation moves; they must mark a valid blank cell on their turn according to the current phase, maintaining the turn order and legality constraints throughout.",
    "output": "(role crosser)\n(role blocker)\n(init (cell1 1 1 b))\n(init (cell1 1 2 b))\n(init (cell1 1 3 b))\n(init (cell1 1 4 b))\n(init (cell1 2 1 b))\n(init (cell1 2 2 b))\n(init (cell1 2 3 b))\n(init (cell1 2 4 b))\n(init (cell1 3 1 b))\n(init (cell1 3 2 b))\n(init (cell1 3 3 b))\n(init (cell1 3 4 b))\n(init (cell1 4 1 b))\n(init (cell1 4 2 b))\n(init (cell1 4 3 b))\n(init (cell1 4 4 b))\n(init (cell2 1 1 b))\n(init (cell2 1 2 b))\n(init (cell2 1 3 b))\n(init (cell2 1 4 b))\n(init (cell2 2 1 b))\n(init (cell2 2 2 b))\n(init (cell2 2 3 b))\n(init (cell2 2 4 b))\n(init (cell2 3 1 b))\n(init (cell2 3 2 b))\n(init (cell2 3 3 b))\n(init (cell2 3 4 b))\n(init (cell2 4 1 b))\n(init (cell2 4 2 b))\n(init (cell2 4 3 b))\n(init (cell2 4 4 b))\n(<= (legal ?who (mark1 ?x ?y))\n    (not game1Over)\n    (role ?who)\n    (true (cell1 ?x ?y b)))\n(<= (legal ?who (mark2 ?x ?y))\n    game1Over\n    (role ?who)\n    (true (cell2 ?x ?y b)))\n(<= (next (cell1 ?x ?y blk))\n    (does blocker (mark1 ?x ?y)))\n(<= (next (cell1 ?xC ?yC crosser))\n    (does crosser (mark1 ?xC ?yC))\n    (does blocker (mark1 ?xB ?yB))\n    (distinctCell ?xC ?yC ?xB ?yB))\n(<= (next (cell1 ?x ?y ?mark))\n    (true (cell1 ?x ?y ?mark))\n    (does blocker (mark1 ?xB ?yB))\n    (does crosser (mark1 ?xC ?yC))\n    (distinctCell ?x ?y ?xB ?yB)\n    (distinctCell ?x ?y ?xC ?yC))\n(<= (next (cell1 ?x ?y ?mark))\n    (true (cell1 ?x ?y ?mark))\n    game1Over)\n(<= (next (cell2 ?x ?y blk))\n    (does blocker (mark2 ?x ?y)))\n(<= (next (cell2 ?xC ?yC crosser))\n    (does crosser (mark2 ?xC ?yC))\n    (does blocker (mark2 ?xB ?yB))\n    (distinctCell ?xC ?yC ?xB ?yB))\n(<= (next (cell2 ?x ?y ?mark))\n    (true (cell2 ?x ?y ?mark))\n    (does blocker (mark2 ?xB ?yB))\n    (does crosser (mark2 ?xC ?yC))\n    (distinctCell ?x ?y ?xB ?yB)\n    (distinctCell ?x ?y ?xC ?yC))\n(<= (next (cell2 ?x ?y ?mark))\n    (true (cell2 ?x ?y ?mark))\n    (not game1Over))\n(<= (next game1OverLock)\n    game1TermCond)\n(<= (next game1OverLock)\n    (true game1OverLock))\n(<= terminal\n    game2TermCond)\n(<= (goal blocker 100)\n    goalBlocker1-100\n    goalBlocker2-100)\n(<= (goal blocker 50)\n    goalBlocker1-100\n    goalBlocker2-0)\n(<= (goal blocker 50)\n    goalBlocker1-0\n    goalBlocker2-100)\n(<= (goal blocker 0)\n    goalBlocker1-0\n    goalBlocker2-0)\n(<= (goal crosser 100)\n    goalCrosser1-100\n    goalCrosser2-100)\n(<= (goal crosser 50)\n    goalCrosser1-100\n    goalCrosser2-0)\n(<= (goal crosser 50)\n    goalCrosser1-0\n    goalCrosser2-100)\n(<= (goal crosser 0)\n    goalCrosser1-0\n    goalCrosser2-0)\n(<= game1Over\n    game1TermCond)\n(<= game1Over\n    (true game1OverLock))\n(<= game1TermCond\n    bridge1)\n(<= game1TermCond\n    (not open1))\n(<= game2TermCond\n    bridge2)\n(<= game2TermCond\n    (not open2))\n(<= bridge1\n    (true (cell1 1 ?a crosser))\n    (cont ?a ?b)\n    (true (cell1 2 ?b crosser))\n    (cont ?b ?c)\n    (true (cell1 3 ?c crosser))\n    (cont ?c ?d)\n    (true (cell1 4 ?d crosser)))\n(<= bridge2\n    (true (cell2 1 ?a crosser))\n    (cont ?a ?b)\n    (true (cell2 2 ?b crosser))\n    (cont ?b ?c)\n    (true (cell2 3 ?c crosser))\n    (cont ?c ?d)\n    (true (cell2 4 ?d crosser)))\n(<= open1\n    (true (cell1 ?m ?n b)))\n(<= open2\n    (true (cell2 ?m ?n b)))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= goalBlocker1-100\n    (not bridge1)\n    (not open1))\n(<= goalBlocker1-0\n    bridge1)\n(<= goalBlocker1-0\n    open1)\n(<= goalBlocker2-100\n    (not bridge2)\n    (not open2))\n(<= goalBlocker2-0\n    bridge2)\n(<= goalBlocker2-0\n    open2)\n(<= goalCrosser1-100\n    bridge1)\n(<= goalCrosser1-0\n    (not bridge1))\n(<= goalCrosser2-100\n    bridge2)\n(<= goalCrosser2-0\n    (not bridge2))\n(cont 1 1)\n(cont 2 2)\n(cont 3 3)\n(cont 4 4)\n(cont 1 2)\n(cont 2 3)\n(cont 3 4)\n(cont 2 1)\n(cont 3 2)\n(cont 4 3)\n(cell 1 1) (cell 2 1) (cell 3 1) (cell 4 1)\n(cell 1 2) (cell 2 2) (cell 3 2) (cell 4 2)\n(cell 1 3) (cell 2 3) (cell 3 3) (cell 4 3)\n(cell 1 4) (cell 2 4) (cell 3 4) (cell 4 4)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on two separate 3-by-3 grids, each with coordinates ranging from 1 to 3 along both the x and y axes, defining the cells within each grid. There are two players, named xplayer and oplayer, who alternate turns throughout the game. Initially, all cells in both grids are blank. Control initially rests with xplayer on both grids. During the first phase of the game, players take turns marking cells on the first grid, with xplayer starting. A legal move consists of marking a blank cell on the first grid, and only the player currently in control of the first grid may mark a cell there. If it is not a player's turn to control the first grid, that player may only pass by performing a no-operation move. After the first phase ends—determined by either a winning line being formed or no blank cells remaining on the first grid—the game transitions to the second grid, where players again alternate turns marking blank cells. In this second phase, players may only mark blank cells on the second grid if the first phase has concluded, and similar turn-taking and noop rules apply. Each move updates the state by placing the player's mark in the chosen cell, while all other cells retain their previous state unless the game has transitioned phases. Control switches between players after each move, except when the game phase changes, in which case control remains consistent with the rules. Throughout play, cells cannot be marked more than once, and all moves must respect the boundaries of the 3-by-3 grids. The game ends when a terminal condition is met on the second grid, which occurs if a player completes a winning line or no blank cells remain. Victory is determined by evaluating the presence of complete lines—rows, columns, or diagonals—of a player's marks on either grid, with higher scores awarded for winning lines and lesser scores for draws or losses, as defined by a detailed scoring system that considers both grids' outcomes. Thus, the gameplay consists of sequential marking on two tic-tac-toe boards, with strict turn order, state updates, and victory conditions that depend on forming lines or filling the boards without lines.",
    "output": "(role xplayer)\n(role oplayer)\n(init (cell1 1 1 b))\n(init (cell1 1 2 b))\n(init (cell1 1 3 b))\n(init (cell1 2 1 b))\n(init (cell1 2 2 b))\n(init (cell1 2 3 b))\n(init (cell1 3 1 b))\n(init (cell1 3 2 b))\n(init (cell1 3 3 b))\n(init (control1 xplayer))\n(init (cell2 1 1 b))\n(init (cell2 1 2 b))\n(init (cell2 1 3 b))\n(init (cell2 2 1 b))\n(init (cell2 2 2 b))\n(init (cell2 2 3 b))\n(init (cell2 3 1 b))\n(init (cell2 3 2 b))\n(init (cell2 3 3 b))\n(init (control2 xplayer))\n(<= (legal ?player (mark1 ?x ?y))\n    (not game1Over)\n    (true (control1 ?player))\n    (true (cell1 ?x ?y b)))\n(<= (legal xplayer noop)\n    (not game1Over)\n    (true (control1 oplayer)))\n(<= (legal oplayer noop)\n    (not game1Over)\n    (true (control1 xplayer)))\n(<= (legal ?player (mark2 ?x ?y))\n    game1Over\n    (true (control2 ?player))\n    (true (cell2 ?x ?y b)))\n(<= (legal xplayer noop)\n    game1Over\n    (true (control2 oplayer)))\n(<= (legal oplayer noop)\n    game1Over\n    (true (control2 xplayer)))\n(<= (next (cell1 ?x ?y x))\n    (does xplayer (mark1 ?x ?y)))\n(<= (next (cell1 ?x ?y o))\n    (does oplayer (mark1 ?x ?y)))\n(<= (next (cell1 ?x1 ?y1 ?mark))\n    (true (cell1 ?x1 ?y1 ?mark))\n    (does xplayer (mark1 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x2 ?y2))\n(<= (next (cell1 ?x1 ?y1 ?mark))\n    (true (cell1 ?x1 ?y1 ?mark))\n    (does oplayer (mark1 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x2 ?y2))\n(<= (next (cell1 ?x ?y ?mark))\n    (true (cell1 ?x ?y ?mark))\n    game1Over)\n(<= (next (control1 xplayer))\n    (not game1Over)\n    (true (control1 oplayer)))\n(<= (next (control1 oplayer))\n    (not game1Over)\n    (true (control1 xplayer)))\n(<= (next (control1 ?player))\n    (true (control1 ?player))\n    game1Over)\n(<= (next (cell2 ?x ?y x))\n    (does xplayer (mark2 ?x ?y)))\n(<= (next (cell2 ?x ?y o))\n    (does oplayer (mark2 ?x ?y)))\n(<= (next (cell2 ?x1 ?y1 ?mark))\n    (true (cell2 ?x1 ?y1 ?mark))\n    (does xplayer (mark2 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x2 ?y2))\n(<= (next (cell2 ?x1 ?y1 ?mark))\n    (true (cell2 ?x1 ?y1 ?mark))\n    (does oplayer (mark2 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x2 ?y2))\n(<= (next (cell2 ?x ?y ?mark))\n    (true (cell2 ?x ?y ?mark))\n    (not game1Over))\n(<= (next (control2 xplayer))\n    game1Over\n    (true (control2 oplayer)))\n(<= (next (control2 oplayer))\n    game1Over\n    (true (control2 xplayer)))\n(<= (next (control2 ?player))\n    (true (control2 ?player))\n    (not game1Over))\n(<= (next game1OverLock)\n    game1TermCond)\n(<= (next game1OverLock)\n    (true game1OverLock))\n(<= terminal\n    game2TermCond)\n(<= (goal xplayer 100)\n    goalXPlayer1100\n    goalXPlayer2100)\n(<= (goal xplayer 75)\n    goalXPlayer1100\n    goalXPlayer250)\n(<= (goal xplayer 75)\n    goalXPlayer150\n    goalXPlayer2100)\n(<= (goal xplayer 50)\n    goalXPlayer1100\n    goalXPlayer20)\n(<= (goal xplayer 50)\n    goalXPlayer150\n    goalXPlayer250)\n(<= (goal xplayer 50)\n    goalXPlayer10\n    goalXPlayer2100)\n(<= (goal xplayer 25)\n    goalXPlayer150\n    goalXPlayer20)\n(<= (goal xplayer 25)\n    goalXPlayer10\n    goalXPlayer250)\n(<= (goal xplayer 0)\n    goalXPlayer10\n    goalXPlayer20)\n(<= (goal oplayer 100)\n    goalOPlayer1100\n    goalOPlayer2100)\n(<= (goal oplayer 75)\n    goalOPlayer1100\n    goalOPlayer250)\n(<= (goal oplayer 75)\n    goalOPlayer150\n    goalOPlayer2100)\n(<= (goal oplayer 50)\n    goalOPlayer1100\n    goalOPlayer20)\n(<= (goal oplayer 50)\n    goalOPlayer150\n    goalOPlayer250)\n(<= (goal oplayer 50)\n    goalOPlayer10\n    goalOPlayer2100)\n(<= (goal oplayer 25)\n    goalOPlayer150\n    goalOPlayer20)\n(<= (goal oplayer 25)\n    goalOPlayer10\n    goalOPlayer250)\n(<= (goal oplayer 0)\n    goalOPlayer10\n    goalOPlayer20)\n(<= game1Over\n    game1TermCond)\n(<= game1Over\n    (true game1OverLock))\n(<= game1TermCond\n    (line1 x))\n(<= game1TermCond\n    (line1 o))\n(<= game1TermCond\n    (not open1))\n(<= game2TermCond\n    (line2 x))\n(<= game2TermCond\n    (line2 o))\n(<= game2TermCond\n    (not open2))\n(<= goalXPlayer1100\n    (line1 x))\n(<= goalXPlayer150\n    (not (line1 x))\n    (not (line1 o))\n    (not open1))\n(<= goalXPlayer10\n    (line1 o))\n(<= goalXPlayer10\n    (not (line1 x))\n    (not (line1 o))\n    open1)\n(<= goalOPlayer1100\n    (line1 o))\n(<= goalOPlayer150\n    (not (line1 x))\n    (not (line1 o))\n    (not open1))\n(<= goalOPlayer10\n    (line1 x))\n(<= goalOPlayer10\n    (not (line1 x))\n    (not (line1 o))\n    open1)\n(<= goalXPlayer2100\n    (line2 x))\n(<= goalXPlayer250\n    (not (line2 x))\n    (not (line2 o))\n    (not open2))\n(<= goalXPlayer20\n    (line2 o))\n(<= goalXPlayer20\n    (not (line2 x))\n    (not (line2 o))\n    open2)\n(<= goalOPlayer2100\n    (line2 o))\n(<= goalOPlayer250\n    (not (line2 x))\n    (not (line2 o))\n    (not open2))\n(<= goalOPlayer20\n    (line2 x))\n(<= goalOPlayer20\n    (not (line2 x))\n    (not (line2 o))\n    open2)\n(<= (row1 ?x ?mark)\n    (true (cell1 ?x 1 ?mark))\n    (true (cell1 ?x 2 ?mark))\n    (true (cell1 ?x 3 ?mark)))\n(<= (column1 ?y ?mark)\n    (true (cell1 1 ?y ?mark))\n    (true (cell1 2 ?y ?mark))\n    (true (cell1 3 ?y ?mark)))\n(<= (diagonal1 ?mark)\n    (true (cell1 1 1 ?mark))\n    (true (cell1 2 2 ?mark))\n    (true (cell1 3 3 ?mark)))\n(<= (diagonal1 ?mark)\n    (true (cell1 1 3 ?mark))\n    (true (cell1 2 2 ?mark))\n    (true (cell1 3 1 ?mark)))\n(<= (line1 ?mark)\n    (row1 ?x ?mark))\n(<= (line1 ?mark)\n    (column1 ?y ?mark))\n(<= (line1 ?mark)\n    (diagonal1 ?mark))\n(<= open1\n    (true (cell1 ?x ?y b)))\n(<= (row2 ?x ?mark)\n    (true (cell2 ?x 1 ?mark))\n    (true (cell2 ?x 2 ?mark))\n    (true (cell2 ?x 3 ?mark)))\n(<= (column2 ?y ?mark)\n    (true (cell2 1 ?y ?mark))\n    (true (cell2 2 ?y ?mark))\n    (true (cell2 3 ?y ?mark)))\n(<= (diagonal2 ?mark)\n    (true (cell2 1 1 ?mark))\n    (true (cell2 2 2 ?mark))\n    (true (cell2 3 3 ?mark)))\n(<= (diagonal2 ?mark)\n    (true (cell2 1 3 ?mark))\n    (true (cell2 2 2 ?mark))\n    (true (cell2 3 1 ?mark)))\n(<= (line2 ?mark)\n    (row2 ?x ?mark))\n(<= (line2 ?mark)\n    (column2 ?y ?mark))\n(<= (line2 ?mark)\n    (diagonal2 ?mark))\n(<= open2\n    (true (cell2 ?x ?y b)))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(cell 1 1) (cell 1 2) (cell 1 3)\n(cell 2 1) (cell 2 2) (cell 2 3)\n(cell 3 1) (cell 3 2) (cell 3 3)\n(markType x) (markType o) (markType b)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8x8 grid, with coordinates indexed from 1 to 8 along both the x (horizontal) and y (vertical) axes, forming a standard two-dimensional Cartesian coordinate system where each cell is identified by its x and y coordinates. There are two player roles, black and red, which alternate turns throughout the game; black moves first as indicated by the initial control state. The game begins with four pieces placed near the center of the board: black pieces occupy cells (4,4) and (5,5), while red pieces occupy cells (4,5) and (5,4). The player who has control at any point is the one who makes the current move, and control switches to the opposing player after each turn. If a player has no legal moves available, they may pass their turn by performing a no-operation (noop) action. \n\nOn their turn, a player may either choose to place a piece on an empty cell or pass if no moves are possible. A legal move involves placing a piece on an empty cell that is adjacent in any direction—north, south, east, west, or any of the four diagonals—to at least one opponent’s piece, and such that in that direction there exists a continuous line of one or more opponent pieces ending with a piece of the current player’s color, effectively \"sandwiching\" the opponent’s pieces. The directions are defined relative to the grid with increments or decrements of one in x and/or y coordinates accordingly, allowing identification of neighboring cells. Occupied cells cannot be chosen for moves, and all moves must remain within the boundaries of the 8x8 board. \n\nWhen a piece is placed, it captures all opponent pieces that lie in straight lines in any of the eight directions between the newly placed piece and other pieces of the current player’s color; these captured pieces are flipped to the current player’s color. This flipping is processed automatically following the move, and the board state updates accordingly. The game ends when neither player can make a legal move, signaling the terminal condition. At this point, the scores are calculated by counting the total number of pieces each player owns on the board. The player with the greater number of pieces is declared the winner and receives a score of 100, while the loser receives 0. In the event of a tie with no clear winner, both players receive a neutral score of 50. This scoring system incentivizes controlling the majority of the board at the end of play. Overall, the game combines strategic placement and area control within a bounded grid, alternating turns with enforced move legality and automatic piece flipping to determine the final outcome.",
    "output": "(role black)\n(role red)\n(opponent black red)\n(opponent red black)\n(init (cell 4 4 black))\n(init (cell 4 5 red))\n(init (cell 5 4 red))\n(init (cell 5 5 black))\n(init (control black))\n(oppDir nw se)\n(oppDir ne sw)\n(oppDir se nw)\n(oppDir sw ne)\n(oppDir n s)\n(oppDir e w)\n(oppDir s n)\n(oppDir w e)\n(dir n 0 p1)\n(dir s 0 n1)\n(dir e p1 0)\n(dir w n1 0)\n(dir nw n1 p1)\n(dir ne p1 p1)\n(dir se p1 n1)\n(dir sw n1 n1)\n(<= (hasOtherColorInDir ?x1 ?y1 ?dir)\n    (true (cell ?x1 ?y1 ?color))\n    (opponent ?color ?otherColor)\n    (nextCellInDir ?x1 ?y1 ?dir ?x2 ?y2)\n    (true (cell ?x2 ?y2 ?otherColor)))\n(<= (hasOtherColorInDir ?x1 ?y1 ?dir)\n    (true (cell ?x1 ?y1 ?color))\n    (nextCellInDir ?x1 ?y1 ?dir ?x2 ?y2)\n    (true (cell ?x2 ?y2 ?color))\n    (hasOtherColorInDir ?x2 ?y2 ?dir))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?anyColor)))\n(<= (empty ?x ?y)\n    (index ?x)\n    (index ?y)\n    (not (occupied ?x ?y)))\n(<= (playerCanMoveAt ?color ?x ?y)\n\t(empty ?x ?y)\n\t(opponent ?color ?otherColor)\n\t(nextCellInDir ?x ?y ?dir ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?otherColor))\n\t(hasOtherColorInDir ?x2 ?y2 ?dir))\n(<= (playerCanMove ?player)\n    (playerCanMoveAt ?player ?anyX ?anyY))\n(<= (legal ?player noop)\n    (true (control ?opponent))\n    (opponent ?player ?opponent))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (playerCanMove ?player)))\n(<= (legal ?player (move ?x ?y))\n    (true (control ?player))\n    (playerCanMoveAt ?player ?x ?y))\n(<= (next (control ?nextPlayer))\n    (true (control ?curPlayer))\n    (opponent ?curPlayer ?nextPlayer))\n(<= (affected ?x2 ?y2 ?dir ?otherColor)\n    (does ?player (move ?x1 ?y1))\n    (opponent ?player ?otherColor)\n    (nextCellInDir ?x1 ?y1 ?dir ?x2 ?y2)\n    (hasOtherColorInDir ?x2 ?y2 ?dir)\n    (true (cell ?x2 ?y2 ?otherColor)))\n(<= (affected ?x2 ?y2 ?dir ?color)\n    (hasOtherColorInDir ?x2 ?y2 ?dir)\n    (oppDir ?dir ?oppDir)\n    (nextCellInDir ?x2 ?y2 ?oppDir ?x1 ?y1)\n    (affected ?x1 ?y1 ?dir ?color)\n    (true (cell ?x2 ?y2 ?color)))\n(<= (affectedCell ?x ?y)\n    (affected ?x ?y ?anyDir ?anyColor))\n(<= (next (cell ?x ?y ?color))\n    (true (cell ?x ?y ?color))\n    (not (affectedCell ?x ?y)))\n(<= (next (cell ?x ?y ?color))\n    (does ?color (move ?x ?y)))\n(<= (next (cell ?x ?y ?color))\n    (does ?color (move ?anyX ?anyY))\n    (affectedCell ?x ?y))\n(<= terminal\n    (not (playerCanMove black))\n    (not (playerCanMove red)))\n(<= (pieceCount 1 1 ?color 1)\n    (true (cell 1 1 ?color)))\n(<= (pieceCount 1 1 ?color 0)\n    (role ?color)\n    (not (true (cell 1 1 ?color))))\n(<= (pieceCount ?x ?yp1 ?color ?np1)\n    (add ?y p1 ?yp1)\n    (pieceCount ?x ?y ?color ?n)\n    (succ ?n ?np1)\n    (true (cell ?x ?yp1 ?color)))\n(<= (pieceCount ?x ?yp1 ?color ?n)\n    (add ?y p1 ?yp1)\n    (pieceCount ?x ?y ?color ?n)\n    (not (true (cell ?x ?yp1 ?color))))\n(<= (pieceCount ?xp1 1 ?color ?np1)\n    (add ?x p1 ?xp1)\n    (pieceCount ?x 8 ?color ?n)\n    (succ ?n ?np1)\n    (true (cell ?xp1 1 ?color)))\n(<= (pieceCount ?xp1 1 ?color ?n)\n    (add ?x p1 ?xp1)\n    (pieceCount ?x 8 ?color ?n)\n    (not (true (cell ?xp1 1 ?color))))\n(<= (totalCount ?player ?n)\n    (pieceCount 8 8 ?player ?n))\n(<= (winner black)\n    (totalCount black ?blackCount)\n    (totalCount red ?redCount)\n    (lessThan ?redCount ?blackCount))\n(<= (winner red)\n    (totalCount black ?blackCount)\n    (totalCount red ?redCount)\n    (lessThan ?blackCount ?redCount))\n(<= (goal ?player 100)\n    (winner ?player))\n(<= (goal ?player 0)\n    (winner ?opponent)\n    (opponent ?player ?opponent))\n(<= (goal ?player 50)\n\t(role ?player)\n\t(not (winner black))\n\t(not (winner red)))\n(<= (nextCellInDir ?x1 ?y1 ?dir ?x2 ?y2)\n    (index ?x1)\n    (index ?y1)\n    (dir ?dir ?xDelta ?yDelta)\n    (add ?x1 ?xDelta ?x2)\n    (add ?y1 ?yDelta ?y2))\n(add 1 p1 2)\n(add 2 p1 3)\n(add 3 p1 4)\n(add 4 p1 5)\n(add 5 p1 6)\n(add 6 p1 7)\n(add 7 p1 8)\n(add 1 0 1)\n(add 2 0 2)\n(add 3 0 3)\n(add 4 0 4)\n(add 5 0 5)\n(add 6 0 6)\n(add 7 0 7)\n(add 8 0 8)\n(add 8 n1 7)\n(add 7 n1 6)\n(add 6 n1 5)\n(add 5 n1 4)\n(add 4 n1 3)\n(add 3 n1 2)\n(add 2 n1 1)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(<= (lessThan ?x ?z)\n    (succ ?x ?y)\n    (lessThan ?y ?z))\n(<= (lessThan ?x ?y)\n    (succ ?x ?y))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 5-by-5 grid where each cell is identified by a pair of coordinates ranging from 1 to 5 for both rows and columns. There are two players, designated as \"xplayer\" and \"oplayer,\" who alternate turns, beginning with the xplayer. Initially, all cells on the board are blank. On a player's turn, they may mark a blank cell with their respective symbol (\"x\" for xplayer and \"o\" for oplayer), provided it is their turn to move and the chosen cell is currently unoccupied. If it is not a player's turn, their only legal action is to perform a noop, effectively passing control to the other player. The game enforces turn-taking by switching control between players after each move or noop. Each action consists of specifying the coordinates of the cell to mark, and a move is legal only if the cell is blank and it is the moving player's turn. Once a move is made, the board's state updates to reflect the new mark, and the control passes to the opposing player. Implicit rules ensure that marked cells cannot be overwritten and that moves are confined within the 5-by-5 boundaries. The game continuously checks for a winning line, defined as any complete row, column, or one of the two main diagonals fully occupied by the same player's symbol. The game ends when either player achieves such a line or when there are no blank cells remaining, resulting in a terminal state. Scoring assigns 100 points to a player who alone has a winning line, 0 points if only the opponent has a winning line, and 50 points in the case of a draw or simultaneous lines. Thus, victory is achieved by forming an unbroken line of five marks in any row, column, or diagonal before the opponent or by having a higher score at game's end.",
    "output": "(role xplayer)\n(role oplayer)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(init (cell 1 1 b))\n(init (cell 1 2 b))\n(init (cell 1 3 b))\n(init (cell 1 4 b))\n(init (cell 1 5 b))\n(init (cell 2 1 b))\n(init (cell 2 2 b))\n(init (cell 2 3 b))\n(init (cell 2 4 b))\n(init (cell 2 5 b))\n(init (cell 3 1 b))\n(init (cell 3 2 b))\n(init (cell 3 3 b))\n(init (cell 3 4 b))\n(init (cell 3 5 b))\n(init (cell 4 1 b))\n(init (cell 4 2 b))\n(init (cell 4 3 b))\n(init (cell 4 4 b))\n(init (cell 4 5 b))\n(init (cell 5 1 b))\n(init (cell 5 2 b))\n(init (cell 5 3 b))\n(init (cell 5 4 b))\n(init (cell 5 5 b))\n(init (control xplayer))\n(<= (legal ?W (mark ?X ?Y)) (true (cell ?X ?Y b)) (true (control ?W)))\n(<= (legal xplayer noop) (true (control oplayer)))\n(<= (legal oplayer noop) (true (control xplayer)))\n(<= (next (cell ?I ?J ?W)) futureline (true (cell ?I ?J ?W)) (distinct ?W b))\n(<= (next (cell ?I ?J o)) futureline (true (cell ?I ?J b)) (does oplayer (mark ?I ?J)))\n(<= (next (cell ?I ?J x)) futureline (true (cell ?I ?J b)) (does xplayer (mark ?I ?J)))\n(<= (next (cell ?I ?J b)) futureline (true (cell ?I ?J b)) (does ?P (mark ?K ?L)) (distinct ?I ?K))\n(<= (next (cell ?I ?J b)) futureline (true (cell ?I ?J b)) (does ?P (mark ?K ?L)) (distinct ?J ?L))\n(<= (next (cell ?I ?J x)) (does xplayer (mark ?OldI ?OldJ)) (update ?OldI ?OldJ ?I ?J) (not futureline))\n(<= (next (cell ?I ?J o)) (does oplayer (mark ?OldI ?OldJ)) (update ?OldI ?OldJ ?I ?J) (not futureline))\n(<= (next (cell ?I ?J ?W)) (true (cell ?OldI ?OldJ ?W)) (update ?OldI ?OldJ ?I ?J) (distinct ?W b) (not futureline))\n(<= (next (cell ?I ?J b)) (does ?W (mark ?K ?L)) (true (cell ?OldI ?OldJ b)) (update ?OldI ?OldJ ?I ?J) (distinct ?K ?OldI) (not futureline))\n(<= (next (cell ?I ?J b)) (does ?W (mark ?K ?L)) (true (cell ?OldI ?OldJ b)) (update ?OldI ?OldJ ?I ?J) (distinct ?L ?OldJ) (not futureline))\n(<= (sign o) (true (control oplayer)))\n(<= (sign x) (true (control xplayer)))\n(<= (futurerow ?M ?P ?W) (does ?P (mark ?M 1)) (sign ?W) (true (cell ?M 2 ?W)) (true (cell ?M 3 ?W)) (true (cell ?M 4 ?W)) (true (cell ?M 5 ?W)))\n(<= (futurerow ?M ?P ?W) (true (cell ?M 1 ?W)) (does ?P (mark ?M 2)) (sign ?W) (true (cell ?M 3 ?W)) (true (cell ?M 4 ?W)) (true (cell ?M 5 ?W)))\n(<= (futurerow ?M ?P ?W) (true (cell ?M 1 ?W)) (true (cell ?M 2 ?W)) (does ?P (mark ?M 3)) (sign ?W) (true (cell ?M 4 ?W)) (true (cell ?M 5 ?W)))\n(<= (futurerow ?M ?P ?W) (true (cell ?M 1 ?W)) (true (cell ?M 2 ?W)) (true (cell ?M 3 ?W)) (does ?P (mark ?M 4)) (sign ?W) (true (cell ?M 5 ?W)))\n(<= (futurerow ?M ?P ?W) (true (cell ?M 1 ?W)) (true (cell ?M 2 ?W)) (true (cell ?M 3 ?W)) (true (cell ?M 4 ?W)) (does ?P (mark ?M 5)) (sign ?W))\n(<= (futurecolumn ?N ?P ?W) (does ?P (mark 1 ?N)) (sign ?W) (true (cell 2 ?N ?W)) (true (cell 3 ?N ?W)) (true (cell 4 ?N ?W)) (true (cell 5 ?N ?W)))\n(<= (futurecolumn ?N ?P ?W) (true (cell 1 ?N ?W)) (does ?P (mark 2 ?N)) (sign ?W) (true (cell 3 ?N ?W)) (true (cell 4 ?N ?W)) (true (cell 5 ?N ?W)))\n(<= (futurecolumn ?N ?P ?W) (true (cell 1 ?N ?W)) (true (cell 2 ?N ?W)) (does ?P (mark 3 ?N)) (sign ?W) (true (cell 4 ?N ?W)) (true (cell 5 ?N ?W)))\n(<= (futurecolumn ?N ?P ?W) (true (cell 1 ?N ?W)) (true (cell 2 ?N ?W)) (true (cell 3 ?N ?W)) (does ?P (mark 4 ?N)) (sign ?W) (true (cell 5 ?N ?W)))\n(<= (futurecolumn ?N ?P ?W) (true (cell 1 ?N ?W)) (true (cell 2 ?N ?W)) (true (cell 3 ?N ?W)) (true (cell 4 ?N ?W)) (does ?P (mark 5 ?N)) (sign ?W))\n(<= (futurediagonal ?P ?W) (does ?P (mark 1 1)) (sign ?W) (true (cell 2 2 ?W)) (true (cell 3 3 ?W)) (true (cell 4 4 ?W)) (true (cell 5 5 ?W)))\n(<= (futurediagonal ?P ?W) (true (cell 1 1 ?W)) (does ?P (mark 2 2)) (sign ?W) (true (cell 3 3 ?W)) (true (cell 4 4 ?W)) (true (cell 5 5 ?W)))\n(<= (futurediagonal ?P ?W) (true (cell 1 1 ?W)) (true (cell 2 2 ?W)) (does ?P (mark 3 3)) (sign ?W) (true (cell 4 4 ?W)) (true (cell 5 5 ?W)))\n(<= (futurediagonal ?P ?W) (true (cell 1 1 ?W)) (true (cell 2 2 ?W)) (true (cell 3 3 ?W)) (does ?P (mark 4 4)) (sign ?W) (true (cell 5 5 ?W)))\n(<= (futurediagonal ?P ?W) (true (cell 1 1 ?W)) (true (cell 2 2 ?W)) (true (cell 3 3 ?W)) (true (cell 4 4 ?W)) (does ?P (mark 5 5)) (sign ?W))\n(<= (futurediagonal ?P ?W) (does ?P (mark 1 5)) (sign ?W) (true (cell 2 4 ?W)) (true (cell 3 3 ?W)) (true (cell 4 2 ?W)) (true (cell 5 1 ?W)))\n(<= (futurediagonal ?P ?W) (true (cell 1 5 ?W)) (does ?P (mark 2 4)) (sign ?W) (true (cell 3 3 ?W)) (true (cell 4 2 ?W)) (true (cell 5 1 ?W)))\n(<= (futurediagonal ?P ?W) (true (cell 1 5 ?W)) (true (cell 2 4 ?W)) (does ?P (mark 3 3)) (sign ?W) (true (cell 4 2 ?W)) (true (cell 5 1 ?W)))\n(<= (futurediagonal ?P ?W) (true (cell 1 5 ?W)) (true (cell 2 4 ?W)) (true (cell 3 3 ?W)) (does ?P (mark 4 2)) (sign ?W) (true (cell 5 1 ?W)))\n(<= (futurediagonal ?P ?W) (true (cell 1 5 ?W)) (true (cell 2 4 ?W)) (true (cell 3 3 ?W)) (true (cell 4 2 ?W)) (does ?P (mark 5 1)) (sign ?W))\n(<= futureline (futurerow ?M ?P ?W))\n(<= futureline (futurecolumn ?M ?P ?W))\n(<= futureline (futurediagonal ?P ?W))\n(update 1 1 1 2)\n(update 1 2 1 3)\n(update 1 3 1 4)\n(update 1 4 1 5)\n(update 1 5 2 5)\n(update 2 1 1 1)\n(update 2 2 3 2)\n(update 2 3 2 2)\n(update 2 4 2 3)\n(update 2 5 3 5)\n(update 3 1 2 1)\n(update 3 2 4 2)\n(update 3 3 3 3)\n(update 3 4 2 4)\n(update 3 5 4 5)\n(update 4 1 3 1)\n(update 4 2 4 3)\n(update 4 3 4 4)\n(update 4 4 3 4)\n(update 4 5 5 5)\n(update 5 1 4 1)\n(update 5 2 5 1)\n(update 5 3 5 2)\n(update 5 4 5 3)\n(update 5 5 5 4)\n(<= (next (control xplayer)) (true (control oplayer)))\n(<= (next (control oplayer)) (true (control xplayer)))\n(<= (row ?M ?W) (true (cell ?M 1 ?W)) (true (cell ?M 2 ?W)) (true (cell ?M 3 ?W)) (true (cell ?M 4 ?W)) (true (cell ?M 5 ?W)))\n(<= (column ?N ?W) (true (cell 1 ?N ?W)) (true (cell 2 ?N ?W)) (true (cell 3 ?N ?W)) (true (cell 4 ?N ?W)) (true (cell 5 ?N ?W)))\n(<= (diagonal ?W) (true (cell 1 1 ?W)) (true (cell 2 2 ?W)) (true (cell 3 3 ?W)) (true (cell 4 4 ?W)) (true (cell 5 5 ?W)))\n(<= (diagonal ?W) (true (cell 1 5 ?W)) (true (cell 2 4 ?W)) (true (cell 3 3 ?W)) (true (cell 4 2 ?W)) (true (cell 5 1 ?W)))\n(<= (line ?W) (row ?M ?W))\n(<= (line ?W) (column ?M ?W))\n(<= (line ?W) (diagonal ?W))\n(<= open (true (cell ?M ?N b)))\n(<= (goal xplayer 100) (line x) (not (line o)))\n(<= (goal xplayer 50) (not (line x)) (not (line o)))\n(<= (goal xplayer 50) (line x) (line o))\n(<= (goal xplayer 0) (not (line x)) (line o))\n(<= (goal oplayer 100) (not (line x)) (line o))\n(<= (goal oplayer 50) (not (line x)) (not (line o)))\n(<= (goal oplayer 50) (line x) (line o))\n(<= (goal oplayer 0) (line x) (not (line o)))\n(<= terminal (line x))\n(<= terminal (line o))\n(<= terminal (not open))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is set on a grid-based board where each cell is identified by a row and a column number, both drawn from a defined numerical range with successor relations establishing order among these numbers. The environment starts with all cells marked as blank, and the single player role, known as the robot, takes turns placing queens onto the board. The initial game state is characterized by a placing counter set to one, indicating the first queen placement. On each turn, the robot must place a queen on a cell that is currently blank, with the legality of the action contingent on the cell's vacancy. The action format consists of the robot choosing to place a queen at a specific row and column coordinate. Each successful placement updates the board by marking the chosen cell as occupied by a queen, while all other cells remain unchanged. After a queen is placed, the placing counter increments by one, guiding the progression toward the game's end. The game continues this turn-by-turn placement process until the placing counter indicates that all required queens have been positioned, at which point the game terminates. The board's boundaries and numerical order implicitly constrain cell coordinates, preventing placements outside the defined grid. Additionally, no two queens may occupy the same cell, ensuring that placement actions cannot target already occupied positions. The game includes an automatic evaluation of whether any queen is under attack; a queen is considered attacked if another queen shares its row, column, or diagonal, determined by arithmetic relations on their coordinates. If any queen is attacked at the end of the game, the robot receives a score of zero; otherwise, it achieves the maximum score of one hundred. Thus, the victory condition requires the robot to place queens so that none threaten each other according to the rules governing attacks, effectively embodying an n-queens puzzle on a numbered grid.",
    "output": "(role robot)\n(<= (init (cell ?row ?col blank))\n    (number ?row)\n    (number ?col))\n(init (placing 1))\n(<= (legal robot (place ?row ?col))\n    (true (cell ?row ?col blank)))\n(<= (next (cell ?row ?col queen))\n    (does robot (place ?row ?col)))\n(<= (next (cell ?row ?col ?type))\n    (true (cell ?row ?col ?type))\n    (not (does robot (place ?row ?col))))\n(<= (next (placing ?n2))\n    (true (placing ?n1))\n    (succ ?n1 ?n2))\n(<= terminal\n    (not still_placing))\n(<= still_placing\n    (true (placing ?n)))\n(<= (goal robot 0)\n    (true (cell ?row ?col queen))\n    (attacked ?row ?col))\n(<= (goal robot 100)\n    (not (goal robot 0)))\n(<= (number ?n)\n    (succ ?n ?m))\n(<= (number ?m)\n    (succ ?n ?m))\n(<= (ext_succ ?n1 ?n2)\n    (succ ?n1 ?n2))\n(<= (ext_number ?n)\n    (ext_succ ?n ?m))\n(<= (ext_number ?m)\n    (ext_succ ?n ?m))\n(<= (plus ?n 0 ?n)\n    (ext_number ?n))\n(<= (plus ?x ?y ?z)\n    (ext_succ ?y2 ?y)\n    (ext_succ ?x ?x2)\n    (plus ?x2 ?y2 ?z))\n(type queen)\n(type blank)\n(<= (attacked ?row ?col)\n    (true (cell ?row ?col2 queen))\n    (number ?col)\n    (distinct ?col ?col2))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col queen))\n    (number ?row)\n    (distinct ?row ?row2))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col2 queen))\n    (plus ?row ?col ?c)\n    (plus ?row2 ?col2 ?c)\n    (distinct ?row ?row2))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col2 queen))\n    (plus ?c ?col ?row)\n    (plus ?c ?col2 ?row2)\n    (distinct ?row ?row2))\n(succ 1   2)\n(succ 2   3)\n(succ 3   4)\n(succ 4   5)\n(succ 5   6)\n(succ 6   7)\n(succ 7   8)\n(succ 8   9)\n(succ 9  10)\n(succ 10 11)\n(succ 11 12)\n(ext_succ m12 m11)\n(ext_succ m11 m10)\n(ext_succ m10 m9)\n(ext_succ m9  m8)\n(ext_succ m8  m7)\n(ext_succ m7  m6)\n(ext_succ m6  m5)\n(ext_succ m5  m4)\n(ext_succ m4  m3)\n(ext_succ m3  m2)\n(ext_succ m2  m1)\n(ext_succ m1   0)\n(ext_succ  0   1)\n(ext_succ  1   2)\n(ext_succ  2   3)\n(ext_succ  3   4)\n(ext_succ  4   5)\n(ext_succ  5   6)\n(ext_succ  6   7)\n(ext_succ  7   8)\n(ext_succ  8   9)\n(ext_succ  9  10)\n(ext_succ 10  11)\n(ext_succ 11  12)\n(ext_succ 12  13)\n(ext_succ 13  14)\n(ext_succ 14  15)\n(ext_succ 15  16)\n(ext_succ 16  17)\n(ext_succ 17  18)\n(ext_succ 18  19)\n(ext_succ 19  20)\n(ext_succ 20  21)\n(ext_succ 21  22)\n(ext_succ 22  23)\n(ext_succ 23  24)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played in an environment consisting of a three-dimensional grid structured as a 3x3x3 cube of smaller 3x3 cells, effectively forming a 3x3 arrangement of 3x3 Sudoku-like boards. The coordinate system uses four indices: the first two indices (i and j) identify which of the nine 3x3 sub-boards (or \"squares\") within the larger cube is referenced, with values ranging from 1 to 3; the next two indices (k and l) specify the position within each 3x3 sub-board, also each ranging from 1 to 3. There is a single player role named \"robot\" who takes all turns sequentially throughout the game. The initial state is a partially filled set of cells across the 3x3x3 cube, where each cell may contain a digit from 1 to 9 or be blank (represented as 'b'). The player makes moves by marking a blank cell with a digit from 1 to 9, abiding by the constraint that the chosen digit cannot already exist in the same row, column, or 3x3 sub-board of the cell being marked. More specifically, the \"row\" constraint applies to all cells sharing the same k and l indices across all i and j coordinates, the \"column\" constraint applies to all cells sharing the same i and j coordinates but varying k and l, and the \"square\" constraint applies to the 3x3 sub-board indexed by i and j with fixed k indices. An action is legal only if the targeted cell is currently blank and the digit placed does not violate these Sudoku-like uniqueness rules within its corresponding row, column, or sub-board. On each turn, the robot selects one such legal action to mark a cell. If no legal moves are available, the game terminates. The state updates by replacing the blank cell at the specified coordinates with the chosen digit, while all other cells remain unchanged. The game ends when no empty cells remain or no legal moves can be made, indicated by the absence of any playable moves. The robot's goal is to correctly fill all blank cells without violating the Sudoku constraints, achieving a perfect completion of the puzzle; successful completion awards a goal value of 100, whereas failure to do so results in a goal value of 0. There is no explicit noop action mentioned; the game implicitly ends if no legal marking moves are available. The board boundaries are strictly enforced to the 1-to-3 range for all indices, and occupancy conflicts prevent placing digits in already occupied cells. The victory condition is thus the full and valid completion of the Sudoku-like cube, with scoring based solely on whether the puzzle is completely and correctly solved.",
    "output": "(role robot)\n  (init (cell 1 1 1 1 b))\n  (init (cell 1 1 1 2 9))\n  (init (cell 1 1 1 3 8))\n  (init (cell 1 1 2 1 5))\n  (init (cell 1 1 2 2 b))\n  (init (cell 1 1 2 3 b))\n  (init (cell 1 1 3 1 2))\n  (init (cell 1 1 3 2 b))\n  (init (cell 1 1 3 3 b))\n  (init (cell 1 2 1 1 1))\n  (init (cell 1 2 1 2 b))\n  (init (cell 1 2 1 3 b))\n  (init (cell 1 2 2 1 b))\n  (init (cell 1 2 2 2 b))\n  (init (cell 1 2 2 3 b))\n  (init (cell 1 2 3 1 b))\n  (init (cell 1 2 3 2 b))\n  (init (cell 1 2 3 3 4))\n  (init (cell 1 3 1 1 b))\n  (init (cell 1 3 1 2 5))\n  (init (cell 1 3 1 3 b))\n  (init (cell 1 3 2 1 b))\n  (init (cell 1 3 2 2 b))\n  (init (cell 1 3 2 3 b))\n  (init (cell 1 3 3 1 b))\n  (init (cell 1 3 3 2 3))\n  (init (cell 1 3 3 3 b))\n  (init (cell 2 1 1 1 b))\n  (init (cell 2 1 1 2 b))\n  (init (cell 2 1 1 3 2))\n  (init (cell 2 1 2 1 6))\n  (init (cell 2 1 2 2 4))\n  (init (cell 2 1 2 3 3))\n  (init (cell 2 1 3 1 1))\n  (init (cell 2 1 3 2 b))\n  (init (cell 2 1 3 3 b))\n  (init (cell 2 2 1 1 b))\n  (init (cell 2 2 1 2 b))\n  (init (cell 2 2 1 3 b))\n  (init (cell 2 2 2 1 9))\n  (init (cell 2 2 2 2 b))\n  (init (cell 2 2 2 3 8))\n  (init (cell 2 2 3 1 b))\n  (init (cell 2 2 3 2 b))\n  (init (cell 2 2 3 3 b))\n  (init (cell 2 3 1 1 b))\n  (init (cell 2 3 1 2 b))\n  (init (cell 2 3 1 3 7))\n  (init (cell 2 3 2 1 1))\n  (init (cell 2 3 2 2 5))\n  (init (cell 2 3 2 3 2))\n  (init (cell 2 3 3 1 6))\n  (init (cell 2 3 3 2 b))\n  (init (cell 2 3 3 3 b))\n  (init (cell 3 1 1 1 b))\n  (init (cell 3 1 1 2 7))\n  (init (cell 3 1 1 3 b))\n  (init (cell 3 1 2 1 b))\n  (init (cell 3 1 2 2 b))\n  (init (cell 3 1 2 3 b))\n  (init (cell 3 1 3 1 b))\n  (init (cell 3 1 3 2 8))\n  (init (cell 3 1 3 3 b))\n  (init (cell 3 2 1 1 2))\n  (init (cell 3 2 1 2 b))\n  (init (cell 3 2 1 3 b))\n  (init (cell 3 2 2 1 b))\n  (init (cell 3 2 2 2 b))\n  (init (cell 3 2 2 3 b))\n  (init (cell 3 2 3 1 b))\n  (init (cell 3 2 3 2 b))\n  (init (cell 3 2 3 3 7))\n  (init (cell 3 3 1 1 b))\n  (init (cell 3 3 1 2 b))\n  (init (cell 3 3 1 3 6))\n  (init (cell 3 3 2 1 b))\n  (init (cell 3 3 2 2 b))\n  (init (cell 3 3 2 3 1))\n  (init (cell 3 3 3 1 5))\n  (init (cell 3 3 3 2 2))\n  (init (cell 3 3 3 3 b))\n  (<= (legal robot (mark ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l b))\n      (digit ?x)\n      (not (row ?k ?l ?x))\n      (not (col ?i ?j ?x))\n      (not (square ?i ?k ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 3 ?k ?l ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 3 ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?i ?j ?k ?l ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?s ?i))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?t ?j))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?u ?k))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?v ?l))\n  (<= (goal robot 100) (not open))\n  (<= (goal robot 0) open)\n  (<= terminal (not playable))\n  (<= (filler ?x) (digit ?x))\n  (filler b)\n  (<= open (true (cell ?i ?j ?k ?l b)))\n  (<= playable (legal robot (mark ?i ?j ?k ?l ?x)))\n  (index 1)\n  (index 2)\n  (index 3)\n  (digit 1)\n  (digit 2)\n  (digit 3)\n  (digit 4)\n  (digit 5)\n  (digit 6)\n  (digit 7)\n  (digit 8)\n  (digit 9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a standard chessboard defined by files labeled from 'a' to 'h' and ranks numbered from 1 to 8, establishing a coordinate system where each cell is identified by a file-rank pair. There are two players, white and black, who alternate turns with white taking the first move. The initial setup places a simplified assortment of pieces on the board: each side has a king, a queen, two rooks, and the rest of the squares are mostly empty, with black pawns occupying several ranks. Control for the first turn is assigned to white. On a player's turn, they may move one of their own pieces according to movement rules specific to the piece type; legal moves must be feasible, meaning the piece belongs to the player in control, it is moved from a cell currently occupied by that piece, and the destination cell must be either empty or occupied by an opponent's piece. Movement rules are standard chess moves for kings, queens, and rooks: kings move one square in any direction adjacent horizontally, vertically, or diagonally; queens combine rook and bishop moves; rooks move any number of squares along a rank or file. Moves must not be obstructed by other pieces along the path—columns, rows, and diagonals need to be clear for the piece to move accordingly. After a move, the piece is relocated to the destination cell, and any opponent's piece there is captured and removed from play, reducing the opponent's piece count by one. The player in control switches to the opponent automatically after each move, ensuring alternate turns. If it is not a player's turn, they may issue a noop (no operation) action, which is legal only when the other player has the move. The game advances in discrete steps, incrementing a step counter each turn. The game terminates when either player has no remaining pieces on the board or when the step counter reaches 11, signaling the end of the game. Scoring is based on the number of opponent pieces remaining, with a scoring scale that assigns the highest score when the opponent has no pieces left and progressively lower scores as more opponent pieces survive. Victory is determined by these scores, rewarding the player who captures more of the opponent's pieces before the terminal condition is met. Implicit constraints ensure that moves must remain within the board boundaries; cells are identified by valid file and rank combinations, and no two pieces may occupy the same cell simultaneously except during a capture move where the opponent's piece is removed. Thus, the game is a turn-based, simplified chess variant focusing on kings, queens, and rooks, where players alternate moving their pieces legally on an 8x8 grid with the objective of capturing the opponent's pieces within a limited number of steps.",
    "output": "(role white)\n(role black)\n(init (cell a 1 wr))\n(init (cell a 2 b))\n(init (cell a 3 b))\n(init (cell a 4 b))\n(init (cell a 5 b))\n(init (cell a 6 b))\n(init (cell a 7 b))\n(init (cell a 8 br))\n(init (cell b 1 b))\n(init (cell b 2 b))\n(init (cell b 3 b))\n(init (cell b 4 b))\n(init (cell b 5 b))\n(init (cell b 6 b))\n(init (cell b 7 b))\n(init (cell b 8 b))\n(init (cell c 1 b))\n(init (cell c 2 b))\n(init (cell c 3 b))\n(init (cell c 4 b))\n(init (cell c 5 b))\n(init (cell c 6 b))\n(init (cell c 7 b))\n(init (cell c 8 b))\n(init (cell d 1 wq))\n(init (cell d 2 b))\n(init (cell d 3 b))\n(init (cell d 4 b))\n(init (cell d 5 b))\n(init (cell d 6 b))\n(init (cell d 7 b))\n(init (cell d 8 bq))\n(init (cell e 1 wk))\n(init (cell e 2 b))\n(init (cell e 3 b))\n(init (cell e 4 b))\n(init (cell e 5 b))\n(init (cell e 6 b))\n(init (cell e 7 b))\n(init (cell e 8 bk))\n(init (cell f 1 b))\n(init (cell f 2 b))\n(init (cell f 3 b))\n(init (cell f 4 b))\n(init (cell f 5 b))\n(init (cell f 6 b))\n(init (cell f 7 b))\n(init (cell f 8 b))\n(init (cell g 1 b))\n(init (cell g 2 b))\n(init (cell g 3 b))\n(init (cell g 4 b))\n(init (cell g 5 b))\n(init (cell g 6 b))\n(init (cell g 7 b))\n(init (cell g 8 b))\n(init (cell h 1 wr))\n(init (cell h 2 b))\n(init (cell h 3 b))\n(init (cell h 4 b))\n(init (cell h 5 b))\n(init (cell h 6 b))\n(init (cell h 7 b))\n(init (cell h 8 br))\n(init (control white))\n(init (pieces white 4))\n(init (pieces black 4))\n(init (step 1))\n(<= (next (cell ?x ?y ?p))\n(does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?u ?v b))\n(does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?x ?y ?p))\n(does ?player (move ?piece ?x1 ?y1 ?x2 ?y2))\n(true (cell ?x ?y ?p))\n(different_cells ?x ?y ?x1 ?y1)\n(different_cells ?x ?y ?x2 ?y2))\n(<= (next (pieces ?player ?n))\n(does ?player (move ?p ?u ?v ?x ?y))\n(true (pieces ?player ?n)))\n(<= (next (pieces ?opponent ?n))\n(does ?player (move ?p ?u ?v ?x ?y))\n(true (cell ?x ?y b))\n(opponent ?player ?opponent)\n(true (pieces ?opponent ?n)))\n(<= (next (pieces ?opponent ?m))\n(does ?player (move ?p ?u ?v ?x ?y))\n(true (cell ?x ?y ?q))\n(distinct ?q b)\n(opponent ?player ?opponent)\n(true (pieces ?opponent ?n))\n(succ ?m ?n))\n(<= (next (control white))\n(true (control black)))\n(<= (next (control black))\n(true (control white)))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(<= (legal ?player ?move)\n(true (control ?player))\n(feasible ?player ?move))\n(<= (feasible ?player (move ?piece ?u ?v ?x ?y))\n(piece_owner_type ?piece ?player king)\n(true (cell ?u ?v ?piece))\n(kingmove ?u ?v ?x ?y)\n(occupied_by_opponent_or_blank ?x ?y ?player))\n(<= (kingmove ?u ?v ?u ?y)\n(nextrank ?v ?y)\n(file ?u))\n(<= (kingmove ?u ?v ?x ?v)\n(nextfile ?u ?x)\n(rank ?v))\n(<= (kingmove ?u ?v ?x ?y)\n(nextfile ?u ?x)\n(nextrank ?v ?y))\n(<= (feasible ?player (move ?piece ?u ?v ?x ?y))\n(piece_owner_type ?piece ?player queen)\n(true (cell ?u ?v ?piece))\n(queenmove ?u ?v ?x ?y)\n(occupied_by_opponent_or_blank ?x ?y ?player))\n(<= (queenmove ?u ?v ?x ?y)\n(bishopmove ?u ?v ?x ?y))\n(<= (queenmove ?u ?v ?x ?y)\n(rookmove ?u ?v ?x ?y))\n(<= (feasible ?player (move ?piece ?u ?v ?x ?y))\n(piece_owner_type ?piece ?player rook)\n(true (cell ?u ?v ?piece))\n(rookmove ?u ?v ?x ?y)\n(occupied_by_opponent_or_blank ?x ?y ?player))\n(<= (rookmove ?u ?v ?u ?y)\n(clear_column ?u ?v ?y))\n(<= (rookmove ?u ?v ?u ?y)\n(clear_column ?u ?y ?v))\n(<= (rookmove ?u ?v ?x ?v)\n(clear_row ?u ?x ?v))\n(<= (rookmove ?u ?v ?x ?v)\n(clear_row ?x ?u ?v))\n(<= (bishopmove ?u ?v ?x ?y)\n(clear_diagonal_ne ?u ?v ?x ?y))\n(<= (bishopmove ?u ?v ?x ?y)\n(clear_diagonal_ne ?x ?y ?u ?v))\n(<= (bishopmove ?u ?v ?x ?y)\n(clear_diagonal_se ?u ?v ?x ?y))\n(<= (bishopmove ?u ?v ?x ?y)\n(clear_diagonal_se ?x ?y ?u ?v))\n(<= (legal white noop)\n(true (control black)))\n(<= (legal black noop)\n(true (control white)))\n(<= (nextfile ?x1 ?x2)\n(next_file ?x1 ?x2))\n(<= (nextfile ?x1 ?x2)\n(next_file ?x2 ?x1))\n(<= (nextrank ?y1 ?y2)\n(next_rank ?y1 ?y2))\n(<= (nextrank ?y1 ?y2)\n(next_rank ?y2 ?y1))\n(<= (adjacent ?x1 ?x2)\n(next_file ?x1 ?x2))\n(<= (adjacent ?x1 ?x2)\n(next_file ?x2 ?x1))\n(<= (adjacent ?y1 ?y2)\n(next_rank ?y1 ?y2))\n(<= (adjacent ?y1 ?y2)\n(next_rank ?y2 ?y1))\n(<= (adjacent_two ?a ?b)\n(adjacent ?a ?mid)\n(adjacent ?mid ?b)\n(distinct ?a ?b))\n(<= (clear_column ?u ?v ?y)\n(next_rank ?v ?y)\n(file ?u))\n(<= (clear_column ?u ?v ?y)\n(next_rank ?v ?w)\n(true (cell ?u ?w b))\n(clear_column ?u ?w ?y))\n(<= (clear_row ?u ?x ?v)\n(next_file ?u ?x)\n(rank ?v))\n(<= (clear_row ?u ?x ?v)\n(next_file ?u ?w)\n(true (cell ?w ?v b))\n(clear_row ?w ?x ?v))\n(<= (clear_diagonal_ne ?u ?v ?x ?y)\n(next_file ?u ?x)\n(next_rank ?v ?y))\n(<= (clear_diagonal_ne ?u ?v ?x ?y)\n(next_file ?u ?u2)\n(next_rank ?v ?v2)\n(true (cell ?u2 ?v2 b))\n(clear_diagonal_ne ?u2 ?v2 ?x ?y))\n(<= (clear_diagonal_se ?u ?v ?x ?y)\n(next_file ?u ?x)\n(next_rank ?y ?v))\n(<= (clear_diagonal_se ?u ?v ?x ?y)\n(next_file ?u ?u2)\n(next_rank ?v2 ?v)\n(true (cell ?u2 ?v2 b))\n(clear_diagonal_se ?u2 ?v2 ?x ?y))\n(<= (different_cells ?x1 ?y1 ?x2 ?y2)\n(distinct ?x1 ?x2)\n(file ?x1)\n(file ?x2)\n(rank ?y1)\n(rank ?y2))\n(<= (different_cells ?x1 ?y1 ?x2 ?y2)\n(distinct ?y1 ?y2)\n(file ?x1)\n(file ?x2)\n(rank ?y1)\n(rank ?y2))\n(<= (occupied_by_opponent_or_blank ?x ?y ?player)\n(true (cell ?x ?y b))\n(role ?player))\n(<= (occupied_by_opponent_or_blank ?x ?y ?player)\n(true (cell ?x ?y ?piece))\n(opponent ?player ?opponent)\n(piece_owner_type ?piece ?opponent ?type))\n(<= (goal white ?n)\n(true (pieces black ?m))\n(score ?m ?n))\n(<= (goal black ?n)\n(true (pieces white ?m))\n(score ?m ?n))\n(<= terminal\n(true (step 11)))\n(<= terminal\n(true (pieces white 0)))\n(<= terminal\n(true (pieces black 0)))\n(opponent white black)\n(opponent black white)\n(piece_owner_type wk white king)\n(piece_owner_type wq white queen)\n(piece_owner_type wr white rook)\n(piece_owner_type wb white bishop)\n(piece_owner_type wn white knight)\n(piece_owner_type wp white pawn)\n(piece_owner_type bk black king)\n(piece_owner_type bq black queen)\n(piece_owner_type br black rook)\n(piece_owner_type bb black bishop)\n(piece_owner_type bn black knight)\n(piece_owner_type bp black pawn)\n(next_rank 1 2)\n(next_rank 2 3)\n(next_rank 3 4)\n(next_rank 4 5)\n(next_rank 5 6)\n(next_rank 6 7)\n(next_rank 7 8)\n(next_file a b)\n(next_file b c)\n(next_file c d)\n(next_file d e)\n(next_file e f)\n(next_file f g)\n(next_file g h)\n(file a)\n(file b)\n(file c)\n(file d)\n(file e)\n(file f)\n(file g)\n(file h)\n(rank 1)\n(rank 2)\n(rank 3)\n(rank 4)\n(rank 5)\n(rank 6)\n(rank 7)\n(rank 8)\n(score  0 100)\n(score  1  75)\n(score  2  50)\n(score  3  25)\n(score  4  0)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game takes place on an 8-by-8 grid with coordinates labeled from 1 to 8 along both the x and y axes. Four players participate, each assigned a unique role identified by a color: blue, red, green, and yellow. The order of play follows these roles, presumably in the sequence blue, red, green, then yellow, cycling continuously through the turns. At the start, each player’s brush piece is located on a specific starting cell: blue’s brush at (2,2), red’s at (2,7), green’s at (7,2), and yellow’s at (7,7). Correspondingly, these starting cells are initially colored to match the respective player's color, while the rest of the board begins uncolored. During each turn, a player may choose to move their brush to an adjacent cell—adjacency being defined as horizontally or vertically neighboring cells within the board boundaries—and by doing so, the player colors that cell with their own color. A player’s move is legal only if the cell they wish to move to is adjacent to their brush’s current location and is not already occupied by any brush. A player who is in a \"dizzy\" state, indicated by a status flag that lasts for two full turns after an interaction, cannot move their brush. The dizzy state is triggered if a player attempts to move their brush onto a cell targeted simultaneously by at least one other player; in this case, none of the competing moves color the cell, but the involved players become dizzy starting the next turn. If a player is dizzy or if their brush is completely surrounded by occupied cells with no empty adjacent cells, their only legal action is to \"feeldizzy,\" effectively a no-operation that allows the dizzy status to wear off. The brush positions update automatically based on each player's move, or remain unchanged if the player is dizzy or chooses to feeldizzy. The coloring of cells also updates accordingly: if a player successfully moves their brush to a cell without conflict, that cell’s color changes to that player’s color; if multiple players attempt to move to the same cell, that cell’s color remains as it was, and the involved players become dizzy. The game proceeds turn by turn with a step counter incrementing each turn until it reaches 20, at which point the game ends. Throughout the game, players accumulate points by counting the number of cells on the board that match their respective color. Victory is determined at the end after 20 steps by comparing the players’ scores: the player with the highest score receives the highest reward, while ties and placements are resolved with a tiered scoring system that assigns fractional or zero points based on relative standings and equalities among the four players. Players cannot move their brushes outside the 8x8 grid, and brush pieces cannot occupy the same cell simultaneously. The game’s goal is to maximize the number of cells painted with a player’s own color by strategically moving brushes, managing dizzy states, and competing for control over cells on the board before the 20th turn concludes the play.",
    "output": "(role blue)\n(role red)\n(role green)\n(role yellow)\n(startingcell 2 2)\n(startingcell 2 7)\n(startingcell 7 2)\n(startingcell 7 7)\n(<= (init (cell ?x ?y b))\n    (coordinate ?x)\n    (coordinate ?y)\n    (not (startingcell ?x ?y)))\n(init (cell 2 2 blue))\n(init (cell 2 7 red))\n(init (cell 7 2 green))\n(init (cell 7 7 yellow))\n(init (at bluebrush 2 2))\n(init (at redbrush 2 7))\n(init (at greenbrush 7 2))\n(init (at yellowbrush 7 7))\n(brush blue bluebrush)\n(brush red redbrush)\n(brush green greenbrush)\n(brush yellow yellowbrush)\n(<= (next (cell ?x ?y ?c))\n    (nextcellcolor ?x ?y ?c))\n(<= (nextcellcolor ?x ?y ?s)\n    (true (cell ?x ?y ?s))\n    (not (does blue (goto ?x ?y)))\n    (not (does red (goto ?x ?y)))\n    (not (does green (goto ?x ?y)))\n    (not (does yellow (goto ?x ?y))))\n(<= (nextcellcolor ?x ?y ?s)\n    (true (cell ?x ?y ?s))\n    (role ?r)\n    (does ?r (goto ?x ?y))\n    (role ?r2)\n    (distinct ?r ?r2)\n    (does ?r2 (goto ?x ?y)))\n(<= (nextcellcolor ?x ?y blue)\n    (does blue (goto ?x ?y))\n    (not (does red (goto ?x ?y)))\n    (not (does green (goto ?x ?y)))\n    (not (does yellow (goto ?x ?y))))\n(<= (nextcellcolor ?x ?y red)\n    (does red (goto ?x ?y))\n    (not (does blue (goto ?x ?y)))\n    (not (does green (goto ?x ?y)))\n    (not (does yellow (goto ?x ?y))))\n(<= (nextcellcolor ?x ?y green)\n    (does green (goto ?x ?y))\n    (not (does blue (goto ?x ?y)))\n    (not (does red (goto ?x ?y)))\n    (not (does yellow (goto ?x ?y))))\n(<= (nextcellcolor ?x ?y yellow)\n    (does yellow (goto ?x ?y))\n    (not (does blue (goto ?x ?y)))\n    (not (does red (goto ?x ?y)))\n    (not (does green (goto ?x ?y))))\n(<= (legal ?r (goto ?x ?y))\n    (role ?r)\n    (not (true (dizzy ?r 1)))\n    (not (true (dizzy ?r 0)))\n    (true (cell ?x ?y ?s))\n    (not (occupied ?x ?y))\n    (brush ?r ?b)\n    (true (at ?b ?i ?j))\n    (adjacent ?x ?y ?i ?j))\n(<= (occupied ?x ?y)\n    (true (at ?b ?x ?y)))\n(<= (legal ?r feeldizzy)\n    (true (dizzy ?r ?n)))\n(<= (legal ?r feeldizzy)\n    (brush ?r ?b)\n    (true (at ?b ?x ?y))\n    (not (hasAdjacentEmptyCell ?x ?y)))\n(<= (hasAdjacentEmptyCell ?x ?y)\n    (adjacent ?x ?y ?x2 ?y2)\n    (not (occupied ?x2 ?y2)))\n(<= (adjacent ?x ?y ?x ?j)\n    (coordinate ?x)\n    (nextIndex ?y ?j))\n(<= (adjacent ?x ?y ?x ?j)\n    (coordinate ?x)\n    (nextIndex ?j ?y))\n(<= (adjacent ?x ?y ?i ?y)\n    (coordinate ?y)\n    (nextIndex ?x ?i))\n(<= (adjacent ?x ?y ?i ?y)\n    (coordinate ?y)\n    (nextIndex ?i ?x))\n(<= (next (at bluebrush ?x ?y))\n    (does blue (goto ?x ?y))\n    (not (does red (goto ?x ?y)))\n    (not (does green (goto ?x ?y)))\n    (not (does yellow (goto ?x ?y))))\n(<= (next (at redbrush ?x ?y))\n    (does red (goto ?x ?y))\n    (not (does blue (goto ?x ?y)))\n    (not (does green (goto ?x ?y)))\n    (not (does yellow (goto ?x ?y))))\n(<= (next (at greenbrush ?x ?y))\n    (does green (goto ?x ?y))\n    (not (does blue (goto ?x ?y)))\n    (not (does red (goto ?x ?y)))\n    (not (does yellow (goto ?x ?y))))\n(<= (next (at yellowbrush ?x ?y))\n    (does yellow (goto ?x ?y))\n    (not (does blue (goto ?x ?y)))\n    (not (does red (goto ?x ?y)))\n    (not (does green (goto ?x ?y))))\n(<= (next (at ?b ?x ?y))\n    (role ?r)\n    (brush ?r ?b)\n    (true (at ?b ?x ?y))\n    (willfeeldizzy ?r))\n(<= (next (at ?b ?x ?y))\n    (role ?r)\n    (brush ?r ?b)\n    (true (at ?b ?x ?y))\n    (does ?r feeldizzy))\n(<= (next (dizzy ?r 1))\n    (willfeeldizzy ?r))\n(<= (next (dizzy ?r 0))\n    (true (dizzy ?r 1)))\n(<= (willfeeldizzy ?r)\n    (role ?r)\n    (does ?r (goto ?i ?j))\n    (role ?r2)\n    (distinct ?r ?r2)\n    (does ?r2 (goto ?i ?j)))\n(nextIndex 1 2)\n(nextIndex 2 3)\n(nextIndex 3 4)\n(nextIndex 4 5)\n(nextIndex 5 6)\n(nextIndex 6 7)\n(nextIndex 7 8)\n(<= (threeDistinctRoles ?r1 ?r2 ?r3)\n    (role ?r1)\n    (role ?r2)\n    (role ?r3)\n    (distinct ?r1 ?r2)\n    (distinct ?r1 ?r3)\n    (distinct ?r2 ?r3))\n(succ -1 0)\n(succ 0 1)\n(<= (moreThan ?n ?n2)\n    (succ ?n2 ?n))\n(<= (moreThan ?n ?n2)\n    (succ ?t ?n)\n    (moreThan ?t ?n2))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(<= (points blue ?p)\n    (calculatePoints blue ?p 1 1))\n(<= (points red ?p)\n    (calculatePoints red ?p 1 1))\n(<= (points green ?p)\n    (calculatePoints green ?p 1 1))\n(<= (points yellow ?p)\n    (calculatePoints yellow ?p 1 1))\n(<= (calculatePoints ?r ?pp1 ?x ?y)\n    (true (cell ?x ?y ?r))\n    (nextIndex ?y ?y2)\n    (calculatePoints ?r ?p ?x ?y2)\n    (succ ?p ?pp1))\n(<= (calculatePoints ?r ?pp1 ?x 8)\n    (true (cell ?x 8 ?r))\n    (nextIndex ?x ?x2)\n    (calculatePoints ?r ?p ?x2 1)\n    (succ ?p ?pp1))\n(<= (calculatePoints ?r ?p ?x ?y)\n    (coordinate ?x)\n    (coordinate ?y)\n    (role ?r)\n    (not (true (cell ?x ?y ?r)))\n    (nextIndex ?y ?y2)\n    (calculatePoints ?r ?p ?x ?y2))\n(<= (calculatePoints ?r ?p ?x 8)\n    (coordinate ?x)\n    (role ?r)\n    (not (true (cell ?x 8 ?r)))\n    (nextIndex ?x ?x2)\n    (calculatePoints ?r ?p ?x2 1))\n(<= (calculatePoints ?r 1 8 8)\n    (true (cell 8 8 ?r)))\n(<= (calculatePoints ?r 0 8 8)\n    (role ?r)\n    (not (true (cell 8 8 ?r))))\n(init (step 1))\n(<= (next (step ?n2))\n    (true (step ?n))\n    (succ ?n ?n2))\n(<= terminal\n    (true (step 20)))\n(coordinate 1)\n(coordinate 2)\n(coordinate 3)\n(coordinate 4)\n(coordinate 5)\n(coordinate 6)\n(coordinate 7)\n(coordinate 8)\n(<= (sameScore ?r1 ?r2)\n    (points ?r1 ?n)\n    (points ?r2 ?n)\n    (distinct ?r1 ?r2))\n(<= (higherScore ?r1 ?r2)\n    (points ?r1 ?n1)\n    (points ?r2 ?n2)\n    (moreThan ?n1 ?n2))\n(<= (goal ?r 100)\n    (true (step 20))\n    (higherScore ?r ?r2)\n    (higherScore ?r ?r3)\n    (higherScore ?r ?r4)\n    (threeDistinctRoles ?r2 ?r3 ?r4))\n(<= (goal ?r 50)\n    (true (step 20))\n    (higherScore ?r2 ?r)\n    (higherScore ?r ?r3)\n    (higherScore ?r ?r4)\n    (distinct ?r3 ?r4))\n(<= (goal ?r 25)\n    (true (step 20))\n    (higherScore ?r2 ?r)\n    (higherScore ?r3 ?r)\n    (distinct ?r2 ?r3)\n    (higherScore ?r ?r4))\n(<= (goal ?r 0)\n    (true (step 20))\n    (higherScore ?r2 ?r)\n    (higherScore ?r3 ?r)\n    (higherScore ?r4 ?r)\n    (threeDistinctRoles ?r2 ?r3 ?r4))\n(<= (goal ?r 75)\n    (true (step 20))\n    (sameScore ?r ?r2)\n    (higherScore ?r ?r3)\n    (higherScore ?r ?r4)\n    (distinct ?r3 ?r4))\n(<= (goal ?r 66)\n    (true (step 20))\n    (sameScore ?r ?r2)\n    (sameScore ?r ?r3)\n    (distinct ?r2 ?r3)\n    (higherScore ?r ?r4))\n(<= (goal ?r 50)\n    (true (step 20))\n    (sameScore ?r ?r2)\n    (sameScore ?r ?r3)\n    (sameScore ?r ?r4)\n    (threeDistinctRoles ?r2 ?r3 ?r4))\n(<= (goal ?r 33)\n    (true (step 20))\n    (sameScore ?r ?r2)\n    (higherScore ?r3 ?r)\n    (higherScore ?r ?r4))\n(<= (goal ?r 25)\n    (true (step 20))\n    (sameScore ?r ?r2)\n    (sameScore ?r ?r3)\n    (distinct ?r2 ?r3)\n    (higherScore ?r4 ?r))\n(<= (goal ?r 12)\n    (true (step 20))\n    (sameScore ?r ?r2)\n    (higherScore ?r3 ?r)\n    (higherScore ?r4 ?r)\n    (distinct ?r3 ?r4))\n(<= (goal ?r 0)\n    (role ?r)\n    (not (true (step 20))))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a four-dimensional grid with coordinates labeled i, j, k, and l, each ranging from 1 to 3, forming a 3x3x3x3 board. There are two players, named red and blue, who alternate turns with red moving first. The red player uses the marker \"x\" and the blue player uses the marker \"o\", although these assignments can be swapped by the blue player once per game through a special \"swap\" action. The initial state sets red as the player in control and assigns the markers accordingly, with the swap option available. On a player's turn, if they do not have control, their only legal move is to pass by performing a \"noop\" action. When a player has control, they can choose to place their marker on an empty cell specified by its four coordinates, provided the cell is unoccupied. During the very first move, the current board is considered empty and the player must place their marker on any empty cell. Otherwise, moves must be made on the current active board, identified by coordinates k and l, which is a 3x3 sub-board within the larger 4D grid; this current board can change as players place markers in different sub-boards. The blue player may also execute a \"swap\" action instead of placing a marker, but only if the swap option is still available, which then exchanges the markers used by red and blue for the rest of the game and disables future swaps. After each play action, the chosen cell is marked with the player's current marker and control passes to the opposing player. If blue performs a swap, the markers for red and blue switch accordingly but the control remains with blue until their next action. The game enforces implicit constraints including the board boundaries defined by the indices 1 to 3 in each dimension, that a cell must be empty to be marked, and that the current board must be either the first move or a previously defined sub-board that is completely filled before moving on. The game concludes when a line of three identical markers is formed in any of the dimensions or diagonals within any 3x3 sub-board, or when there are no empty cells left on the current board, indicating a closed board state. Lines can be horizontal rows, vertical columns, or either of the two main diagonals within a 3x3 board at fixed coordinates. Victory is determined by awarding 100 points to a player who completes such a line with their marker. If the board is full without any completed lines, the players receive 50 points each, signifying a draw. Any other state at termination results in zero points. The game thus requires strategic placement of markers within the multidimensional board, using turns alternately, with an optional swap by blue to gain a tactical advantage, and concludes when a player successfully forms a line or the board is filled, with points assigned accordingly.",
    "output": "(role red)\n(role blue)\n(init (control red))\n(init (usingMarker red x))\n(init (usingMarker blue o))\n(init canSwap)\n(<= (legal red noop)\n (true (control blue)))\n(<= (legal blue noop)\n (true (control red)))\n(<= (legal blue swap)\n (true (control blue))\n (true canSwap))\n(<= (legal ?r (play ?i ?j ?k ?l ?m))\n (true (control ?r))\n firstMove\n (true (usingMarker ?r ?m))\n (emptyCell ?i ?j ?k ?l))\n(<= (legal ?r (play ?i ?j ?k ?l ?m))\n (true (control ?r))\n (true (currentBoard ?i ?j))\n (true (usingMarker ?r ?m))\n (emptyCell ?i ?j ?k ?l))\n(<= (legal ?r (play ?i ?j ?k ?l ?m))\n (true (control ?r))\n currentBoardClosed\n (true (usingMarker ?r ?m))\n (emptyCell ?i ?j ?k ?l))\n(<= (next (mark ?i ?j ?k ?l ?mark))\n (role ?player)\n (does ?player (play ?i ?j ?k ?l ?mark)))\n(<= (next (mark ?i ?j ?k ?l ?mark))\n (true (mark ?i ?j ?k ?l ?mark)))\n(<= (next (control red))\n (true (control blue)))\n(<= (next (control blue))\n (true (control red)))\n(<= (next (currentBoard ?k ?l))\n (role ?player)\n (does ?player (play ?i ?j ?k ?l ?mark)))\n(<= (next (currentBoard ?k ?l))\n (true (currentBoard ?k ?l))\n (does blue swap))\n(<= (next (usingMarker ?r ?m))\n (true (usingMarker ?r ?m))\n (not (does blue swap)))\n(<= (next (usingMarker red o))\n (does blue swap))\n(<= (next (usingMarker blue x))\n (does blue swap))\n(<= (next canSwap)\n (true canSwap)\n (does blue noop))\n(<= terminal\n (line x))\n(<= terminal\n (line o))\n(<= terminal\n (not open))\n(<= (goal ?r 100)\n (true (usingMarker ?r ?m))\n (line ?m))\n(<= (goal ?r 50)\n (role ?r)\n (not (line x))\n (not (line o))\n (not open))\n(<= (goal ?r 0)\n (role ?r)\n (not (goal ?r 100))\n (not (goal ?r 50)))\n(<= (row ?i ?j ?k ?mark)\n (true (mark ?i ?j ?k 1 ?mark))\n (true (mark ?i ?j ?k 2 ?mark))\n (true (mark ?i ?j ?k 3 ?mark)))\n(<= (col ?i ?j ?k ?mark)\n (true (mark ?i ?j 1 ?k ?mark))\n (true (mark ?i ?j 2 ?k ?mark))\n (true (mark ?i ?j 3 ?k ?mark)))\n(<= (diag ?i ?j ?mark)\n (true (mark ?i ?j 1 1 ?mark))\n (true (mark ?i ?j 2 2 ?mark))\n (true (mark ?i ?j 3 3 ?mark)))\n(<= (diag ?i ?j ?mark)\n (true (mark ?i ?j 1 3 ?mark))\n (true (mark ?i ?j 2 2 ?mark))\n (true (mark ?i ?j 3 1 ?mark)))\n(<= (line ?mark)\n (index ?i)\n (index ?j)\n (index ?k)\n (row ?i ?j ?k ?mark))\n(<= (line ?mark)\n (index ?i)\n (index ?j)\n (index ?k)\n (col ?i ?j ?k ?mark))\n(<= (line ?mark)\n (index ?i)\n (index ?j)\n (diag ?i ?j ?mark))\n(<= (emptyCell ?i ?j ?k ?l)\n (index ?i)\n (index ?j)\n (index ?k)\n (index ?l)\n (not (true (mark ?i ?j ?k ?l x)))\n (not (true (mark ?i ?j ?k ?l o))))\n(<= open (emptyCell ?i ?j ?k ?l))\n(<= currentBoardClosed\n (true (currentBoard ?i ?j))\n (not (emptyCell ?i ?j 1 1))\n (not (emptyCell ?i ?j 1 2))\n (not (emptyCell ?i ?j 1 3))\n (not (emptyCell ?i ?j 2 1))\n (not (emptyCell ?i ?j 2 2))\n (not (emptyCell ?i ?j 2 3))\n (not (emptyCell ?i ?j 3 1))\n (not (emptyCell ?i ?j 3 2))\n (not (emptyCell ?i ?j 3 3)))\n(<= firstMove\n (not (true (currentBoard 1 1)))\n (not (true (currentBoard 1 2)))\n (not (true (currentBoard 1 3)))\n (not (true (currentBoard 2 1)))\n (not (true (currentBoard 2 2)))\n (not (true (currentBoard 2 3)))\n (not (true (currentBoard 3 1)))\n (not (true (currentBoard 3 2)))\n (not (true (currentBoard 3 3))))\n(index 1) (index 2) (index 3)\n(marker x) (marker o)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a hexagonal-like coordinate grid with positions labeled from a1 through i1, arranged in rows of varying length, creating a non-rectangular board. The coordinate system uses letter-number pairs to identify each cell uniquely. There is a single player role named red, who controls pieces initially placed on cells a1, b1, and b2. The game proceeds in discrete steps, starting at step 1 and incrementing by one each turn, up to a maximum of step 40, which serves as one terminal condition. Each turn, the red player may choose either to make a move or perform a noop action, which is always legal for the player. Moves consist of relocating a piece from one occupied cell to another specific empty cell, following a set of movement rules defined by chains of adjacency relations called \"car\" and \"cdr\" that represent allowed paths on the board; these adjacency relations dictate which cells are reachable from others. A move is legal if it starts from a cell currently occupied by the player's piece and follows these adjacency patterns, requiring certain intermediate cells to be occupied or empty accordingly, effectively enforcing that pieces can only jump over other pieces or move to adjacent empty cells in specified configurations. When a move is made, the piece vacates its original cell, and the destination cell becomes occupied by the player's piece; all other cells remain unchanged unless affected by the move. The player may also choose noop, which results in no change to the board state but advances the game step counter. The game ends either when the step count reaches 40 or when the player's pieces occupy a specific trio of cells denoted h1, h2, and i1 simultaneously. Scoring is determined by the occupancy of these three particular cells: if all three are occupied by the player's pieces, the player scores 100 points, which also triggers game termination; if two of these cells are occupied, the player scores 50 points; if only one cell is occupied, the player scores 25 points; and if none are occupied, the score is zero. The objective is to maximize this score by positioning pieces strategically over the course of the turns, with victory achieved by reaching the highest possible score before the game ends either by step limit or by occupying all three target cells. Throughout the game, implicit constraints prevent moves off the board or onto occupied cells except as allowed by the movement rules, ensuring piece positions remain within the defined grid and respecting the occupancy and adjacency conditions at all times.",
    "output": "(role red)\n(index a1)\n(index b1) (index b2)\n(index c1) (index c2) (index c3) (index c4) (index c5) (index c6) (index c7)\n(index d1) (index d2) (index d3) (index d4) (index d5) (index d6)\n(index e1) (index e2) (index e3) (index e4) (index e5)\n(index f1) (index f2) (index f3) (index f4) (index f5) (index f6)\n(index g1) (index g2) (index g3) (index g4) (index g5) (index g6) (index g7)\n(index h1) (index h2)\n(index i1)\n(init (cell a1 red))\n(init (cell b1 red))\n(init (cell b2 red))\n(init (step 1))\n(<= (next (cell ?e ?player))\n    (does ?player (move ?b ?e)))\n(<= (next (cell ?x ?z))\n    (true (cell ?x ?z))\n    (not (affected ?x)))\n(<= (affected ?x)\n    (does ?player (move ?x ?z)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (succ ?x ?y))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(<= (legal ?player (move ?b ?e))\n    (movable ?player ?b ?e))\n(<= (legal ?player noop)\n    (role ?player))\n(<= (occupied ?c)\n    (true (cell ?c ?p)))\n(<= (empty ?c)\n    (index ?c)\n    (not (occupied ?c)))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?e)\n    (empty ?e))\n(<= (car red ?b ?e)\n    (carred ?b ?e))\n(<= (cdr red ?b ?e)\n    (cdrred ?b ?e))\n(carred a1 b1)\n(carred b1 c3)\n(carred b2 c4)\n(carred c3 d2)\n(carred c4 d3)\n(carred c5 d4)\n(carred d2 e1)\n(carred d3 e2)\n(carred d4 e3)\n(carred d5 e4)\n(carred e2 f2)\n(carred e3 f3)\n(carred e4 f4)\n(carred e5 f5)\n(carred f3 g3)\n(carred f4 g4)\n(carred f5 g5)\n(carred g4 h1)\n(carred g5 h2)\n(carred h2 i1)\n(cdrred a1 b2)\n(cdrred b1 c4)\n(cdrred b2 c5)\n(cdrred c3 d3)\n(cdrred c4 d4)\n(cdrred c5 d5)\n(cdrred d2 e2)\n(cdrred d3 e3)\n(cdrred d4 e4)\n(cdrred d5 e5)\n(cdrred e1 f2)\n(cdrred e2 f3)\n(cdrred e3 f4)\n(cdrred e4 f5)\n(cdrred f2 g3)\n(cdrred f3 g4)\n(cdrred f4 g5)\n(cdrred g3 h1)\n(cdrred g4 h2)\n(cdrred h1 i1)\n(<= (goal ?player ?payoff)\n    (stones ?player ?payoff))\n(toCount red h1 h2 i1)\n(<= (stones ?player 100)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 0)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= terminal\n    (true (step 40)))\n(<= terminal\n    (stones ?player 100))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 7-by-7 grid with coordinates ranging from 1 to 7 along both axes, where the cells on the outermost rows and columns (those with coordinates 1 or 7) are excluded from play, leaving an inner 5-by-5 playable area. Three players—red, yellow, and blue—participate, taking turns in a fixed sequence: red moves first, followed by yellow, then blue, and then back to red, continuing cyclically. Initially, each player controls a single piece placed at a distinct starting position: red at cell (1,4), yellow at (4,1), and blue at (7,4). The game begins at step one, with each player's capture count set to zero. On a player's turn, they may either perform a move or pass by issuing a noop action. A move consists of relocating one of their pieces from a source cell to a target cell according to specific movement rules: the piece may move orthogonally or diagonally by one cell or in an L-shaped pattern resembling a knight's move in chess, provided the destination cell is either occupied by an opponent's piece (allowing a capture) or is an empty cell in the case of the L-shaped move. Moves are only legal if the player controls the piece at the source cell, the target cell lies within the playable board boundaries, and the target is either unoccupied or occupied by a different player’s piece. If a player has no legal moves available, they must perform a noop. After a move, the player's control passes to the next player in the rotation sequence. When a piece moves onto a cell occupied by an opponent's piece, the opponent's piece is captured, incrementing the capturing player's capture count by one. The board state updates accordingly, with the moved piece occupying the new cell and the captured piece removed. The game continues incrementing the step count with each turn, and the game terminates automatically after 31 steps have been completed. Scoring is based solely on the number of captures made by each player, with higher capture counts translating to higher scores through a linear mapping where 0 captures equal 0 points and 10 captures equal 100 points. The ultimate victory condition is determined by these scores at the game's end. Implicit constraints ensure that no piece can occupy the same cell as another piece of the same player, and all moves must stay within the inner 5-by-5 board area defined by excluding the outermost rows and columns. The game enforces orderly turn progression, legal movement patterns, capture tracking, and termination after a fixed number of turns, culminating in a victory assessment based on captured pieces.",
    "output": "(role red)\n(role yellow)\n(role blue)\n(init (control red))\n(init (cell 1 4 red))\n(init (cell 4 1 yellow))\n(init (cell 7 4 blue))\n(init (step 1))\n(init (capture red 0))\n(init (capture yellow 0))\n(init (capture blue 0))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasLegalMove ?player)))\n(<= (legal ?player noop)\n\t  (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player ?move)\n\t  (legal2 ?player ?move))\n(<= (hasLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?player))\n(orthogonal ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(true (cell ?x2 ?y2 ?player2))\n(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?player))\n(diagonal ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(true (cell ?x2 ?y2 ?player2))\n(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?player))\n(ell ?x1 ?y1 ?x2 ?y2)\n(opencell ?x2 ?y2))\n(<= (next (control ?p2))\n(true (control ?p1))\n(rotation ?p1 ?p2))\n(<= (next (cell ?x2 ?y2 ?player))\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?piece))\n(true (cell ?x ?y ?piece))\n(not (camefrom ?x ?y))\n(not (wentto ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n(spawns ?x ?y ?player))\n(<= (next (capture ?player ?count))\n(true (capture ?player ?count))\n(not (captured ?player)))\n(<= (next (capture ?player ?count2))\n(true (capture ?player ?count1))\n(captured ?player)\n(captureplus ?count1 ?count2))\n(<= (next (step ?t2))\n(true (step ?t1))\n(stepcount ?t1 ?t2))\n(<= terminal\n(true (step 31)))\n(<= (goal ?player ?goal)\n(true (capture ?player ?count))\n(scoremap ?count ?goal))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n(plus 1 ?x1 ?x2)\n(index ?y))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n(plus 1 ?x2 ?x1)\n(index ?y))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n(index ?x)\n(plus 1 ?y1 ?y2))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n(index ?x)\n(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x1 ?x2)\n(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x1 ?x2)\n(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x2 ?x1)\n(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x2 ?x1)\n(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 2 ?x1 ?x2)\n(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 2 ?x1 ?x2)\n(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 2 ?x2 ?x1)\n(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 2 ?x2 ?x1)\n(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x1 ?x2)\n(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x1 ?x2)\n(plus 2 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x2 ?x1)\n(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x2 ?x1)\n(plus 2 ?y2 ?y1))\n(<= (opencell ?x ?y)\n(onboard ?x ?y)\n(not (true (cell ?x ?y red)))\n(not (true (cell ?x ?y yellow)))\n(not (true (cell ?x ?y blue))))\n(<= (onboard ?x ?y)\n(index ?x)\n(index ?y)\n(distinct ?x 1)\n(distinct ?x 7)\n(distinct ?y 1)\n(distinct ?y 7))\n(<= (camefrom ?x1 ?y1)\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (wentto ?x2 ?y2)\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (captured ?player)\n(true (control ?player))\n(wentto ?x ?y)\n(true (cell ?x ?y ?any)))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(plus 1 1 2)\n(plus 1 2 3)\n(plus 1 3 4)\n(plus 1 4 5)\n(plus 1 5 6)\n(plus 1 6 7)\n(plus 2 1 3)\n(plus 2 2 4)\n(plus 2 3 5)\n(plus 2 4 6)\n(plus 2 5 7)\n(rotation red yellow)\n(rotation yellow blue)\n(rotation blue red)\n(spawns 1 4 red)\n(spawns 4 1 yellow)\n(spawns 7 4 blue)\n(stepcount 1 2)\n(stepcount 2 3)\n(stepcount 3 4)\n(stepcount 4 5)\n(stepcount 5 6)\n(stepcount 6 7)\n(stepcount 7 8)\n(stepcount 8 9)\n(stepcount 9 10)\n(stepcount 10 11)\n(stepcount 11 12)\n(stepcount 12 13)\n(stepcount 13 14)\n(stepcount 14 15)\n(stepcount 15 16)\n(stepcount 16 17)\n(stepcount 17 18)\n(stepcount 18 19)\n(stepcount 19 20)\n(stepcount 20 21)\n(stepcount 21 22)\n(stepcount 22 23)\n(stepcount 23 24)\n(stepcount 24 25)\n(stepcount 25 26)\n(stepcount 26 27)\n(stepcount 27 28)\n(stepcount 28 29)\n(stepcount 29 30)\n(stepcount 30 31)\n(captureplus 0 1)\n(captureplus 1 2)\n(captureplus 2 3)\n(captureplus 3 4)\n(captureplus 4 5)\n(captureplus 5 6)\n(captureplus 6 7)\n(captureplus 7 8)\n(captureplus 8 9)\n(captureplus 9 10)\n(scoremap 0 0)\n(scoremap 1 10)\n(scoremap 2 20)\n(scoremap 3 30)\n(scoremap 4 40)\n(scoremap 5 50)\n(scoremap 6 60)\n(scoremap 7 70)\n(scoremap 8 80)\n(scoremap 9 90)\n(scoremap 10 100)\n(<= (lt ?n ?np1)\n    (distinct ?n ?np1)\n    (captureplus ?n ?np1))\n(<= (lt ?x ?z)\n    (distinct ?x ?z)\n    (captureplus ?x ?y)\n    (distinct ?x ?y)\n    (distinct ?y ?z)\n    (lt ?y ?z))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set in a simple environment comprising two rooms labeled 'a' and 'b', with an implicit coordinate system defined by a set of discrete directions that include compass points such as west, northwest, north, northeast, east, southeast, south, southwest, and several variants of southwest, along with a special direction called 'straight'. There is only one player role named \"walker,\" who takes turns alone in the game. The initial state places the walker in room 'a' at step 1. Each turn, the walker may choose to perform a walk action, specified by two directions: the first and the second arguments must both be valid directions from the predefined set. This action represents the walker's movement attempt. The only legal action for the walker at any turn is to walk by specifying two directions; there is no explicit noop action defined, so the walker must always choose a walk action. The game's state evolves in discrete steps, with the step count incrementing by one automatically each turn. If the walker chooses to walk straight and straight, they remain in room 'a'; any other combination of directions results in the walker moving to room 'b', and once in room 'b', the walker remains there regardless of subsequent moves. Implicit spatial constraints arise from the legal directions, but the actual spatial layout or distances are abstracted away, as no explicit coordinate changes are specified beyond room transitions. The game terminates automatically when step 200 is reached. The scoring is binary and tied to the walker's room: if the walker remains in room 'a' at any step less than or equal to 200, they achieve a goal value of 100; if the walker is in room 'b' at any time, the goal value is 0. Thus, the walker aims to stay in room 'a' for as many steps as possible until the game ends at step 200 to maximize their score.",
    "output": "(role walker)\n(init (room a))\n(init (step 1))\n(<= (legal walker (walk ?x ?y))\n    (direction ?x)\n    (direction ?y)\n    )\n(direction west)\n(direction northwest)\n(direction north)\n(direction northeast)\n(direction east)\n(direction southeast)\n(direction south)\n(direction southwest)\n(direction southwest1)\n(direction southwest2)\n(direction southwest3)\n(direction southwest4)\n(direction straight)\n(<= (next (step ?s2))\n    (true (step ?s1))\n    (succ ?s1 ?s2)\n    )\n(<= (next (room a))\n    (does walker (walk straight straight))\n    (true (room a))\n    )\n(<= (next (room b))\n    (does walker (walk ?x ?y))\n    (or (distinct ?x straight)\n        (distinct ?y straight)\n        )\n    )\n(<= (next (room b))\n    (true (room b))\n    )\n(<= terminal\n    (true (step 200))\n    )\n(<= (goal walker 100)\n    (true (room a))\n    (true (step ?step))\n    (less-than ?step 201)\n    )\n(<= (goal walker 0)\n    (true (room b))\n    )\n(<= (less-than ?x ?y)\n    (succ ?x ?y)\n    )\n(<= (less-than ?x ?y)\n    (succ ?x ?z)\n    (less-than ?z ?y)\n    )\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)\n(succ 100 101)\n(succ 101 102)\n(succ 102 103)\n(succ 103 104)\n(succ 104 105)\n(succ 105 106)\n(succ 106 107)\n(succ 107 108)\n(succ 108 109)\n(succ 109 110)\n(succ 110 111)\n(succ 111 112)\n(succ 112 113)\n(succ 113 114)\n(succ 114 115)\n(succ 115 116)\n(succ 116 117)\n(succ 117 118)\n(succ 118 119)\n(succ 119 120)\n(succ 120 121)\n(succ 121 122)\n(succ 122 123)\n(succ 123 124)\n(succ 124 125)\n(succ 125 126)\n(succ 126 127)\n(succ 127 128)\n(succ 128 129)\n(succ 129 130)\n(succ 130 131)\n(succ 131 132)\n(succ 132 133)\n(succ 133 134)\n(succ 134 135)\n(succ 135 136)\n(succ 136 137)\n(succ 137 138)\n(succ 138 139)\n(succ 139 140)\n(succ 140 141)\n(succ 141 142)\n(succ 142 143)\n(succ 143 144)\n(succ 144 145)\n(succ 145 146)\n(succ 146 147)\n(succ 147 148)\n(succ 148 149)\n(succ 149 150)\n(succ 150 151)\n(succ 151 152)\n(succ 152 153)\n(succ 153 154)\n(succ 154 155)\n(succ 155 156)\n(succ 156 157)\n(succ 157 158)\n(succ 158 159)\n(succ 159 160)\n(succ 160 161)\n(succ 161 162)\n(succ 162 163)\n(succ 163 164)\n(succ 164 165)\n(succ 165 166)\n(succ 166 167)\n(succ 167 168)\n(succ 168 169)\n(succ 169 170)\n(succ 170 171)\n(succ 171 172)\n(succ 172 173)\n(succ 173 174)\n(succ 174 175)\n(succ 175 176)\n(succ 176 177)\n(succ 177 178)\n(succ 178 179)\n(succ 179 180)\n(succ 180 181)\n(succ 181 182)\n(succ 182 183)\n(succ 183 184)\n(succ 184 185)\n(succ 185 186)\n(succ 186 187)\n(succ 187 188)\n(succ 188 189)\n(succ 189 190)\n(succ 190 191)\n(succ 191 192)\n(succ 192 193)\n(succ 193 194)\n(succ 194 195)\n(succ 195 196)\n(succ 196 197)\n(succ 197 198)\n(succ 198 199)\n(succ 199 200)\n(succ 200 201)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 10 by 10 grid where rows and columns are indexed from 1 to 10, establishing a coordinate system with positions identified by their (x, y) coordinates. There are two players, white and black, who alternate turns in a fixed sequence: white always moves first, followed by black. Initially, each player has four pieces placed on specific cells: white pieces occupy cells at coordinates (1,4), (4,1), (7,1), and (10,4), while black pieces start at (1,7), (4,10), (7,10), and (10,7). The game proceeds in a cycle where each player first makes a move action, then a fire action, before passing the turn to the opponent. On a player's move turn, they must move one of their pieces from one occupied cell to another cell reachable along an unblocked straight path in one of eight directions—north, northeast, east, southeast, south, southwest, west, or northwest—provided that every intermediate cell between the origin and destination is unoccupied and within board boundaries. After moving, the piece's new position is recorded, and the original cell becomes vacated. On the subsequent fire turn, the same player must fire an arrow from the piece's current position along a similar unobstructed straight path; the arrow lands on a target cell that must be empty, and this cell then becomes occupied by an arrow obstacle. Both move and fire actions must be legal as defined by these movement and path constraints. If it is not a player's turn to act, they may perform a noop action, which is legal only when the opponent is to move or fire. The state updates automatically after each action: pieces are relocated after moves, the last moved position is tracked, and arrow cells are added after firing. The game ends when the player whose turn it is to move or fire has no legal moves available, thereby reaching a terminal state. Scoring is binary and based on victory: the player who still has legal moves when the other cannot moves receives a score of 100, while the other scores 0. Throughout the game, no piece or arrow can occupy the same cell simultaneously, all movement and firing paths must stay within the board boundaries, and distances between cells adhere to the sequential index relations that define adjacency in each direction.",
    "output": "(role white)\n(role black)\n(init (cell 1 4 white))\n(init (cell 4 1 white))\n(init (cell 7 1 white))\n(init (cell 10 4 white))\n(init (cell 1 7 black))\n(init (cell 4 10 black))\n(init (cell 7 10 black))\n(init (cell 10 7 black))\n(init (turn white move))\n(<= (legal white noop)\n    (true (turn black ?any)))\n(<= (legal black noop)\n    (true (turn white ?any)))\n(<= (legal ?player ?move)\n    (legalMove ?player ?move))\n(<= (legalMove ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (turn ?player move))\n    (true (cell ?x1 ?y1 ?player))\n    (dir ?dir)\n    (openPath ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (legalMove ?player (fire ?x2 ?y2))\n    (true (turn ?player fire))\n    (true (justMoved ?x1 ?y1))\n    (dir ?dir)\n    (openPath ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (openPath ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2)))\n(<= (openPath ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2))\n    (openPath ?x2 ?y2 ?x3 ?y3 ?dir))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?any)))\n(<= (next (turn ?player fire))\n    (true (turn ?player move)))\n(<= (next (turn ?opponent move))\n    (true (turn ?player fire))\n    (opponent ?player ?opponent))\n(<= (next (cell ?x2 ?y2 ?player))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?player))\n    (true (cell ?x ?y ?player))\n    (not (vacated ?x ?y)))\n(<= (vacated ?x1 ?y1)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (justMoved ?x2 ?y2))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y arrow))\n    (does ?player (fire ?x ?y)))\n(<= terminal\n    (true (turn ?player ?any))\n    (not (anyLegalMove ?player)))\n(<= (anyLegalMove ?player)\n    (legal ?player ?move))\n(<= (goal ?player 100)\n    (true (turn ?player ?any)))\n(<= (goal ?player 0)\n    (true (turn ?opponent ?any))\n    (opponent ?opponent ?player))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(nextIndex 1 2)\n(nextIndex 2 3)\n(nextIndex 3 4)\n(nextIndex 4 5)\n(nextIndex 5 6)\n(nextIndex 6 7)\n(nextIndex 7 8)\n(nextIndex 8 9)\n(nextIndex 9 10)\n(opponent white black)\n(opponent black white)\n(dir n)\n(dir ne)\n(dir e)\n(dir se)\n(dir s)\n(dir sw)\n(dir w)\n(dir nw)\n(<= (oneInDir ?x ?y1 ?x ?y2 n)\n    (index ?x)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x1 ?y1 ?x2 ?y2 ne)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x1 ?y ?x2 ?y e)\n    (nextIndex ?x1 ?x2)\n    (index ?y))\n(<= (oneInDir ?x1 ?y2 ?x2 ?y1 se)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x ?y2 ?x ?y1 s)\n    (index ?x)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x2 ?y2 ?x1 ?y1 sw)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x2 ?y ?x1 ?y w)\n    (nextIndex ?x1 ?x2)\n    (index ?y))\n(<= (oneInDir ?x2 ?y1 ?x1 ?y2 nw)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (dir ?dir)\n    (queenMoveDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (queenMoveDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (queenMoveDir ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (queenMoveDir ?x2 ?y2 ?x3 ?y3 ?dir))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played between two players, designated as white and black, who alternate turns selecting actions simultaneously during each round. The game is structured to last up to a maximum of 20 rounds, with the round count starting at zero and incrementing by one each turn until the terminal round is reached, marking the end of the game. At the start, both players’ scores are initialized to zero, and the round counter is set to zero. On each turn, both players independently choose one of two possible actions: \"stag\" or \"hare.\" These choices constitute the legal moves available to each player at any round before the maximum number of rounds is reached; once round 20 is reached, no further moves are allowed and the game terminates. There is no explicit \"noop\" action mentioned, so players must always select either \"stag\" or \"hare\" each turn. The actions are represented by the player’s color followed by their chosen move, for example \"white stag\" or \"black hare.\" The legality of a move depends solely on the current round being less than the maximum allowed rounds. After both players have acted, the round counter increments by one, and the scores update according to the combination of moves chosen: if both players choose \"stag,\" each player’s score increases by 5 points; if one player chooses \"stag\" while the other chooses \"hare,\" the player choosing \"stag\" gains no points while the player choosing \"hare\" gains 2 points; if both players choose \"hare,\" each gains 2 points. The game board or environment does not have any spatial or coordinate system elements or constraints, nor are there occupancy conflicts or distance relationships to consider, as the game is purely based on simultaneous action selection and score accumulation. The game concludes when the maximum round count of 20 is reached, at which point the player with the higher score is deemed the winner. The final score values of each player are used directly as their goals, reflecting the outcome of the game.",
    "output": "(role white)\n(role black)\n(maxRounds 20)\n(init (whiteScore 0))\n(init (blackScore 0))\n(init (round 0))\n(<= (legal black stag)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal black hare)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal white stag)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal white hare)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (next (round ?x1))\n    (true (round ?x))\n    (succ ?x ?x1))\n(<= (next (whiteScore ?x5))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?x4 ?x5)\n    (does white stag)\n    (does black stag))\n(<= (next (blackScore ?x5))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?x4 ?x5)\n    (does white stag)\n    (does black stag))\n(<= (next (blackScore ?x2))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (does black hare)\n    (does white stag))\n(<= (next (whiteScore ?x))\n    (true (whiteScore ?x))\n    (does black hare)\n    (does white stag))\n(<= (next (blackScore ?x2))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (does black hare)\n    (does white hare))\n(<= (next (whiteScore ?x2))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (does black hare)\n    (does white hare))\n(<= (next (blackScore ?x))\n    (true (blackScore ?x))\n    (does black stag)\n    (does white hare))\n(<= (next (whiteScore ?x2))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (does black stag)\n    (does white hare))\n(<= terminal\n\t(maxRounds ?x)\n    (true (round ?x)))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a rectangular grid with rows labeled from r1 to r7 and columns labeled from c1 to c7, though not all cells in this range are part of the board—specifically, the first row lacks a c1 column and the last row lacks a c1 column as well, creating an irregular board shape. Each cell can be in one of three states: occupied by player X's piece, occupied by player O's piece, or blank (empty). The coordinate system is defined by these row and column labels, with adjacency relationships established between consecutive rows and columns for navigation and pattern recognition. There are two players, identified as X and O, who alternate turns with player X moving first as indicated by the initial control state.\n\nAt the start, each player has a certain number of \"quad\" tokens (12 each) and \"white\" tokens (5 each), though the exact function of these tokens relates to the legality of specific actions. The board's initial state has all specified cells empty. On a player's turn, they may choose one of two possible actions: a \"mark\" action or a \"block\" action. A \"mark\" action places the player's own piece on an empty cell, while a \"block\" action places a white token on an empty cell, which presumably blocks or protects that cell from certain effects. Importantly, for a \"mark\" action to be legal, the targeted cell must be empty and it must be that player's turn to move; for a \"block\" action to be legal, the targeted cell must be empty, it must be that player's turn, and the player must have at least one white token remaining (i.e., their white token count is not zero). Players can also choose to perform a noop (no operation) action, but only when it is the opponent's turn, effectively passing the move or waiting. After each \"mark\" action, the player's quad token count decreases by one, and after each \"block\" action, the player's white token count decreases by one. The control of the turn passes to the other player after a \"mark\" action; however, after a \"block\" action, the current player retains control for another action, allowing for multiple blocks in succession before the turn switches.\n\nCells marked by a player remain occupied by that player in the next state, while cells where a block was placed become white and remain so. The board enforces occupancy conflicts such that a cell cannot be marked or blocked if it is already occupied or blocked. The board boundaries are implicitly respected, as actions targeting non-existent cells or cells outside the defined board are not legal. The game recognizes \"squares\" consisting of four cells arranged in a rectangular shape by checking adjacency relationships among rows and columns, enabling the detection of specific patterns on the board.\n\nThe terminal conditions for the game are met if either player forms a \"win\" pattern, defined as a square of four cells all occupied by that player's pieces; a \"lose\" pattern, where the opponent forms such a square; or if there are no more \"open\" quads left, meaning no player has any quad tokens remaining. Additionally, the game may end if no further actions are possible. The victory criteria are based on these terminal conditions and the count of white tokens remaining for each player. Player X wins outright with a \"win\" pattern and scores 100 points, or scores 95 points if winning by an \"open quad,\" which is a nearly complete square missing one piece or blocked cell. If neither player has won or lost and no open quads remain, the player with more white tokens scores 90 points, equal white tokens yield 50 points, and fewer white tokens yield 10 points for player X. Player X loses outright if player O forms a winning square, scoring 0 points. Conversely, player O scores 100 points if player X loses, 90 points if having fewer white tokens in a neutral state, 50 points with equal white tokens, 10 points with more white tokens, and 5 points when winning by an open quad, scoring 0 points if player X has a winning square. This scoring system encourages strategic placement of marks and blocks to form squares while managing the white tokens and quad tokens resources carefully. The game proceeds with players alternating turns, performing legal actions that modify the board state and their resource counts, until a terminal condition is met and final scores are assigned accordingly.",
    "output": "(role x)\n(role o)\n(init (quad x 12))\n(init (quad o 12))\n(init (white x 5))\n(init (white o 5))\n(init (cell r1 c2 b))\n(init (cell r1 c3 b))\n(init (cell r1 c4 b))\n(init (cell r1 c5 b))\n(init (cell r1 c6 b))\n(init (cell r2 c1 b))\n(init (cell r2 c2 b))\n(init (cell r2 c3 b))\n(init (cell r2 c4 b))\n(init (cell r2 c5 b))\n(init (cell r2 c6 b))\n(init (cell r2 c7 b))\n(init (cell r3 c1 b))\n(init (cell r3 c2 b))\n(init (cell r3 c3 b))\n(init (cell r3 c4 b))\n(init (cell r3 c5 b))\n(init (cell r3 c6 b))\n(init (cell r3 c7 b))\n(init (cell r4 c1 b))\n(init (cell r4 c2 b))\n(init (cell r4 c3 b))\n(init (cell r4 c4 b))\n(init (cell r4 c5 b))\n(init (cell r4 c6 b))\n(init (cell r4 c7 b))\n(init (cell r5 c1 b))\n(init (cell r5 c2 b))\n(init (cell r5 c3 b))\n(init (cell r5 c4 b))\n(init (cell r5 c5 b))\n(init (cell r5 c6 b))\n(init (cell r5 c7 b))\n(init (cell r6 c1 b))\n(init (cell r6 c2 b))\n(init (cell r6 c3 b))\n(init (cell r6 c4 b))\n(init (cell r6 c5 b))\n(init (cell r6 c6 b))\n(init (cell r6 c7 b))\n(init (cell r7 c2 b))\n(init (cell r7 c3 b))\n(init (cell r7 c4 b))\n(init (cell r7 c5 b))\n(init (cell r7 c6 b))\n(init (control x))\n(ncol c1 c2)\n(ncol c2 c3)\n(ncol c3 c4)\n(ncol c4 c5)\n(ncol c5 c6)\n(ncol c6 c7)\n(nrow r1 r2)\n(nrow r2 r3)\n(nrow r3 r4)\n(nrow r4 r5)\n(nrow r5 r6)\n(nrow r6 r7)\n(<= (prow ?x ?y) (nrow ?y ?x))\n(<= (pcol ?x ?y) (ncol ?y ?x))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(<= (legal ?player (mark ?x ?y)) (true (cell ?x ?y b)) (true (control ?player)))\n(<= (legal ?player (block ?x ?y)) (true (cell ?x ?y b)) (true (control ?player)) (true (white ?player ?c)) (distinct ?c 0))\n(<= (legal x noop) (true (control o)))\n(<= (legal o noop) (true (control x)))\n(<= (next (cell ?m ?n ?p)) (does ?p (mark ?m ?n)))\n(<= (next (cell ?m ?n w)) (does ?p (block ?m ?n)))\n(<= (next (cell ?m ?n ?p)) (true (cell ?m ?n ?p)) (distinct ?p b))\n(<= (next (cell ?m ?n b)) (does ?W (mark ?j ?k)) (true(cell ?m ?n b)) (distinct ?m ?j))\n(<= (next (cell ?m ?n b)) (does ?W (mark ?j ?k)) (true(cell ?m ?n b)) (distinct ?n ?k))\n(<= (next (cell ?m ?n b)) (does ?W (block ?j ?k)) (true(cell ?m ?n b)) (distinct ?m ?j))\n(<= (next (cell ?m ?n b)) (does ?W (block ?j ?k)) (true(cell ?m ?n b)) (distinct ?n ?k))\n(<= (next (quad ?p ?c)) (true (control ?q)) (true (quad ?p ?c)) (distinct ?p ?q))\n(<= (next (white ?p ?c)) (true (control ?q)) (true (white ?p ?c)) (distinct ?p ?q))\n(<= (next (quad ?p ?c)) (does ?p (mark ?j ?k)) (true (quad ?p ?c1)) (succ ?c ?c1))\n(<= (next (white ?p ?c)) (does ?p (block ?j ?k)) (true (white ?p ?c1)) (succ ?c ?c1))\n(<= (next (quad ?p ?c)) (does ?p (block ?j ?k)) (true (quad ?p ?c)))\n(<= (next (white ?p ?c)) (does ?p (mark ?j ?k)) (true (white ?p ?c)))\n(<= (next (control x)) (does o (mark ?j ?k)) (true (control o)))\n(<= (next (control o)) (does x (mark ?j ?k)) (true (control x)))\n(<= (next (control ?p)) (does ?p (block ?j ?k)) (true (control ?p)))\n(<= (square ?x1 ?y1 ?x1 ?y2 ?x2 ?y1 ?x2 ?y2) (ncol ?y1 ?y2) (nrow ?x1 ?x2))\n(<= (square ?x1 ?y1 ?x1 ?y2 ?x2 ?y1 ?x2 ?y2) (ncol ?y3 ?y2) (nrow ?x3 ?x2) (square ?x1 ?y1 ?x1 ?y3 ?x3 ?y1 ?x3 ?y3))\n(<= (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) (prow ?x2p ?x2) (ncol ?y3n ?y3) (prow ?x4p ?x4) (ncol ?y4n ?y4)\n   (square ?x1 ?y1 ?x2p ?y2 ?x3 ?y3n ?x4p ?y4n))\n(<= win\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= lose\n   (true (cell ?x1 ?y1 o)) (true (cell ?x2 ?y2 o))\n   (true (cell ?x3 ?y3 o)) (true (cell ?x4 ?y4 o))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 b))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 b))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 b)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 b)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= open\n   (true (quad ?p ?c)) (distinct ?c 0))\n(<= (more ?x 0) (succ ?y ?x))\n(<= (more ?x ?y) (succ ?x1 ?x) (succ ?y1 ?y) (more ?x1 ?y1))\n(<= morewhite (true (white x ?a)) (true (white o ?b)) (more ?a ?b))\n(<= lesswhite (true (white x ?a)) (true (white o ?b)) (more ?b ?a))\n(<= equalwhite (true (white x ?a)) (true (white o ?a)))\n(<= (goal x 100) win)\n(<= (goal x 95)  (not win) winByOpenQuad)\n(<= (goal x 90)  (not win) (not winByOpenQuad) (not lose) (not open) morewhite)\n(<= (goal x 50)  (not win) (not winByOpenQuad) (not lose) (not open) equalwhite)\n(<= (goal x 10)  (not win) (not winByOpenQuad) (not lose) (not open) lesswhite)\n(<= (goal x 0)   lose)\n(<= (goal o 100) lose)\n(<= (goal o 90)  (not win) (not winByOpenQuad) (not lose) (not open) lesswhite)\n(<= (goal o 50)  (not win) (not winByOpenQuad) (not lose) (not open) equalwhite)\n(<= (goal o 10)  (not win) (not winByOpenQuad) (not lose) (not open) morewhite)\n(<= (goal o 5)   (not win) winByOpenQuad)\n(<= (goal o 0)   win)\n(<= terminal win)\n(<= terminal lose)\n(<= terminal (not open))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game Jumper is played on a grid defined by rows labeled a through g and columns labeled c1 through c7, creating a coordinate system where each hole is identified by a row and column pair. The board initially contains pegs placed in nearly all holes except for a single empty hole at position c3 in row c. The player, assigned the role \"jumper,\" takes turns performing actions with the objective of reducing the number of pegs on the board. There is only one player in this game, and they make moves sequentially. Each turn, the player may either perform a jump action or commit suicide to end the game prematurely. A jump action is specified by four coordinates: the starting hole row and column, and the destination hole row and column. A jump is legal only if the starting hole contains a peg, the destination hole is empty, and there is a middle hole between the start and destination that also contains a peg. The middle hole must be exactly between the start and destination either horizontally in the same row or vertically in the same column, with adjacency defined by the successor and predecessor relations on rows and columns. When a jump is executed, the peg in the starting hole moves to the destination hole, the peg in the middle hole is removed (making it empty), and the starting hole becomes empty. The number of pegs decreases by one with each successful jump. The player may choose to commit suicide only during the first four moves, which immediately ends the game and marks the player as dead. The game terminates when no more legal moves are possible, the player commits suicide, or only one peg remains on the board. Scoring is determined by the number of pegs left, with a maximum score of 100 for having a single peg remaining, and decreasing scores assigned as the number of pegs increases. If the player dies by suicide, a fixed score of 15 is assigned. The board enforces implicit constraints such as the boundaries of rows and columns and occupancy conflicts that prevent illegal jumps or moves outside the grid. The player must carefully plan moves to jump pegs over others, removing them until the terminal condition is reached to maximize the score.",
    "output": "(role jumper)\n(init (hole a c3 peg))\n(init (hole a c4 peg))\n(init (hole a c5 peg))\n(init (hole b c3 peg))\n(init (hole b c4 peg))\n(init (hole b c5 peg))\n(init (hole c c1 peg))\n(init (hole c c2 peg))\n(init (hole c c3 empty))\n(init (hole c c4 peg))\n(init (hole c c5 peg))\n(init (hole c c6 peg))\n(init (hole c c7 peg))\n(init (hole d c1 peg))\n(init (hole d c2 peg))\n(init (hole d c3 peg))\n(init (hole d c4 peg))\n(init (hole d c5 peg))\n(init (hole d c6 peg))\n(init (hole d c7 peg))\n(init (hole e c1 peg))\n(init (hole e c2 peg))\n(init (hole e c3 peg))\n(init (hole e c4 peg))\n(init (hole e c5 peg))\n(init (hole e c6 peg))\n(init (hole e c7 peg))\n(init (hole f c3 peg))\n(init (hole f c4 peg))\n(init (hole f c5 peg))\n(init (hole g c3 peg))\n(init (hole g c4 peg))\n(init (hole g c5 peg))\n(init (pegs s32))\n(<= (next (you are dead))\n(does jumper (commit suicide)))\n(<= (next (pegs ?x))\n(does jumper (jump ?sr ?sc ?dr ?dc))\n(true (pegs ?y))\n(succ ?x ?y))\n(<= (next (hole ?sr ?sc empty))\n(does jumper (jump ?sr ?sc ?dr ?dc)))\n(<= (next (hole ?or ?oc empty))\n(does jumper (jump ?sr ?sc ?dr ?dc))\n(middle ?sr ?sc ?or ?oc ?dr ?dc))\n(<= (next (hole ?dr ?dc peg))\n(does jumper (jump ?sr ?sc ?dr ?dc)))\n(<= (next (hole ?x ?y empty))\n(does jumper (jump ?sr ?sc ?dr ?dc))\n(true (hole ?x ?y empty))\n(distinct ?x ?dr))\n(<= (next (hole ?x ?y empty))\n(does jumper (jump ?sr ?sc ?dr ?dc))\n(true (hole ?x ?y empty))\n(distinct ?y ?dc))\n(<= (next (hole ?x ?y peg))\n(does jumper (jump ?sr ?sc ?dr ?dc))\n(true (hole ?x ?y peg))\n(distinct ?x ?sr)\n(middle ?sr ?sc ?or ?oc ?dr ?dc)\n(distinct ?x ?or))\n(<= (next (hole ?x ?y peg))\n(does jumper (jump ?sr ?sc ?dr ?dc))\n(true (hole ?x ?y peg))\n(distinct ?y ?sc)\n(middle ?sr ?sc ?or ?oc ?dr ?dc)\n(distinct ?y ?oc))\n(<= (middle ?row ?sc ?row ?oc ?row ?dc)\n(pc ?sc ?oc)\n(nc ?dc ?oc)\n(row ?row))\n(<= (middle ?row ?sc ?row ?oc ?row ?dc)\n(nc ?sc ?oc)\n(pc ?dc ?oc)\n(row ?row))\n(<= (middle ?sr ?col ?or ?col ?dr ?col)\n(pr ?sr ?or)\n(nr ?dr ?or)\n(column ?col))\n(<= (middle ?sr ?col ?or ?col ?dr ?col)\n(nr ?sr ?or)\n(pr ?dr ?or)\n(column ?col))\n(nc c1 c2)\n(nc c2 c3)\n(nc c3 c4)\n(nc c4 c5)\n(nc c5 c6)\n(nc c6 c7)\n(pc c2 c1)\n(pc c3 c2)\n(pc c4 c3)\n(pc c5 c4)\n(pc c6 c5)\n(pc c7 c6)\n(column c1)\n(column c2)\n(column c3)\n(column c4)\n(column c5)\n(column c6)\n(column c7)\n(nr a b)\n(nr b c)\n(nr c d)\n(nr d e)\n(nr e f)\n(nr f g)\n(pr b a)\n(pr c b)\n(pr d c)\n(pr e d)\n(pr f e)\n(pr g f)\n(row a)\n(row b)\n(row c)\n(row d)\n(row e)\n(row f)\n(row g)\n(<= (legal jumper (commit suicide))\n(not first4moves))\n(<= (legal jumper (jump ?sr ?sc ?dr ?dc))\n(true (hole ?sr ?sc peg))\n(true (hole ?dr ?dc empty))\n(middle ?sr ?sc ?or ?oc ?dr ?dc)\n(true (hole ?or ?oc peg)))\n(<= moveable\n(true (hole ?sr ?sc peg))\n(true (hole ?dr ?dc empty))\n(middle ?sr ?sc ?or ?oc ?dr ?dc)\n(true (hole ?or ?oc peg)))\n(<= first4moves\n(or (true (pegs s32))\n(true (pegs s31))\n(true (pegs s30))\n(true (pegs s29))))\n(<= (goal jumper 100)\n(true (pegs s1)))\n(<= (goal jumper 90)\n(true (pegs s2)))\n(<= (goal jumper 80)\n(true (pegs s3)))\n(<= (goal jumper 70)\n(true (pegs s4)))\n(<= (goal jumper 60)\n(true (pegs s5)))\n(<= (goal jumper 50)\n(true (pegs s6)))\n(<= (goal jumper 40)\n(true (pegs s7)))\n(<= (goal jumper 30)\n(true (pegs s8)))\n(<= (goal jumper 20)\n(true (pegs s9)))\n(<= (goal jumper 10)\n(true (pegs s10)))\n(<= (goal jumper 0)\n(true (pegs ?x))\n(distinct ?x s10)\n(distinct ?x s9)\n(distinct ?x s8)\n(distinct ?x s7)\n(distinct ?x s6)\n(distinct ?x s5)\n(distinct ?x s4)\n(distinct ?x s3)\n(distinct ?x s2)\n(distinct ?x s1))\n(<= (goal jumper 15)\n(true (you are dead)))\n(succ s1 s2)\n(succ s2 s3)\n(succ s3 s4)\n(succ s4 s5)\n(succ s5 s6)\n(succ s6 s7)\n(succ s7 s8)\n(succ s8 s9)\n(succ s9 s10)\n(succ s10 s11)\n(succ s11 s12)\n(succ s12 s13)\n(succ s13 s14)\n(succ s14 s15)\n(succ s15 s16)\n(succ s16 s17)\n(succ s17 s18)\n(succ s18 s19)\n(succ s19 s20)\n(succ s20 s21)\n(succ s21 s22)\n(succ s22 s23)\n(succ s23 s24)\n(succ s24 s25)\n(succ s25 s26)\n(succ s26 s27)\n(succ s27 s28)\n(succ s28 s29)\n(succ s29 s30)\n(succ s30 s31)\n(succ s31 s32)\n(<= terminal\n(not moveable))\n(<= terminal\n(true (you are dead)))\n(<= terminal\n(true (pegs s1)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a grid-based board where each cell is identified by a row and column number, with coordinates defined as numeric values starting from 1 upwards. The board cells can be in one of two states: blank or occupied by a queen. There is a single player role named \"robot,\" who takes all the turns sequentially. The initial state sets all cells on the board as blank and begins with the robot in a \"placing\" phase, starting at 1. On each turn, the robot may place a queen on a blank cell that is not currently under attack; alternatively, the robot may choose to quit the game. Legal placement actions must specify the row and column coordinates of a blank cell that is not attacked, meaning it is not under threat from any queen already placed on the board. After a placement, the cell state updates to contain a queen, and the placing index increments by one; if the robot chooses to quit, the game enters a finished state. The concept of cells being \"attacked\" is determined by the presence of queens in the same row or column or diagonally aligned with the cell in question, using coordinate sums and differences to define diagonal attacks. The game enforces implicit constraints such as board boundaries defined by the numeric range of rows and columns, preventing placement outside the grid, and forbids placing a queen on any cell under attack or already occupied. The game terminates either when the robot chooses to quit or when there are no further placements to be made (no \"still placing\" phase remains). The scoring system awards the robot 100 points for successfully placing queens without quitting and 0 points if the robot quits before finishing. No other players participate, and no further moves are made after termination. Thus, the game challenges the robot to place queens on a grid without mutual attacks, reflecting a variant of the classic n-queens puzzle, with the option to end the game at any time by quitting.",
    "output": "(role robot)\n(<= (init (cell ?row ?col blank))\n    (number ?row)\n    (number ?col))\n(init (placing 1))\n(<= (legal robot (place ?row ?col))\n    (true (cell ?row ?col blank))\n    (not (attacked ?row ?col))\n    )\n(legal robot quit)\n(<= (next (cell ?row ?col queen))\n    (does robot (place ?row ?col)))\n(<= (next (cell ?row ?col ?type))\n    (true (cell ?row ?col ?type))\n    (not (does robot (place ?row ?col))))\n(<= (next (placing ?n2))\n    (true (placing ?n1))\n    (succ ?n1 ?n2))\n(<= (next finished)\n    (does robot quit))\n(<= terminal\n    (true finished))\n(<= terminal\n    (not still_placing))\n(<= still_placing\n    (true (placing ?n)))\n(<= (goal robot 0)\n    (true finished))\n(<= (goal robot 100)\n    (not (goal robot 0)))\n(<= (number ?n)\n    (succ ?n ?m))\n(<= (number ?m)\n    (succ ?n ?m))\n(<= (ext_succ ?n1 ?n2)\n    (succ ?n1 ?n2))\n(<= (ext_number ?n)\n    (ext_succ ?n ?m))\n(<= (ext_number ?m)\n    (ext_succ ?n ?m))\n(<= (plus ?n 0 ?n)\n    (ext_number ?n))\n(<= (plus ?x ?y ?z)\n    (ext_succ ?y2 ?y)\n    (ext_succ ?x ?x2)\n    (plus ?x2 ?y2 ?z))\n(type queen)\n(type blank)\n(<= (attacked ?row ?col)\n    (true (cell ?row ?col2 queen))\n    (number ?col))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col queen))\n    (number ?row))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col2 queen))\n    (plus ?row ?col ?c)\n    (plus ?row2 ?col2 ?c))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col2 queen))\n    (plus ?c ?col ?row)\n    (plus ?c ?col2 ?row2))\n(succ  1  2)\n(succ  2  3)\n(succ  3  4)\n(succ  4  5)\n(succ  5  6)\n(succ  6  7)\n(succ  7  8)\n(succ  8  9)\n(succ  9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(ext_succ m31 m30)\n(ext_succ m30 m29)\n(ext_succ m29 m28)\n(ext_succ m28 m27)\n(ext_succ m27 m26)\n(ext_succ m26 m25)\n(ext_succ m25 m24)\n(ext_succ m24 m23)\n(ext_succ m23 m22)\n(ext_succ m22 m21)\n(ext_succ m21 m20)\n(ext_succ m20 m19)\n(ext_succ m19 m18)\n(ext_succ m18 m17)\n(ext_succ m17 m16)\n(ext_succ m16 m15)\n(ext_succ m15 m14)\n(ext_succ m14 m13)\n(ext_succ m13 m12)\n(ext_succ m12 m11)\n(ext_succ m11 m10)\n(ext_succ m10  m9)\n(ext_succ  m9  m8)\n(ext_succ  m8  m7)\n(ext_succ  m7  m6)\n(ext_succ  m6  m5)\n(ext_succ  m5  m4)\n(ext_succ  m4  m3)\n(ext_succ  m3  m2)\n(ext_succ  m2  m1)\n(ext_succ  m1   0)\n(ext_succ   0   1)\n(ext_succ   1   2)\n(ext_succ   2   3)\n(ext_succ   3   4)\n(ext_succ   4   5)\n(ext_succ   5   6)\n(ext_succ   6   7)\n(ext_succ   7   8)\n(ext_succ   8   9)\n(ext_succ   9  10)\n(ext_succ  10  11)\n(ext_succ  11  12)\n(ext_succ  12  13)\n(ext_succ  13  14)\n(ext_succ  14  15)\n(ext_succ  15  16)\n(ext_succ  16  17)\n(ext_succ  17  18)\n(ext_succ  18  19)\n(ext_succ  19  20)\n(ext_succ  20  21)\n(ext_succ  21  22)\n(ext_succ  22  23)\n(ext_succ  23  24)\n(ext_succ  24  25)\n(ext_succ  25  26)\n(ext_succ  26  27)\n(ext_succ  27  28)\n(ext_succ  28  29)\n(ext_succ  29  30)\n(ext_succ  30  31)\n(ext_succ  31  32)\n(ext_succ  32  33)\n(ext_succ  33  34)\n(ext_succ  34  35)\n(ext_succ  35  36)\n(ext_succ  36  37)\n(ext_succ  37  38)\n(ext_succ  38  39)\n(ext_succ  39  40)\n(ext_succ  40  41)\n(ext_succ  41  42)\n(ext_succ  42  43)\n(ext_succ  43  44)\n(ext_succ  44  45)\n(ext_succ  45  46)\n(ext_succ  46  47)\n(ext_succ  47  48)\n(ext_succ  48  49)\n(ext_succ  49  50)\n(ext_succ  50  51)\n(ext_succ  51  52)\n(ext_succ  52  53)\n(ext_succ  53  54)\n(ext_succ  54  55)\n(ext_succ  55  56)\n(ext_succ  56  57)\n(ext_succ  57  58)\n(ext_succ  58  59)\n(ext_succ  59  60)\n(ext_succ  60  61)\n(ext_succ  61  62)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played between two players, white and black, who take turns simultaneously in each round. The environment is abstract and does not involve a spatial coordinate system; instead, it tracks numerical scores and rounds. Initially, both white and black start with a score of 50, and the round counter is set to 0. The game proceeds for a maximum of 5 rounds, with round number incrementing by one after each pair of bids. On each turn, both players must submit a bid action, which is a numerical value not exceeding their current score; bidding more than their available score is illegal. There is no explicit noop action defined, so players must always bid within their score limits. The bids are submitted simultaneously. The state updates at the end of each round depend on the minimum of the two bids made. If one player bids strictly higher than the other, the player who bids higher gains 10 points plus the minimum bid amount, while the other player gains only the minimum bid. If both players bid equally, each gains 5 points plus the minimum bid. Scores are updated by adding these values to the previous scores, and the round counter increments by one. Implicit constraints include that bids must be integers between 0 and the player's current score, and the game ends once the round counter reaches the maximum of 5. The victory condition is based on the scores at the end of the final round: each player's goal value equals their final score, effectively making the player with the higher score the winner. The game thus revolves around strategic bidding to maximize one's own score while limiting the opponent's gains within a limited number of rounds.",
    "output": "(role white)\n(role black)\n(maxRounds 5)\n(init (whiteScore 50))\n(init (blackScore 50))\n(init (round 0))\n(<= (legal white (bid ?x1))\n    (true (whiteScore ?x2))\n    (gte ?x2 ?x1))\n(<= (legal black (bid ?x1))\n    (true (blackScore ?x2))\n    (gte ?x2 ?x1))\n(<= (next (round ?x1))\n    (true (round ?x))\n    (succ ?x ?x1))\n(<= (next (whiteScore ?xNext))\n    (true (whiteScore ?x))\n    (does white (bid ?x1))\n    (does black (bid ?y1))\n    (min ?x1 ?y1 ?minBid)\n    (w1 ?score)\n    (sum ?x2 ?minBid ?x)\n    (sum ?x2 ?score ?xNext))\n(<= (next (blackScore ?xNext))\n    (true (blackScore ?x))\n    (does white (bid ?x1))\n    (does black (bid ?y1))\n    (min ?x1 ?y1 ?minBid)\n    (b1 ?score)\n    (sum ?x2 ?minBid ?x)\n    (sum ?x2 ?score ?xNext))\n(<= terminal\n    (true (round ?x))\n    (maxRounds ?x))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(<= (min ?a ?a ?a)\n    (index ?a))\n(<= (min ?a ?b ?a)\n    (gt ?b ?a))\n(<= (min ?b ?a ?a)\n    (gt ?b ?a))\n(<= (w1 10)\n    (does white (bid ?x1))\n    (does black (bid ?y1))\n    (gt ?x1 ?y1))\n(<= (b1 0)\n    (does white (bid ?x1))\n    (does black (bid ?y1))\n    (gt ?x1 ?y1))\n(<= (w1 0)\n    (does black (bid ?x1))\n    (does white (bid ?y1))\n    (gt ?x1 ?y1))\n(<= (b1 10)\n    (does black (bid ?x1))\n    (does white (bid ?y1))\n    (gt ?x1 ?y1))\n(<= (w1 5)\n    (does white (bid ?x1))\n    (does black (bid ?x1)))\n(<= (b1 5)\n    (does white (bid ?x1))\n    (does black (bid ?x1)))\n(<= (sum ?x 0 ?x)\n    (index ?x))\n(<= (sum ?x ?y ?z)\n    (succ ?y0 ?y)\n    (succ ?z0 ?z)\n    (sum ?x ?y0 ?z0))\n(<= (gt ?a ?b)\n    (index ?x)\n    (not (succ ?x 1))\n    (sum ?b ?x ?a))\n(<= (gte ?a ?b)\n    (index ?x)\n    (sum ?b ?x ?a))\n(index 0)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(index 11)\n(index 12)\n(index 13)\n(index 14)\n(index 15)\n(index 16)\n(index 17)\n(index 18)\n(index 19)\n(index 20)\n(index 21)\n(index 22)\n(index 23)\n(index 24)\n(index 25)\n(index 26)\n(index 27)\n(index 28)\n(index 29)\n(index 30)\n(index 31)\n(index 32)\n(index 33)\n(index 34)\n(index 35)\n(index 36)\n(index 37)\n(index 38)\n(index 39)\n(index 40)\n(index 41)\n(index 42)\n(index 43)\n(index 44)\n(index 45)\n(index 46)\n(index 47)\n(index 48)\n(index 49)\n(index 50)\n(index 51)\n(index 52)\n(index 53)\n(index 54)\n(index 55)\n(index 56)\n(index 57)\n(index 58)\n(index 59)\n(index 60)\n(index 61)\n(index 62)\n(index 63)\n(index 64)\n(index 65)\n(index 66)\n(index 67)\n(index 68)\n(index 69)\n(index 70)\n(index 71)\n(index 72)\n(index 73)\n(index 74)\n(index 75)\n(index 76)\n(index 77)\n(index 78)\n(index 79)\n(index 80)\n(index 81)\n(index 82)\n(index 83)\n(index 84)\n(index 85)\n(index 86)\n(index 87)\n(index 88)\n(index 89)\n(index 90)\n(index 91)\n(index 92)\n(index 93)\n(index 94)\n(index 95)\n(index 96)\n(index 97)\n(index 98)\n(index 99)\n(index 100)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a two-dimensional grid defined by coordinates where the first coordinate ranges from 0 to 19 and the second coordinate ranges from 1 to 2, forming a board with 40 cells in total. Each cell is identified by three indices: the first index represents the series or group number (from 0 to 19), and the second and third indices specify the position within that series, either 1 or 2. The only player role in this game is the \"robot,\" who takes turns performing actions. The game begins with all cells initialized to a state value of 0 and a step counter set to 0; the current series game is also initialized to 0. Turn control is managed by the robot acting alone, and at each turn, the robot may perform a single legal action or a no-operation; legal actions are of the form \"press z x y,\" where z is the series index, and x and y are positional indices within that series. An action is legal only if the series z matches the current seriesGame value and x and y are valid indices (either 1 or 2). When the robot presses a cell, that cell's state is immediately set to 4; in subsequent turns, any cell in state 4 automatically degrades by one level each step, moving to states 3, then 2, then 1, and finally 0, unless it is pressed again. Cells not pressed remain in their current state unless they are already at 0, which is the lowest state. The \"step\" counter increments by one with each turn, and at specific steps—namely 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, and 80—the current seriesGame value advances to the next integer, thereby changing the series of cells that the robot is allowed to press. This progression controls which series the robot can act upon at any given time. The game imposes implicit constraints that actions must be within the board boundaries, and only cells in the current series can be pressed. The termination condition is met when the step counter reaches 84, at which point the game ends. Victory is determined by whether any series from 10 through 19 has all four cells in that series lit—that is, in a nonzero state (1, 2, 3, or 4)—simultaneously. If such a series is lit, the robot achieves a goal score of 100, indicating a win; otherwise, the score is 0. Thus, the robot’s objective is to press cells within the allowed series before the step count reaches 84 and to maintain at least one of the higher-numbered series fully lit to secure a win.",
    "output": "(role robot)\n(init (cell 0 1 1 0))\n(init (cell 0 1 2 0))\n(init (cell 0 2 1 0))\n(init (cell 0 2 2 0))\n(init (cell 1 1 1 0))\n(init (cell 1 1 2 0))\n(init (cell 1 2 1 0))\n(init (cell 1 2 2 0))\n(init (cell 2 1 1 0))\n(init (cell 2 1 2 0))\n(init (cell 2 2 1 0))\n(init (cell 2 2 2 0))\n(init (cell 3 1 1 0))\n(init (cell 3 1 2 0))\n(init (cell 3 2 1 0))\n(init (cell 3 2 2 0))\n(init (cell 4 1 1 0))\n(init (cell 4 1 2 0))\n(init (cell 4 2 1 0))\n(init (cell 4 2 2 0))\n(init (cell 5 1 1 0))\n(init (cell 5 1 2 0))\n(init (cell 5 2 1 0))\n(init (cell 5 2 2 0))\n(init (cell 6 1 1 0))\n(init (cell 6 1 2 0))\n(init (cell 6 2 1 0))\n(init (cell 6 2 2 0))\n(init (cell 7 1 1 0))\n(init (cell 7 1 2 0))\n(init (cell 7 2 1 0))\n(init (cell 7 2 2 0))\n(init (cell 8 1 1 0))\n(init (cell 8 1 2 0))\n(init (cell 8 2 1 0))\n(init (cell 8 2 2 0))\n(init (cell 9 1 1 0))\n(init (cell 9 1 2 0))\n(init (cell 9 2 1 0))\n(init (cell 9 2 2 0))\n(init (cell 10 1 1 0))\n(init (cell 10 1 2 0))\n(init (cell 10 2 1 0))\n(init (cell 10 2 2 0))\n(init (cell 11 1 1 0))\n(init (cell 11 1 2 0))\n(init (cell 11 2 1 0))\n(init (cell 11 2 2 0))\n(init (cell 12 1 1 0))\n(init (cell 12 1 2 0))\n(init (cell 12 2 1 0))\n(init (cell 12 2 2 0))\n(init (cell 13 1 1 0))\n(init (cell 13 1 2 0))\n(init (cell 13 2 1 0))\n(init (cell 13 2 2 0))\n(init (cell 14 1 1 0))\n(init (cell 14 1 2 0))\n(init (cell 14 2 1 0))\n(init (cell 14 2 2 0))\n(init (cell 15 1 1 0))\n(init (cell 15 1 2 0))\n(init (cell 15 2 1 0))\n(init (cell 15 2 2 0))\n(init (cell 16 1 1 0))\n(init (cell 16 1 2 0))\n(init (cell 16 2 1 0))\n(init (cell 16 2 2 0))\n(init (cell 17 1 1 0))\n(init (cell 17 1 2 0))\n(init (cell 17 2 1 0))\n(init (cell 17 2 2 0))\n(init (cell 18 1 1 0))\n(init (cell 18 1 2 0))\n(init (cell 18 2 1 0))\n(init (cell 18 2 2 0))\n(init (cell 19 1 1 0))\n(init (cell 19 1 2 0))\n(init (cell 19 2 1 0))\n(init (cell 19 2 2 0))\n(init (step 0))\n(init (seriesGame 0))\n(<= (legal robot (press ?z ?x ?y))\n\t(index ?x)\n\t(index ?y)\n\t(true (seriesGame ?z)))\n(<= (next (cell ?z ?x ?y 4))\n\t(does robot (press ?z ?x ?y)))\n(<= (next (cell ?z ?x ?y 3))\n\t(true (cell ?z ?x ?y 4)))\n(<= (next (cell ?z ?x ?y 2))\n\t(true (cell ?z ?x ?y 3)))\n(<= (next (cell ?z ?x ?y 1))\n\t(true (cell ?z ?x ?y 2)))\n(<= (next (cell ?z ?x ?y 0))\n\t(true (cell ?z ?x ?y 1)))\n(<= (next (cell ?z ?x ?y 0))\n\t(true (cell ?z ?x ?y 0)))\n(<= (next (won ?z))\n    (true (won ?z)))\n(<= (next (step ?x))\n    (true (step ?y))\n    (successor ?y ?x))\n(<= (next (seriesGame 1))\n    (true (step 4)))\n(<= (next (seriesGame 2))\n    (true (step 8)))\n(<= (next (seriesGame 3))\n    (true (step 12)))\n(<= (next (seriesGame 4))\n    (true (step 16)))\n(<= (next (seriesGame 5))\n    (true (step 20)))\n(<= (next (seriesGame 6))\n    (true (step 24)))\n(<= (next (seriesGame 7))\n    (true (step 28)))\n(<= (next (seriesGame 8))\n    (true (step 32)))\n(<= (next (seriesGame 9))\n    (true (step 36)))\n(<= (next (seriesGame 10))\n    (true (step 40)))\n(<= (next (seriesGame 11))\n    (true (step 44)))\n(<= (next (seriesGame 12))\n    (true (step 48)))\n(<= (next (seriesGame 13))\n    (true (step 52)))\n(<= (next (seriesGame 14))\n    (true (step 56)))\n(<= (next (seriesGame 15))\n    (true (step 60)))\n(<= (next (seriesGame 16))\n    (true (step 64)))\n(<= (next (seriesGame 17))\n    (true (step 68)))\n(<= (next (seriesGame 18))\n    (true (step 72)))\n(<= (next (seriesGame 19))\n    (true (step 76)))\n(<= (next (seriesGame 20))\n    (true (step 80)))\n(<= (next (seriesGame ?x))\n    (true (seriesGame ?x))\n    (not (true (step 4)))\n    (not (true (step 8)))\n    (not (true (step 12)))\n    (not (true (step 16)))\n    (not (true (step 20)))\n    (not (true (step 24)))\n    (not (true (step 28)))\n    (not (true (step 32)))\n    (not (true (step 36)))\n    (not (true (step 40)))\n    (not (true (step 44)))\n    (not (true (step 48)))\n    (not (true (step 52)))\n    (not (true (step 56)))\n    (not (true (step 60)))\n    (not (true (step 64)))\n    (not (true (step 68)))\n    (not (true (step 72)))\n    (not (true (step 76)))\n    (not (true (step 80))))\n(<= (next (won ?z))\n    (lightsOn ?z))\n(<= terminal\n    (true (step 84)))\n(<= (goal robot 100)\n\twonAGame)\n(<= (goal robot 0)\n    (not wonAGame))\n(<= wonAGame\n    (true (won 10)))\n(<= wonAGame\n    (true (won 11)))\n(<= wonAGame\n    (true (won 12)))\n(<= wonAGame\n    (true (won 13)))\n(<= wonAGame\n    (true (won 14)))\n(<= wonAGame\n    (true (won 15)))\n(<= wonAGame\n    (true (won 16)))\n(<= wonAGame\n    (true (won 17)))\n(<= wonAGame\n    (true (won 18)))\n(<= wonAGame\n    (true (won 19)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 1)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 2)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 3)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 4)))\n(<= (lightsOn ?z)\n\t(on ?z 1 1)\n\t(on ?z 1 2)\n\t(on ?z 2 1)\n\t(on ?z 2 2))\n(index 1) (index 2)\n  (successor 0 1)\n  (successor 1 2)\n  (successor 2 3)\n  (successor 3 4)\n  (successor 4 5)\n  (successor 5 6)\n  (successor 6 7)\n  (successor 7 8)\n  (successor 8 9)\n  (successor 9 10)\n  (successor 10 11)\n  (successor 11 12)\n  (successor 12 13)\n  (successor 13 14)\n  (successor 14 15)\n  (successor 15 16)\n  (successor 16 17)\n  (successor 17 18)\n  (successor 18 19)\n  (successor 19 20)\n  (successor 20 21)\n  (successor 21 22)\n  (successor 22 23)\n  (successor 23 24)\n  (successor 24 25)\n  (successor 25 26)\n  (successor 26 27)\n  (successor 27 28)\n  (successor 28 29)\n  (successor 29 30)\n  (successor 30 31)\n  (successor 31 32)\n  (successor 32 33)\n  (successor 33 34)\n  (successor 34 35)\n  (successor 35 36)\n  (successor 36 37)\n  (successor 37 38)\n  (successor 38 39)\n  (successor 39 40)\n  (successor 40 41)\n  (successor 41 42)\n  (successor 42 43)\n  (successor 43 44)\n  (successor 44 45)\n  (successor 45 46)\n  (successor 46 47)\n  (successor 47 48)\n  (successor 48 49)\n  (successor 49 50)\n  (successor 50 51)\n  (successor 51 52)\n  (successor 52 53)\n  (successor 53 54)\n  (successor 54 55)\n  (successor 55 56)\n  (successor 56 57)\n  (successor 57 58)\n  (successor 58 59)\n  (successor 59 60)\n  (successor 60 61)\n  (successor 61 62)\n  (successor 62 63)\n  (successor 63 64)\n  (successor 64 65)\n  (successor 65 66)\n  (successor 66 67)\n  (successor 67 68)\n  (successor 68 69)\n  (successor 69 70)\n  (successor 70 71)\n  (successor 71 72)\n  (successor 72 73)\n  (successor 73 74)\n  (successor 74 75)\n  (successor 75 76)\n  (successor 76 77)\n  (successor 77 78)\n  (successor 78 79)\n  (successor 79 80)\n  (successor 80 81)\n  (successor 81 82)\n  (successor 82 83)\n  (successor 83 84)\n  (successor 84 85)\n(<= (next (interesting-numbers ?a ?b ?c ?d))\n  (successor ?a ?b)\n  (successor ?c ?d)\n  (successor 1 2))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a coordinate system where each coordinate is an integer index ranging from 0 to 10, and actions involve triplets of these indices whose sum must equal 10. Two players participate in the game, designated as white and black, with white taking the first turn followed by black, alternating thereafter. The initial state sets both players' scores to zero and the round count to zero, with a maximum of five rounds specified. On each turn, a player selects an action called \"troops,\" which consists of three indices whose sum is exactly ten, ensuring each index is within the allowed range from 0 to 10. Both players must submit their \"troops\" actions simultaneously each round, and all actions are legal only if the sum condition and index bounds are satisfied; there is no explicit noop action defined. After both players have chosen their triplets, the game automatically computes new scores for each player based on comparisons of their respective coordinate values in the chosen triplets: for each position in the triplet, if the white player's index is greater than the black player's corresponding index, white gains 2 points and black gains 0 points; if black's index is greater, black gains 2 points and white gains none; if the indices are equal, both players gain 1 point each. These point values for each position in the triplet are summed to update the players' scores cumulatively. The round counter increments by one after each pair of moves, and the game terminates when the number of rounds reaches the maximum of five. At termination, the final scores of the white and black players determine the outcome, with the players' goals corresponding directly to their accumulated scores; the player with the higher score is considered the winner. Implicit constraints include the requirement that the three indices chosen by each player sum to exactly 10 and lie within the range 0 to 10, enforcing a balanced selection of troop distributions. The game thus centers on strategic allocation of troop strengths across three positions per round, rewarding players who allocate higher values in comparison to their opponent, and lasting exactly five rounds before final scoring concludes the match.",
    "output": "(role white)\n(role black)\n(init (whiteScore 0))\n(init (blackScore 0))\n(init (rounds 0))\n(init (maxRounds 5))\n(<= (legal white (troops ?x1 ?x2 ?x3))\n    (index ?x1)\n    (index ?x2)\n    (index ?x3)\n    (sum ?x1 ?x2 ?s1)\n    (sum ?s1 ?x3 10))\n(<= (legal black (troops ?x1 ?x2 ?x3))\n\t(index ?x1)\n\t(index ?x2)\n\t(index ?x3)\n    (sum ?x1 ?x2 ?s1)\n    (sum ?s1 ?x3 10))\n(<= (next (maxRounds ?x))\n    (true (maxRounds ?x)))\n(<= (next (rounds ?x1))\n    (true (rounds ?x))\n    (succ ?x ?x1))\n(<= (next (whiteScore ?xNext))\n    (true (whiteScore ?x))\n    (w1 ?p1)\n    (w2 ?p2)\n    (w3 ?p3)\n    (sum ?x ?p1 ?s1)\n    (sum ?s1 ?p2 ?s2)\n    (sum ?s2 ?p3 ?xNext))\n(<= (next (blackScore ?xNext))\n    (true (blackScore ?x))\n    (b1 ?p1)\n    (b2 ?p2)\n    (b3 ?p3)\n    (sum ?x ?p1 ?s1)\n    (sum ?s1 ?p2 ?s2)\n    (sum ?s2 ?p3 ?xNext))\n(<= terminal\n    (true (rounds ?x))\n    (true (maxRounds ?x)))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(<= (w1 2)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?x1 ?y1))\n(<= (b1 0)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?x1 ?y1))\n(<= (b1 2)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?y1 ?x1))\n(<= (w1 0)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?y1 ?x1))\n(<= (w1 1)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?x1 ?y2 ?y3)))\n(<= (b1 1)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?x1 ?y2 ?y3)))\n(<= (w2 2)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?x2 ?y2))\n(<= (b2 0)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?x2 ?y2))\n(<= (b2 2)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?y2 ?x2))\n(<= (w2 0)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?y2 ?x2))\n(<= (w2 1)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?x2 ?y3)))\n(<= (b2 1)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?x2 ?y3)))\n(<= (w3 2)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?x3 ?y3))\n(<= (b3 0)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?x3 ?y3))\n(<= (b3 2)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?y3 ?x3))\n(<= (w3 0)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?y3))\n    (gt ?y3 ?x3))\n(<= (w3 1)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?x3)))\n(<= (b3 1)\n    (does white (troops ?x1 ?x2 ?x3))\n    (does black (troops ?y1 ?y2 ?x3)))\n(<= (sum ?x 0 ?x)\n    (or (succ ?x ?y) (succ ?y ?x)))\n(<= (sum ?x ?y ?z)\n    (succ ?y0 ?y)\n    (succ ?z0 ?z)\n    (sum ?x ?y0 ?z0))\n(<= (gt ?a ?b)\n    (index ?x)\n    (not (succ ?x 1))\n    (sum ?b ?x ?a))\n(index 0)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 grid with coordinates ranging from 1 to 8 along both axes, where positions are identified by their x and y indices. Two players participate, designated as white and black, taking turns in strict alternation with white moving first. At the start, each player has four pieces placed on specific cells: white occupies the cells at (1,3), (3,1), (6,1), and (8,3), while black occupies (1,6), (3,8), (6,8), and (8,6). The game proceeds in a cycle of two phases per player: a move phase followed by a fire phase. On a player's move turn, they may move one of their pieces along a straight path in any of the eight compass directions—north, northeast, east, southeast, south, southwest, west, or northwest—provided that the path to the destination cell is unobstructed by any occupied cells. The destination cell must be empty, and the direction of movement must be consistent throughout the move. After moving a piece, the player enters the fire phase, during which they must fire an arrow from the newly moved piece's position in a straight, unobstructed line along any of the eight directions. The arrow lands in an empty cell reachable by a clear path from the just-moved piece, and this cell becomes occupied by an arrow marker, permanently blocking that position. Players may also choose to perform a no-operation (noop) action, but only when it is the opponent's turn to move or fire, effectively passing the turn without changing the state. Moves and fires must only be executed when it is the appropriate phase of the player's turn, and the legality of each action is determined by the occupancy and directional constraints. The state updates automatically after each action: moving a piece vacates its original cell and occupies the new cell, firing places an arrow on the targeted empty cell, and turn control switches accordingly, from move to fire for the same player, then from fire to move for the opposing player. The game enforces boundary constraints corresponding to the 8x8 board and prohibits movement or firing through or onto occupied cells. The game ends when the player whose turn it is to move has no legal moves available. Scoring is binary and zero-sum: the player who cannot move on their turn receives a score of zero, while the opponent is awarded a score of 100, thereby determining the winner. Overall, the game challenges players to maneuver their pieces strategically while blocking their opponent's movements by firing arrows that permanently occupy cells on the board.",
    "output": "(role white)\n(role black)\n(init (cell 1 3 white))\n(init (cell 3 1 white))\n(init (cell 6 1 white))\n(init (cell 8 3 white))\n(init (cell 1 6 black))\n(init (cell 3 8 black))\n(init (cell 6 8 black))\n(init (cell 8 6 black))\n(init (turn white move))\n(<= (legal white noop)\n    (true (turn black ?any)))\n(<= (legal black noop)\n    (true (turn white ?any)))\n(<= (legal ?player ?move)\n    (legalMove ?player ?move))\n(<= (legalMove ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (turn ?player move))\n    (true (cell ?x1 ?y1 ?player))\n    (dir ?dir)\n    (openPath ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (legalMove ?player (fire ?x2 ?y2))\n    (true (turn ?player fire))\n    (true (justMoved ?x1 ?y1))\n    (dir ?dir)\n    (openPath ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (openPath ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2)))\n(<= (openPath ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2))\n    (openPath ?x2 ?y2 ?x3 ?y3 ?dir))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?any)))\n(<= (next (turn ?player fire))\n    (true (turn ?player move)))\n(<= (next (turn ?opponent move))\n    (true (turn ?player fire))\n    (opponent ?player ?opponent))\n(<= (next (cell ?x2 ?y2 ?player))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?player))\n    (true (cell ?x ?y ?player))\n    (not (vacated ?x ?y)))\n(<= (vacated ?x1 ?y1)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (justMoved ?x2 ?y2))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y arrow))\n    (does ?player (fire ?x ?y)))\n(<= terminal\n    (true (turn ?player ?any))\n    (not (anyLegalMove ?player)))\n(<= (anyLegalMove ?player)\n    (legal ?player ?move))\n(<= (goal ?player 0)\n    (true (turn ?player ?any)))\n(<= (goal ?player 100)\n    (true (turn ?opponent ?any))\n    (opponent ?opponent ?player))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(nextIndex 1 2)\n(nextIndex 2 3)\n(nextIndex 3 4)\n(nextIndex 4 5)\n(nextIndex 5 6)\n(nextIndex 6 7)\n(nextIndex 7 8)\n(opponent white black)\n(opponent black white)\n(dir n)\n(dir ne)\n(dir e)\n(dir se)\n(dir s)\n(dir sw)\n(dir w)\n(dir nw)\n(<= (oneInDir ?x ?y1 ?x ?y2 n)\n    (index ?x)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x1 ?y1 ?x2 ?y2 ne)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x1 ?y ?x2 ?y e)\n    (nextIndex ?x1 ?x2)\n    (index ?y))\n(<= (oneInDir ?x1 ?y2 ?x2 ?y1 se)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x ?y2 ?x ?y1 s)\n    (index ?x)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x2 ?y2 ?x1 ?y1 sw)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x2 ?y ?x1 ?y w)\n    (nextIndex ?x1 ?x2)\n    (index ?y))\n(<= (oneInDir ?x2 ?y1 ?x1 ?y2 nw)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (dir ?dir)\n    (queenMoveDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (queenMoveDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (queenMoveDir ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (queenMoveDir ?x2 ?y2 ?x3 ?y3 ?dir))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on an 8x8 grid with coordinates labeled from c1 to c8 along both axes, establishing a square board environment. There are two player roles: the wolf and the sheep, who alternate turns with the wolf moving first followed by the sheep. The initial state positions a wolf on cell c4 c8 and multiple sheep on cells c1 c1, c3 c1, c5 c1, and c7 c1, with all remaining cells initially empty (denoted as b). Turns are controlled strictly in alternating fashion, and a player not having a legal move may perform a noop (no operation) action; notably, the wolf may noop only when it is the sheep's turn, and the sheep may noop only when it is the wolf's turn, ensuring proper turn flow. Each action consists of a move command specifying a piece's current coordinates and its target adjacent coordinates; moves are legal only if the piece belongs to the player whose turn it is, the piece is located at the starting cell, the target cell is empty, and the target cell is adjacent based on role-specific adjacency rules. The wolf’s adjacency includes all eight surrounding cells diagonally, horizontally, and vertically, whereas the sheep’s adjacency is limited to the four diagonal neighboring cells. Moves result in updating the board state by relocating the piece to the target cell and marking its previous cell empty, while all other cells retain their states unless occupied by the moved piece. Control alternates after each move. Implicit constraints include the board boundaries defined by c1 through c8 on both axes, preventing moves off the board, and occupancy conflicts prohibiting moving onto occupied cells. The game terminates when one of three conditions is met: the wolf is positioned behind the sheep in terms of the y-coordinate (i.e., the wolf's y-coordinate is numerically greater than any sheep's y-coordinate), or either the wolf or the sheep have no legal moves available. Victory is determined by scoring 100 points for the wolf if it remains moveable at termination, or 0 otherwise; conversely, the sheep score 100 points if the wolf is immobile at termination, or 0 if the wolf can still move. Thus, the game revolves around the wolf attempting to maneuver behind the sheep while the sheep try to block or immobilize the wolf, with movement restricted by adjacency and board boundaries, and the turn structure ensuring orderly play and the possibility of noop actions when a player cannot move.",
    "output": "(role wolf)\n(role sheep)\n(init(cell c1 c1 s))\n(init(cell c1 c2 b))\n(init(cell c1 c3 b))\n(init(cell c1 c4 b))\n(init(cell c1 c5 b))\n(init(cell c1 c6 b))\n(init(cell c1 c7 b))\n(init(cell c1 c8 b))\n(init(cell c2 c1 b))\n(init(cell c2 c2 b))\n(init(cell c2 c3 b))\n(init(cell c2 c4 b))\n(init(cell c2 c5 b))\n(init(cell c2 c6 b))\n(init(cell c2 c7 b))\n(init(cell c2 c8 b))\n(init(cell c3 c1 s))\n(init(cell c3 c2 b))\n(init(cell c3 c3 b))\n(init(cell c3 c4 b))\n(init(cell c3 c5 b))\n(init(cell c3 c6 b))\n(init(cell c3 c7 b))\n(init(cell c3 c8 b))\n(init(cell c4 c1 b))\n(init(cell c4 c2 b))\n(init(cell c4 c3 b))\n(init(cell c4 c4 b))\n(init(cell c4 c5 b))\n(init(cell c4 c6 b))\n(init(cell c4 c7 b))\n(init(cell c4 c8 w))\n(init(cell c5 c1 s))\n(init(cell c5 c2 b))\n(init(cell c5 c3 b))\n(init(cell c5 c4 b))\n(init(cell c5 c5 b))\n(init(cell c5 c6 b))\n(init(cell c5 c7 b))\n(init(cell c5 c8 b))\n(init(cell c6 c1 b))\n(init(cell c6 c2 b))\n(init(cell c6 c3 b))\n(init(cell c6 c4 b))\n(init(cell c6 c5 b))\n(init(cell c6 c6 b))\n(init(cell c6 c7 b))\n(init(cell c6 c8 b))\n(init(cell c7 c1 s))\n(init(cell c7 c2 b))\n(init(cell c7 c3 b))\n(init(cell c7 c4 b))\n(init(cell c7 c5 b))\n(init(cell c7 c6 b))\n(init(cell c7 c7 b))\n(init(cell c7 c8 b))\n(init(cell c8 c1 b))\n(init(cell c8 c2 b))\n(init(cell c8 c3 b))\n(init(cell c8 c4 b))\n(init(cell c8 c5 b))\n(init(cell c8 c6 b))\n(init(cell c8 c7 b))\n(init(cell c8 c8 b))\n(init(control wolf))\n(<= (next (cell ?x ?y b))\n(does ?role (move ?x ?y ?tox ?toy)))\n(<= (next (cell ?x ?y w))\n(does wolf (move ?fromx ?fromy ?x ?y)))\n(<= (next (cell ?x ?y ?s))\n(does sheep (move ?fromx ?fromy ?x ?y))\n(true (cell ?fromx ?fromy ?s)))\n(<=(next (cell ?x ?y ?z))\n(true (cell ?x ?y ?z))\n(distinct ?z b)\n(does ?role (move ?fromx ?fromy ?tox ?toy))\n(or (distinct ?fromx ?x) (distinct ?fromy ?y)))\n(<= (next (cell ?x ?y b))\n(true (cell ?x ?y b))\n(does ?role (move ?a ?b ?c ?d))\n(or (distinct ?c ?x) (distinct ?d ?y)))\n(<= (next (control sheep))\n(true (control wolf)))\n(<= (next (control wolf))\n(true (control sheep)))\n(<= (legal wolf (move ?fromx ?fromy ?tox ?toy))\n(true (control wolf))\n(true (cell ?fromx ?fromy w))\n(adjacent wolf ?fromx ?fromy ?tox ?toy)\n(true (cell ?tox ?toy b)))\n(<=(legal sheep (move ?fromx ?fromy  ?tox ?toy))\n(true (control sheep))\n(true (cell ?fromx ?fromy s))\n(adjacent sheep ?fromx ?fromy ?tox ?toy)\n(true (cell ?tox ?toy b)))\n(<= (legal wolf noop)\n(true (control sheep)))\n(<= (legal sheep noop)\n(true (control wolf)))\n(<= (adjacent sheep ?x ?y ?x1 ?y1) (succ ?x ?x1) (succ ?y ?y1))\n(<= (adjacent sheep ?x ?y ?x1 ?y1) (succ ?x1 ?x) (succ ?y ?y1))\n(<= (adjacent wolf ?x ?y ?x1 ?y1) (succ ?x1 ?x) (succ ?y1 ?y))\n(<= (adjacent wolf ?x ?y ?x1 ?y1) (succ ?x ?x1) (succ ?y1 ?y))\n(<= (adjacent wolf ?x ?y ?x1 ?y1) (succ ?x ?x1) (succ ?y ?y1))\n(<= (adjacent wolf ?x ?y ?x1 ?y1) (succ ?x1 ?x) (succ ?y ?y1))\n(<= terminal\nwolf_behind_sheep)\n(<= terminal\n(not (moveable wolf)))\n(<= terminal\n(not (moveable sheep)))\n(<= (goal wolf 100)\n(moveable wolf))\n(<= (goal wolf 0)\n(not (moveable wolf)))\n(<= (goal sheep 100)\n(not (moveable wolf)))\n(<= (goal sheep 0)\n(moveable wolf))\n(<= (moveable wolf)\n(true (cell ?x ?y w))\n(adjacent wolf ?x ?y ?tox ?toy)\n(true (cell ?tox ?toy b)))\n(<= (moveable sheep)\n(true (cell ?x ?y s))\n(adjacent sheep ?x ?y ?tox ?toy)\n(true (cell ?tox ?toy b)))\n(<= wolf_behind_sheep\n(not not_wolf_behind_sheep))\n(<= not_wolf_behind_sheep\n(true (cell ?xw ?yw w))\n(true (cell ?xs ?ys s))\n(smaller ?ys ?yw))\n(<= (smaller ?x ?y)\n(succ ?x ?y))\n(<= (smaller ?x ?y)\n(succ ?x ?z)\n(smaller ?z ?y))\n(succ c1 c2)\n(succ c2 c3)\n(succ c3 c4)\n(succ c4 c5)\n(succ c5 c6)\n(succ c6 c7)\n(succ c7 c8)\n(index c1)\n(index c2)\n(index c3)\n(index c4)\n(index c5)\n(index c6)\n(index c7)\n(index c8)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a hierarchical 3-by-3 grid system consisting of smaller cells arranged within larger boards, each indexed by coordinates from 1 to 3 along both rows and columns. There are two players, named xplayer and oplayer, who alternate turns controlling both the smaller cells and the larger boards. Initially, all small cells start blank, marked as 'b', and control of both small cells and large boards is assigned to xplayer. The game begins in a special first turn state during which players may perform various named actions such as factorize, dance, cry, laugh, sing, frolic, or twist. After this, players take turns making moves. Each turn, a player can either place their mark ('x' for xplayer, 'o' for oplayer) on a blank small cell that they are allowed to mark, or perform a move on the larger board by playing a large move to claim a cell within a larger board grid. The legality of marking a small cell depends on it being blank, the player having control over small cells, and certain conditions related to inhibition and factorization being satisfied; players may also choose to take a noop action, which is always legal and effectively passes their turn without changing the state. When a player marks a small cell, that cell's state updates to reflect the player's mark, and the control of small cells and large boards alternates between players after each move. The state also tracks inhibition of small cells based on moves made on the larger board, restricting marking options accordingly. Marking a large cell is only legal if the player controls the large board, the targeted larger cell is empty, and either it is the first large move or the current board corresponds to the move's coordinates, or the current board is closed. The game automatically updates the state after each move, including marking cells, toggling control, and recording board control and inhibition states. The implicit constraints include the 3-by-3 grid boundaries for both small and large cells, occupancy rules preventing marking occupied cells, and inhibition rules that restrict marking certain small cells after large moves. The game ends when a terminal condition is met, which occurs if either player achieves a line of three marks in a row, column, or diagonal on either the small or large boards, or when no empty small or large cells remain open. Victory is determined by the presence of such lines: a player receives a full score of 100 for completing a line on the small or large board, 50 if the board is full without any lines (a draw), and 0 if the opponent has completed a line. The final goal scores for each player reflect these conditions, and the terminal states trigger the end of the game. Thus, play proceeds with players alternately marking cells or passing until one achieves a winning line or the boards are filled, with scoring based on the lines formed on both levels of the grid hierarchy.",
    "output": "( role xplayer)\n( role oplayer)\n( init ( cell_small 1 1 b ) )\n( init ( cell_small 1 2 b ) )\n( init ( cell_small 1 3 b ) )\n( init ( cell_small 2 1 b ) )\n( init ( cell_small 2 2 b ) )\n( init ( cell_small 2 3 b ) )\n( init ( cell_small 3 1 b ) )\n( init ( cell_small 3 2 b ) )\n( init ( cell_small 3 3 b ) )\n( init ( control_small xplayer ) )\n( init ( control_large xplayer ) )\n( init first_turn )\n( index 1 )\n( index 2 )\n( index 3 )\n( <= ( legal ?p factorize ) ( role ?p ) ( true first_turn ) )\n( <= ( legal ?p dance ) ( role ?p ) ( true first_turn ) )\n( <= ( legal ?p cry ) ( role ?p ) ( true first_turn ) )\n( <= ( legal ?p laugh ) ( role ?p ) ( true first_turn ) )\n( <= ( legal ?p sing ) ( role ?p ) ( true first_turn ) )\n( <= ( legal ?p frolic ) ( role ?p ) ( true first_turn ) )\n( <= ( legal ?p twist ) ( role ?p ) ( true first_turn ) )\n( <= ( next ( factorized ?p ) ) ( does ?p factorize ) )\n( <= ( next ( factorized ?p ) ) ( true ( factorized ?p ) ) )\n( <= ( next ( cell_small ?m ?n x ) ) ( does xplayer ( mark_small ?m ?n) ) ( true ( cell_small ?m ?n b ) ) )\n( <= ( next ( cell_small ?m ?n o ) ) ( does oplayer ( mark_small ?m ?n) ) ( true ( cell_small ?m ?n b ) ) )\n( <= ( next ( cell_small ?m ?n ?w ) ) ( true ( cell_small ?m ?n ?w ) ) ( distinct ?w b ) )\n( <= ( marking_small ?m ?n ) ( does ?p ( mark_small ?m ?n ) ) )\n( <= ( next ( cell_small ?m ?n b ) ) ( true ( cell_small ?m ?n b ) ) ( role ?player ) ( not ( marking_small ?m ?n ) ) )\n( <= ( next ( mark_large ?i ?j ?k ?l ?m ) ) ( role ?player ) ( does ?player ( play_large ?i ?j ?k ?l ?m ) ) )\n( <= ( next ( mark_large ?i ?j ?k ?l ?m ) ) ( true ( mark_large ?i ?j ?k ?l ?m ) ) )\n( <= large_played ( does ?player ( play_large ?i ?j ?k ?l ?m ) ) )\n( <= ( next ( current_board ?k ?l ) ) ( role ?player ) ( does ?player ( play_large ?i ?j ?k ?l ?m ) ) )\n( <= ( next ( current_board ?k ?l ) ) ( true ( current_board ?k ?l ) ) ( not large_played ) )\n( <= ( next ( inhibit_small ?i ?j ?p ) ) ( role ?p ) ( does ?p ( play_large ?i ?j ?k ?l ?m ) ) )\n( <= ( next ( inhibit_small ?i ?j ?p ) ) ( true ( inhibit_small ?i ?j ?p ) ) )\n( <= ( next ( control_small oplayer ) ) ( true ( control_small xplayer ) ) )\n( <= ( next ( control_small xplayer ) ) ( true ( control_small oplayer ) ) )\n( <= ( next ( control_large xplayer ) ) ( true ( control_large oplayer ) ) )\n( <= ( next ( control_large oplayer ) ) ( true ( control_large xplayer ) ) )\n( <= ( row_small ?m ?x ) ( true ( cell_small ?m 1 ?x ) )\n  ( true ( cell_small ?m 2 ?x ) ) ( true ( cell_small ?m 3 ?x ) ) )\n( <= ( col_small ?n ?x ) ( true ( cell_small 1 ?n ?x ) )\n  ( true ( cell_small 2 ?n ?x ) ) ( true ( cell_small 3 ?n ?x ) ) )\n( <= ( diag_small ?x ) ( true ( cell_small 1 1 ?x ) )\n  ( true ( cell_small 2 2 ?x ) ) ( true ( cell_small 3 3 ?x ) ) )\n( <= ( diag_small ?x ) ( true ( cell_small 1 3 ?x ) )\n  ( true ( cell_small 2 2 ?x ) ) ( true ( cell_small 3 1 ?x ) ) )\n( <= ( line_small ?x ) ( row_small ?m ?x ) )\n( <= ( line_small ?x ) ( col_small ?m ?x ) )\n( <= ( line_small ?x ) ( diag_small ?x ) )\n( <= open_small ( true ( cell_small ?m ?n b ) ) )\n( <= ( legal ?p noop) ( role ?p ) )\n( <= ( special_cond_satisfied ?p ?x ?y ) ( index ?x ) ( index ?y ) ( true ( factorized ?p ) ) )\n( <= ( special_cond_satisfied ?p ?x ?y ) ( index ?x ) ( index ?y ) ( role ?p ) ( not ( true ( inhibit_small ?x ?y ?p ) ) ) )\n( <= ( legal ?w ( mark_small ?x ?y ) ) ( true ( cell_small ?x ?y b ) ) ( true ( control_small ?w ) ) ( special_cond_satisfied ?w ?x ?y ) )\n( <= ( legal xplayer ( play_large ?i ?j ?k ?l x ) ) ( true ( control_large xplayer ) ) first_move_large ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal xplayer ( play_large ?i ?j ?k ?l x ) ) ( true ( control_large xplayer ) ) ( true ( current_board ?i ?j ) ) ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal xplayer ( play_large ?i ?j ?k ?l x ) ) ( true ( control_large xplayer ) ) cur_board_closed_large ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal oplayer ( play_large ?i ?j ?k ?l o ) ) ( true ( control_large oplayer ) ) first_move_large ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal oplayer ( play_large ?i ?j ?k ?l o ) ) ( true ( control_large oplayer ) ) ( true ( current_board ?i ?j ) ) ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal oplayer ( play_large ?i ?j ?k ?l o ) ) ( true ( control_large oplayer ) ) cur_board_closed_large ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( goal_small xplayer 100 ) ( line_small x ) )\n( <= ( goal_small xplayer 50 ) ( not ( line_small x ) )\n  ( not ( line_small o ) ) ( not open_small ) )\n( <= ( goal_small xplayer 0 ) ( line_small o ) )\n( <= ( goal_small oplayer 100 ) ( line_small o ) )\n( <= ( goal_small oplayer 50 ) ( not ( line_small x ) )\n  ( not ( line_small o ) ) ( not open_small ) )\n( <= ( goal_small oplayer 0 ) ( line_small x ) )\n( <= ( goal_large xplayer 0 ) ( not ( line_large x ) ) ( not ( line_large o ) ) open_large )\n( <= ( goal_large xplayer 100 ) ( line_large x ) )\n( <= ( goal_large xplayer 50 ) ( not ( line_large x ) ) ( not ( line_large o ) ) ( not open_large ) )\n( <= ( goal_large xplayer 0 ) ( line_large o ) )\n( <= ( goal_large oplayer 0 ) ( not ( line_large x ) ) ( not ( line_large o ) ) open_large )\n( <= ( goal_large oplayer 100 ) ( line_large o ) )\n( <= ( goal_large oplayer 50 ) ( not ( line_large x ) ) ( not ( line_large o ) ) ( not open_large ) )\n( <= ( goal_large oplayer 0 ) ( line_large x ) )\n( <= ( goal xplayer 100 ) ( goal_large xplayer 100 ) terminal_large )\n( <= ( goal xplayer 100 ) ( goal_small xplayer 100 ) terminal_small )\n( <= ( goal xplayer 50 ) ( goal_large xplayer 50 ) terminal_large )\n( <= ( goal xplayer 50 ) ( goal_small xplayer 50 ) terminal_small )\n( <= ( goal xplayer 0 ) ( goal_large xplayer 0 ) terminal_large )\n( <= ( goal xplayer 0 ) ( goal_small xplayer 0 ) terminal_small )\n( <= ( goal oplayer 100 ) ( goal_large oplayer 100 ) terminal_large )\n( <= ( goal oplayer 100 ) ( goal_small oplayer 100 ) terminal_small )\n( <= ( goal oplayer 50 ) ( goal_large oplayer 50 ) terminal_large )\n( <= ( goal oplayer 50 ) ( goal_small oplayer 50 ) terminal_small )\n( <= ( goal oplayer 0 ) ( goal_large oplayer 0 ) terminal_large )\n( <= ( goal oplayer 0 ) ( goal_small oplayer 0 ) terminal_small )\n( <= terminal_small ( line_small x ) )\n( <= terminal_small ( line_small o ) )\n( <= terminal_small ( not open_small ) )\n( <= ( empty_cell_large ?i ?j ?k ?l ) ( index ?i ) ( index ?j ) ( index ?k ) ( index ?l ) ( not ( true ( mark_large ?i ?j ?k ?l x ) ) ) ( not ( true ( mark_large ?i ?j ?k ?l o ) ) ) )\n( <= open_large ( index ?i ) ( index ?j ) ( index ?k ) ( index ?l ) ( empty_cell_large ?i ?j ?k ?l ) )\n( <= terminal_large ( line_large x ) )\n( <= terminal_large ( line_large o ) )\n( <= terminal_large ( not open_large ) )\n( <= terminal terminal_small )\n( <= terminal terminal_large )\n( <= ( row_large ?i ?j ?k ?m ) ( true ( mark_large ?i ?j ?k 1 ?m ) ) ( true ( mark_large ?i ?j ?k 2 ?m ) ) ( true ( mark_large ?i ?j ?k 3 ?m ) ) )\n( <= ( col_large ?i ?j ?k ?m ) ( true ( mark_large ?i ?j 1 ?k ?m ) ) ( true ( mark_large ?i ?j 2 ?k ?m ) ) ( true ( mark_large ?i ?j 3 ?k ?m ) ) )\n( <= ( diag_large ?i ?j ?m ) ( true ( mark_large ?i ?j 1 1 ?m ) ) ( true ( mark_large ?i ?j 2 2 ?m ) ) ( true ( mark_large ?i ?j 3 3 ?m ) ) )\n( <= ( diag_large ?i ?j ?m ) ( true ( mark_large ?i ?j 1 3 ?m ) ) ( true ( mark_large ?i ?j 2 2 ?m ) ) ( true ( mark_large ?i ?j 3 1 ?m ) ) )\n( <= ( line_large ?m ) ( index ?i ) ( index ?j ) ( index ?k ) ( row_large ?i ?j ?k ?m ) )\n( <= ( line_large ?m ) ( index ?i ) ( index ?j ) ( index ?k ) ( col_large ?i ?j ?k ?m ) )\n( <= ( line_large ?m ) ( index ?i ) ( index ?j ) ( diag_large ?i ?j ?m ) )\n( <= cur_board_closed_large ( true ( current_board ?i ?j ) ) ( not ( empty_cell_large ?i ?j 1 1 ) ) ( not ( empty_cell_large ?i ?j 1 2 ) ) ( not ( empty_cell_large ?i ?j 1 3 ) ) ( not ( empty_cell_large ?i ?j 2 1 ) ) ( not ( empty_cell_large ?i ?j 2 2 ) ) ( not ( empty_cell_large ?i ?j 2 3 ) ) ( not ( empty_cell_large ?i ?j 3 1 ) ) ( not ( empty_cell_large ?i ?j 3 2 ) ) ( not ( empty_cell_large ?i ?j 3 3 ) ) )\n( <= first_move_large ( not ( true ( current_board 1 1 ) ) ) ( not ( true ( current_board 1 2 ) ) ) ( not ( true ( current_board 1 3 ) ) ) ( not ( true ( current_board 2 1 ) ) ) ( not ( true ( current_board 2 2 ) ) ) ( not ( true ( current_board 2 3 ) ) ) ( not ( true ( current_board 3 1 ) ) ) ( not ( true ( current_board 3 2 ) ) ) ( not ( true ( current_board 3 3 ) ) ) )"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a three-dimensional grid defined by coordinates labeled as rows, columns, and levels, each ranging from 1 to 4, creating a 4x4x4 board. The environment consists of cells identified by this triplet coordinate system, and each cell can hold a marker or remain blank. Two teams, X and O, each comprised of three distinct player roles—row, column, and level—take turns in a fixed cyclic order within their respective teams: for team X, the order is xrow, then xcolumn, then xlevel, and for team O, it is orow, then ocolumn, then olevel. The game initializes with all cells empty and the control assigned to the xrow role, with the first roles for each team recorded accordingly. On a player's turn, they may select a coordinate value corresponding to their assigned role: xrow and orow select a row number, xcolumn and ocolumn select a column number, and xlevel and olevel select a level number. A legal action consists of a selection of a coordinate value within the range of 1 to 4, provided the chosen cell at the intersection of the currently selected row, column, and level is unoccupied (blank), ensuring no overlapping pieces. If it is not a player's turn, their only legal action is to perform a no-operation (noop), effectively passing. When a player selects a coordinate value, the game updates that coordinate for their role, and if the selected cell defined by the current row, column, and level selections is blank, the cell is marked with the player's team symbol (X or O). After a successful placement, the turn passes to the next role in the cyclic order, and the game state reflects the updated board and current control. The game imposes implicit constraints such as board boundaries (coordinates must be between 1 and 4), exclusivity of cell occupation, and the necessity that selections correspond to the current player's role. The game terminates when a player forms a line of four of their symbols in a row, column, level, or any straight line along any direction in the three-dimensional grid, or when no blank cells remain on the board, indicating a full board. Victory is awarded to the player who achieves a line of four symbols, granting them a score of 100. If no such line exists and the board is full, both players receive a score of 50. Conversely, if a player’s opponent has formed a line, the player receives zero points. Thus, the objective is to strategically select coordinates on one's turn to place markers and create a straight line of four in the 4x4x4 grid before the opponent does or before the board fills up.",
    "output": "(role xrow)\n(role xcolumn)\n(role xlevel)\n(role orow)\n(role ocolumn)\n(role olevel)\n(role_selects xrow row)\n(role_selects orow row)\n(role_selects xcolumn column)\n(role_selects ocolumn column)\n(role_selects xlevel level)\n(role_selects olevel level)\n(sign xrow x)\n(sign xcolumn x)\n(sign xlevel x)\n(sign orow o)\n(sign ocolumn o)\n(sign olevel o)\n(next_role_in_team xrow xcolumn)\n(next_role_in_team xcolumn xlevel)\n(next_role_in_team xlevel xrow)\n(next_role_in_team orow ocolumn)\n(next_role_in_team ocolumn olevel)\n(next_role_in_team olevel orow)\n(<= (init (cell ?x ?y ?z b))\n(coord ?x)\n(coord ?y)\n(coord ?z))\n(init (control xrow))\n(init (first_role_in_team x xrow))\n(init (first_role_in_team o orow))\n(coord 1)\n(coord 2)\n(coord 3)\n(coord 4)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(<= (next (cell ?m ?n ?o ?s))\n(true (cell ?m ?n ?o ?s))\n(not (selected_cell ?m ?n ?o)))\n(<= (next (cell ?m ?n ?o ?s))\n(selected_cell ?m ?n ?o)\n(true (control ?p))\n(sign ?p ?s))\n(<= (next (selected ?which ?x))\n(selected_2 ?which ?x)\n(not selected_a_cell))\n(<= (nextplayer ?p1 ?p2)\nselected_a_cell\n(sign ?p1 ?s1)\n(true (first_role_in_team ?s2 ?p2))\n(distinct ?s1 ?s2))\n(<= (nextplayer ?p1 ?p2)\n(not selected_a_cell)\n(next_role_in_team ?p1 ?p2))\n(<= (next (control ?p2))\n(true (control ?p1))\n(nextplayer ?p1 ?p2))\n(<= (next (first_role_in_team ?s ?p))\n(not selected_a_cell)\n(true (first_role_in_team ?s ?p)))\n(<= (next (first_role_in_team ?s ?pold))\nselected_a_cell\n(true (control ?p))\n(true (first_role_in_team ?s ?pold))\n(not (sign ?p ?s)))\n(<= (next (first_role_in_team ?s ?pnew))\nselected_a_cell\n(true (control ?p))\n(sign ?p ?s)\n(true (first_role_in_team ?s ?pold))\n(next_role_in_team ?pold ?pnew))\n(<= (selected_cell ?m ?n ?o)\n(selected_2 row ?m)\n(selected_2 column ?n)\n(selected_2 level ?o))\n(<= selected_a_cell\n(selected_cell ?m ?n ?o))\n(<= (selected_2 ?which ?x)\n(true (selected ?which ?x)))\n(<= (selected_2 ?which ?x)\n(does ?p (select ?which ?x)))\n(<= (line ?s)\n(true (cell ?x1 ?y1 ?z1 ?s))\n(direction ?xd ?yd ?zd)\n(next_coord ?xd ?x1 ?x2)\n(next_coord ?yd ?y1 ?y2)\n(next_coord ?zd ?z1 ?z2)\n(true (cell ?x2 ?y2 ?z2 ?s))\n(next_coord ?xd ?x2 ?x3)\n(next_coord ?yd ?y2 ?y3)\n(next_coord ?zd ?z2 ?z3)\n(true (cell ?x3 ?y3 ?z3 ?s))\n(next_coord ?xd ?x3 ?x4)\n(next_coord ?yd ?y3 ?y4)\n(next_coord ?zd ?z3 ?z4)\n(true (cell ?x4 ?y4 ?z4 ?s)))\n(direction plus equal equal)\n(direction equal plus equal)\n(direction equal equal plus)\n(direction plus plus equal)\n(direction plus minus equal)\n(direction plus equal plus)\n(direction plus equal minus)\n(direction equal plus plus)\n(direction equal plus minus)\n(direction plus plus plus)\n(direction plus plus minus)\n(direction plus minus plus)\n(direction plus minus minus)\n(<= (next_coord equal ?x ?x)\n(coord ?x))\n(<= (next_coord plus ?x1 ?x2)\n(succ ?x1 ?x2))\n(<= (next_coord minus ?x1 ?x2)\n(succ ?x2 ?x1))\n(<= open\n(true (cell ?x ?y ?z b)))\n(<= (legal ?p noop)\n(role ?p)\n(not (true (control ?p))))\n(<= (legal ?p (select ?which ?m))\n(true (control ?p))\n(role_selects ?p ?which)\n(legal_select_cell ?x ?y ?z)\n(legal_select ?x ?y ?z ?which ?m))\n(<= (legal_select ?x ?y ?z row ?x)\n(coord ?x)\n(coord ?y)\n(coord ?z))\n(<= (legal_select ?x ?y ?z column ?y)\n(coord ?x)\n(coord ?y)\n(coord ?z))\n(<= (legal_select ?x ?y ?z level ?z)\n(coord ?x)\n(coord ?y)\n(coord ?z))\n(<= (legal_select_cell ?x ?y ?z)\n(true (cell ?x ?y ?z b))\n(possible row ?x)\n(possible column ?y)\n(possible level ?z))\n(<= (possible ?which ?x)\n(true (selected ?which ?x)))\n(<= (possible ?which ?x)\n(role_selects ?someone ?which)\n(not (selected_any ?which))\n(coord ?x))\n(<= (selected_any ?which)\n(true (selected ?which ?x)))\n(<= (goal ?p 100)\n(sign ?p ?s)\n(line ?s))\n(<= (goal ?p 50)\n(role ?p)\n(not (line x))\n(not (line o)))\n(<= (goal ?p 0)\n(sign ?p ?s)\n(sign ?p1 ?s1)\n(distinct ?s ?s1)\n(line ?s1))\n(<= terminal\n(sign ?p ?s)\n(line ?s))\n(<= terminal\n(not open))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-6 grid defined by coordinates from 1 to 8 along the x-axis (columns) and 1 to 6 along the y-axis (rows), where the bottom row is y=1 and the top y=6. There are two players, red and black, who alternate turns in two separate modes or phases referred to as \"normal\" and \"suicide,\" each controlling the play in turn. Initially, both control states start with red having the move in normal mode. On each turn, a player either performs a drop action or, if it is not their turn in either mode, they must choose the noop action, which is legal only when the player is not in control in either mode. A legal drop action consists of placing a disc into a column that has at least one open cell at the topmost unoccupied position within that column for the mode in question; the action format is either drop_normal or drop_suicide followed by the column number, and a drop is legal only if that column is open in the respective mode and the player has control in that mode. When a disc is dropped into a column, it occupies the lowest unoccupied cell in that column, either at row 1 if the column is empty or the next open row above the existing discs, updating the corresponding cell state for that mode. After a move, control passes to the opposing player in the same mode, alternating between red and black in normal and suicide modes independently. The game enforces implicit constraints such as no disc can be placed outside the defined board boundaries of columns 1 through 8 and rows 1 through 6, discs stack vertically without gaps, and no cell can be occupied by more than one disc. The game terminates when either player forms a line of four consecutive discs horizontally, vertically, or diagonally in the current mode's board or when the board is full with no open columns remaining. The line is defined by four cells in succession either in a row, a column, or along either diagonal direction. Scoring depends on the mode and outcome: in normal mode, a player who forms a line wins with a score of 100, if neither player has a line and the board is full, both score 50, and if the opponent forms a line first or the board is still open with no line, the score is zero. In suicide mode, the scoring is inverted so that forming a line results in zero points for that player and 100 for the opponent, and filling the board without a line yields 50 points for both. The overall game ends when either the normal or suicide mode reaches a terminal state, and the final goals and scores are derived accordingly from whichever mode triggered the termination.",
    "output": "(role red)\n(role black)\n(init (control_normal red))\n(init (control_suicide red))\n(<= (legal ?p noop)\n    (role ?p)\n    (not (true (control_normal ?p)))\n    (not (true (control_suicide ?p))))\n(<= (legal red (drop_normal ?x))\n    (true (control_normal red))\n    (column_open_normal ?x))\n(<= (legal black (drop_normal ?x))\n    (true (control_normal black))\n    (column_open_normal ?x))\n(<= (next (cell_normal ?x 1 ?player))\n    (does ?player (drop_normal ?x))\n    (column_empty_normal ?x))\n(<= (next (cell_normal ?x ?y2 ?player))\n    (does ?player (drop_normal ?x))\n    (cell_normal_open_normal ?x ?y2)\n    (succ ?y1 ?y2)\n    (not (cell_normal_open_normal ?x ?y1)))\n(<= (next (cell_normal ?x ?y ?player))\n    (true (cell_normal ?x ?y ?player)))\n(<= (next (control_normal red))\n    (true (control_normal black)))\n(<= (next (control_normal black))\n    (true (control_normal red)))\n(<= (next (control_suicide red))\n    (true (control_suicide black)))\n(<= (next (control_suicide black))\n    (true (control_suicide red)))\n(<= terminal_normal\n    (line_normal red))\n(<= terminal_normal\n    (line_normal black))\n(<= terminal_normal\n    (not board_open_normal))\n(<= (goal_normal red 100)\n    (line_normal red))\n(<= (goal_normal red 50)\n    (not (line_normal red))\n    (not (line_normal black))\n    (not board_open_normal))\n(<= (goal_normal red 0)\n    (line_normal black))\n(<= (goal_normal red 0)\n    (not (line_normal red))\n    (not (line_normal black))\n    board_open_normal)\n(<= (goal_normal black 100)\n    (line_normal black))\n(<= (goal_normal black 50)\n    (not (line_normal red))\n    (not (line_normal black))\n    (not board_open_normal))\n(<= (goal_normal black 0)\n    (line_normal red))\n(<= (goal_normal black 0)\n    (not (line_normal red))\n    (not (line_normal black))\n    board_open_normal)\n(<= (cell_normal_open_normal ?x ?y)\n    (x ?x)\n    (y ?y)\n    (not (true (cell_normal ?x ?y red)))\n    (not (true (cell_normal ?x ?y black))))\n(<= (column_open_normal ?x)\n    (cell_normal_open_normal ?x 6))\n(<= (column_empty_normal ?x)\n    (cell_normal_open_normal ?x 1))\n(<= board_open_normal (x ?x)\n    (column_open_normal ?x))\n(<= (line_normal ?player)\n    (true (cell_normal ?x1 ?y ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (true (cell_normal ?x2 ?y ?player))\n    (true (cell_normal ?x3 ?y ?player))\n    (true (cell_normal ?x4 ?y ?player)))\n(<= (line_normal ?player)\n    (true (cell_normal ?x ?y1 ?player))\n    (succ ?y1 ?y2)\n    (succ ?y2 ?y3)\n    (succ ?y3 ?y4)\n    (true (cell_normal ?x ?y2 ?player))\n    (true (cell_normal ?x ?y3 ?player))\n    (true (cell_normal ?x ?y4 ?player)))\n(<= (line_normal ?player)\n    (true (cell_normal ?x1 ?y1 ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?y1 ?y2)\n    (succ ?y2 ?y3)\n    (succ ?y3 ?y4)\n    (true (cell_normal ?x2 ?y2 ?player))\n    (true (cell_normal ?x3 ?y3 ?player))\n    (true (cell_normal ?x4 ?y4 ?player)))\n(<= (line_normal ?player)\n    (true (cell_normal ?x1 ?y4 ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?y3 ?y4)\n    (succ ?y2 ?y3)\n    (succ ?y1 ?y2)\n    (true (cell_normal ?x2 ?y3 ?player))\n    (true (cell_normal ?x3 ?y2 ?player))\n    (true (cell_normal ?x4 ?y1 ?player)))\n(<= (legal red (drop_suicide ?x))\n    (true (control_suicide red))\n    (column_open_suicide ?x))\n(<= (legal black (drop_suicide ?x))\n    (true (control_suicide black))\n    (column_open_suicide ?x))\n(<= (next (cell_suicide ?x 1 ?player))\n    (does ?player (drop_suicide ?x))\n    (column_empty_suicide ?x))\n(<= (next (cell_suicide ?x ?y2 ?player))\n    (does ?player (drop_suicide ?x))\n    (cell_suicide_open_suicide ?x ?y2)\n    (succ ?y1 ?y2)\n    (not (cell_suicide_open_suicide ?x ?y1)))\n(<= (next (cell_suicide ?x ?y ?player))\n    (true (cell_suicide ?x ?y ?player)))\n(<= terminal_suicide\n    (line_suicide red))\n(<= terminal_suicide\n    (line_suicide black))\n(<= terminal_suicide\n    (not board_open_suicide))\n(<= (goal_suicide red 100)\n    (line_suicide black))\n(<= (goal_suicide red 50)\n    (not board_open_suicide))\n(<= (goal_suicide red 0)\n    (line_suicide red))\n(<= (goal_suicide black 100)\n    (line_suicide red))\n(<= (goal_suicide black 50)\n    (not board_open_suicide))\n(<= (goal_suicide black 0)\n    (line_suicide black))\n(<= (cell_suicide_open_suicide ?x ?y)\n    (x ?x)\n    (y ?y)\n    (not (true (cell_suicide ?x ?y red)))\n    (not (true (cell_suicide ?x ?y black))))\n(<= (column_open_suicide ?x)\n    (cell_suicide_open_suicide ?x 6))\n(<= (column_empty_suicide ?x)\n    (cell_suicide_open_suicide ?x 1))\n(<= board_open_suicide\n    (x ?x)\n    (column_open_suicide ?x))\n(<= (line_suicide ?player)\n    (true (cell_suicide ?x1 ?y ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (true (cell_suicide ?x2 ?y ?player))\n    (true (cell_suicide ?x3 ?y ?player))\n    (true (cell_suicide ?x4 ?y ?player)))\n(<= (line_suicide ?player)\n    (true (cell_suicide ?x ?y1 ?player))\n    (succ ?y1 ?y2)\n    (succ ?y2 ?y3)\n    (succ ?y3 ?y4)\n    (true (cell_suicide ?x ?y2 ?player))\n    (true (cell_suicide ?x ?y3 ?player))\n    (true (cell_suicide ?x ?y4 ?player)))\n(<= (line_suicide ?player)\n    (true (cell_suicide ?x1 ?y1 ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?y1 ?y2)\n    (succ ?y2 ?y3)\n    (succ ?y3 ?y4)\n    (true (cell_suicide ?x2 ?y2 ?player))\n    (true (cell_suicide ?x3 ?y3 ?player))\n    (true (cell_suicide ?x4 ?y4 ?player)))\n(<= (line_suicide ?player)\n    (true (cell_suicide ?x1 ?y4 ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?y3 ?y4)\n    (succ ?y2 ?y3)\n    (succ ?y1 ?y2)\n    (true (cell_suicide ?x2 ?y3 ?player))\n    (true (cell_suicide ?x3 ?y2 ?player))\n    (true (cell_suicide ?x4 ?y1 ?player)))\n(<= (goal red 100)\n    (goal_normal red 100)\n    terminal_normal)\n(<= (goal red 50)\n    (goal_normal red 50)\n    terminal_normal)\n(<= (goal red 0)\n    (goal_normal red 0)\n    terminal_normal)\n(<= (goal red 100)\n    (goal_suicide red 100)\n    terminal_suicide)\n(<= (goal red 50)\n    (goal_suicide red 50)\n    terminal_suicide)\n(<= (goal red 0)\n    (goal_suicide red 0)\n    terminal_suicide)\n(<= (goal black 100)\n    (goal_normal black 100)\n    terminal_normal)\n(<= (goal black 50)\n    (goal_normal black 50)\n    terminal_normal)\n(<= (goal black 0)\n    (goal_normal black 0)\n    terminal_normal)\n(<= (goal black 100)\n    (goal_suicide black 100)\n    terminal_suicide)\n(<= (goal black 50)\n    (goal_suicide black 50)\n    terminal_suicide)\n(<= (goal black 0)\n    (goal_suicide black 0)\n    terminal_suicide)\n(<= terminal\n    terminal_normal)\n(<= terminal\n    terminal_suicide)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(x 1)\n(x 2)\n(x 3)\n(x 4)\n(x 5)\n(x 6)\n(x 7)\n(x 8)\n(y 1)\n(y 2)\n(y 3)\n(y 4)\n(y 5)\n(y 6)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid defined by rows labeled r1 through r5 and columns labeled c1 through c5, with neighboring rows and columns established to form a coordinate system where adjacency is defined by immediate succession in rows and columns. Two players, named 'x' and 'o', alternate turns with player 'x' starting the game as indicated by the initial control state. Each player begins with eight quads and zero white tokens. The board cells are initialized as empty (denoted by 'b') in the specified grid locations. On a player's turn, they may perform one of two legal actions if it is their control: either mark a cell that is currently blank, or block a cell that is blank provided that the player has at least one white token available. Marking a cell changes that cell's state to the current player's marker, while blocking changes it to a white token, consuming one white token from the player. If it is not a player's turn, their only legal action is a no-operation (noop). After each action, control typically passes to the other player following a mark action, but remains with the same player after a block action. The board state updates accordingly, maintaining that cells can only be marked or blocked if they are blank, and the grid boundaries restrict positions to the specified rows and columns. The game detects terminal conditions when one player has formed a square of four of their marks anywhere on the board, resulting in a win for that player and a loss for the opponent. Additionally, the game ends if no open positions remain. A special win condition, called winByOpenQuad, occurs when one player has three markers in a square with one blank cell, provided the opponent has no winning squares and the game is not open; this influences scoring but does not immediately end the game. Scoring is based on these conditions: a win yields 100 points, a winByOpenQuad yields 95 for player x and 5 for player o, while other outcomes depend on the comparative number of white tokens each player holds, with more white tokens providing a higher score when no wins or open quads exist. The opponent's score is complementary, with losses scoring zero points. The game proceeds until a terminal condition—win, lose, or no open moves—is met, at which point the final goal values determine the winner.",
    "output": "(role x)\n(role o)\n(init (quad x 8))\n(init (quad o 8))\n(init (white x 0))\n(init (white o 0))\n(init (cell r1 c2 b))\n(init (cell r1 c3 b))\n(init (cell r1 c4 b))\n(init (cell r2 c1 b))\n(init (cell r2 c2 b))\n(init (cell r2 c3 b))\n(init (cell r2 c4 b))\n(init (cell r2 c5 b))\n(init (cell r3 c1 b))\n(init (cell r3 c2 b))\n(init (cell r3 c3 b))\n(init (cell r3 c4 b))\n(init (cell r3 c5 b))\n(init (cell r4 c1 b))\n(init (cell r4 c2 b))\n(init (cell r4 c3 b))\n(init (cell r4 c4 b))\n(init (cell r4 c5 b))\n(init (cell r5 c2 b))\n(init (cell r5 c3 b))\n(init (cell r5 c4 b))\n(init (control x))\n(ncol c1 c2)\n(ncol c2 c3)\n(ncol c3 c4)\n(ncol c4 c5)\n(ncol c5 c6)\n(ncol c6 c7)\n(ncol c7 c8)\n(ncol c8 c9)\n(ncol c9 c10)\n(ncol c10 c11)\n(nrow r1 r2)\n(nrow r2 r3)\n(nrow r3 r4)\n(nrow r4 r5)\n(nrow r5 r6)\n(nrow r6 r7)\n(nrow r7 r8)\n(nrow r8 r9)\n(nrow r9 r10)\n(nrow r10 r11)\n(<= (prow ?x ?y) (nrow ?y ?x))\n(<= (pcol ?x ?y) (ncol ?y ?x))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(<= (legal ?player (mark ?x ?y)) (true (cell ?x ?y b)) (true (control ?player)))\n(<= (legal ?player (block ?x ?y)) (true (cell ?x ?y b)) (true (control ?player)) (true (white ?player ?c)) (distinct ?c 0))\n(<= (legal x noop) (true (control o)))\n(<= (legal o noop) (true (control x)))\n(<= (next (cell ?m ?n ?p)) (does ?p (mark ?m ?n)))\n(<= (next (cell ?m ?n w)) (does ?p (block ?m ?n)))\n(<= (next (cell ?m ?n ?p)) (true (cell ?m ?n ?p)) (distinct ?p b))\n(<= (next (cell ?m ?n b)) (does ?W (mark ?j ?k)) (true(cell ?m ?n b)) (distinct ?m ?j))\n(<= (next (cell ?m ?n b)) (does ?W (mark ?j ?k)) (true(cell ?m ?n b)) (distinct ?n ?k))\n(<= (next (cell ?m ?n b)) (does ?W (block ?j ?k)) (true(cell ?m ?n b)) (distinct ?m ?j))\n(<= (next (cell ?m ?n b)) (does ?W (block ?j ?k)) (true(cell ?m ?n b)) (distinct ?n ?k))\n(<= (next (quad ?p ?c)) (true (control ?q)) (true (quad ?p ?c)) (distinct ?p ?q))\n(<= (next (white ?p ?c)) (true (control ?q)) (true (white ?p ?c)) (distinct ?p ?q))\n(<= (next (quad ?p ?c)) (does ?p (mark ?j ?k)) (true (quad ?p ?c1)) (succ ?c ?c1))\n(<= (next (white ?p ?c)) (does ?p (block ?j ?k)) (true (white ?p ?c1)) (succ ?c ?c1))\n(<= (next (quad ?p ?c)) (does ?p (block ?j ?k)) (true (quad ?p ?c)))\n(<= (next (white ?p ?c)) (does ?p (mark ?j ?k)) (true (white ?p ?c)))\n(<= (next (control x)) (does o (mark ?j ?k)) (true (control o)))\n(<= (next (control o)) (does x (mark ?j ?k)) (true (control x)))\n(<= (next (control ?p)) (does ?p (block ?j ?k)) (true (control ?p)))\n(<= (square ?x1 ?y1 ?x1 ?y2 ?x2 ?y1 ?x2 ?y2) (ncol ?y1 ?y2) (nrow ?x1 ?x2))\n(<= (square ?x1 ?y1 ?x1 ?y2 ?x2 ?y1 ?x2 ?y2) (ncol ?y3 ?y2) (nrow ?x3 ?x2) (square ?x1 ?y1 ?x1 ?y3 ?x3 ?y1 ?x3 ?y3))\n(<= (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) (prow ?x2p ?x2) (ncol ?y3n ?y3) (prow ?x4p ?x4) (ncol ?y4n ?y4)\n   (square ?x1 ?y1 ?x2p ?y2 ?x3 ?y3n ?x4p ?y4n))\n(<= win\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= lose\n   (true (cell ?x1 ?y1 o)) (true (cell ?x2 ?y2 o))\n   (true (cell ?x3 ?y3 o)) (true (cell ?x4 ?y4 o))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 b))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 b))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 b)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 b)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= open\n   (true (quad ?p ?c)) (distinct ?c 0))\n(<= (more ?x 0) (succ ?y ?x))\n(<= (more ?x ?y) (succ ?x1 ?x) (succ ?y1 ?y) (more ?x1 ?y1))\n(<= morewhite (true (white x ?a)) (true (white o ?b)) (more ?a ?b))\n(<= lesswhite (true (white x ?a)) (true (white o ?b)) (more ?b ?a))\n(<= equalwhite (true (white x ?a)) (true (white o ?a)))\n(<= (goal x 100) win)\n(<= (goal x 95)  (not win) winByOpenQuad)\n(<= (goal x 90)  (not win) (not winByOpenQuad) (not lose) (not open) morewhite)\n(<= (goal x 50)  (not win) (not winByOpenQuad) (not lose) (not open) equalwhite)\n(<= (goal x 10)  (not win) (not winByOpenQuad) (not lose) (not open) lesswhite)\n(<= (goal x 0)   lose)\n(<= (goal o 100) lose)\n(<= (goal o 90)  (not win) (not winByOpenQuad) (not lose) (not open) lesswhite)\n(<= (goal o 50)  (not win) (not winByOpenQuad) (not lose) (not open) equalwhite)\n(<= (goal o 10)  (not win) (not winByOpenQuad) (not lose) (not open) morewhite)\n(<= (goal o 5)   (not win) winByOpenQuad)\n(<= (goal o 0)   win)\n(<= terminal win)\n(<= terminal lose)\n(<= terminal (not open))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a linear environment consisting of twelve distinct positions arranged sequentially and numbered from one to twelve. The coordinate system is a simple one-dimensional sequence with each position capable of being empty or occupied by a stone. There are two players, designated as black and red, who alternate turns beginning with the black player. Initially, all twelve positions are empty, no stones are placed, and the control is assigned to the black player; the game step counter starts at one. On each turn, the player in control may perform one of the legal actions: adding a stone of their color to an empty position that is allowed for play, removing one of their own stones from such a position, or performing a no-operation (noop) move if it is not their turn to play. The noop action is only legal for the player who does not currently have control, effectively passing the turn to the opponent. To add a stone, the targeted position must be empty and considered a legal play location, the stone type must be valid, and the player must not have already placed two stones of that type; furthermore, the player cannot add a stone of the same type to the same position if they removed it in the previous turn. To remove a stone, the position must be currently occupied by a stone owned by the player and also be a legal play location. After a player's action, control switches to the other player, and the step counter increments by one. The state updates automatically depending on the actions: if a stone is added to a position, that position becomes occupied by that stone; if a stone is removed, the position becomes empty. Positions not affected by the current action maintain their previous occupancy status, and ownership of stones remains consistent unless changed through removal or addition. Implicit constraints include the boundaries of the board (positions one through twelve), the requirement that stones can only be placed on empty and legal positions, and that no more than two stones of the same type may be present at once. The game ends when the predefined terminal conditions are met, which are not explicitly detailed here but typically involve no further legal moves or achieving a victory condition. Victory criteria are not explicitly stated in the provided description, implying the need for additional context or rules to determine scoring or winning. Overall, the game structure enforces alternating turns with careful management of stone placement and removal within a bounded linear board, ensuring orderly progression and state consistency through well-defined legal actions and state transitions.",
    "output": "(role black)\n(role red)\n(init (position 1 empty))\n(init (position 2 empty))\n(init (position 3 empty))\n(init (position 4 empty))\n(init (position 5 empty))\n(init (position 6 empty))\n(init (position 7 empty))\n(init (position 8 empty))\n(init (position 9 empty))\n(init (position 10 empty))\n(init (position 11 empty))\n(init (position 12 empty))\n(init (control black))\n(init (step 1))\n(init (legalPlayLoc 1))\n(init (legalPlayLoc 2))\n(init (legalPlayLoc 3))\n(init (legalPlayLoc 4))\n(init (legalPlayLoc 5))\n(init (legalPlayLoc 6))\n(init (legalPlayLoc 7))\n(init (legalPlayLoc 8))\n(init (legalPlayLoc 9))\n(init (legalPlayLoc 10))\n(init (legalPlayLoc 11))\n(init (legalPlayLoc 12))\n(<= (legal ?player (add ?pos ?stone))\n    (true (control ?player))\n    (true (position ?pos empty))\n    (true (legalPlayLoc ?pos))\n\t(isStone ?stone)\n    (not (alreadyTwoOf ?stone))\n    (not (currentPlayerRemovedLastTurn ?stone ?pos)))\n(<= (legal ?player (remove ?pos ?stone))\n    (true (control ?player))\n    (true (owner ?pos ?player))\n    (true (legalPlayLoc ?pos))\n\t(true (position ?pos ?stone)))\n(<= (legal red noop)\n    (true (control black)))\n(<= (legal black noop)\n    (true (control red)))\n(<= (next (control red))\n\t(true (control black)))\n(<= (next (control black))\n\t(true (control red)))\n(<= (next (step ?stepNum))\n\t(true (step ?oldStep))\n\t(succ ?oldStep ?stepNum))\n(<= (next (owner ?pos ?player))\n\t(true (owner ?pos ?player))\n\t(true (position ?pos ?stone))\n\t(not (does ?player (remove ?pos ?stone))))\n(<= (next (owner ?pos ?player))\n\t(does ?player (add ?pos ?stone)))\n(<= (next (position ?pos empty))\n\t(true (position ?pos empty))\n\t(not (stoneAddedToPos ?pos)))\n(<= (stoneAddedToPos ?pos)\n\t(does ?player (add ?pos ?stone)))\n(<= (next (position ?pos ?stone))\n\t(isStone ?stone)\n\t(true (position ?pos ?stone))\n\t(not (stoneRemovedFromPos ?pos)))\n(<= (stoneRemovedFromPos ?pos)\n\t(does ?player (remove ?pos ?stone)))\n(<= (next (position ?pos empty))\n    (does ?player (remove ?pos ?stone)))\n(<= (next (position ?pos ?stone))\n    (does ?player (add ?pos ?stone)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set in an abstract environment with no spatial coordinates or traditional board layout, instead revolving around four players named player1, player2, player3, and player4, who take turns in a fixed order corresponding to their roles. At the start, none of the players have made any guesses. During each turn, the current player must perform a guess action by selecting a number between 0 and 100 inclusive; this guess is the only legal move allowed for that player when it is their turn. The game proceeds sequentially with each player making exactly one guess, and the game ends immediately after the first guess is made by any player, marking the terminal condition. The action of guessing records the player's chosen number as their guess in the next state. The core mechanics involve calculating the sum of all players' guesses and then determining two-thirds of the average of these guesses, with the average computed by dividing the total sum by four (the number of players). Each player's closeness score is computed as the absolute difference between their individual guess and this two-thirds average. The player whose guess is closest to this value is identified as the closest player, while others are considered not closest. The victory condition awards the player who is closest a goal score of 100, while all other players receive zero. Implicit constraints include that guesses must be within the allowed numeric range and only one guess per player is recorded; since the game ends after the first guess, in practice, only that initial guess is considered for scoring. There is no explicit noop action because players must guess on their turn, and the game concludes right after the initial guess, making further turns irrelevant. The game’s progression and state changes are dictated entirely by the sequence of guesses, the summation of these guesses, and the calculation of closeness to the two-thirds average, culminating in a single player’s victory or others’ losses based on this proximity metric.",
    "output": "(role player1)\n(role player2)\n(role player3)\n(role player4)\n(<= (legal ?player (guess ?number))\n    (role ?player)\n    (guessableNumber ?number))\n(<= (next (guessed ?player ?number))\n    (does ?player (guess ?number)))\n(<= (total ?total)\n    (true (guessed player1 ?n1))\n    (true (guessed player2 ?n2))\n    (sum ?n1 ?n2 ?s1)\n    (true (guessed player3 ?n3))\n    (sum ?s1 ?n3 ?s2)\n    (true (guessed player4 ?n4))\n    (sum ?s2 ?n4 ?total))\n(<= (halfTotal ?half)\n    (total ?total)\n    (times2 ?half ?total))\n(<= (halfTotal ?half)\n    (total ?total)\n    (succ ?total ?tp1)\n    (times2 ?half ?tp1))\n(<= (twoThirdsAverage ?out)\n    (halfTotal ?half)\n    (times3 ?out ?half))\n(<= (twoThirdsAverage ?out)\n    (halfTotal ?half)\n    (succ ?half ?hp1)\n    (times3 ?out ?hp1))\n(<= (twoThirdsAverage ?out)\n    (halfTotal ?half)\n    (succ ?hm1 ?half)\n    (times3 ?out ?hm1))\n(<= (closeness ?player ?score)\n    (true (guessed ?player ?guess))\n    (twoThirdsAverage ?result)\n    (absDiff ?result ?guess ?score))\n(<= (notClosest ?player)\n    (closeness ?player ?score)\n    (closeness ?otherPlayer ?lowerScore)\n    (distinct ?player ?otherPlayer)\n    (lt ?lowerScore ?score))\n(<= (closest ?player)\n    (role ?player)\n    (not (notClosest ?player)))\n(<= (goal ?player 100)\n    (closest ?player))\n(<= (goal ?player 0)\n    (notClosest ?player))\n(<= terminal\n    (true (guessed ?player ?number)))\n(<= (absDiff ?x ?x 0)\n    (anyNumber ?x))\n(<= (absDiff ?x ?y ?z)\n    (lt ?y ?x)\n    (succ ?xm1 ?x)\n    (absDiff ?xm1 ?y ?zm1)\n    (succ ?zm1 ?z))\n(<= (absDiff ?x ?y ?z)\n    (lt ?x ?y)\n    (succ ?ym1 ?y)\n    (absDiff ?x ?ym1 ?zm1)\n    (succ ?zm1 ?z))\n(<= (sum ?x 0 ?x)\n    (anyNumber ?x))\n(<= (sum ?x ?y ?z)\n    (succ ?ym1 ?y)\n    (sum ?x ?ym1 ?zm1)\n    (succ ?zm1 ?z))\n(times2 0 0)\n(<= (times2 ?x ?y)\n    (succ ?ym1 ?y)\n    (succ ?ym2 ?ym1)\n    (times2 ?xm1 ?ym2)\n    (succ ?xm1 ?x))\n(times3 0 0)\n(<= (times3 ?x ?y)\n    (succ ?ym1 ?y)\n    (succ ?ym2 ?ym1)\n    (succ ?ym3 ?ym2)\n    (times3 ?xm1 ?ym3)\n    (succ ?xm1 ?x))\n(<= (lt ?x ?y)\n    (lte ?x ?y)\n    (distinct ?x ?y))\n(<= (lte ?x ?x)\n    (anyNumber ?x))\n(<= (lte ?x ?y)\n    (succ ?ym1 ?y)\n    (lte ?x ?ym1))\n(anyNumber 0)\n(<= (anyNumber ?n)\n    (succ ?m ?n))\n(<= (guessableNumber ?number)\n    (lte ?number 100))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)\n(succ 100 101)\n(succ 101 102)\n(succ 102 103)\n(succ 103 104)\n(succ 104 105)\n(succ 105 106)\n(succ 106 107)\n(succ 107 108)\n(succ 108 109)\n(succ 109 110)\n(succ 110 111)\n(succ 111 112)\n(succ 112 113)\n(succ 113 114)\n(succ 114 115)\n(succ 115 116)\n(succ 116 117)\n(succ 117 118)\n(succ 118 119)\n(succ 119 120)\n(succ 120 121)\n(succ 121 122)\n(succ 122 123)\n(succ 123 124)\n(succ 124 125)\n(succ 125 126)\n(succ 126 127)\n(succ 127 128)\n(succ 128 129)\n(succ 129 130)\n(succ 130 131)\n(succ 131 132)\n(succ 132 133)\n(succ 133 134)\n(succ 134 135)\n(succ 135 136)\n(succ 136 137)\n(succ 137 138)\n(succ 138 139)\n(succ 139 140)\n(succ 140 141)\n(succ 141 142)\n(succ 142 143)\n(succ 143 144)\n(succ 144 145)\n(succ 145 146)\n(succ 146 147)\n(succ 147 148)\n(succ 148 149)\n(succ 149 150)\n(succ 150 151)\n(succ 151 152)\n(succ 152 153)\n(succ 153 154)\n(succ 154 155)\n(succ 155 156)\n(succ 156 157)\n(succ 157 158)\n(succ 158 159)\n(succ 159 160)\n(succ 160 161)\n(succ 161 162)\n(succ 162 163)\n(succ 163 164)\n(succ 164 165)\n(succ 165 166)\n(succ 166 167)\n(succ 167 168)\n(succ 168 169)\n(succ 169 170)\n(succ 170 171)\n(succ 171 172)\n(succ 172 173)\n(succ 173 174)\n(succ 174 175)\n(succ 175 176)\n(succ 176 177)\n(succ 177 178)\n(succ 178 179)\n(succ 179 180)\n(succ 180 181)\n(succ 181 182)\n(succ 182 183)\n(succ 183 184)\n(succ 184 185)\n(succ 185 186)\n(succ 186 187)\n(succ 187 188)\n(succ 188 189)\n(succ 189 190)\n(succ 190 191)\n(succ 191 192)\n(succ 192 193)\n(succ 193 194)\n(succ 194 195)\n(succ 195 196)\n(succ 196 197)\n(succ 197 198)\n(succ 198 199)\n(succ 199 200)\n(succ 200 201)\n(succ 201 202)\n(succ 202 203)\n(succ 203 204)\n(succ 204 205)\n(succ 205 206)\n(succ 206 207)\n(succ 207 208)\n(succ 208 209)\n(succ 209 210)\n(succ 210 211)\n(succ 211 212)\n(succ 212 213)\n(succ 213 214)\n(succ 214 215)\n(succ 215 216)\n(succ 216 217)\n(succ 217 218)\n(succ 218 219)\n(succ 219 220)\n(succ 220 221)\n(succ 221 222)\n(succ 222 223)\n(succ 223 224)\n(succ 224 225)\n(succ 225 226)\n(succ 226 227)\n(succ 227 228)\n(succ 228 229)\n(succ 229 230)\n(succ 230 231)\n(succ 231 232)\n(succ 232 233)\n(succ 233 234)\n(succ 234 235)\n(succ 235 236)\n(succ 236 237)\n(succ 237 238)\n(succ 238 239)\n(succ 239 240)\n(succ 240 241)\n(succ 241 242)\n(succ 242 243)\n(succ 243 244)\n(succ 244 245)\n(succ 245 246)\n(succ 246 247)\n(succ 247 248)\n(succ 248 249)\n(succ 249 250)\n(succ 250 251)\n(succ 251 252)\n(succ 252 253)\n(succ 253 254)\n(succ 254 255)\n(succ 255 256)\n(succ 256 257)\n(succ 257 258)\n(succ 258 259)\n(succ 259 260)\n(succ 260 261)\n(succ 261 262)\n(succ 262 263)\n(succ 263 264)\n(succ 264 265)\n(succ 265 266)\n(succ 266 267)\n(succ 267 268)\n(succ 268 269)\n(succ 269 270)\n(succ 270 271)\n(succ 271 272)\n(succ 272 273)\n(succ 273 274)\n(succ 274 275)\n(succ 275 276)\n(succ 276 277)\n(succ 277 278)\n(succ 278 279)\n(succ 279 280)\n(succ 280 281)\n(succ 281 282)\n(succ 282 283)\n(succ 283 284)\n(succ 284 285)\n(succ 285 286)\n(succ 286 287)\n(succ 287 288)\n(succ 288 289)\n(succ 289 290)\n(succ 290 291)\n(succ 291 292)\n(succ 292 293)\n(succ 293 294)\n(succ 294 295)\n(succ 295 296)\n(succ 296 297)\n(succ 297 298)\n(succ 298 299)\n(succ 299 300)\n(succ 300 301)\n(succ 301 302)\n(succ 302 303)\n(succ 303 304)\n(succ 304 305)\n(succ 305 306)\n(succ 306 307)\n(succ 307 308)\n(succ 308 309)\n(succ 309 310)\n(succ 310 311)\n(succ 311 312)\n(succ 312 313)\n(succ 313 314)\n(succ 314 315)\n(succ 315 316)\n(succ 316 317)\n(succ 317 318)\n(succ 318 319)\n(succ 319 320)\n(succ 320 321)\n(succ 321 322)\n(succ 322 323)\n(succ 323 324)\n(succ 324 325)\n(succ 325 326)\n(succ 326 327)\n(succ 327 328)\n(succ 328 329)\n(succ 329 330)\n(succ 330 331)\n(succ 331 332)\n(succ 332 333)\n(succ 333 334)\n(succ 334 335)\n(succ 335 336)\n(succ 336 337)\n(succ 337 338)\n(succ 338 339)\n(succ 339 340)\n(succ 340 341)\n(succ 341 342)\n(succ 342 343)\n(succ 343 344)\n(succ 344 345)\n(succ 345 346)\n(succ 346 347)\n(succ 347 348)\n(succ 348 349)\n(succ 349 350)\n(succ 350 351)\n(succ 351 352)\n(succ 352 353)\n(succ 353 354)\n(succ 354 355)\n(succ 355 356)\n(succ 356 357)\n(succ 357 358)\n(succ 358 359)\n(succ 359 360)\n(succ 360 361)\n(succ 361 362)\n(succ 362 363)\n(succ 363 364)\n(succ 364 365)\n(succ 365 366)\n(succ 366 367)\n(succ 367 368)\n(succ 368 369)\n(succ 369 370)\n(succ 370 371)\n(succ 371 372)\n(succ 372 373)\n(succ 373 374)\n(succ 374 375)\n(succ 375 376)\n(succ 376 377)\n(succ 377 378)\n(succ 378 379)\n(succ 379 380)\n(succ 380 381)\n(succ 381 382)\n(succ 382 383)\n(succ 383 384)\n(succ 384 385)\n(succ 385 386)\n(succ 386 387)\n(succ 387 388)\n(succ 388 389)\n(succ 389 390)\n(succ 390 391)\n(succ 391 392)\n(succ 392 393)\n(succ 393 394)\n(succ 394 395)\n(succ 395 396)\n(succ 396 397)\n(succ 397 398)\n(succ 398 399)\n(succ 399 400)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on an 8-by-8 grid, where cells are identified by x and y coordinates ranging from 1 to 8, with the origin presumably at the bottom-left corner, and directions north, south, east, and west corresponding to increments or decrements in the y or x coordinates respectively. Two player roles exist: the explorer and the mummy, who alternate turns with the explorer moving first. Initially, the explorer starts at position (6,3), the mummy at (2,5), and there is an exit located at (1,3). Certain boundaries between cells are blocked either to the north or east, preventing movement across these edges. On each turn, the player in control may choose a move action; the explorer can move one step in a direction or choose to stay put (no-op) when it is not their turn, while the mummy can move exactly two steps in sequence, each in a legal direction, or do nothing if it is not its turn. A movement step is legal if it leads to an adjacent cell that is within the board limits, not blocked by any walls, and respects the occupancy constraints, notably that the mummy’s two-step move cannot end on the explorer’s starting cell of that turn to avoid overlap. The control alternates strictly between the explorer and the mummy after each move. Moving involves updating the player’s location based on the chosen directions, and the game state increments a step counter each turn. The game ends under one of three terminal conditions: the explorer is captured by occupying the same cell as the mummy, the explorer reaches the exit cell, or a timeout occurs after 50 steps. The explorer wins by reaching the exit without being captured, earning 100 points, or by surviving until timeout without being caught or exiting, earning 50 points; being captured or failing to reach the exit before timeout yields zero points. Conversely, the mummy wins by capturing the explorer, earning 100 points, or by surviving until timeout without the explorer exiting or being captured, earning 50 points; if the explorer exits safely or timeout occurs without capture, the mummy scores zero. Implicit constraints include blocked edges that prevent crossing from one cell to another in certain directions, the requirement that all moves remain within the bounds of the 8-by-8 grid, and that the mummy’s two-step move cannot land back on its starting cell or overlap with the explorer’s location during that turn. No-ops are only legal when the player does not have the control, serving as a mechanism to pass turns when it is not their move. Thus, the game challenges the explorer to navigate through a maze of blocked paths to reach the exit while evading the mummy who attempts to capture them by moving twice per turn.",
    "output": "(role explorer)\n(role mummy)\n(init (location explorer 6 3))\n(init (location mummy 2 5))\n(init (location exit 1 3))\n(init (blockedNorth 1 1))\n(init (blockedNorth 8 1))\n(init (blockedNorth 6 2))\n(init (blockedNorth 7 2))\n(init (blockedNorth 2 3))\n(init (blockedNorth 3 3))\n(init (blockedNorth 4 3))\n(init (blockedNorth 5 3))\n(init (blockedNorth 6 3))\n(init (blockedNorth 8 3))\n(init (blockedNorth 1 4))\n(init (blockedNorth 2 4))\n(init (blockedNorth 4 4))\n(init (blockedNorth 8 4))\n(init (blockedNorth 2 5))\n(init (blockedNorth 5 5))\n(init (blockedNorth 7 5))\n(init (blockedNorth 1 6))\n(init (blockedNorth 3 6))\n(init (blockedNorth 5 6))\n(init (blockedNorth 1 7))\n(init (blockedNorth 7 7))\n(init (blockedNorth 8 7))\n(init (blockedEast 1 2))\n(init (blockedEast 1 4))\n(init (blockedEast 2 1))\n(init (blockedEast 2 3))\n(init (blockedEast 2 5))\n(init (blockedEast 2 7))\n(init (blockedEast 4 2))\n(init (blockedEast 4 4))\n(init (blockedEast 5 3))\n(init (blockedEast 5 4))\n(init (blockedEast 5 7))\n(init (blockedEast 5 8))\n(init (blockedEast 6 1))\n(init (blockedEast 6 4))\n(init (blockedEast 6 6))\n(init (blockedEast 7 7))\n(init (control explorer))\n(init (step 1))\n(<= (legal explorer (move1 ?dir))\n    (true (control explorer))\n    (true (location explorer ?x ?y))\n    (legalStep ?dir ?x ?y))\n(<= (legal explorer (move1 nowhere))\n    (not (true (control explorer))))\n(<= (legal mummy (move2 ?dir1 ?dir2))\n    (true (control mummy))\n    (true (location mummy ?x1 ?y1))\n    (legalStep ?dir1 ?x1 ?y1)\n    (distinct ?dir1 nowhere)\n    (nextCell ?dir1 ?x1 ?y1 ?x2 ?y2)\n    (legalStep ?dir2 ?x2 ?y2)\n    (nextCell ?dir2 ?x2 ?y2 ?x3 ?y3)\n    (distinctCell ?x1 ?y1 ?x3 ?y3))\n(<= (legal mummy (move2 nowhere nowhere))\n    (not (true (control mummy))))\n(<= (next (control explorer))\n    (true (control mummy)))\n(<= (next (control mummy))\n    (true (control explorer)))\n(<= (next (location exit ?x ?y))\n    (true (location exit ?x ?y)))\n(<= (next (blockedNorth ?x ?y))\n    (true (blockedNorth ?x ?y)))\n(<= (next (blockedEast ?x ?y))\n    (true (blockedEast ?x ?y)))\n(<= (next (location explorer ?x2 ?y2))\n    (true (location explorer ?x1 ?y1))\n    (does explorer (move1 ?dir))\n    (nextCell ?dir ?x1 ?y1 ?x2 ?y2))\n(<= (next (location mummy ?x3 ?y3))\n    (true (location mummy ?x1 ?y1))\n    (does mummy (move2 ?dir1 ?dir2))\n    (nextCell ?dir1 ?x1 ?y1 ?x2 ?y2)\n    (nextCell ?dir2 ?x2 ?y2 ?x3 ?y3))\n(<= (next (step ?n++))\n    (true (step ?n))\n    (succ ?n ?n++))\n(<= terminal\n    captured)\n(<= terminal\n    atExit)\n(<= terminal\n    timeout)\n(<= (goal explorer 0)\n    captured)\n(<= (goal explorer 0)\n    (not atExit)\n    (not captured)\n    (not timeout))\n(<= (goal explorer 50)\n    timeout\n    (not atExit)\n    (not captured))\n(<= (goal explorer 100)\n    atExit\n    (not captured))\n(<= (goal mummy 0)\n    atExit\n    (not captured))\n(<= (goal mummy 0)\n    (not atExit)\n    (not captured)\n    (not timeout))\n(<= (goal mummy 50)\n    timeout\n    (not atExit)\n    (not captured))\n(<= (goal mummy 100)\n    captured)\n(<= (legalStep north ?x ?y)\n    (++ ?y ?yNew)\n    (cell ?x ?yNew)\n    (not (blocked ?x ?y ?x ?yNew)))\n(<= (legalStep south ?x ?y)\n    (-- ?y ?yNew)\n    (cell ?x ?yNew)\n    (not (blocked ?x ?y ?x ?yNew)))\n(<= (legalStep east ?x ?y)\n    (++ ?x ?xNew)\n    (cell ?xNew ?y)\n    (not (blocked ?x ?y ?xNew ?y)))\n(<= (legalStep west ?x ?y)\n    (-- ?x ?xNew)\n    (cell ?xNew ?y)\n    (not (blocked ?x ?y ?xNew ?y)))\n(<= (legalStep nowhere ?x ?y)\n    (cell ?x ?y))\n(<= (nextCell north ?x ?y ?x ?yNew)\n    (index ?x)\n    (++ ?y ?yNew))\n(<= (nextCell south ?x ?y ?x ?yNew)\n    (index ?x)\n    (-- ?y ?yNew))\n(<= (nextCell east ?x ?y ?xNew ?y)\n    (index ?y)\n    (++ ?x ?xNew))\n(<= (nextCell west ?x ?y ?xNew ?y)\n    (index ?y)\n    (-- ?x ?xNew))\n(<= (nextCell nowhere ?x ?y ?x ?y)\n    (cell ?x ?y))\n(<= (blocked ?x ?y1 ?x ?y2)\n    (true (blockedNorth ?x ?y1))\n    (++ ?y1 ?y2))\n(<= (blocked ?x ?y2 ?x ?y1)\n    (true (blockedNorth ?x ?y1))\n    (++ ?y1 ?y2))\n(<= (blocked ?x1 ?y ?x2 ?y)\n    (true (blockedEast ?x1 ?y))\n    (++ ?x1 ?x2))\n(<= (blocked ?x2 ?y ?x1 ?y)\n    (true (blockedEast ?x1 ?y))\n    (++ ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n\t(cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n\t(cell ?x1 ?y1)\n\t(cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= atExit\n    (true (location explorer ?x ?y))\n    (true (location exit ?x ?y)))\n(<= captured\n    (true (location explorer ?x ?y))\n    (true (location mummy ?x ?y)))\n(<= timeout\n    (true (step 50)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(cell 1 8) (cell 2 8) (cell 3 8) (cell 4 8) (cell 5 8) (cell 6 8) (cell 7 8) (cell 8 8)\n(cell 1 7) (cell 2 7) (cell 3 7) (cell 4 7) (cell 5 7) (cell 6 7) (cell 7 7) (cell 8 7)\n(cell 1 6) (cell 2 6) (cell 3 6) (cell 4 6) (cell 5 6) (cell 6 6) (cell 7 6) (cell 8 6)\n(cell 1 5) (cell 2 5) (cell 3 5) (cell 4 5) (cell 5 5) (cell 6 5) (cell 7 5) (cell 8 5)\n(cell 1 4) (cell 2 4) (cell 3 4) (cell 4 4) (cell 5 4) (cell 6 4) (cell 7 4) (cell 8 4)\n(cell 1 3) (cell 2 3) (cell 3 3) (cell 4 3) (cell 5 3) (cell 6 3) (cell 7 3) (cell 8 3)\n(cell 1 2) (cell 2 2) (cell 3 2) (cell 4 2) (cell 5 2) (cell 6 2) (cell 7 2) (cell 8 2)\n(cell 1 1) (cell 2 1) (cell 3 1) (cell 4 1) (cell 5 1) (cell 6 1) (cell 7 1) (cell 8 1)\n(++ 1 2) (++ 2 3) (++ 3 4) (++ 4 5) (++ 5 6) (++ 6 7) (++ 7 8)\n(-- 8 7) (-- 7 6) (-- 6 5) (-- 5 4) (-- 4 3) (-- 3 2) (-- 2 1)\n(succ  1  2) (succ  2  3) (succ  3  4) (succ  4  5) (succ  5  6)\n(succ  6  7) (succ  7  8) (succ  8  9) (succ  9 10) (succ 10 11)\n(succ 11 12) (succ 12 13) (succ 13 14) (succ 14 15) (succ 15 16)\n(succ 16 17) (succ 17 18) (succ 18 19) (succ 19 20) (succ 20 21)\n(succ 21 22) (succ 22 23) (succ 23 24) (succ 24 25) (succ 25 26)\n(succ 26 27) (succ 27 28) (succ 28 29) (succ 29 30) (succ 30 31)\n(succ 31 32) (succ 32 33) (succ 33 34) (succ 34 35) (succ 35 36)\n(succ 36 37) (succ 37 38) (succ 38 39) (succ 39 40) (succ 40 41)\n(succ 41 42) (succ 42 43) (succ 43 44) (succ 44 45) (succ 45 46)\n(succ 46 47) (succ 47 48) (succ 48 49) (succ 49 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a board arranged as a grid with seven rows labeled from r1 to r7 and nine columns labeled from c1 to c9, where rows and columns wrap around cyclically. Each cell on the board can be in one of several states such as blank (b), wall, point, or exit, with initial placements predefined for each cell. There is a single player role called \"snake\" who controls the movement of the snake on the board. The game begins with the snake positioned at cell c6 r4, which is also the initial tail position, and the player's score starting at zero points. Turns proceed sequentially with the snake making a move each step, up to a maximum of 50 steps; if no legal move exists or the snake reaches an exit cell, the game ends. On each turn, the snake must choose a move direction from up, down, left, or right, represented by actions that move the snake's head to an adjacent cell in the specified direction, provided that the destination cell is either blank, contains a point, or is the exit, and is not occupied by a wall or otherwise impassable terrain. The coordinate system enforces adjacency by defining \"next cells\" for each direction, ensuring moves wrap around the board edges due to the cyclic nature of rows and columns. When a move is executed, the snake's head advances to the new cell, and the tail position updates accordingly every other move, effectively simulating the snake's movement and growth. If the snake moves onto a point cell, the points counter increments by one, and the previous position of the tail becomes blank on even moves. The state transitions are governed by whether the current move count is even or odd, toggling tail movement and cell state changes appropriately. The snake cannot move into walls or outside the board, and it must avoid positions already occupied by its body except the tail under specific conditions. The game terminates if the snake reaches an exit cell, if 50 steps have elapsed, or if there are no legal moves available. The player's score upon termination depends on the number of points collected and whether the snake is on an exit cell, with a predefined scoring table mapping points to scores; reaching the exit yields a higher score than not doing so with the same number of points. Thus, the objective is to maneuver the snake around the board to collect points and reach the exit within the step limit while avoiding collisions and impassable cells.",
    "output": "(role snake)\n(init (cell c1 r1 b))\n(init (cell c2 r1 b))\n(init (cell c3 r1 b))\n(init (cell c4 r1 wall))\n(init (cell c5 r1 b))\n(init (cell c6 r1 b))\n(init (cell c7 r1 wall))\n(init (cell c8 r1 point))\n(init (cell c9 r1 b))\n(init (cell c1 r2 wall))\n(init (cell c2 r2 wall))\n(init (cell c3 r2 point))\n(init (cell c4 r2 wall))\n(init (cell c5 r2 b))\n(init (cell c6 r2 b))\n(init (cell c7 r2 b))\n(init (cell c8 r2 b))\n(init (cell c9 r2 b))\n(init (cell c1 r3 b))\n(init (cell c2 r3 b))\n(init (cell c3 r3 b))\n(init (cell c4 r3 wall))\n(init (cell c5 r3 wall))\n(init (cell c6 r3 wall))\n(init (cell c7 r3 point))\n(init (cell c8 r3 wall))\n(init (cell c9 r3 wall))\n(init (cell c1 r4 point))\n(init (cell c2 r4 wall))\n(init (cell c3 r4 b))\n(init (cell c4 r4 b))\n(init (cell c5 r4 b))\n(init (cell c6 r4 b))\n(init (cell c7 r4 b))\n(init (cell c8 r4 b))\n(init (cell c9 r4 b))\n(init (cell c1 r5 wall))\n(init (cell c2 r5 wall))\n(init (cell c3 r5 b))\n(init (cell c4 r5 wall))\n(init (cell c5 r5 wall))\n(init (cell c6 r5 b))\n(init (cell c7 r5 wall))\n(init (cell c8 r5 b))\n(init (cell c9 r5 wall))\n(init (cell c1 r6 b))\n(init (cell c2 r6 wall))\n(init (cell c3 r6 exit))\n(init (cell c4 r6 b))\n(init (cell c5 r6 b))\n(init (cell c6 r6 point))\n(init (cell c7 r6 wall))\n(init (cell c8 r6 point))\n(init (cell c9 r6 b))\n(init (cell c1 r7 b))\n(init (cell c2 r7 wall))\n(init (cell c3 r7 wall))\n(init (cell c4 r7 wall))\n(init (cell c5 r7 wall))\n(init (cell c6 r7 b))\n(init (cell c7 r7 wall))\n(init (cell c8 r7 b))\n(init (cell c9 r7 b))\n(init (step 0))\n(init (pos c6 r4))\n(init (tailpos c6 r4))\n(init (points 0))\n(<= (nextcell ?x ?y1 mov_up ?x ?y2)\n(rowinc ?y2 ?y1)\n(column ?x))\n(<= (nextcell ?x ?y1 mov_down ?x ?y2)\n(rowinc ?y1 ?y2)\n(column ?x))\n(<= (nextcell ?x1 ?y mov_left ?x2 ?y)\n(colinc ?x2 ?x1)\n(row ?y))\n(<= (nextcell ?x1 ?y mov_right ?x2 ?y)\n(colinc ?x1 ?x2)\n(row ?y))\n(rowinc r1 r2) (rowinc r2 r3) (rowinc r3 r4) (rowinc r4 r5) (rowinc r5 r6) (rowinc r6 r7) (rowinc r7 r1)\n(row r1) (row r2) (row r3) (row r4) (row r5) (row r6) (row r7)\n(colinc c1 c2) (colinc c2 c3) (colinc c3 c4) (colinc c4 c5) (colinc c5 c6) (colinc c6 c7) (colinc c7 c8) (colinc c8 c9) (colinc c9 c1)\n(column c1) (column c2) (column c3) (column c4) (column c5) (column c6) (column c7) (column c8) (column c9)\n(<= (legal snake ?move)\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn)\n(maymove ?xn ?yn))\n(<= (maymove ?x ?y)\n(true (cell ?x ?y b)))\n(<= (maymove ?x ?y)\n(true (cell ?x ?y point)))\n(<= (maymove ?x ?y)\n(true (cell ?x ?y exit)))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(<= (next (cell ?x ?y ?move))\n(does snake ?move)\n(true (pos ?x ?y)))\n(<= (next (pos ?xn ?yn))\n(does snake ?move)\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn))\n(<= (next evenmove) (not (true evenmove)))\n(<= (next (tailpos ?x ?y))\n(not (true evenmove))\n(true (tailpos ?x ?y)))\n(<= (next (tailpos ?xn ?yn))\n(true evenmove)\n(true (tailpos ?x ?y))\n(true (cell ?x ?y ?move))\n(nextcell ?x ?y ?move ?xn ?yn))\n(<= (next (cell ?x ?y b))\n(true evenmove)\n(true (tailpos ?x ?y)))\n(<= (next (cell ?x ?y ?sym))\n(true (cell ?x ?y ?sym))\n(not (true (pos ?x ?y)))\n(not (true evenmove)))\n(<= (next (cell ?x ?y ?sym))\n(true (cell ?x ?y ?sym))\n(not (true (pos ?x ?y)))\n(not (true (tailpos ?x ?y))))\n(<= (next (points ?n1))\n(true (points ?n))\ndoscore\n(succ ?n ?n1))\n(<= (next (points ?n))\n(true (points ?n))\n(not doscore))\n(<= doscore\n(true (pos ?x ?y))\n(true (cell ?x ?y point)))\n(score 0 0 0)\n(score 1 8 58)\n(score 2 16 66)\n(score 3 24 74)\n(score 4 32 82)\n(score 5 40 90)\n(score 6 50 100)\n(<= (goal snake ?s)\n(true (points ?n))\n(true (pos ?x ?y))\n(true (cell ?x ?y exit))\n(score ?n ?s1 ?s))\n(<= (goal snake ?s)\n(true (points ?n))\n(true (pos ?x ?y))\n(not (true (cell ?x ?y exit)))\n(score ?n ?s ?s1))\n(<= terminal\n(true (pos ?x ?y))\n(true (cell ?x ?y exit)))\n(<= terminal\n(true (step 50)))\n(<= terminal\n(not exists_legal))\n(<= exists_legal\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn)\n(maymove ?xn ?yn))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played by a single player role called \"robot\" within a grid-based environment defined by rows and columns numbered sequentially from 1 upwards, with each cell initially blank. The coordinate system uses these row and column numbers to identify cells, and the initial state sets all cells to blank and establishes a placement counter starting at one. Players take turns in a sequence consisting solely of the robot, who on each turn may place a queen on any blank cell; the action format is \"place\" followed by the row and column numbers, and it is legal only if the targeted cell is currently blank. Upon placing a queen, the state updates that cell to hold a queen, while all other cells retain their previous contents, and the placement counter increments by one. The turn control progresses automatically with no explicit 'noop' action needed, as the robot must place a queen each turn until all placements are completed, indicated by the absence of an ongoing placing phase. Implicit constraints include that queens cannot be placed outside the predefined grid boundaries, and no cell may be occupied by more than one queen. A cell is considered attacked if it shares the same row, the same column, or the same diagonal with any placed queen, where diagonals are determined by equal sums or differences of row and column indices. The game terminates once the placing phase concludes, meaning no further placements remain. Scoring is binary: the robot scores zero if any queen is attacked by another, otherwise the robot scores 100 points, representing a successful configuration with no queens threatening each other.",
    "output": "(role robot)\n(<= (init (cell ?row ?col blank))\n    (number ?row)\n    (number ?col))\n(init (placing 1))\n(<= (legal robot (place ?row ?col))\n    (true (cell ?row ?col blank)))\n(<= (next (cell ?row ?col queen))\n    (does robot (place ?row ?col)))\n(<= (next (cell ?row ?col ?type))\n    (true (cell ?row ?col ?type))\n    (not (does robot (place ?row ?col))))\n(<= (next (placing ?n2))\n    (true (placing ?n1))\n    (succ ?n1 ?n2))\n(<= terminal\n    (not still_placing))\n(<= still_placing\n    (true (placing ?n)))\n(<= (goal robot 0)\n    (true (cell ?row ?col queen))\n    (attacked ?row ?col))\n(<= (goal robot 100)\n    (not (goal robot 0)))\n(<= (number ?n)\n    (succ ?n ?m))\n(<= (number ?m)\n    (succ ?n ?m))\n(<= (ext_succ ?n1 ?n2)\n    (succ ?n1 ?n2))\n(<= (ext_number ?n)\n    (ext_succ ?n ?m))\n(<= (ext_number ?m)\n    (ext_succ ?n ?m))\n(<= (plus ?n 0 ?n)\n    (ext_number ?n))\n(<= (plus ?x ?y ?z)\n    (ext_succ ?y2 ?y)\n    (ext_succ ?x ?x2)\n    (plus ?x2 ?y2 ?z))\n(type queen)\n(type blank)\n(<= (attacked ?row ?col)\n    (true (cell ?row ?col2 queen))\n    (number ?col)\n    (distinct ?col ?col2))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col queen))\n    (number ?row)\n    (distinct ?row ?row2))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col2 queen))\n    (plus ?row ?col ?c)\n    (plus ?row2 ?col2 ?c)\n    (distinct ?row ?row2))\n(<= (attacked ?row ?col)\n    (true (cell ?row2 ?col2 queen))\n    (plus ?c ?col ?row)\n    (plus ?c ?col2 ?row2)\n    (distinct ?row ?row2))\n(succ 1   2)\n(succ 2   3)\n(succ 3   4)\n(succ 4   5)\n(succ 5   6)\n(succ 6   7)\n(succ 7   8)\n(succ 8   9)\n(succ 9  10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(ext_succ m16 m15)\n(ext_succ m15 m14)\n(ext_succ m14 m13)\n(ext_succ m13 m12)\n(ext_succ m12 m11)\n(ext_succ m11 m10)\n(ext_succ m10 m9)\n(ext_succ m9  m8)\n(ext_succ m8  m7)\n(ext_succ m7  m6)\n(ext_succ m6  m5)\n(ext_succ m5  m4)\n(ext_succ m4  m3)\n(ext_succ m3  m2)\n(ext_succ m2  m1)\n(ext_succ m1   0)\n(ext_succ  0   1)\n(ext_succ  1   2)\n(ext_succ  2   3)\n(ext_succ  3   4)\n(ext_succ  4   5)\n(ext_succ  5   6)\n(ext_succ  6   7)\n(ext_succ  7   8)\n(ext_succ  8   9)\n(ext_succ  9  10)\n(ext_succ 10  11)\n(ext_succ 11  12)\n(ext_succ 12  13)\n(ext_succ 13  14)\n(ext_succ 14  15)\n(ext_succ 15  16)\n(ext_succ 16  17)\n(ext_succ 17  18)\n(ext_succ 18  19)\n(ext_succ 19  20)\n(ext_succ 20  21)\n(ext_succ 21  22)\n(ext_succ 22  23)\n(ext_succ 23  24)\n(ext_succ 24  25)\n(ext_succ 25  26)\n(ext_succ 26  27)\n(ext_succ 27  28)\n(ext_succ 28  29)\n(ext_succ 29  30)\n(ext_succ 30  31)\n(ext_succ 31  32)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on an 8-by-8 grid with coordinates labeled from 1 to 8 along both the horizontal (x) and vertical (y) axes, forming the board environment. Two players participate, identified as black and red, who alternate turns with black moving first. The initial setup places four pieces in the center of the board: black pieces at positions (4,4) and (5,5), and red pieces at (4,5) and (5,4), with black having the initial control to make a move. On each turn, the player in control may take a legal action to mark a cell by placing their piece at coordinates (x,y) if that cell is open and the move results in flipping at least one of the opponent's pieces according to the game’s flipping rules, which involve line sequences of opponent pieces bounded by player pieces in any of the eight directions (north, south, east, west, northeast, northwest, southeast, southwest). If the player has no legal moves available, they must perform a noop action to pass their turn. Additionally, if the opponent has no legal moves on their subsequent turn, they too must noop, allowing the original player to continue. The marking action updates the board by placing the player's piece at the specified cell and flipping all appropriate opponent pieces that are enclosed between the newly placed piece and another piece of the current player along valid directions. The turn then passes to the opponent unless they have no legal moves, in which case control remains with the current player. Moves are constrained by the board boundaries, requiring all coordinates for placement and flipping to lie within the 1-to-8 range on both axes, and by the occupancy rule that a move can only be made on an empty cell. The game terminates when neither player has any legal moves remaining, at which point the winner is determined by counting the number of pieces each player controls on the board. The player with the greater number of pieces is awarded a victory score of 100, the player with fewer pieces receives 0, and in the event of a tie, both players receive a score of 50. Thus, the game embodies a turn-based strategy focused on area control through piece placement and flipping mechanics, with the outcome decided by final piece majority on the grid.",
    "output": "(role black)\n(role red)\n(init (cell 4 4 black))\n(init (cell 4 5 red))\n(init (cell 5 4 red))\n(init (cell 5 5 black))\n(init (control black))\n(<= (legal ?player (mark ?x ?y))\n(true (control ?player))\n(haslegalmoveat ?player ?x ?y))\n(<= (legal ?player noop)\n(true (control ?player))\n(not (hasanylegalmove ?player)))\n(<= (legal ?player noop)\n(opponent ?player ?opponent)\n(true (control ?opponent)))\n(<= (next (cell ?x ?y ?player))\n(does ?player (mark ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n(true (cell ?x ?y ?player))\n(opponent ?player ?opponent)\n(does ?opponent noop))\n(<= (next (cell ?xp ?yp ?player))\n(true (cell ?xp ?yp ?player))\n(opponent ?player ?opponent)\n(does ?opponent (mark ?xo ?yo))\n(not (playwillflip ?opponent ?xo ?yo ?player ?xp ?yp)))\n(<= (next (cell ?xp ?yp ?opponent))\n(true (cell ?xp ?yp ?player))\n(opponent ?player ?opponent)\n(does ?opponent (mark ?xo ?yo))\n(playwillflip ?opponent ?xo ?yo ?player ?xp ?yp))\n(<= (next (control black))\n(true (control red)))\n(<= (next (control red))\n(true (control black)))\n(<= terminal\ngameover)\n(<= (goal black 0)\n(not gameover))\n(<= (goal black 100)\ngameover\n(tally ?black ?red)\n(lessthan ?red ?black))\n(<= (goal black 50)\ngameover\n(tally ?tied ?tied))\n(<= (goal black 0)\ngameover\n(tally ?black ?red)\n(lessthan ?black ?red))\n(<= (goal red 0)\n(not gameover))\n(<= (goal red 100)\ngameover\n(tally ?black ?red)\n(lessthan ?black ?red))\n(<= (goal red 50)\ngameover\n(tally ?tied ?tied))\n(<= (goal red 0)\ngameover\n(tally ?black ?red)\n(lessthan ?red ?black))\n(<= (cellopen ?x ?y)\n(index ?x)\n(index ?y)\n(not (true (cell ?x ?y black)))\n(not (true (cell ?x ?y red))))\n(<= (nextcell n ?x ?y1 ?x ?y2)\n(index ?x)\n(index++ ?y1 ?y2))\n(<= (nextcell s ?x ?y1 ?x ?y2)\n(index ?x)\n(index++ ?y2 ?y1))\n(<= (nextcell e ?x1 ?y ?x2 ?y)\n(index++ ?x1 ?x2)\n(index ?y))\n(<= (nextcell w ?x1 ?y ?x2 ?y)\n(index++ ?x2 ?x1)\n(index ?y))\n(<= (nextcell ne ?x1 ?y1 ?x2 ?y2)\n(index++ ?x1 ?x2)\n(index++ ?y1 ?y2))\n(<= (nextcell nw ?x1 ?y1 ?x2 ?y2)\n(index++ ?x2 ?x1)\n(index++ ?y1 ?y2))\n(<= (nextcell se ?x1 ?y1 ?x2 ?y2)\n(index++ ?x1 ?x2)\n(index++ ?y2 ?y1))\n(<= (nextcell sw ?x1 ?y1 ?x2 ?y2)\n(index++ ?x2 ?x1)\n(index++ ?y2 ?y1))\n(<= (openpiecestring ?player ?x0 ?y0 ?dir ?xf ?yf)\n(true (cell ?x0 ?y0 ?player))\n(nextcell ?dir ?x0 ?y0 ?xnext ?ynext)\n(openpiecestring ?player ?xnext ?ynext ?dir ?xf ?yf))\n(<= (openpiecestring ?player ?x0 ?y0 ?dir ?xf ?yf)\n(true (cell ?x0 ?y0 ?player))\n(nextcell ?dir ?x0 ?y0 ?xf ?yf))\n(<= (closedpiecestring ?player ?x0 ?y0 ?dir ?xf ?yf)\n(true (cell ?x0 ?y0 ?player))\n(nextcell ?dir ?x0 ?y0 ?xnext ?ynext)\n(closedpiecestring ?player ?xnext ?ynext ?dir ?xf ?yf))\n(<= (closedpiecestring ?player ?x0 ?y0 ?dir ?xf ?yf)\n(true (cell ?x0 ?y0 ?player))\n(nextcell ?dir ?x0 ?y0 ?xf ?yf)\n(opponent ?player ?opponent)\n(true (cell ?xf ?yf ?opponent)))\n(<= (playwillflip ?player ?xp ?yp ?opponent ?xo ?yo)\n(role ?player)\n(openpiecestring ?opponent ?xo ?yo ?dir ?xp ?yp)\n(opposite ?dir ?oppdir)\n(closedpiecestring ?opponent ?xo ?yo ?oppdir ?xany ?yany))\n(<= (haslegalmoveat ?player ?xp ?yp)\n(cellopen ?xp ?yp)\n(opponent ?player ?opponent)\n(true (cell ?xo ?yo ?opponent))\n(playwillflip ?player ?xp ?yp ?opponent ?xo ?yo))\n(<= (hasanylegalmove ?player)\n(haslegalmoveat ?player ?x ?y))\n(<= (tally ?black ?red)\n(piececount 1 1 ?black ?red))\n(<= (piececount ?x ?y ?blackcount++ ?redcount)\n(distinct ?y 8)\n(index++ ?y ?y++)\n(true (cell ?x ?y black))\n(piececount ?x ?y++ ?blackcount ?redcount)\n(++ ?blackcount ?blackcount++))\n(<= (piececount ?x ?y ?blackcount ?redcount++)\n(distinct ?y 8)\n(index++ ?y ?y++)\n(true (cell ?x ?y red))\n(piececount ?x ?y++ ?blackcount ?redcount)\n(++ ?redcount ?redcount++))\n(<= (piececount ?x ?y ?blackcount ?redcount)\n(distinct ?y 8)\n(index++ ?y ?y++)\n(cellopen ?x ?y)\n(piececount ?x ?y++ ?blackcount ?redcount))\n(<= (piececount ?x 8 ?blackcount++ ?redcount)\n(distinct ?x 8)\n(index++ ?x ?x++)\n(true (cell ?x 8 black))\n(piececount ?x++ 1 ?blackcount ?redcount)\n(++ ?blackcount ?blackcount++))\n(<= (piececount ?x 8 ?blackcount ?redcount++)\n(distinct ?x 8)\n(index++ ?x ?x++)\n(true (cell ?x 8 red))\n(piececount ?x++ 1 ?blackcount ?redcount)\n(++ ?redcount ?redcount++))\n(<= (piececount ?x 8 ?blackcount ?redcount)\n(distinct ?x 8)\n(index++ ?x ?x++)\n(cellopen ?x 8)\n(piececount ?x++ 1 ?blackcount ?redcount))\n(<= (piececount 8 8 1 0)\n(true (cell 8 8 black)))\n(<= (piececount 8 8 0 1)\n(true (cell 8 8 red)))\n(<= (piececount 8 8 0 0)\n(cellopen 8 8))\n(<= (lessthan ?x ?y)\n(++ ?x ?x++)\n(lessthan ?x++ ?y))\n(<= (lessthan ?x ?y)\n(++ ?x ?y))\n(<= gameover\n(not (hasanylegalmove black))\n(not (hasanylegalmove red)))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index++ 1 2)\n(index++ 2 3)\n(index++ 3 4)\n(index++ 4 5)\n(index++ 5 6)\n(index++ 6 7)\n(index++ 7 8)\n(opponent red black)\n(opponent black red)\n(direction n)\n(direction s)\n(direction e)\n(direction w)\n(direction ne)\n(direction nw)\n(direction se)\n(direction sw)\n(opposite n s)\n(opposite s n)\n(opposite e w)\n(opposite w e)\n(opposite ne sw)\n(opposite sw ne)\n(opposite nw se)\n(opposite se nw)\n(int 0)\n(int 1)\n(int 2)\n(int 3)\n(int 4)\n(int 5)\n(int 6)\n(int 7)\n(int 8)\n(int 9)\n(int 10)\n(int 11)\n(int 12)\n(int 13)\n(int 14)\n(int 15)\n(int 16)\n(int 17)\n(int 18)\n(int 19)\n(int 20)\n(int 21)\n(int 22)\n(int 23)\n(int 24)\n(int 25)\n(int 26)\n(int 27)\n(int 28)\n(int 29)\n(int 30)\n(int 31)\n(int 32)\n(int 33)\n(int 34)\n(int 35)\n(int 36)\n(int 37)\n(int 38)\n(int 39)\n(int 40)\n(int 41)\n(int 42)\n(int 43)\n(int 44)\n(int 45)\n(int 46)\n(int 47)\n(int 48)\n(int 49)\n(int 50)\n(int 51)\n(int 52)\n(int 53)\n(int 54)\n(int 55)\n(int 56)\n(int 57)\n(int 58)\n(int 59)\n(int 60)\n(int 61)\n(int 62)\n(int 63)\n(int 64)\n(++ 0 1)\n(++ 1 2)\n(++ 2 3)\n(++ 3 4)\n(++ 4 5)\n(++ 5 6)\n(++ 6 7)\n(++ 7 8)\n(++ 8 9)\n(++ 9 10)\n(++ 10 11)\n(++ 11 12)\n(++ 12 13)\n(++ 13 14)\n(++ 14 15)\n(++ 15 16)\n(++ 16 17)\n(++ 17 18)\n(++ 18 19)\n(++ 19 20)\n(++ 20 21)\n(++ 21 22)\n(++ 22 23)\n(++ 23 24)\n(++ 24 25)\n(++ 25 26)\n(++ 26 27)\n(++ 27 28)\n(++ 28 29)\n(++ 29 30)\n(++ 30 31)\n(++ 31 32)\n(++ 32 33)\n(++ 33 34)\n(++ 34 35)\n(++ 35 36)\n(++ 36 37)\n(++ 37 38)\n(++ 38 39)\n(++ 39 40)\n(++ 40 41)\n(++ 41 42)\n(++ 42 43)\n(++ 43 44)\n(++ 44 45)\n(++ 45 46)\n(++ 46 47)\n(++ 47 48)\n(++ 48 49)\n(++ 49 50)\n(++ 50 51)\n(++ 51 52)\n(++ 52 53)\n(++ 53 54)\n(++ 54 55)\n(++ 55 56)\n(++ 56 57)\n(++ 57 58)\n(++ 58 59)\n(++ 59 60)\n(++ 60 61)\n(++ 61 62)\n(++ 62 63)\n(++ 63 64)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game \"Flipper\" is played in an abstract environment involving six distinct pancakes labeled p1 through p6, without explicit spatial coordinates but with an implicit order among these pancakes. The player role is singularly named flipper, who takes turns according to a fixed initial player order sequence p1, p5, p3, p6, p4, p2. This sequence represents the order of pancakes associated with the game state. At the start of the game, the flip count is set to zero, and all six pancakes are present. On each turn, the sole player performs exactly one action by selecting a pancake to flip, where the action is formatted as (flip ?x), with ?x being the pancake to flip; this action is legal only if the chosen pancake currently exists in the game state. Performing a flip action triggers a state change where the order of the pancakes is updated by moving the selected pancake to the front of the order and reversing the order of pancakes that were previously ahead of it, effectively rearranging the player order list. Simultaneously, the flip count increments by one, progressing through a succession of states from zero up to a maximum of forty. There is no explicit noop mechanism mentioned; the player must always flip one of the existing pancakes to proceed. Implicit constraints include that only existing pancakes can be flipped, and the order of pancakes must remain a permutation of the original six pancakes, with no additions or removals. The game terminates either when the pancake order returns to the original sequence p1, p2, p3, p4, p5, p6, or when the flip count reaches forty, whichever comes first. The scoring system awards the flipper player a maximum of 100 points if the original pancake order is restored within six flips; the score decreases in increments as the flip count increases, diminishing from 90 points at six flips to 0 points at forty flips, with intermediate thresholds defining the score slabs. Thus, the objective is to restore the original pancake sequence efficiently, minimizing the number of flips to maximize the score before the flip count reaches the terminal limit.",
    "output": "(role flipper)\n(init (porder p1 p5 p3 p6 p4 p2))\n(init (flipcount s0))\n(pancake p1)\n(pancake p2)\n(pancake p3)\n(pancake p4)\n(pancake p5)\n(pancake p6)\n(succ s0 s1)\n(succ s1 s2)\n(succ s2 s3)\n(succ s3 s4)\n(succ s4 s5)\n(succ s5 s6)\n(succ s6 s7)\n(succ s7 s8)\n(succ s8 s9)\n(succ s9 s10)\n(succ s10 s11)\n(succ s11 s12)\n(succ s12 s13)\n(succ s13 s14)\n(succ s14 s15)\n(succ s15 s16)\n(succ s16 s17)\n(succ s17 s18)\n(succ s18 s19)\n(succ s19 s20)\n(succ s20 s21)\n(succ s21 s22)\n(succ s22 s23)\n(succ s23 s24)\n(succ s24 s25)\n(succ s25 s26)\n(succ s26 s27)\n(succ s27 s28)\n(succ s28 s29)\n(succ s29 s30)\n(succ s30 s31)\n(succ s31 s32)\n(succ s32 s33)\n(succ s33 s34)\n(succ s34 s35)\n(succ s35 s36)\n(succ s36 s37)\n(succ s37 s38)\n(succ s38 s39)\n(succ s39 s40)\n(<= (greater ?a ?b)\n    (succ ?b ?a))\n(<= (greater ?a ?b)\n    (distinct ?a ?b)\n    (succ ?c ?a)\n    (greater ?c ?b))\n(<= (legal flipper (flip ?x))\n    (pancake ?x))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p1))\n    (true (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p2))\n    (true (porder ?ng2 ?ng1 ?ng3 ?ng4 ?ng5 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p3))\n    (true (porder ?ng3 ?ng2 ?ng1 ?ng4 ?ng5 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p4))\n    (true (porder ?ng4 ?ng3 ?ng2 ?ng1 ?ng5 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p5))\n    (true (porder ?ng5 ?ng4 ?ng3 ?ng2 ?ng1 ?ng6)))\n(<= (next (porder ?ng1 ?ng2 ?ng3 ?ng4 ?ng5 ?ng6))\n    (does flipper (flip p6))\n    (true (porder ?ng6 ?ng5 ?ng4 ?ng3 ?ng2 ?ng1)))\n(<= (next (flipcount ?b))\n    (true (flipcount ?v))\n    (succ ?v ?b))\n(<= (goal flipper 100)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount ?x))\n    (greater s6 ?x))\n(<= (goal flipper 90)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s6)))\n(<= (goal flipper 85)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s7)))\n(<= (goal flipper 80)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s8)))\n(<= (goal flipper 75)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s9)))\n(<= (goal flipper 70)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s10)))\n(<= (goal flipper 65)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s11)))\n(<= (goal flipper 60)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount s12)))\n(<= (goal flipper 50)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount ?x))\n    (greater ?x s12)\n    (greater s20 ?x))\n(<= (goal flipper 45)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount ?x))\n    (greater ?x s19)\n    (greater s30 ?x))\n(<= (goal flipper 40)\n    (true (porder p1 p2 p3 p4 p5 p6))\n    (true (flipcount ?x))\n    (greater ?x s29)\n    (greater s40 ?x))\n(<= (goal flipper 0)\n    (true (flipcount s40)))\n(<= terminal\n    (true (porder p1 p2 p3 p4 p5 p6)))\n(<= terminal\n    (true (flipcount s40)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a 4-by-4 grid with coordinates ranging from 1 to 4 on both the x (horizontal) and y (vertical) axes. Two players participate, designated as white and black, who alternate turns in a fixed sequence starting with white. The initial state of the board has all cells empty, and all pieces—sixteen distinct pieces identified by unique bit patterns—are available in a shared pool. On each turn, a player first selects one piece from the pool that has not been chosen or placed yet; this selection phase is controlled by the player with selectControl, initially assigned to white. Once a piece is selected, the same player proceeds to place the selected piece onto any empty cell on the board during the placeControl phase. Actions must adhere to strict legality conditions: a player may only select a piece if it is still in the pool and it is their turn to select, and may only place a piece if they have selected it and the target cell is empty. Noop actions are available but only when the player has neither selection nor placement control, effectively serving as a pass or wait mechanism outside of active phases. After a piece is placed, it is removed from the pool and the cell state updates to reflect the piece's presence, while all other cell states remain unchanged. The turn control alternates between players, moving from white's select phase to white's place phase, then to black's select phase, black's place phase, and back to white's select phase, and so forth. The game terminates when a winning line is formed or when no empty cells remain on the board. A winning line consists of four pieces aligned horizontally, vertically, or diagonally, all sharing a common bit value in at least one bit position, meaning that for some bit index, all four pieces in the line have the same bit set or unset. The line formation check occurs for every row, column, and both diagonals. Scoring is based on who placed the last piece and whether a line exists: the player who creates the line receives 100 points, the other player receives zero. If the board is full without a line, both players receive 50 points. If the board is not full and no line exists, both players receive zero points. Implicit constraints include the board boundaries limiting placement to coordinates from 1 to 4 in both directions, each cell can hold only one piece, and pieces once placed cannot be moved again. The game thus requires players to strategically select and place pieces to create a line of four pieces sharing a specific bit characteristic before the board fills up.",
    "output": "(role white)\n(role black)\n(piece p0000)\n(piece p0001)\n(piece p0010)\n(piece p0011)\n(piece p0100)\n(piece p0101)\n(piece p0110)\n(piece p0111)\n(piece p1000)\n(piece p1001)\n(piece p1010)\n(piece p1011)\n(piece p1100)\n(piece p1101)\n(piece p1110)\n(piece p1111)\n(init (cell 1 1 empty))\n(init (cell 1 2 empty))\n(init (cell 1 3 empty))\n(init (cell 1 4 empty))\n(init (cell 2 1 empty))\n(init (cell 2 2 empty))\n(init (cell 2 3 empty))\n(init (cell 2 4 empty))\n(init (cell 3 1 empty))\n(init (cell 3 2 empty))\n(init (cell 3 3 empty))\n(init (cell 3 4 empty))\n(init (cell 4 1 empty))\n(init (cell 4 2 empty))\n(init (cell 4 3 empty))\n(init (cell 4 4 empty))\n(<= (init (pool ?piece)) (piece ?piece))\n(init (selectControl white))\n(<= (legal ?player (select ?piece))\n    (role ?player)\n\t(true (selectControl ?player))\n\t(true (pool ?piece)))\n(<= (legal ?player (place ?piece ?x ?y))\n    (role ?player)\n\t(true (placeControl ?player))\n\t(true (selected ?piece))\n\t(true (cell ?x ?y empty)))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (selectControl ?player)))\n    (not (true (placeControl ?player))))\n(<= (next (pool ?piece))\n    (true (pool ?piece))\n\t(not (does white (select ?piece)))\n    (not (does black (select ?piece))))\n(<= (next (selected ?piece))\n    (role ?player)\n    (does ?player (select ?piece)))\n(<= (next (cell ?x ?y ?state))\n    (true (cell ?x ?y ?state))\n    (role ?player)\n\t(does ?player (select ?piece)))\n(<= (next (cell ?x1 ?y1 ?state))\n    (true (cell ?x1 ?y1 ?state))\n    (role ?player)\n\t(does ?player (place ?piece ?x2 ?y2))\n\t(distinctCell ?x1 ?y1 ?x2 ?y2))\n(<= (next (cell ?x ?y ?piece))\n    (does ?player (place ?piece ?x ?y)))\n(<= (next (selectControl white))\n    (true (placeControl white)))\n(<= (next (placeControl white))\n    (true (selectControl black)))\n(<= (next (selectControl black))\n    (true (placeControl black)))\n(<= (next (placeControl black))\n    (true (selectControl white)))\n(<= terminal\n    line)\n(<= terminal\n    (not boardOpen))\n(<= (goal white 100)\n    line\n\t(placedLast white))\n(<= (goal white 50)\n    (not line)\n\t(not boardOpen))\n(<= (goal white 0)\n    (not line)\n\tboardOpen)\n(<= (goal white 0)\n    line\n\t(placedLast black))\n(<= (goal black 100)\n    line\n\t(placedLast black))\n(<= (goal black 50)\n    (not line)\n\t(not boardOpen))\n(<= (goal black 0)\n    (not line)\n\tboardOpen)\n(<= (goal black 0)\n    line\n\t(placedLast white))\n(<= (placedLast ?player)\n    (true (selectControl ?player)))\n(<= boardOpen\n    (true (cell ?x ?y empty)))\n(<= line\n    row)\n(<= line\n    column)\n(<= line\n    diagonal)\n(<= row\n    (index ?y)\n    (true (cell 1 ?y ?p1))\n\t(true (cell 2 ?y ?p2))\n\t(true (cell 3 ?y ?p3))\n\t(true (cell 4 ?y ?p4))\n\t(set ?p1 ?p2 ?p3 ?p4))\n(<= column\n    (index ?x)\n    (true (cell ?x 1 ?p1))\n\t(true (cell ?x 2 ?p2))\n\t(true (cell ?x 3 ?p3))\n\t(true (cell ?x 4 ?p4))\n\t(set ?p1 ?p2 ?p3 ?p4))\n(<= diagonal\n    (true (cell 1 1 ?p1))\n\t(true (cell 2 2 ?p2))\n\t(true (cell 3 3 ?p3))\n\t(true (cell 4 4 ?p4))\n\t(set ?p1 ?p2 ?p3 ?p4))\n(<= diagonal\n    (true (cell 1 4 ?p1))\n\t(true (cell 2 3 ?p2))\n\t(true (cell 3 2 ?p3))\n\t(true (cell 4 1 ?p4))\n\t(set ?p1 ?p2 ?p3 ?p4))\n(<= (set ?p1 ?p2 ?p3 ?p4)\n    (bit ?bit)\n\t(index ?n)\n    (bitNIs ?n ?p1 ?bit)\n\t(bitNIs ?n ?p2 ?bit)\n\t(bitNIs ?n ?p3 ?bit)\n\t(bitNIs ?n ?p4 ?bit))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n\t(index ?x1)\n\t(index ?y1)\n\t(index ?x2)\n\t(index ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n\t(index ?x1)\n\t(index ?y1)\n\t(index ?x2)\n\t(index ?y2)\n    (distinct ?y1 ?y2))\n(bit 0) (bit 1)\n(index 1) (index 2) (index 3) (index 4)\n(bitNIs 4 p0000 0) (bitNIs 3 p0000 0) (bitNIs 2 p0000 0) (bitNIs 1 p0000 0)\n(bitNIs 4 p0001 0) (bitNIs 3 p0001 0) (bitNIs 2 p0001 0) (bitNIs 1 p0001 1)\n(bitNIs 4 p0010 0) (bitNIs 3 p0010 0) (bitNIs 2 p0010 1) (bitNIs 1 p0010 0)\n(bitNIs 4 p0011 0) (bitNIs 3 p0011 0) (bitNIs 2 p0011 1) (bitNIs 1 p0011 1)\n(bitNIs 4 p0100 0) (bitNIs 3 p0100 1) (bitNIs 2 p0100 0) (bitNIs 1 p0100 0)\n(bitNIs 4 p0101 0) (bitNIs 3 p0101 1) (bitNIs 2 p0101 0) (bitNIs 1 p0101 1)\n(bitNIs 4 p0110 0) (bitNIs 3 p0110 1) (bitNIs 2 p0110 1) (bitNIs 1 p0110 0)\n(bitNIs 4 p0111 0) (bitNIs 3 p0111 1) (bitNIs 2 p0111 1) (bitNIs 1 p0111 1)\n(bitNIs 4 p1000 1) (bitNIs 3 p1000 0) (bitNIs 2 p1000 0) (bitNIs 1 p1000 0)\n(bitNIs 4 p1001 1) (bitNIs 3 p1001 0) (bitNIs 2 p1001 0) (bitNIs 1 p1001 1)\n(bitNIs 4 p1010 1) (bitNIs 3 p1010 0) (bitNIs 2 p1010 1) (bitNIs 1 p1010 0)\n(bitNIs 4 p1011 1) (bitNIs 3 p1011 0) (bitNIs 2 p1011 1) (bitNIs 1 p1011 1)\n(bitNIs 4 p1100 1) (bitNIs 3 p1100 1) (bitNIs 2 p1100 0) (bitNIs 1 p1100 0)\n(bitNIs 4 p1101 1) (bitNIs 3 p1101 1) (bitNIs 2 p1101 0) (bitNIs 1 p1101 1)\n(bitNIs 4 p1110 1) (bitNIs 3 p1110 1) (bitNIs 2 p1110 1) (bitNIs 1 p1110 0)\n(bitNIs 4 p1111 1) (bitNIs 3 p1111 1) (bitNIs 2 p1111 1) (bitNIs 1 p1111 1)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a grid defined by rows labeled from 'a' through 'g' and columns labeled from 'c1' through 'c7', forming a coordinate system where each hole is identified by a row and column pair. There is a single player role called \"jumper,\" who takes turns making moves throughout the game. The initial configuration places pegs in almost every hole except for the central hole at row 'd' and column 'c4', which starts empty. On each turn, the jumper may perform a jump action, specified by the starting hole coordinates (source row and column) and the destination hole coordinates (destination row and column). This action is legal only if the starting hole contains a peg, the destination hole is empty, and there exists a middle hole directly between the start and destination positions that also contains a peg. The middle hole is determined by either being horizontally or vertically adjacent between the start and destination holes, with adjacency defined by successor and predecessor relations for rows and columns. When a jump occurs, the peg from the starting hole moves to the destination hole, the peg in the middle hole is removed (the hole becomes empty), and the original starting hole becomes empty. All other holes retain their states unless affected by the jump. Moves cannot be made outside the defined board boundaries, and holes cannot be occupied by more than one peg. The game continues as long as there exist valid jump moves; if no move is possible, the game ends. Scoring is based on the number of remaining pegs, tracked by a counter starting at 32 and decreasing by one after each jump. The highest score of 100 is awarded if the final remaining peg is at the central hole (row 'd', column 'c4') with only one peg left on the board. Scores decrease progressively as more pegs remain or if the last peg is not in the central hole. If no pegs remain or the number of pegs does not meet these criteria, the score can be as low as zero. There is no explicit noop action defined; the game progresses by the jumper making legal jumps until no such moves are available, at which point the game terminates automatically.",
    "output": "(role jumper)\n   (init (hole a c3 peg))\n   (init (hole a c4 peg))\n   (init (hole a c5 peg))\n   (init (hole b c3 peg))\n   (init (hole b c4 peg))\n   (init (hole b c5 peg))\n   (init (hole c c1 peg))\n   (init (hole c c2 peg))\n   (init (hole c c3 peg))\n   (init (hole c c4 peg))\n   (init (hole c c5 peg))\n   (init (hole c c6 peg))\n   (init (hole c c7 peg))\n   (init (hole d c1 peg))\n   (init (hole d c2 peg))\n   (init (hole d c3 peg))\n   (init (hole d c4 empty))\n   (init (hole d c5 peg))\n   (init (hole d c6 peg))\n   (init (hole d c7 peg))\n   (init (hole e c1 peg))\n   (init (hole e c2 peg))\n   (init (hole e c3 peg))\n   (init (hole e c4 peg))\n   (init (hole e c5 peg))\n   (init (hole e c6 peg))\n   (init (hole e c7 peg))\n   (init (hole f c3 peg))\n   (init (hole f c4 peg))\n   (init (hole f c5 peg))\n   (init (hole g c3 peg))\n   (init (hole g c4 peg))\n   (init (hole g c5 peg))\n   (init (pegs s32))\n   (<= (next (pegs ?x))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (pegs ?y))\n       (succ ?x ?y))\n   (<= (next (hole ?sr ?sc empty))\n       (does jumper (jump ?sr ?sc ?dr ?dc)))\n   (<= (next (hole ?or ?oc empty))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (middle ?sr ?sc ?or ?oc ?dr ?dc))\n   (<= (next (hole ?dr ?dc peg))\n       (does jumper (jump ?sr ?sc ?dr ?dc)))\n   (<= (next (hole ?x ?y empty))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?x ?y empty))\n       (distinct ?x ?dr))\n   (<= (next (hole ?x ?y empty))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?x ?y empty))\n       (distinct ?y ?dc))\n   (<= (next (hole ?x ?y peg))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?x ?y peg))\n       (distinct ?x ?sr)\n       (middle ?sr ?sc ?or ?oc ?dr ?dc)\n       (distinct ?x ?or))\n   (<= (next (hole ?x ?y peg))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?x ?y peg))\n       (distinct ?y ?sc)\n       (middle ?sr ?sc ?or ?oc ?dr ?dc)\n       (distinct ?y ?oc))\n   (<= (middle ?row ?sc ?row ?oc ?row ?dc)\n       (pc ?sc ?oc)\n       (nc ?dc ?oc)\n       (row ?row))\n   (<= (middle ?row ?sc ?row ?oc ?row ?dc)\n       (nc ?sc ?oc)\n       (pc ?dc ?oc)\n       (row ?row))\n   (<= (middle ?sr ?col ?or ?col ?dr ?col)\n       (pr ?sr ?or)\n       (nr ?dr ?or)\n       (column ?col))\n   (<= (middle ?sr ?col ?or ?col ?dr ?col)\n       (nr ?sr ?or)\n       (pr ?dr ?or)\n       (column ?col))\n   (nc c1 c2)\n   (nc c2 c3)\n   (nc c3 c4)\n   (nc c4 c5)\n   (nc c5 c6)\n   (nc c6 c7)\n   (pc c2 c1)\n   (pc c3 c2)\n   (pc c4 c3)\n   (pc c5 c4)\n   (pc c6 c5)\n   (pc c7 c6)\n   (column c1)\n   (column c2)\n   (column c3)\n   (column c4)\n   (column c5)\n   (column c6)\n   (column c7)\n   (nr a b)\n   (nr b c)\n   (nr c d)\n   (nr d e)\n   (nr e f)\n   (nr f g)\n   (pr b a)\n   (pr c b)\n   (pr d c)\n   (pr e d)\n   (pr f e)\n   (pr g f)\n   (row a)\n   (row b)\n   (row c)\n   (row d)\n   (row e)\n   (row f)\n   (row g)\n   (<= (legal jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?sr ?sc peg))\n       (true (hole ?dr ?dc empty))\n       (middle ?sr ?sc ?or ?oc ?dr ?dc)\n       (true (hole ?or ?oc peg)))\n   (<= moveable\n       (true (hole ?sr ?sc peg))\n       (true (hole ?dr ?dc empty))\n       (middle ?sr ?sc ?or ?oc ?dr ?dc)\n       (true (hole ?or ?oc peg)))\n   (<= (goal jumper 100)\n       (true (hole d c4 peg))\n       (true (pegs s1)))\n   (<= (goal jumper 99)\n       (true (hole ?row ?col peg))\n       (true (pegs s1))\n       (distinct ?row d))\n   (<= (goal jumper 99)\n       (true (hole ?row ?col peg))\n       (true (pegs s1))\n       (distinct ?col c4))\n   (<= (goal jumper 90)\n       (true (pegs s2)))\n   (<= (goal jumper 80)\n       (true (pegs s3)))\n   (<= (goal jumper 70)\n       (true (pegs s4)))\n   (<= (goal jumper 60)\n       (true (pegs s5)))\n   (<= (goal jumper 50)\n       (true (pegs s6)))\n   (<= (goal jumper 40)\n       (true (pegs s7)))\n   (<= (goal jumper 30)\n       (true (pegs s8)))\n   (<= (goal jumper 20)\n       (true (pegs s9)))\n   (<= (goal jumper 10)\n       (true (pegs s10)))\n   (<= (goal jumper 0)\n       (true (pegs ?x))\n       (distinct ?x s10)\n       (distinct ?x s9)\n       (distinct ?x s8)\n       (distinct ?x s7)\n       (distinct ?x s6)\n       (distinct ?x s5)\n       (distinct ?x s4)\n       (distinct ?x s3)\n       (distinct ?x s2)\n       (distinct ?x s1))\n   (succ s1 s2)\n   (succ s2 s3)\n   (succ s3 s4)\n   (succ s4 s5)\n   (succ s5 s6)\n   (succ s6 s7)\n   (succ s7 s8)\n   (succ s8 s9)\n   (succ s9 s10)\n   (succ s10 s11)\n   (succ s11 s12)\n   (succ s12 s13)\n   (succ s13 s14)\n   (succ s14 s15)\n   (succ s15 s16)\n   (succ s16 s17)\n   (succ s17 s18)\n   (succ s18 s19)\n   (succ s19 s20)\n   (succ s20 s21)\n   (succ s21 s22)\n   (succ s22 s23)\n   (succ s23 s24)\n   (succ s24 s25)\n   (succ s25 s26)\n   (succ s26 s27)\n   (succ s27 s28)\n   (succ s28 s29)\n   (succ s29 s30)\n   (succ s30 s31)\n   (succ s31 s32)\n   (<= terminal\n       (not moveable))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on an 8-by-8 grid labeled with columns a through h and rows 1 through 8, forming a coordinate system where each cell is identified by a letter-number pair such as a1 or h8. There is a single player role named \"player\" who takes turns making moves. The initial state places a single knight piece on cell a1, while all other cells are initially blank. The game progresses in discrete steps starting from 1 and incrementing by one each turn. On each turn, the player must either move the knight or if no legal moves exist, the game ends. A move action consists of the player specifying a target cell to which the knight will move. Moves are legal only if the knight currently occupies some cell and the target cell is blank, and the move corresponds to a valid knight's move in chess: specifically, the knight moves in an \"L\" shape by moving two columns in one direction and one row perpendicular to that, or vice versa. The adjacency of rows and the sequence of columns are defined to enforce these constraints. When the player moves the knight to a new cell, that cell becomes occupied by the knight, and the previous cell becomes occupied by an \"o\" marker, representing a trail or visited cell. All other cells retain their current state unless changed by the move. The step counter advances by one after each move. The game implicitly disallows moves outside the 8-by-8 board and prohibits moving onto any cell already occupied by \"o\" or the knight itself. The game terminates when the player has no legal knight moves available. The scoring depends on how many steps have been taken: reaching step 64 yields a score of 100, and the score decreases in increments of 10 for ranges of steps below 64, going down to 0 if fewer than 32 steps have been completed. Thus, the objective is to move the knight around the board as long as possible without running out of legal moves, maximizing the number of steps taken before termination.",
    "output": "(role player)\n(init (cell a 1 k))\n(init (cell a 2 b))\n(init (cell a 3 b))\n(init (cell a 4 b))\n(init (cell a 5 b))\n(init (cell a 6 b))\n(init (cell a 7 b))\n(init (cell a 8 b))\n(init (cell b 1 b))\n(init (cell b 2 b))\n(init (cell b 3 b))\n(init (cell b 4 b))\n(init (cell b 5 b))\n(init (cell b 6 b))\n(init (cell b 7 b))\n(init (cell b 8 b))\n(init (cell c 1 b))\n(init (cell c 2 b))\n(init (cell c 3 b))\n(init (cell c 4 b))\n(init (cell c 5 b))\n(init (cell c 6 b))\n(init (cell c 7 b))\n(init (cell c 8 b))\n(init (cell d 1 b))\n(init (cell d 2 b))\n(init (cell d 3 b))\n(init (cell d 4 b))\n(init (cell d 5 b))\n(init (cell d 6 b))\n(init (cell d 7 b))\n(init (cell d 8 b))\n(init (cell e 1 b))\n(init (cell e 2 b))\n(init (cell e 3 b))\n(init (cell e 4 b))\n(init (cell e 5 b))\n(init (cell e 6 b))\n(init (cell e 7 b))\n(init (cell e 8 b))\n(init (cell f 1 b))\n(init (cell f 2 b))\n(init (cell f 3 b))\n(init (cell f 4 b))\n(init (cell f 5 b))\n(init (cell f 6 b))\n(init (cell f 7 b))\n(init (cell f 8 b))\n(init (cell g 1 b))\n(init (cell g 2 b))\n(init (cell g 3 b))\n(init (cell g 4 b))\n(init (cell g 5 b))\n(init (cell g 6 b))\n(init (cell g 7 b))\n(init (cell g 8 b))\n(init (cell h 1 b))\n(init (cell h 2 b))\n(init (cell h 3 b))\n(init (cell h 4 b))\n(init (cell h 5 b))\n(init (cell h 6 b))\n(init (cell h 7 b))\n(init (cell h 8 b))\n(init (step 1))\n(<= (next (cell ?x ?y k))\n\t(does player (move ?x ?y)))\n(<= (next (cell ?x ?y o))\n\t(true (cell ?x ?y k)))\n(<= (next (cell ?x ?y o))\n\t(true (cell ?x ?y o)))\n(<= (next (cell ?x ?y b))\n\t(true (cell ?x ?y b))\n\t(not (does player (move ?x ?y))))\n(<= (next (step ?y))\n\t(true (step ?x))\n(succ ?x ?y))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(<= (legal player (move ?x ?y))\n\t(true (cell ?u ?v k))\n\t(true (cell ?x ?y b))\n\t(knightmove ?u ?v ?x ?y))\n(<= (knightmove ?u ?v ?x ?y)\n\t(nextcolumn ?u ?w)\n\t(nextcolumn ?w ?x)\n\t(adjacent ?v ?y))\n(<= (knightmove ?u ?v ?x ?y)\n\t(nextcolumn ?x ?w)\n\t(nextcolumn ?w ?u)\n\t(adjacent ?v ?y))\n(<= (knightmove ?u ?v ?x ?y)\n\t(nextcolumn ?u ?w)\n\t(nextcolumn ?w ?x)\n\t(adjacent ?y ?v))\n(<= (knightmove ?u ?v ?x ?y)\n\t(nextcolumn ?x ?w)\n\t(nextcolumn ?w ?u)\n\t(adjacent ?y ?v))\n(<= (knightmove ?u ?v ?x ?y)\n\t(nextcolumn ?u ?x)\n\t(adjacent ?v ?w)\n\t(adjacent ?w ?y))\n(<= (knightmove ?u ?v ?x ?y)\n\t(nextcolumn ?u ?x)\n\t(adjacent ?y ?w)\n\t(adjacent ?w ?v))\n(<= (knightmove ?u ?v ?x ?y)\n\t(nextcolumn ?x ?u)\n\t(adjacent ?v ?w)\n\t(adjacent ?w ?y))\n(<= (knightmove ?u ?v ?x ?y)\n\t(nextcolumn ?x ?u)\n(adjacent ?y ?w)\n(adjacent ?w ?v))\n(adjacent 1 2)\n(adjacent 2 3)\n(adjacent 3 4)\n(adjacent 4 5)\n(adjacent 5 6)\n(adjacent 6 7)\n(adjacent 7 8)\n(nextcolumn a b)\n(nextcolumn b c)\n(nextcolumn c d)\n(nextcolumn d e)\n(nextcolumn e f)\n(nextcolumn f g)\n(nextcolumn g h)\n(<= (goal player 100)\n\t(true (step 64)))\n(<= (goal player 90)\n\t(true (step ?x))\n\t(smaller ?x 64)\n\t(smaller 61 ?x))\n(<= (goal player 80)\n\t(true (step ?x))\n\t(smaller ?x 62)\n\t(smaller 59 ?x))\n(<= (goal player 70)\n\t(true (step ?x))\n\t(smaller ?x 60)\n\t(smaller 55 ?x))\n(<= (goal player 60)\n\t(true (step ?x))\n\t(smaller ?x 56)\n\t(smaller 51 ?x))\n(<= (goal player 50)\n\t(true (step ?x))\n\t(smaller ?x 52)\n\t(smaller 47 ?x))\n(<= (goal player 40)\n\t(true (step ?x))\n\t(smaller ?x 48)\n\t(smaller 43 ?x))\n(<= (goal player 30)\n\t(true (step ?x))\n\t(smaller ?x 44)\n\t(smaller 39 ?x))\n(<= (goal player 20)\n\t(true (step ?x))\n\t(smaller ?x 40)\n\t(smaller 35 ?x))\n(<= (goal player 10)\n\t(true (step ?x))\n\t(smaller ?x 36)\n\t(smaller 31 ?x))\n(<= (goal player 0)\n\t(true (step ?x))\n\t(smaller ?x 32))\n(<= terminal\n\t(not existslegalmove))\n(<= existslegalmove\n\t(true (cell ?u ?v k))\n\t(true (cell ?x ?y b))\n\t(knightmove ?u ?v ?x ?y))\n(<= (smaller ?x ?y)\n\t(succ ?x ?y))\n(<= (smaller ?x ?y)\n\t(succ ?z ?y)\n\t(smaller ?x ?z))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a two-dimensional grid with coordinates ranging from 0 to 5 on both the x (horizontal) and y (vertical) axes, defining a 6x6 board. Each cell on this board can hold a variety of states, including empty spaces denoted by 'w', or occupied by either the red or blue player's head, labeled as 'redHead' or 'blueHead', respectively. Two players participate in this game, identified as red and blue, each assigned a distinct role and taking turns alternately. The initial configuration places the red player's head at cell (1,1) and the blue player's head at cell (4,4), with a number of other cells initialized as empty. On a player's turn, they must choose one of four directional movement actions: moveUp, moveDown, moveLeft, or moveRight. All these actions are always legal for their respective player on their turn, and it is implied that players cannot skip or pass their turn via a noop action. Each action is formatted as the player role followed by the movement direction, for example, \"red moveLeft.\" Executing such an action updates the position of that player's head on the board according to the direction specified, effectively moving the head one cell in that direction. The game's rules enforce that the head cannot move onto a cell already occupied by an obstacle, the opponent's head, or into forbidden states; doing so results in an error state for the player. The board boundaries implicitly restrict movement so that players cannot move beyond the 0 to 5 range in either coordinate. After each move, the cell previously occupied by the player's head becomes marked as 'f', indicating it is now a forbidden or occupied cell, preventing any player from occupying it subsequently. The game continues with players alternating moves until one of three terminal conditions is met: either player makes an illegal move by moving into a forbidden cell, or the board no longer contains any blank cells where movement can occur. Scoring is determined at the end of the game based on the error states and the presence of blank cells; if a player commits an error and the other does not, the non-error player wins with a score of 100, while the erring player scores 0. If both players commit errors or if no blank cells remain without errors, both players receive a score of 50. The game's objective is to maneuver the player's head to avoid errors while occupying cells strategically, with victory awarded to the player who manages to avoid errors and outlast the opponent within the constraints of the board.",
    "output": "(role red)\n(role blue)\n(index 0)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(init (cell 1 1 redHead))\n(init (cell 4 4 blueHead))\n(init (cell 0 0 w))\n(init (cell 0 1 w))\n(init (cell 0 2 w))\n(init (cell 0 3 w))\n(init (cell 0 4 w))\n(init (cell 0 5 w))\n(init (cell 1 0 w))\n(init (cell 2 0 w))\n(init (cell 3 0 w))\n(init (cell 4 0 w))\n(init (cell 5 0 w))\n(init (cell 5 1 w))\n(init (cell 5 2 w))\n(init (cell 5 3 w))\n(init (cell 5 4 w))\n(init (cell 5 5 w))\n(init (cell 1 5 w))\n(init (cell 2 5 w))\n(init (cell 3 5 w))\n(init (cell 4 5 w))\n(<= (legal ?player moveDown)\n  (role ?player))\n(<= (legal ?player moveUp)\n  (role ?player))\n(<= (legal ?player moveLeft)\n  (role ?player))\n(<= (legal ?player moveRight)\n  (role ?player))\n(<= (next (cell ?x ?y f))\n  (true (cell ?x ?y f)))\n(<= (next (cell ?x ?y w))\n  (true (cell ?x ?y w)))\n(<= (next (cell ?x ?y f))\n  (true (cell ?x ?y blueHead)))\n(<= (next (cell ?a ?y blueHead))\n  (does blue moveLeft)\n  (true (cell ?x ?y blueHead))\n  (plusplus ?a ?x))\n(<= (next (cell ?a ?y blueHead))\n  (does blue moveRight)\n  (true (cell ?x ?y blueHead))\n  (plusplus ?x ?a))\n(<= (next (cell ?x ?b blueHead))\n  (does blue moveDown)\n  (true (cell ?x ?y blueHead))\n  (plusplus ?y ?b))\n(<= (next (cell ?x ?b blueHead))\n  (does blue moveUp)\n  (true (cell ?x ?y blueHead))\n  (plusplus ?b ?y))\n(<= (next (cell ?x ?y f))\n  (true (cell ?x ?y redHead)))\n(<= (next (cell ?a ?y redHead))\n  (does red moveLeft)\n  (true (cell ?x ?y redHead))\n  (plusplus ?a ?x))\n(<= (next (cell ?a ?y redHead))\n  (does red moveRight)\n  (true (cell ?x ?y redHead))\n  (plusplus ?x ?a))\n(<= (next (cell ?x ?b redHead))\n  (does red moveDown)\n  (true (cell ?x ?y redHead))\n  (plusplus ?y ?b))\n(<= (next (cell ?x ?b redHead))\n  (does red moveUp)\n  (true (cell ?x ?y redHead))\n  (plusplus ?b ?y))\n(<= hasBlank\n  (index ?y)\n  (index ?x)\n  (not (true (cell ?x ?y redHead)))\n  (not (true (cell ?x ?y blueHead)))\n  (not (true (cell ?x ?y f)))\n  (not (true (cell ?x ?y w))))\n(<= blueError\n  (true (cell ?x ?y blueHead))\n  (true (cell ?x ?y w)))\n(<= blueError\n  (true (cell ?x ?y blueHead))\n  (true (cell ?x ?y f)))\n(<= blueError\n  (true (cell ?x ?y blueHead))\n  (true (cell ?x ?y redHead)))\n(<= redError\n  (true (cell ?x ?y redHead))\n  (true (cell ?x ?y w)))\n(<= redError\n  (true (cell ?x ?y redHead))\n  (true (cell ?x ?y f)))\n(<= redError\n  (true (cell ?x ?y redHead))\n  (true (cell ?x ?y blueHead)))\n(<= (goal red 0)\n  (not blueError)\n  (not redError)\n  hasBlank)\n(<= (goal red 0)\n  (not blueError)\n  redError\n  hasBlank)\n(<= (goal red 100)\n  blueError\n  (not redError)\n  hasBlank)\n(<= (goal red 50)\n  blueError\n  redError\n  hasBlank)\n(<= (goal red 50)\n  (not blueError)\n  (not redError)\n  (not hasBlank))\n(<= (goal red 0)\n  (not blueError)\n  redError\n  (not hasBlank))\n(<= (goal red 100)\n  blueError\n  (not redError)\n  (not hasBlank))\n(<= (goal red 50)\n  blueError\n  redError\n  (not hasBlank))\n(<= (goal blue 100)\n  (goal red 0))\n(<= (goal blue 0)\n  (goal red 100))\n(<= (goal blue 50)\n  (goal red 50))\n(<= terminal\n  blueError)\n(<= terminal\n  redError)\n(<= terminal\n  (not hasBlank))\n(plusplus 0 1)\n(plusplus 1 2)\n(plusplus 2 3)\n(plusplus 3 4)\n(plusplus 4 5)\n(plusplus 5 6)\n(plusplus 6 7)\n(plusplus 7 8)\n(plusplus 8 9)\n(plusplus 9 10)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a 6-by-6 grid defined by rows numbered 1 through 6 and columns numbered 1 through 6, where each cell may hold either a blank value or a number between 1 and 5 initially placed in some cells. The single player, identified as \"robot,\" acts alone and takes turns placing numbers into blank cells or choosing to quit; the player may perform exactly one action per turn. The initial state features specific numbers placed at certain cells—number 5 at row 1 column 1, number 3 at row 3 column 6, and number 3 at row 5 column 2—with all other cells initially blank. On each turn, the robot can legally place a number into a blank cell provided that the placement does not violate any constraints that make it illegal: the number must not already appear in the same row or column, and it must respect a set of specified pairwise inequalities between cells, where some cells must hold numbers greater than or less than numbers in designated neighboring cells either to the right or below. The robot may also elect to quit at any time, which immediately ends the game. Actions are represented in the form \"place row column number\" or \"quit,\" and placing a number updates the state by setting that cell to the chosen number while leaving all other cells unchanged; quitting sets the finished flag true. No operation or noop moves other than quitting are possible. The board boundaries implicitly restrict positions to valid rows and columns from 1 to 6, and no two cells in the same row or column can contain the same number. The constraints enforce ordering relationships between pairs of neighboring cells, requiring that one cell's number is strictly greater or less than the other's as specified. The game ends terminally either when no blank cells remain (the board is filled) or when the robot chooses to quit. The scoring system assigns zero points if any blank cells remain at termination, and a perfect score of 100 points if the robot fills all cells without violating the constraints. Thus, success requires the robot to fill the entire board with numbers respecting all uniqueness and inequality constraints or to quit early, with the latter yielding no points.",
    "output": "(role robot)\n(init (cell 1 1 5))\n(init (cell 1 2 blank))\n(init (cell 1 3 blank))\n(init (cell 1 4 blank))\n(init (cell 1 5 blank))\n(init (cell 1 6 blank))\n(init (cell 2 1 blank))\n(init (cell 2 2 blank))\n(init (cell 2 3 blank))\n(init (cell 2 4 blank))\n(init (cell 2 5 blank))\n(init (cell 2 6 blank))\n(init (cell 3 1 blank))\n(init (cell 3 2 blank))\n(init (cell 3 3 blank))\n(init (cell 3 4 blank))\n(init (cell 3 5 blank))\n(init (cell 3 6 3))\n(init (cell 4 1 blank))\n(init (cell 4 2 blank))\n(init (cell 4 3 blank))\n(init (cell 4 4 blank))\n(init (cell 4 5 blank))\n(init (cell 4 6 blank))\n(init (cell 5 1 blank))\n(init (cell 5 2 3))\n(init (cell 5 3 blank))\n(init (cell 5 4 blank))\n(init (cell 5 5 blank))\n(init (cell 5 6 blank))\n(init (cell 6 1 blank))\n(init (cell 6 2 blank))\n(init (cell 6 3 blank))\n(init (cell 6 4 blank))\n(init (cell 6 5 blank))\n(init (cell 6 6 blank))\n(<= (legal robot (place ?row ?col ?n))\n    (true (cell ?row ?col blank))\n    (number ?n)\n    (not (illegal ?row ?col ?n)))\n(<= (illegal ?row ?col ?n)\n    (number ?row)\n    (true (cell ?row2 ?col ?n)))\n(<= (illegal ?row ?col ?n)\n    (number ?col)\n    (true (cell ?row ?col2 ?n)))\n(<= (illegal ?row ?col ?n)\n    (gt_constraint ?row ?col ?row2 ?col2)\n    (true (cell ?row2 ?col2 ?n2))\n    (gt ?n2 ?n))\n(<= (illegal ?row ?col ?n)\n    (gt_constraint ?row2 ?col2 ?row ?col)\n    (true (cell ?row2 ?col2 ?n2))\n    (gt ?n ?n2))\n(legal robot quit)\n(<= (next (cell ?row ?col ?n))\n    (true (cell ?row ?col ?n))\n    (number ?n))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot (place ?row2 ?col2 ?n))\n    (distinct ?row ?row2))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot (place ?row2 ?col2 ?n))\n    (distinct ?col ?col2))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot quit))\n(<= (next (cell ?row ?col ?n))\n    (does robot (place ?row ?col ?n)))\n(<= (next finished)\n    (does robot quit))\n(<= terminal\n    filled)\n(<= filled\n    (not anyblank))\n(<= anyblank\n    (true (cell ?row ?col blank)))\n(<= terminal\n    (true finished))\n(<= (goal robot 0)\n    (true (cell ?row ?col blank)))\n(<= (goal robot 100)\n    (not (goal robot 0)))\n(<= (number ?n)\n    (succ ?n ?m))\n(<= (number ?m)\n    (succ ?n ?m))\n(<= (gt ?n1 ?n2)\n    (succ ?n2 ?n1))\n(<= (gt ?n1 ?n3)\n    (succ ?n2 ?n1)\n    (gt ?n2 ?n3))\n(<= (init (cell_gt_right ?row ?col1))\n    (succ ?col1 ?col2)\n    (gt_constraint ?row ?col1 ?row ?col2))\n(<= (init (cell_lt_right ?row ?col1))\n    (succ ?col1 ?col2)\n    (gt_constraint ?row ?col2 ?row ?col1))\n(<= (init (cell_gt_below ?row1 ?col))\n    (succ ?row1 ?row2)\n    (gt_constraint ?row1 ?col ?row2 ?col))\n(<= (init (cell_lt_below ?row1 ?col))\n    (succ ?row1 ?row2)\n    (gt_constraint ?row2 ?col ?row1 ?col))\n(<= (next (cell_gt_right ?row ?col))\n    (true (cell_gt_right ?row ?col)))\n(<= (next (cell_lt_right ?row ?col))\n    (true (cell_lt_right ?row ?col)))\n(<= (next (cell_gt_below ?row ?col))\n    (true (cell_gt_below ?row ?col)))\n(<= (next (cell_lt_below ?row ?col))\n    (true (cell_lt_below ?row ?col)))\n(succ  1  2)\n(succ  2  3)\n(succ  3  4)\n(succ  4  5)\n(succ  5  6)\n(gt_constraint 1 4 1 3)\n(gt_constraint 1 6 2 6)\n(gt_constraint 2 2 3 2)\n(gt_constraint 2 6 3 6)\n(gt_constraint 4 3 3 3)\n(gt_constraint 4 4 4 3)\n(gt_constraint 4 5 4 4)\n(gt_constraint 4 5 5 5)\n(gt_constraint 4 6 4 5)\n(gt_constraint 5 3 5 4)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on two parallel lanes, designated as \"wlane\" and \"blane,\" each consisting of a grid with rows labeled from 'a' to 'e' and columns numbered 1 through 3, forming a coordinate system where positions are identified by a lane, row, and column. Two players, named white and black, participate, with white associated with the \"wlane\" and black with the \"blane,\" and turns alternate between these players in the order of white followed by black. The initial setup places a white pawn on the cell at lane wlane, row a, column 3, and a black pawn on lane blane, row a, column 3, with all other cells initially empty, represented by 'b.' Additionally, each lane has wall slots labeled by rows 'a' through 'd' initially set to 'none,' indicating no walls are placed, and each player starts with four walls available to place. The game state includes a step counter initialized to zero, incrementing by one each turn. On a player's turn, they may perform one of two legal actions: either move their pawn or place a wall on their opponent's lane. A move action consists of moving the player's pawn from its current cell to an adjacent cell within the same lane, following specific pawn movement rules that allow vertical and horizontal moves constrained by existing walls and the board's boundaries; the destination cell must be unoccupied. The pawn may move forward or sideways within the same row or move to the next row depending on the presence or absence of walls at certain positions. When a pawn moves, its previous cell becomes empty, and the new cell is occupied by the pawn. A place action involves placing one of the player's remaining walls on a wall slot in the opponent's lane on a specific row and side (left or right), provided that the player has at least one wall left to place and that the wall slot is currently empty. Placing a wall decreases the player's available walls by one and marks the opponent's lane wall slot as occupied on the chosen side, which influences the opponent's pawn movement by blocking certain moves. The game enforces implicit constraints, such as the lanes being fixed to five rows and three columns, pawns cannot move outside these boundaries, walls can only be placed on specific available slots in the opponent's lane, and pawns cannot move into occupied cells. The game terminates either when the step counter reaches 20 or when a pawn reaches the end row 'e' of either lane. Victory conditions hinge on the positions of the pawns and the number of walls remaining: a player wins with a score of 100 if their pawn reaches the end row 'e' in their lane while the opponent's pawn is not in the end row, or if both pawns are in the end row but the player has placed more walls than the opponent. If both pawns occupy the end row and both players have placed the same number of walls, the game results in a draw with a score of 50 for both players. If a player's pawn has not reached the end row by the time the maximum step count is reached, the game is also a draw. No-op moves are not explicitly defined, so each turn requires an action either to move or place a wall. This structure ensures strategic placement of walls to impede the opponent while advancing one's own pawn towards the goal, with the game progressing through alternating turns until terminal conditions are met and the winner is determined accordingly.",
    "output": "(role white)\n    (role black)\n    (init (cell wlane a 1 b))\n    (init (cell wlane a 2 b))\n    (init (cell wlane a 3 white))\n    (init (cell wlane b 1 b))\n    (init (cell wlane b 2 b))\n    (init (cell wlane b 3 b))\n    (init (cell wlane c 1 b))\n    (init (cell wlane c 2 b))\n    (init (cell wlane c 3 b))\n    (init (cell wlane d 1 b))\n    (init (cell wlane d 2 b))\n    (init (cell wlane d 3 b))\n    (init (cell wlane e 1 b))\n    (init (cell wlane e 2 b))\n    (init (cell wlane e 3 b))\n    (init (cell blane a 1 b))\n    (init (cell blane a 2 b))\n    (init (cell blane a 3 black))\n    (init (cell blane b 1 b))\n    (init (cell blane b 2 b))\n    (init (cell blane b 3 b))\n    (init (cell blane c 1 b))\n    (init (cell blane c 2 b))\n    (init (cell blane c 3 b))\n    (init (cell blane d 1 b))\n    (init (cell blane d 2 b))\n    (init (cell blane d 3 b))\n    (init (cell blane e 1 b))\n    (init (cell blane e 2 b))\n    (init (cell blane e 3 b))\n    (init (wall wlane a none))\n    (init (wall wlane b none))\n    (init (wall wlane c none))\n    (init (wall wlane d none))\n    (init (wall blane a none))\n    (init (wall blane b none))\n    (init (wall blane c none))\n    (init (wall blane d none))\n    (init (walls white 4))\n    (init (walls black 4))\n    (init (step 0))\n    (<= (next (cell ?lane ?x ?y ?q))\n        (true (cell ?lane ?x ?y ?q))\n        (playerlane ?player ?lane)\n        (does ?player (place ?row ?side)))\n    (<= (next (cell ?lane ?x ?y ?p))\n        (playerlane ?player ?lane)\n        (does ?player (move ?p ?u ?v ?x ?y)))\n    (<= (next (cell ?lane ?u ?v b))\n        (playerlane ?player ?lane)\n        (does ?player (move ?p ?u ?v ?x ?y)))\n    (<= (next (cell ?lane ?w ?z b))\n        (playerlane ?player ?lane)\n        (does ?player (move ?p ?u ?v ?x ?y))\n        (true (cell ?lane ?w ?z b))\n        (distinct ?z ?y))\n    (<= (next (cell ?lane ?w ?z b))\n        (playerlane ?player ?lane)\n        (does ?player (move ?p ?u ?v ?x ?y))\n        (true (cell ?lane ?w ?z b))\n        (distinct ?w ?x))\n    (<= (next (wall ?lane ?r ?s))\n        (does ?player (move ?p ?u ?v ?x ?y))\n        (opponentlane ?player ?lane)\n        (true (wall ?lane ?r ?s)))\n    (<= (next (wall ?lane ?row ?side))\n        (does ?player (place ?row ?side))\n        (opponentlane ?player ?lane)\n        (true (wall ?lane ?row none)))\n    (<= (next (wall ?lane ?row none))\n        (does ?player (place ?r1 ?s1))\n        (opponentlane ?player ?lane)\n        (true (wall ?lane ?row none))\n        (distinct ?r1 ?row))\n    (<= (next (walls ?player ?walls))\n        (does ?player (move ?p ?u ?v ?x ?y))\n        (true (walls ?player ?walls)))\n    (<= (next (walls ?player ?walls))\n        (does ?player (place ?row ?side))\n        (true (walls ?player ?pwalls))\n        (successor ?pwalls ?walls))\n    (<= (next (step ?y))\n        (true (step ?x))\n        (successor ?x ?y))\n    (<= (legal ?player (move ?player ?u ?v ?x ?y))\n        (playerlane ?player ?lane)\n        (true (cell ?lane ?u ?v ?player))\n        (pawnmove ?lane ?u ?v ?x ?y)\n        (true (cell ?lane ?x ?y b)))\n    (<= (legal ?player (place ?row left))\n        (true (walls ?player ?n))\n        (greaterthan ?n 0)\n        (opponentlane ?player ?lane)\n        (true (wall ?lane ?row none)))\n    (<= (legal ?player (place ?row right))\n        (true (walls ?player ?n))\n        (greaterthan ?n 0)\n        (opponentlane ?player ?lane)\n        (true (wall ?lane ?row none)))\n    (playerlane white wlane)\n    (playerlane black blane)\n    (opponentlane white blane)\n    (opponentlane black wlane)\n    (<= (pawnmove ?lane ?r1 1 ?r2 1)\n        (nrow ?r1 ?r2)\n        (true (wall ?lane ?r1 none)))\n    (<= (pawnmove ?lane ?r1 1 ?r2 1)\n        (nrow ?r1 ?r2)\n        (true (wall ?lane ?r1 right)))\n    (<= (pawnmove ?lane ?r1 2 ?r2 2)\n        (nrow ?r1 ?r2)\n        (true (wall ?lane ?r1 none)))\n    (<= (pawnmove ?lane ?r1 3 ?r2 3)\n        (nrow ?r1 ?r2)\n        (true (wall ?lane ?r1 none)))\n    (<= (pawnmove ?lane ?r1 3 ?r2 3)\n        (nrow ?r1 ?r2)\n        (true (wall ?lane ?r1 left)))\n    (<= (pawnmove ?lane ?r 1 ?r 2)\n    \t(row ?r)\n    \t(lane ?lane))\n    (<= (pawnmove ?lane ?r 2 ?r 1)\n    \t(row ?r)\n    \t(lane ?lane))\n    (<= (pawnmove ?lane ?r 2 ?r 3)\n        (row ?r)\n    \t(lane ?lane))\n    (<= (pawnmove ?lane ?r 3 ?r 2)\n        (row ?r)\n    \t(lane ?lane))\n    (row a)\n    (row b)\n    (row c)\n    (row d)\n    (row e)\n    (lane wlane)\n    (lane blane)\n    (nrow a b)\n    (nrow b c)\n    (nrow c d)\n    (nrow d e)\n    (successor 0 1)\n    (successor 1 2)\n    (successor 2 3)\n    (successor 3 4)\n    (successor 4 5)\n    (successor 5 6)\n    (successor 6 7)\n    (successor 7 8)\n    (successor 8 9)\n    (successor 9 10)\n    (successor 10 11)\n    (successor 11 12)\n    (successor 12 13)\n    (successor 13 14)\n    (successor 14 15)\n    (successor 15 16)\n    (successor 16 17)\n    (successor 17 18)\n    (successor 18 19)\n    (successor 19 20)\n    (<= (greaterthan ?larger ?smaller)\n        (successor ?smaller ?larger))\n    (<= (greaterthan ?larger ?smaller)\n        (successor ?next ?larger)\n        (greaterthan ?next ?smaller))\n    (<= (goal white 100)\n        (true (cell wlane e ?x white))\n        (true (cell blane ?r ?x1 black))\n        (distinct ?r e))\n    (<= (goal white 100)\n        (true (cell wlane e ?x white))\n        (true (cell blane e ?x1 black))\n        (true (walls white ?wn))\n        (true (walls black ?bn))\n        (greaterthan ?wn ?bn))\n    (<= (goal white 0)\n        (true (cell blane e ?x black))\n        (true (cell wlane ?r ?x1 white))\n        (distinct ?r e))\n    (<= (goal white 0)\n        (true (cell wlane e ?x white))\n        (true (cell blane e ?x1 black))\n        (true (walls white ?wn))\n        (true (walls black ?bn))\n        (greaterthan ?bn ?wn))\n    (<= (goal black 100)\n        (true (cell blane e ?x black))\n        (true (cell wlane ?r ?x1 white))\n        (distinct ?r e))\n    (<= (goal black 100)\n        (true (cell wlane e ?x white))\n        (true (cell blane e ?x1 black))\n        (true (walls white ?wn))\n        (true (walls black ?bn))\n        (greaterthan ?bn ?wn))\n    (<= (goal black 0)\n        (true (cell wlane e ?x white))\n        (true (cell blane ?r ?x1 black))\n        (distinct ?r e))\n    (<= (goal black 0)\n        (true (cell wlane e ?x white))\n        (true (cell blane e ?x1 black))\n        (true (walls white ?wn))\n        (true (walls black ?bn))\n        (greaterthan ?wn ?bn))\n    (<= (goal ?role 50)\n        (true (cell wlane e ?x white))\n        (true (cell blane e ?x1 black))\n        (true (walls white ?n))\n        (true (walls black ?n))\n        (role ?role))\n    (<= (goal ?role 50)\n        (true (step 20))\n        (true (cell wlane ?r1 ?x1 white))\n        (true (cell blane ?r2 ?x2 black))\n        (distinct ?r1 e)\n        (distinct ?r2 e)\n        (role ?role))\n    (<= terminal\n        (true (step 20)))\n    (<= terminal\n        (true (cell ?lane e ?r ?p))\n        (distinct ?p b))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played between two players, designated as white and black, within a turn-based framework that lasts for a maximum of 20 rounds. The environment does not involve a spatial coordinate system or board layout but instead focuses on sequential rounds and score tracking. Both players simultaneously select one of two possible actions each round: defect or cooperate. At the start of the game, both players’ scores are initialized to zero, and the round counter begins at zero. Each round increments this counter by one, and the game proceeds until the round number reaches the preset maximum of 20, at which point the game terminates. On each turn, both players must choose either defect or cooperate; no-operation (noop) moves are not defined, so an action is always required. The legality of an action depends solely on whether the game has ended; actions are allowed only while the current round is less than the maximum. The result of the players’ combined actions determines the score increments for each player, following a payoff structure akin to the classic prisoner's dilemma: if one defects while the other cooperates, the defector’s score increases by five and the cooperator’s score remains unchanged; if both cooperate, each gains three points; if both defect, each gains one point. Scores accumulate over rounds, and the round counter advances by one after every pair of actions. There are no spatial or occupancy constraints since the game does not involve a board or pieces; only the temporal sequence of rounds and the players’ choices matter. The game ends automatically when the 20th round is completed, and the final scores of white and black are used to determine the outcome. The player with the higher score at the end of the final round is effectively the winner, with the scoring explicitly represented as goal values for each player corresponding to their final accumulated score.",
    "output": "(role white)\n(role black)\n(maxRounds 20)\n(init (whiteScore 0))\n(init (blackScore 0))\n(init (round 0))\n(<= (legal black defect)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal black cooperate)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal white defect)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal white cooperate)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (next (round ?x1))\n    (true (round ?x))\n    (succ ?x ?x1))\n(<= (next (whiteScore ?x5))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?x4 ?x5)\n    (does white defect)\n    (does black cooperate))\n(<= (next (blackScore ?x))\n    (true (blackScore ?x))\n    (does white defect)\n    (does black cooperate))\n(<= (next (blackScore ?x5))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?x4 ?x5)\n    (does black defect)\n    (does white cooperate))\n(<= (next (whiteScore ?x))\n    (true (whiteScore ?x))\n    (does black defect)\n    (does white cooperate))\n(<= (next (blackScore ?x3))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (does black cooperate)\n    (does white cooperate))\n(<= (next (whiteScore ?x3))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (does black cooperate)\n    (does white cooperate))\n(<= (next (blackScore ?x1))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (does black defect)\n    (does white defect))\n(<= (next (whiteScore ?x1))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (does black defect)\n    (does white defect))\n(<= terminal\n    (true (round ?x))\n    (maxRounds ?x))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a grid defined by coordinates indexed from 1 through 6 along both the horizontal and vertical axes, forming a 6-by-6 lattice of points. Two players, named xplayer and oplayer, alternate turns in a fixed sequence where the player controlling the current turn attempts to draw a line segment between two adjacent points on the grid. The turn order cycles through these players, with xplayer moving first and then oplayer, and so on. Initially, no lines have been drawn, no boxes are claimed, and xplayer has control to make the first move. On a player's turn, they must either draw a single line segment between two undrawn adjacent points—either vertically or horizontally adjacent indices that do not yet have a connecting line—or, if it is not their turn, they must perform a no-operation action, which is legal only when they do not have control. Actions are specified by the player indicating a draw command with the coordinates of the two points to be connected; this action is only legal if the line between those points is currently undrawn and the player has control. When a player draws a line, the game state updates to include that line permanently. The drawing of a line may result in the formation of one or more boxes—defined as unit squares bounded by four lines—if that new line completes the fourth side of such a box. A box is considered formed if the four edges surrounding a square between consecutive coordinate indices are all drawn. If one box is formed by a player's action, their box count increases by one; if two boxes are formed simultaneously, their box count increases by two accordingly. Importantly, if any box is formed during a player's turn, they retain control and get another move; control only passes to the other player if no box is completed during the turn. The game imposes implicit constraints that lines must connect adjacent points within the grid boundaries, no line may be drawn twice, and boxes may only be claimed when fully enclosed. The game ends when there are no remaining undrawn lines on the grid, i.e., when all possible edges between points have been drawn. The victory condition is determined by comparing the number of boxes claimed by each player: the player with the higher count of boxes wins, while a tie results in a win for oplayer as per the definition. Scoring assigns 100 points to the winning player and 0 points to the loser, with the tie condition awarding victory—and thus 100 points—to oplayer. Thus, the game encapsulates a classic dots-and-boxes style competition on a 6-by-6 grid, emphasizing strategic line drawing to claim boxes and control turn order until all edges are drawn and a winner is declared by the number of boxes claimed.",
    "output": "(role xplayer)\n(role oplayer)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(next_index 1 2)\n(next_index 2 3)\n(next_index 3 4)\n(next_index 4 5)\n(next_index 5 6)\n(init (box_count xplayer 0))\n(init (box_count oplayer 0))\n(init (control xplayer))\n(<= (undrawn ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(next_index ?y1 ?y2)\n\t(not (true (line ?x ?y1 ?x ?y2))))\n(<= (undrawn ?x1 ?y ?x2 ?y)\n\t(next_index ?x1 ?x2)\n\t(index ?y)\n\t(not (true (line ?x1 ?y ?x2 ?y))))\n(<= any_undrawn\n\t(undrawn ?x1 ?y1 ?x2 ?y2))\n(<= (legal ?player (draw ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(undrawn ?x1 ?y1 ?x2 ?y2))\n(<= (next (line ?x1 ?y1 ?x2 ?y2))\n\t(does ?player (draw ?x1 ?y1 ?x2 ?y2)))\n(<= (next (line ?x1 ?y1 ?x2 ?y2))\n\t(true (line ?x1 ?y1 ?x2 ?y2)))\n(<= (legal ?player noop)\n\t(role ?player)\n\t(not (true (control ?player))))\n(<= (v_drawn ?x ?y1 ?x ?y2)\n\t(does ?player (draw ?x ?y1 ?x ?y2)))\n(<= (h_drawn ?x1 ?y ?x2 ?y)\n\t(does ?player (draw ?x1 ?y ?x2 ?y)))\n(<= (box_formed ?x1 ?y1)\n\t(v_drawn ?x1 ?y1 ?x1 ?y2)\n\t(true (line ?x1 ?y2 ?x2 ?y2))\n\t(true (line ?x1 ?y1 ?x2 ?y1))\n\t(true (line ?x2 ?y1 ?x2 ?y2)))\n(<= (box_formed ?x1 ?y1)\n\t(v_drawn ?x2 ?y1 ?x2 ?y2)\n\t(true (line ?x1 ?y1 ?x2 ?y1))\n\t(true (line ?x1 ?y1 ?x1 ?y2))\n\t(true (line ?x1 ?y2 ?x2 ?y2)))\n(<= (box_formed ?x1 ?y1)\n\t(h_drawn ?x1 ?y1 ?x2 ?y1)\n\t(true (line ?x2 ?y1 ?x2 ?y2))\n\t(true (line ?x1 ?y1 ?x1 ?y2))\n\t(true (line ?x1 ?y2 ?x2 ?y2)))\n(<= (box_formed ?x1 ?y1)\n\t(h_drawn ?x1 ?y2 ?x2 ?y2)\n\t(true (line ?x1 ?y1 ?x1 ?y2))\n\t(true (line ?x1 ?y1 ?x2 ?y1))\n\t(true (line ?x2 ?y1 ?x2 ?y2)))\n(<= any_box_formed\n\t(box_formed ?x ?y))\n(<= two_boxes_formed\n\t(box_formed ?x1 ?y1)\n\t(box_formed ?x2 ?y2)\n\t(or (distinct ?x1 ?x2)\n\t\t(distinct ?y1 ?y2)))\n(<= (next (box_count ?player ?n))\n\t(true (box_count ?player ?n))\n\t(not (true (control ?player))))\n(<= (next (box_count ?player ?n))\n\t(true (box_count ?player ?n))\n\t(true (control ?player))\n\t(not any_box_formed))\n(<= (next (box_count ?player ?np1))\n\t(true (box_count ?player ?n))\n\t(true (control ?player))\n\tany_box_formed\n\t(not two_boxes_formed)\n\t(succ ?n ?np1))\n(<= (next (box_count ?player ?np2))\n\t(true (box_count ?player ?n))\n\t(true (control ?player))\n\ttwo_boxes_formed\n\t(succ ?n ?np1)\n\t(succ ?np1 ?np2))\n(<= (next (control ?player))\n\t(true (control ?player))\n\tany_box_formed)\n(<= (next (control xplayer))\n\t(true (control oplayer))\n\t(not any_box_formed))\n(<= (next (control oplayer))\n\t(true (control xplayer))\n\t(not any_box_formed))\n(<= (next (box ?x ?y x))\n\t(box_formed ?x ?y)\n\t(true (control xplayer)))\n(<= (next (box ?x ?y o))\n\t(box_formed ?x ?y)\n\t(true (control oplayer)))\n(<= (next (box ?x ?y ?mark))\n\t(true (box ?x ?y ?mark)))\n(<= terminal\n\t(not any_undrawn))\n(<= x_wins\n\t(true (box_count xplayer ?xscore))\n\t(true (box_count oplayer ?oscore))\n\t(gt ?xscore ?oscore))\n(<= o_wins\n\t(true (box_count xplayer ?xscore))\n\t(true (box_count oplayer ?oscore))\n\t(gt ?oscore ?xscore))\n(<= o_wins\n\t(true (box_count xplayer ?tied))\n\t(true (box_count oplayer ?tied)))\n(<= (goal xplayer 0)\n\tx_wins)\n(<= (goal xplayer 100)\n\t(not x_wins))\n(<= (goal oplayer 0)\n\to_wins)\n(<= (goal oplayer 100)\n\t(not o_wins))\n(<= (gt ?h ?l)\n\t(succ ?l ?h))\n(<= (gt ?h ?l)\n\t(succ ?m ?h)\n\t(gt ?m ?l)\n\t(succ ?l ?lp1))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on an 8-by-8 grid coordinate system with cells labeled from 1 to 8 on both the x (horizontal) and y (vertical) axes, where each cell is identified by its x and y coordinates. Two player roles exist: the explorer and the ghost, who alternate turns with the explorer starting first. Initially, the explorer is positioned at cell (2,6) and the ghost at cell (7,3), with an exit located at cell (8,8). Certain cells have directional blockages either to their north or east, preventing movement through those edges. On each turn, the player in control may choose a move action specifying a direction—north, south, east, west, or nowhere—or, in the case of the ghost, may also choose to drop slime. Legal moves for the explorer require that the target adjacent cell be within the board boundaries, not blocked by north or east walls, and not the 'nowhere' direction unless it is not their turn, in which case doing nothing (move nowhere) is permitted. Similarly, the ghost can move to any adjacent cell within the board or choose to drop slime at its current location; dropping slime leaves a slime marker on the cell occupied by the ghost. After each action, control passes to the other player, and the game step counter increments by one. The explorer and ghost cannot move through blocked edges, and movement must remain within the board cells. The game terminates under three conditions: if the explorer reaches the exit cell, if the explorer occupies a cell with slime (melting), or if 50 steps have elapsed (timeout). Scoring favors the explorer when successfully reaching the exit, earning a score of 100; if the explorer melts or fails to exit within 50 steps, the explorer's score is zero or 50 respectively. Conversely, the ghost scores 100 points if the explorer melts, 50 points if the game times out without exit or melting, and zero if the explorer successfully reaches the exit. Overall, the game revolves around the explorer attempting to reach the exit safely while avoiding slime dropped by the ghost, both constrained by board boundaries and directional blockages, with alternating turns and clear conditions for legal actions and game termination.",
    "output": "(role explorer)\n(role ghost)\n(init (location explorer 2 6))\n(init (location ghost 7 3))\n(exitCell 8 8)\n(<= (init (location exit ?x ?y))\n    (exitCell ?x ?y))\n(blockedNorthCell 3 1)\n(blockedNorthCell 4 1)\n(blockedNorthCell 5 1)\n(blockedNorthCell 8 1)\n(blockedNorthCell 7 2)\n(blockedNorthCell 4 3)\n(blockedNorthCell 7 3)\n(blockedNorthCell 2 4)\n(blockedNorthCell 3 4)\n(blockedNorthCell 8 4)\n(blockedNorthCell 1 5)\n(blockedNorthCell 4 5)\n(blockedNorthCell 7 5)\n(blockedNorthCell 2 6)\n(blockedNorthCell 6 6)\n(blockedNorthCell 8 6)\n(blockedNorthCell 4 7)\n(blockedNorthCell 6 7)\n(<= (init (blockedNorth ?x ?y))\n    (blockedNorthCell ?x ?y))\n(blockedEastCell 1 2)\n(blockedEastCell 1 4)\n(blockedEastCell 1 7)\n(blockedEastCell 1 8)\n(blockedEastCell 2 2)\n(blockedEastCell 2 8)\n(blockedEastCell 3 1)\n(blockedEastCell 3 4)\n(blockedEastCell 3 5)\n(blockedEastCell 3 6)\n(blockedEastCell 4 2)\n(blockedEastCell 4 8)\n(blockedEastCell 5 5)\n(blockedEastCell 6 8)\n(<= (init (blockedEast ?x ?y))\n    (blockedEastCell ?x ?y))\n(init (control explorer))\n(init (step 1))\n(<= (legal explorer (move ?dir))\n    (true (control explorer))\n    (true (location explorer ?x ?y))\n    (legalStep ?dir ?x ?y)\n    (distinct ?dir nowhere))\n(<= (legal explorer (move nowhere))\n    (not (true (control explorer))))\n(<= (legal ghost (move ?dir))\n    (true (control ghost))\n    (true (location ghost ?x1 ?y1))\n    (nextCell ?dir ?x1 ?y1 ?x2 ?y2)\n    (cell ?x2 ?y2))\n(<= (legal ghost dropSlime)\n    (true (control ghost)))\n(<= (legal ghost (move nowhere))\n    (not (true (control ghost))))\n(<= (next (control explorer))\n    (true (control ghost)))\n(<= (next (control ghost))\n    (true (control explorer)))\n(<= (next (location exit ?x ?y))\n    (true (location exit ?x ?y)))\n(<= (next (blockedNorth ?x ?y))\n    (true (blockedNorth ?x ?y)))\n(<= (next (blockedEast ?x ?y))\n    (true (blockedEast ?x ?y)))\n(<= (next (location explorer ?x2 ?y2))\n    (true (location explorer ?x1 ?y1))\n    (does explorer (move ?dir))\n    (nextCell ?dir ?x1 ?y1 ?x2 ?y2))\n(<= (next (location ghost ?x2 ?y2))\n    (true (location ghost ?x1 ?y1))\n    (does ghost (move ?dir))\n    (nextCell ?dir ?x1 ?y1 ?x2 ?y2))\n(<= (next (location ghost ?x ?y))\n    (true (location ghost ?x ?y))\n    (does ghost dropSlime))\n(<= (next (location slime ?x ?y))\n    (true (location ghost ?x ?y))\n    (does ghost dropSlime))\n(<= (next (location slime ?x ?y))\n    (true (location slime ?x ?y)))\n(<= (next (step ?nplusplus))\n    (true (step ?n))\n    (succ ?n ?nplusplus))\n(<= terminal\n    melted)\n(<= terminal\n    atExit)\n(<= terminal\n    timeout)\n(<= (goal explorer 0)\n    melted)\n(<= (goal explorer 0)\n    (not atExit)\n    (not melted)\n    (not timeout))\n(<= (goal explorer 50)\n    timeout\n    (not atExit)\n    (not melted))\n(<= (goal explorer 100)\n    atExit\n    (not melted))\n(<= (goal ghost 0)\n    atExit\n    (not melted))\n(<= (goal ghost 0)\n    (not atExit)\n    (not melted)\n    (not timeout))\n(<= (goal ghost 50)\n    timeout\n    (not atExit)\n    (not melted))\n(<= (goal ghost 100)\n    melted)\n(<= (legalStep north ?x ?y)\n    (plusplus ?y ?yNew)\n    (cell ?x ?yNew)\n    (not (blocked ?x ?y ?x ?yNew)))\n(<= (legalStep south ?x ?y)\n    (minusminus ?y ?yNew)\n    (cell ?x ?yNew)\n    (not (blocked ?x ?y ?x ?yNew)))\n(<= (legalStep east ?x ?y)\n    (plusplus ?x ?xNew)\n    (cell ?xNew ?y)\n    (not (blocked ?x ?y ?xNew ?y)))\n(<= (legalStep west ?x ?y)\n    (minusminus ?x ?xNew)\n    (cell ?xNew ?y)\n    (not (blocked ?x ?y ?xNew ?y)))\n(<= (legalStep nowhere ?x ?y)\n    (cell ?x ?y))\n(<= (nextCell north ?x ?y ?x ?yNew)\n    (index ?x)\n    (plusplus ?y ?yNew))\n(<= (nextCell south ?x ?y ?x ?yNew)\n    (index ?x)\n    (minusminus ?y ?yNew))\n(<= (nextCell east ?x ?y ?xNew ?y)\n    (index ?y)\n    (plusplus ?x ?xNew))\n(<= (nextCell west ?x ?y ?xNew ?y)\n    (index ?y)\n    (minusminus ?x ?xNew))\n(<= (nextCell nowhere ?x ?y ?x ?y)\n    (cell ?x ?y))\n(<= (blocked ?x ?y1 ?x ?y2)\n    (true (blockedNorth ?x ?y1))\n    (plusplus ?y1 ?y2))\n(<= (blocked ?x ?y2 ?x ?y1)\n    (true (blockedNorth ?x ?y1))\n    (plusplus ?y1 ?y2))\n(<= (blocked ?x1 ?y ?x2 ?y)\n    (true (blockedEast ?x1 ?y))\n    (plusplus ?x1 ?x2))\n(<= (blocked ?x2 ?y ?x1 ?y)\n    (true (blockedEast ?x1 ?y))\n    (plusplus ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n\t(cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n\t(cell ?x1 ?y1)\n\t(cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= atExit\n    (true (location explorer ?x ?y))\n    (true (location exit ?x ?y)))\n(<= melted\n    (true (location explorer ?x ?y))\n    (true (location slime ?x ?y)))\n(<= timeout\n    (true (step 50)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(cell 1 8) (cell 2 8) (cell 3 8) (cell 4 8) (cell 5 8) (cell 6 8) (cell 7 8) (cell 8 8)\n(cell 1 7) (cell 2 7) (cell 3 7) (cell 4 7) (cell 5 7) (cell 6 7) (cell 7 7) (cell 8 7)\n(cell 1 6) (cell 2 6) (cell 3 6) (cell 4 6) (cell 5 6) (cell 6 6) (cell 7 6) (cell 8 6)\n(cell 1 5) (cell 2 5) (cell 3 5) (cell 4 5) (cell 5 5) (cell 6 5) (cell 7 5) (cell 8 5)\n(cell 1 4) (cell 2 4) (cell 3 4) (cell 4 4) (cell 5 4) (cell 6 4) (cell 7 4) (cell 8 4)\n(cell 1 3) (cell 2 3) (cell 3 3) (cell 4 3) (cell 5 3) (cell 6 3) (cell 7 3) (cell 8 3)\n(cell 1 2) (cell 2 2) (cell 3 2) (cell 4 2) (cell 5 2) (cell 6 2) (cell 7 2) (cell 8 2)\n(cell 1 1) (cell 2 1) (cell 3 1) (cell 4 1) (cell 5 1) (cell 6 1) (cell 7 1) (cell 8 1)\n(plusplus 1 2) (plusplus 2 3) (plusplus 3 4) (plusplus 4 5) (plusplus 5 6) (plusplus 6 7) (plusplus 7 8)\n(minusminus 8 7) (minusminus 7 6) (minusminus 6 5) (minusminus 5 4) (minusminus 4 3) (minusminus 3 2) (minusminus 2 1)\n(succ  1  2) (succ  2  3) (succ  3  4) (succ  4  5) (succ  5  6)\n(succ  6  7) (succ  7  8) (succ  8  9) (succ  9 10) (succ 10 11)\n(succ 11 12) (succ 12 13) (succ 13 14) (succ 14 15) (succ 15 16)\n(succ 16 17) (succ 17 18) (succ 18 19) (succ 19 20) (succ 20 21)\n(succ 21 22) (succ 22 23) (succ 23 24) (succ 24 25) (succ 25 26)\n(succ 26 27) (succ 27 28) (succ 28 29) (succ 29 30) (succ 30 31)\n(succ 31 32) (succ 32 33) (succ 33 34) (succ 34 35) (succ 35 36)\n(succ 36 37) (succ 37 38) (succ 38 39) (succ 39 40) (succ 40 41)\n(succ 41 42) (succ 42 43) (succ 43 44) (succ 44 45) (succ 45 46)\n(succ 46 47) (succ 47 48) (succ 48 49) (succ 49 50)\n(dir north)\n(dir south)\n(dir east)\n(dir west)\n(dir nowhere)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a circular board consisting of ten normal pits labeled p1 through p10, and two special scoring pits named pwinnorth and pwinsouth, each associated with one of the two players: north and south. The pits are arranged such that each pit has a \"next\" pit in a sequence that loops around the board, with the scoring pits positioned between certain normal pits, allowing stones to cycle through the board in a fixed order. The players north and south each control five normal pits on opposite sides of the board: north owns p6 through p10, while south owns p1 through p5. At the start of the game, all pits contain three stones each, except the scoring pits which start empty, and the north player has the initial control of the turn. Players alternate turns, with the control passing according to the actions taken, or passing to the opponent if a noop is played when it is not their turn.\n\nDuring a player's turn, they may perform one of several actions depending on the game state and their hand status, which indicates whether they are currently holding stones or not. If it is a player's turn, and the other player still has stones in their pits, the player may pick up all stones from one of their own non-empty pits, provided they are not already holding any stones. After picking stones, the player must then place them one by one into subsequent pits in the sequence, starting from the pit following the one picked, by executing put actions. The put action requires that the player is holding stones (hand not s0) and specifies the pit into which to place a stone; the pit must be the current position of the stones being sown. If the last stone lands in a scoring pit belonging to the player and some conditions about emptiness of pits opposite to the landing pit are met, special scoring rules apply, potentially capturing stones from opposite pits and adding them to the scoring pit. If the last stone lands in an empty pit on the player's side, capturing may also occur by taking stones from the opposite pit. The player may also clear a pit, which removes all stones from that pit and adds them to the player's scoring pit, but this action is only legal if the opponent's pits are all empty and the player is not holding any stones. If it is not a player's turn, their only legal move is noop, which essentially passes control without changing the game state. Additionally, a player must play noop if all their pits are empty and they hold no stones.\n\nThe game enforces several implicit constraints: actions must target pits owned by the player or valid pits in the sequence; placing stones must follow the next pit sequence order; the hand status must be consistent with picking or putting stones; and players cannot pick or clear empty pits. The control of turns changes as follows: after a pick or clear action, the same player retains control; after a put action, control passes to the other player if the last stone was not placed in the player's scoring pit with a single stone in hand; otherwise, the player may continue. The game ends when all pits owned by both players are empty, meaning no more stones remain to be played. The scoring is determined by the number of stones in each player's scoring pit, with a mapping from the stone count to a numerical score. The player with the higher score in their scoring pit at the end wins the game. Throughout play, the game state evolves automatically according to the rules governing stone movement, captures, and pit emptiness, ensuring the circular sowing of stones and scoring mechanics reflect traditional mancala-like gameplay on the specified board layout.",
    "output": "(role north)\n(role south)\n(<= (init (pit ?p s3))\n  (normalpit ?p))\n(<= (init (pit ?p s0))\n  (scoringpit ?r ?p))\n(<= (init (hand ?r s0))\n  (role ?r))\n(init (control north))\n(<= (legal ?r noop)\n  (role ?r)\n  (true (control ?r2))\n  (distinct ?r ?r2))\n(<= (legal ?r noop)\n  (true (control ?r))\n  (allempty ?r)\n  (true (hand ?r s0)))\n(<= (legal ?r (clear ?p))\n  (true (control ?r))\n  (owner ?r ?p)\n  (not (true (pit ?p s0)))\n  (role ?r2)\n  (distinct ?r ?r2)\n  (allempty ?r2))\n(<= (legal ?r (pick ?p))\n  (true (control ?r))\n  (true (hand ?r s0))\n  (owner ?r ?p)\n  (not (true (pit ?p s0)))\n  (role ?r2)\n  (distinct ?r ?r2)\n  (not (allempty ?r2)))\n(<= (legal ?r (put ?p))\n  (true (control ?r))\n  (true (at ?p))\n  (true (hand ?r ?n))\n  (distinct ?n s0))\n(<= terminal\n  (allempty north)\n  (allempty south))\n(<= (goal ?r ?score)\n  (scoringpit ?r ?p)\n  (true (pit ?p ?n))\n  (map_to_score ?n ?score))\n(<= (next (control ?r))\n  (does ?r (pick ?p)))\n(<= (next (control ?r))\n  (does ?r (clear ?p)))\n(<= (next (control ?r))\n  (does ?r (put ?p))\n  (true (hand ?r ?n))\n  (distinct ?n s1))\n(<= (next (control ?r))\n  (does ?r (put ?p))\n  (true (hand ?r s1))\n  (scoringpit ?r ?p))\n(<= (next (control ?r2))\n  (does ?r (put ?p))\n  (true (hand ?r s1))\n  (not (scoringpit ?r ?p))\n  (role ?r2)\n  (distinct ?r2 ?r))\n(<= (next (control ?r2))\n  (true (control ?r))\n  (does ?r noop)\n  (role ?r2)\n  (distinct ?r2 ?r))\n(<= (next (hand ?r ?n))\n  (does ?r (pick ?p))\n  (true (pit ?p ?n)))\n(<= (next (hand ?r ?n))\n  (does ?r (put ?p))\n  (true (hand ?r ?n1))\n  (succ ?n ?n1))\n(<= (next (hand ?r ?n))\n  (does ?r noop)\n  (true (hand ?r ?n)))\n(<= (next (hand ?r ?n))\n  (does ?r (clear ?p))\n  (true (hand ?r ?n)))\n(<= (next (at ?p2))\n  (does ?r (pick ?p))\n  (nextpit ?r ?p ?p2))\n(<= (next (at ?p2))\n  (does ?r (put ?p))\n  (true (hand ?r ?n))\n  (distinct ?n s1)\n  (nextpit ?r ?p ?p2))\n(<= (next (pit ?p s0))\n  (does ?r (clear ?p)))\n(<= (next (pit ?p ?n2))\n  (does ?r (clear ?p2))\n  (scoringpit ?r ?p)\n  (true (pit ?p ?n))\n  (true (pit ?p2 ?n1))\n  (plus ?n ?n1 ?n2))\n(<= (next (pit ?p ?n))\n  (true (pit ?p ?n))\n  (does ?r (clear ?p2))\n  (distinct ?p ?p2)\n  (not (scoringpit ?r ?p)))\n(<= (next (pit ?p s0))\n  (does ?r (pick ?p)))\n(<= (next (pit ?p ?n))\n  (does ?r (pick ?p2))\n  (true (pit ?p ?n))\n  (distinct ?p ?p2))\n(<= (next (pit ?p ?n2))\n  (does ?r (put ?p))\n  (not (true (hand ?r s1)))\n  (true (pit ?p ?n))\n  (succ ?n ?n2))\n(<= (next (pit ?p ?n))\n  (does ?r (put ?p2))\n  (true (pit ?p ?n))\n  (distinct ?p ?p2)\n  (not (true (hand ?r s1))))\n(<= (next (pit ?p ?n2))\n  (does ?r (put ?p))\n  (true (hand ?r s1))\n  (not (emptyonlastput ?r ?p ?p))\n  (true (pit ?p ?n))\n  (succ ?n ?n2))\n(<= (next (pit ?p ?n))\n  (does ?r (put ?p2))\n  (true (pit ?p ?n))\n  (distinct ?p ?p2)\n  (true (hand ?r s1))\n  (not (emptyonlastput ?r ?p2 ?p2)))\n(<= (next (pit ?p s0))\n  (does ?r (put ?p2))\n  (true (hand ?r s1))\n  (emptyonlastput ?r ?p2 ?p))\n(<= (next (pit ?p ?n2))\n  (does ?r (put ?p2))\n  (true (hand ?r s1))\n  (scoringpit ?r ?p)\n  (emptyonlastput ?r ?p2 ?p2)\n  (opposite ?p2 ?p3)\n  (true (pit ?p ?n))\n  (true (pit ?p3 ?np3))\n  (plus ?n ?np3 ?n1)\n  (succ ?n1 ?n2))\n(<= (next (pit ?p ?n))\n  (does ?r (put ?p2))\n  (true (hand ?r s1))\n  (true (pit ?p ?n))\n  (distinct ?p ?p2)\n  (not (scoringpit ?r ?p))\n  (not (opposite ?p ?p2))\n  (emptyonlastput ?r ?p2 ?p2))\n(<= (next (pit ?p ?n))\n  (does north noop)\n  (does south noop)\n  (true (pit ?p ?n)))\n(<= (allempty north)\n  (true (pit p6 s0))\n  (true (pit p7 s0))\n  (true (pit p8 s0))\n  (true (pit p9 s0))\n  (true (pit p10 s0)))\n(<= (allempty south)\n  (true (pit p1 s0))\n  (true (pit p2 s0))\n  (true (pit p3 s0))\n  (true (pit p4 s0))\n  (true (pit p5 s0)))\n(<= (some_not_empty ?r)\n  (owner ?r ?p)\n  (true (pit ?p ?n))\n  (distinct ?n s0))\n(<= (emptyonlastput ?r ?p ?p)\n  (owner ?r ?p)\n  (true (pit ?p s0)))\n(<= (emptyonlastput ?r ?p ?p2)\n  (opposite ?p ?p2)\n  (owner ?r ?p)\n  (true (pit ?p s0)))\n(<= (opposite ?p1 ?p2)\n  (basicopposite ?p1 ?p2))\n(<= (opposite ?p1 ?p2)\n  (basicopposite ?p2 ?p1))\n(<= (plus ?x s0 ?x)\n  (number ?x))\n(<= (plus ?x ?y ?z)\n  (succ ?y2 ?y)\n  (succ ?x ?x2)\n  (plus ?x2 ?y2 ?z))\n(<= (anypit ?p)\n  (normalpit ?p))\n(<= (anypit ?p)\n  (scoringpit ?r ?p))\n(normalpit p1)\n(normalpit p2)\n(normalpit p3)\n(normalpit p4)\n(normalpit p5)\n(normalpit p6)\n(normalpit p7)\n(normalpit p8)\n(normalpit p9)\n(normalpit p10)\n(scoringpit north pwinnorth)\n(scoringpit south pwinsouth)\n(owner north p6)\n(owner north p7)\n(owner north p8)\n(owner north p9)\n(owner north p10)\n(owner south p1)\n(owner south p2)\n(owner south p3)\n(owner south p4)\n(owner south p5)\n(basicopposite p1 p10)\n(basicopposite p2 p9)\n(basicopposite p3 p8)\n(basicopposite p4 p7)\n(basicopposite p5 p6)\n(nextpit south p1 p2)\n(nextpit south p2 p3)\n(nextpit south p3 p4)\n(nextpit south p4 p5)\n(nextpit south p5 pwinsouth)\n(nextpit south pwinsouth p6)\n(nextpit south p6 p7)\n(nextpit south p7 p8)\n(nextpit south p8 p9)\n(nextpit south p9 p10)\n(nextpit south p10 p1)\n(nextpit north p1 p2)\n(nextpit north p2 p3)\n(nextpit north p3 p4)\n(nextpit north p4 p5)\n(nextpit north p5 p6)\n(nextpit north p6 p7)\n(nextpit north p7 p8)\n(nextpit north p8 p9)\n(nextpit north p9 p10)\n(nextpit north p10 pwinnorth)\n(nextpit north pwinnorth p1)\n(map_to_score s0 0)\n(map_to_score s1 0)\n(map_to_score s2 0)\n(map_to_score s3 0)\n(map_to_score s4 0)\n(map_to_score s5 0)\n(map_to_score s6 0)\n(map_to_score s7 0)\n(map_to_score s8 0)\n(map_to_score s9 0)\n(map_to_score s10 0)\n(map_to_score s11 0)\n(map_to_score s12 0)\n(map_to_score s13 0)\n(map_to_score s14 0)\n(map_to_score s15 50)\n(map_to_score s16 86)\n(map_to_score s17 87)\n(map_to_score s18 88)\n(map_to_score s19 89)\n(map_to_score s20 90)\n(map_to_score s21 91)\n(map_to_score s22 92)\n(map_to_score s23 93)\n(map_to_score s24 94)\n(map_to_score s25 95)\n(map_to_score s26 96)\n(map_to_score s27 97)\n(map_to_score s28 98)\n(map_to_score s29 99)\n(map_to_score s30 100)\n(number s0)\n(number s1)\n(number s2)\n(number s3)\n(number s4)\n(number s5)\n(number s6)\n(number s7)\n(number s8)\n(number s9)\n(number s10)\n(number s11)\n(number s12)\n(number s13)\n(number s14)\n(number s15)\n(number s16)\n(number s17)\n(number s18)\n(number s19)\n(number s20)\n(number s21)\n(number s22)\n(number s23)\n(number s24)\n(number s25)\n(number s26)\n(number s27)\n(number s28)\n(number s29)\n(number s30)\n(succ s0 s1)\n(succ s1 s2)\n(succ s2 s3)\n(succ s3 s4)\n(succ s4 s5)\n(succ s5 s6)\n(succ s6 s7)\n(succ s7 s8)\n(succ s8 s9)\n(succ s9 s10)\n(succ s10 s11)\n(succ s11 s12)\n(succ s12 s13)\n(succ s13 s14)\n(succ s14 s15)\n(succ s15 s16)\n(succ s16 s17)\n(succ s17 s18)\n(succ s18 s19)\n(succ s19 s20)\n(succ s20 s21)\n(succ s21 s22)\n(succ s22 s23)\n(succ s23 s24)\n(succ s24 s25)\n(succ s25 s26)\n(succ s26 s27)\n(succ s27 s28)\n(succ s28 s29)\n(succ s29 s30)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a checkered board with files labeled a through h and ranks numbered 1 through 8, forming an 8x8 grid. The coordinate system identifies each cell by its file and rank, with valid squares alternating based on file and rank parity, effectively creating a checkerboard pattern. There are two players, White and Black, who alternate turns starting from the initial state where the last move was made by Black. The board begins populated with pawns of each color placed on specific squares: White pawns occupy a2, b1, c2, d1, e2, f1, g2, h1, b3, d3, f3, and h3; Black pawns occupy a8, b7, c8, d7, e8, f7, g8, h7, a6, c6, e6, and g6. Each turn, the player whose turn it is may perform one legal action or, if no action is legal, may perform a no-operation (noop) move. The game enforces a capturing rule: if a capturing move is available, the player must capture; if multiple captures are possible, the player must continue capturing with the same piece until no further captures are available. Control of the turn passes to the player who made the last capture if that player can continue capturing; otherwise, control switches to the opponent.\n\nActions in this game take the form of move or capture commands. A move action is specified by the piece's current coordinates and the target coordinates to which it moves. For White, a move consists of moving a piece diagonally forward by one square to an empty square; for Black, moves are diagonally backward by one square to an empty square. The king pieces have slightly different movement: White kings move diagonally backward by one square, and Black kings move diagonally forward by one square, also to empty squares. A capture action involves a piece at an initial position jumping over an opponent's piece diagonally forward or backward into a vacant square immediately beyond it, provided the three squares are consecutive diagonally in a line. The piece being jumped over is removed from the board. Capturing moves must be made if available, and multiple captures in a sequence by the same piece are enforced when possible.\n\nAfter a move or capture, the game state updates accordingly: the piece moves to the new square, any captured piece is removed, and if a pawn reaches the opponent's back rank (rank 8 for White, rank 1 for Black), it is promoted to a king. The piece that made the last capture remains the capturing piece for potential chained captures. The game tracks steps, incrementing after moves or captures unless a pawn moves or a capture occurs, in which case the step counter resets to zero. The game ends when a player has no legal moves available, resulting in that player losing, or when the step counter reaches 20, indicating a draw or forced termination. Victory is awarded to the player who does not lose, with a scoring system assigning 100 points to the winner, 0 to the loser, and 50 points to each player if the game ends without a loser. Thus, the game combines elements of forced capturing, promotion to kings, and movement constrained to diagonal squares on a checkered board, with turn control depending on capture sequences and a step-based termination condition.",
    "output": "(role white)\n(role black)\n(opponent black white)\n(opponent white black)\n(init (lastToMove black))\n(init (cell a 2 white pawn))\n(init (cell b 1 white pawn))\n(init (cell c 2 white pawn))\n(init (cell d 1 white pawn))\n(init (cell e 2 white pawn))\n(init (cell f 1 white pawn))\n(init (cell g 2 white pawn))\n(init (cell h 1 white pawn))\n(init (cell b 3 white pawn))\n(init (cell d 3 white pawn))\n(init (cell f 3 white pawn))\n(init (cell h 3 white pawn))\n(init (cell a 8 black pawn))\n(init (cell b 7 black pawn))\n(init (cell c 8 black pawn))\n(init (cell d 7 black pawn))\n(init (cell e 8 black pawn))\n(init (cell f 7 black pawn))\n(init (cell g 8 black pawn))\n(init (cell h 7 black pawn))\n(init (cell a 6 black pawn))\n(init (cell c 6 black pawn))\n(init (cell e 6 black pawn))\n(init (cell g 6 black pawn))\n(<= (hasPiece ?x ?y)\n    (true (cell ?x ?y ?anyPlayer ?anyType)))\n(<= (empty ?x ?y)\n    (file ?x)\n    (rank ?y)\n    (not (hasPiece ?x ?y)))\n(<= (legal2 white (move ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 white ?anyType))\n    (or (nextFile ?x1 ?x2)\n        (nextFile ?x2 ?x1))\n    (nextRank ?y1 ?y2)\n    (empty ?x2 ?y2))\n(<= (legal2 white (move ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 white king))\n    (or (nextFile ?x1 ?x2)\n        (nextFile ?x2 ?x1))\n    (nextRank ?y2 ?y1)\n    (empty ?x2 ?y2))\n(<= (legal2 black (move ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 black ?anyType))\n    (or (nextFile ?x1 ?x2)\n        (nextFile ?x2 ?x1))\n    (nextRank ?y2 ?y1)\n    (empty ?x2 ?y2))\n(<= (legal2 black (move ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 black king))\n    (or (nextFile ?x1 ?x2)\n        (nextFile ?x2 ?x1))\n    (nextRank ?y1 ?y2)\n    (empty ?x2 ?y2))\n(<= (legal2 white (capture ?x1 ?y1 ?x3 ?y3))\n    (true (cell ?x1 ?y1 white ?anyType))\n    (nextRank ?y1 ?y2)\n    (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (true (cell ?x2 ?y2 black ?anyType2))\n    (not (hasPiece ?x3 ?y3)))\n(<= (legal2 white (capture ?x1 ?y1 ?x3 ?y3))\n    (true (cell ?x1 ?y1 white king))\n    (nextRank ?y2 ?y1)\n    (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (true (cell ?x2 ?y2 black ?anyType))\n    (not (hasPiece ?x3 ?y3)))\n(<= (legal2 black (capture ?x1 ?y1 ?x3 ?y3))\n    (true (cell ?x1 ?y1 black ?anyType))\n    (nextRank ?y2 ?y1)\n    (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (true (cell ?x2 ?y2 white ?anyType2))\n    (not (hasPiece ?x3 ?y3)))\n(<= (legal2 black (capture ?x1 ?y1 ?x3 ?y3))\n    (true (cell ?x1 ?y1 black king))\n    (nextRank ?y1 ?y2)\n    (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (true (cell ?x2 ?y2 white ?anyType))\n    (not (hasPiece ?x3 ?y3)))\n(<= (captureAvailable ?player)\n    (legal2 ?player (capture ?x1 ?y1 ?x3 ?y3)))\n(<= captureAvailableForLastCapturingPiece\n    (true (capturingPiece ?x ?y))\n    (legal2 ?player (capture ?x ?y ?x3 ?y3)))\n(<= (control ?lastPlayer)\n    (true (lastToMove ?lastPlayer))\n    captureAvailableForLastCapturingPiece)\n(<= (control ?notLastPlayer)\n    (true (lastToMove ?lastPlayer))\n    (opponent ?lastPlayer ?notLastPlayer)\n    (not captureAvailableForLastCapturingPiece))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (control ?player)))\n(<= (legal ?player (capture ?x1 ?y1 ?x3 ?y3))\n    (control ?player)\n    (true (capturingPiece ?x1 ?y1))\n    (legal2 ?player (capture ?x1 ?y1 ?x3 ?y3)))\n(<= (legal ?player (capture ?x1 ?y1 ?x3 ?y3))\n    (control ?player)\n    (captureAvailable ?player)\n    (not captureAvailableForLastCapturingPiece)\n    (legal2 ?player (capture ?x1 ?y1 ?x3 ?y3)))\n(<= (legal ?player (move ?x1 ?y1 ?x2 ?y2))\n    (control ?player)\n    (not (captureAvailable ?player))\n    (legal2 ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= captureWasMade\n    (does ?player (capture ?x1 ?y1 ?x3 ?y3)))\n(<= kingingCaptureWasMade\n    (does ?player (capture ?x1 ?y1 ?x3 1))\n    (true (cell ?x1 ?y1 ?anyPlayer pawn)))\n(<= kingingCaptureWasMade\n    (does ?player (capture ?x1 ?y1 ?x3 8))\n    (true (cell ?x1 ?y1 ?anyPlayer pawn)))\n(<= (next (capturingPiece ?x3 ?y3))\n    (does ?player (capture ?x1 ?y1 ?x3 ?y3))\n    (not kingingCaptureWasMade))\n(<= (next (lastToMove ?player))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (lastToMove ?player))\n    (does ?player (capture ?x1 ?y1 ?x2 ?y2)))\n(<= (affected ?x1 ?y1)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (affected ?x2 ?y2)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (affected ?x1 ?y1)\n    (does ?player (capture ?x1 ?y1 ?x3 ?y3)))\n(<= (affected ?x2 ?y2)\n    (does ?player (capture ?x1 ?y1 ?x3 ?y3))\n    (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n(<= (affected ?x3 ?y3)\n    (does ?player (capture ?x1 ?y1 ?x3 ?y3)))\n(<= (next (cell ?x ?y ?player ?type))\n    (true (cell ?x ?y ?player ?type))\n    (not (affected ?x ?y)))\n(<= (next (cell ?x2 8 white king))\n    (does white (move ?x1 ?y1 ?x2 8)))\n(<= (next (cell ?x3 8 white king))\n    (does white (capture ?x1 ?y1 ?x3 8)))\n(<= (next (cell ?x2 1 black king))\n    (does black (move ?x1 ?y1 ?x2 1)))\n(<= (next (cell ?x3 1 black king))\n    (does black (capture ?x1 ?y1 ?x3 1)))\n(<= (next (cell ?x2 ?y2 white ?type))\n    (does white (move ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 white ?type))\n    (distinct ?y2 8))\n(<= (next (cell ?x3 ?y3 white ?type))\n    (does white (capture ?x1 ?y1 ?x3 ?y3))\n    (true (cell ?x1 ?y1 white ?type))\n    (distinct ?y3 8))\n(<= (next (cell ?x2 ?y2 black ?type))\n    (does black (move ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 black ?type))\n    (distinct ?y2 1))\n(<= (next (cell ?x3 ?y3 black ?type))\n    (does black (capture ?x1 ?y1 ?x3 ?y3))\n    (true (cell ?x1 ?y1 black ?type))\n    (distinct ?y3 1))\n(<= (anyLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (loser ?player)\n    (control ?player)\n    (not (anyLegalMove ?player)))\n(<= terminal\n    (loser ?player))\n(<= (goal ?player 0)\n    (loser ?player))\n(<= (goal ?player 100)\n    (loser ?opp)\n    (opponent ?player ?opp))\n(init (step 0))\n(<= shouldResetStepCounter\n    (does ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (cell ?x1 ?y1 ?player pawn)))\n(<= shouldResetStepCounter\n    (does ?player (capture ?x1 ?y1 ?x3 ?y3)))\n(<= (next (step 0))\n    shouldResetStepCounter)\n(<= (next (step ?np1))\n    (not shouldResetStepCounter)\n    (true (step ?n))\n    (succ ?n ?np1))\n(<= terminal\n    (true (step 20)))\n(<= anyLoser\n    (loser ?player))\n(<= (goal ?player 50)\n    (role ?player)\n    (not anyLoser))\n(nextFile a b)\n(nextFile b c)\n(nextFile c d)\n(nextFile d e)\n(nextFile e f)\n(nextFile f g)\n(nextFile g h)\n(nextRank 1 2)\n(nextRank 2 3)\n(nextRank 3 4)\n(nextRank 4 5)\n(nextRank 5 6)\n(nextRank 6 7)\n(nextRank 7 8)\n(<= (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (nextFile ?x1 ?x2)\n    (nextFile ?x2 ?x3)\n    (nextRank ?y1 ?y2)\n    (nextRank ?y2 ?y3))\n(<= (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (nextFile ?x3 ?x2)\n    (nextFile ?x2 ?x1)\n    (nextRank ?y1 ?y2)\n    (nextRank ?y2 ?y3))\n(<= (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (nextFile ?x1 ?x2)\n    (nextFile ?x2 ?x3)\n    (nextRank ?y3 ?y2)\n    (nextRank ?y2 ?y1))\n(<= (threeInARow ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (nextFile ?x3 ?x2)\n    (nextFile ?x2 ?x1)\n    (nextRank ?y3 ?y2)\n    (nextRank ?y2 ?y1))\n(file1 a)\n(file2 b)\n(file1 c)\n(file2 d)\n(file1 e)\n(file2 f)\n(file1 g)\n(file2 h)\n(<= (file ?x) (file1 ?x))\n(<= (file ?x) (file2 ?x))\n(rank1 1)\n(rank2 2)\n(rank1 3)\n(rank2 4)\n(rank1 5)\n(rank2 6)\n(rank1 7)\n(rank2 8)\n(<= (rank ?y) (rank1 ?y))\n(<= (rank ?y) (rank2 ?y))\n(<= (validSquare ?x ?y)\n    (file1 ?x)\n    (rank2 ?y))\n(<= (validSquare ?x ?y)\n    (file2 ?x)\n    (rank1 ?y))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board divided into four quadrants, each containing a 3x3 grid indexed by coordinates 1 through 3 for both rows and columns, resulting in global positioning that accounts for quadrant offsets. Two players, designated as red and black, alternate turns in a fixed sequence starting with red placing a piece, followed by black placing a piece, then red rotating a quadrant, then black rotating a quadrant, and so forth. The initial state grants red the control to place a piece first. On a player's turn, if they have placement control, they may place one of their pieces on any empty cell within any quadrant; if they have rotation control, they may rotate one quadrant of the board either clockwise or counterclockwise. If a player does not have either placement or rotation control, they must perform a noop action. Each action must be legal: a placement must target an empty cell within the board boundaries, and a rotation must specify a valid quadrant and direction. Placing a piece updates the cell to be held by that player; rotating a quadrant rearranges the pieces within that quadrant according to the specified rotation direction, transforming coordinates accordingly. Following each action, control passes from placement phase to rotation phase or vice versa, cycling between players in the order red place, black place, red rotate, black rotate, and so forth. The board's boundaries and occupancy rules prevent placing pieces outside the board or on occupied cells. The game ends when either player forms a line of five consecutive pieces horizontally, vertically, or diagonally across the global board, or when no empty cells remain on the board. Lines are detected by mapping quadrant-relative coordinates to global coordinates and checking sequences of five aligned pieces held by the same player, including all rows, columns, and both diagonal directions. Scoring assigns 100 points to a player who achieves a line while the opponent does not, zero points if the opponent has a line and the player does not, and 50 points if both have lines simultaneously or if the board is full without a line. If the game is still ongoing with no lines and empty cells remain, both players have zero points. This structure ensures a strategic interplay of placement and rotation phases, with the goal of aligning five consecutive pieces to win.",
    "output": "(role red)\n(role black)\n(init (placeControl red))\n(<= (legal ?player (place ?q ?x ?y))\n    (role ?player)\n    (true (placeControl ?player))\n    (cellEmpty ?q ?x ?y))\n(<= (legal ?player (rotate ?q ?dir))\n    (quadrant ?q)\n    (direction ?dir)\n    (role ?player)\n    (true (rotateControl ?player)))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (placeControl ?player)))\n    (not (true (rotateControl ?player))))\n(<= (next (cellHolds ?q ?x ?y ?player))\n    (role ?player)\n    (does ?player (place ?q ?x ?y)))\n(<= (next (cellHolds ?q ?x ?y ?state))\n    (true (cellHolds ?q ?x ?y ?state))\n    (role ?player)\n    (does ?player (place ?qAny ?xAny ?yAny)))\n(<= (next (cellHolds ?q ?x2 ?y2 ?state))\n    (role ?player)\n    (does ?player (rotate ?q ?dir))\n    (true (cellHolds ?q ?x1 ?y1 ?state))\n    (rotation ?dir ?x1 ?y1 ?x2 ?y2))\n(<= (next (cellHolds ?q1 ?x ?y ?state))\n    (role ?player)\n    (does ?player (rotate ?q2 ?dirAny))\n    (true (cellHolds ?q1 ?x ?y ?state))\n    (distinct ?q1 ?q2))\n(<= (next (rotateControl red))\n    (true ( placeControl red)))\n(<= (next ( placeControl red))\n    (true (rotateControl black)))\n(<= (next (rotateControl black))\n    (true ( placeControl black)))\n(<= (next ( placeControl black))\n    (true (rotateControl red)))\n(<= terminal\n    (line red))\n(<= terminal\n    (line black))\n(<= terminal\n    (not boardOpen))\n(<= (goal red 0)\n    (line red)\n    (not (line black)))\n(<= (goal red 50)\n    (not (line red))\n    (not (line black))\n    (not boardOpen))\n(<= (goal red 50)\n\t(line red)\n\t(line black))\n(<= (goal red 100)\n    (line black)\n    (not (line red)))\n(<= (goal red 0)\n    (not (line red))\n    (not (line black))\n    boardOpen)\n(<= (goal black 0)\n    (line black)\n    (not (line red)))\n(<= (goal black 50)\n    (not (line red))\n    (not (line black))\n    (not boardOpen))\n(<= (goal black 50)\n\t(line red)\n\t(line black))\n(<= (goal black 100)\n    (line red)\n    (not (line black)))\n(<= (goal black 0)\n    (not (line red))\n    (not (line black))\n    boardOpen)\n(<= (line ?player)\n    (row ?player))\n(<= (line ?player)\n    (col ?player))\n(<= (line ?player)\n    (diag ?player))\n(<= (row ?player)\n    (role ?player)\n    (true (cellHolds ?q1 ?x1 ?y1 ?player))\n    (globalIndex ?q1 ?x1 ?y1 ?x1G ?yG)\n    (++ ?x1G ?x2G)\n    (true (cellHolds ?q2 ?x2 ?y2 ?player))\n    (globalIndex ?q2 ?x2 ?y2 ?x2G ?yG)\n    (++ ?x2G ?x3G)\n    (true (cellHolds ?q3 ?x3 ?y3 ?player))\n    (globalIndex ?q3 ?x3 ?y3 ?x3G ?yG)\n    (++ ?x3G ?x4G)\n    (true (cellHolds ?q4 ?x4 ?y4 ?player))\n    (globalIndex ?q4 ?x4 ?y4 ?x4G ?yG)\n    (++ ?x4G ?x5G)\n    (true (cellHolds ?q5 ?x5 ?y5 ?player))\n    (globalIndex ?q5 ?x5 ?y5 ?x5G ?yG))\n(<= (col ?player)\n    (role ?player)\n    (true (cellHolds ?q1 ?x1 ?y1 ?player))\n    (globalIndex ?q1 ?x1 ?y1 ?xG ?y1G)\n    (++ ?y1G ?y2G)\n    (true (cellHolds ?q2 ?x2 ?y2 ?player))\n    (globalIndex ?q2 ?x2 ?y2 ?xG ?y2G)\n    (++ ?y2G ?y3G)\n    (true (cellHolds ?q3 ?x3 ?y3 ?player))\n    (globalIndex ?q3 ?x3 ?y3 ?xG ?y3G)\n    (++ ?y3G ?y4G)\n    (true (cellHolds ?q4 ?x4 ?y4 ?player))\n    (globalIndex ?q4 ?x4 ?y4 ?xG ?y4G)\n    (++ ?y4G ?y5G)\n    (true (cellHolds ?q5 ?x5 ?y5 ?player))\n    (globalIndex ?q5 ?x5 ?y5 ?xG ?y5G))\n(<= (diag ?player)\n    (role ?player)\n    (true (cellHolds ?q1 ?x1 ?y1 ?player))\n    (globalIndex ?q1 ?x1 ?y1 ?x1G ?y1G)\n    (++ ?x1G ?x2G)\n    (++ ?y1G ?y2G)\n    (true (cellHolds ?q2 ?x2 ?y2 ?player))\n    (globalIndex ?q2 ?x2 ?y2 ?x2G ?y2G)\n    (++ ?x2G ?x3G)\n    (++ ?y2G ?y3G)\n    (true (cellHolds ?q3 ?x3 ?y3 ?player))\n    (globalIndex ?q3 ?x3 ?y3 ?x3G ?y3G)\n    (++ ?x3G ?x4G)\n    (++ ?y3G ?y4G)\n    (true (cellHolds ?q4 ?x4 ?y4 ?player))\n    (globalIndex ?q4 ?x4 ?y4 ?x4G ?y4G)\n    (++ ?x4G ?x5G)\n    (++ ?y4G ?y5G)\n    (true (cellHolds ?q5 ?x5 ?y5 ?player))\n    (globalIndex ?q5 ?x5 ?y5 ?x5G ?y5G))\n(<= (diag ?player)\n    (role ?player)\n    (true (cellHolds ?q1 ?x1 ?y1 ?player))\n    (globalIndex ?q1 ?x1 ?y1 ?x1G ?y5G)\n    (++ ?x1G ?x2G)\n    (++ ?y4G ?y5G)\n    (true (cellHolds ?q2 ?x2 ?y2 ?player))\n    (globalIndex ?q2 ?x2 ?y2 ?x2G ?y4G)\n    (++ ?x2G ?x3G)\n    (++ ?y3G ?y4G)\n    (true (cellHolds ?q3 ?x3 ?y3 ?player))\n    (globalIndex ?q3 ?x3 ?y3 ?x3G ?y3G)\n    (++ ?x3G ?x4G)\n    (++ ?y2G ?y3G)\n    (true (cellHolds ?q4 ?x4 ?y4 ?player))\n    (globalIndex ?q4 ?x4 ?y4 ?x4G ?y2G)\n    (++ ?x4G ?x5G)\n    (++ ?y1G ?y2G)\n    (true (cellHolds ?q5 ?x5 ?y5 ?player))\n    (globalIndex ?q5 ?x5 ?y5 ?x5G ?y1G))\n(<= (globalIndex 1 ?x ?y ?xG ?yG)\n    (+ 3 ?x ?xG)\n    (+ 3 ?y ?yG))\n(<= (globalIndex 2 ?x ?y ?x ?yG)\n    (index ?x)\n    (+ 3 ?y ?yG))\n(<= (globalIndex 3 ?x ?y ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (globalIndex 4 ?x ?y ?xG ?y)\n    (+ 3 ?x ?xG)\n    (index ?y))\n(<= (rotation clockwise ?x1 ?y1 ?x2 ?y2)\n    (verticalFlip ?y1 ?x1 ?x2 ?y2))\n(<= (rotation counterclockwise ?x1 ?y1 ?x2 ?y2)\n    (horizontalFlip ?y1 ?x1 ?x2 ?y2))\n(<= (horizontalFlip 1 ?y 3 ?y)\n    (index ?y))\n(<= (horizontalFlip 2 ?y 2 ?y)\n    (index ?y))\n(<= (horizontalFlip 3 ?y 1 ?y)\n    (index ?y))\n(<= (verticalFlip ?x 1 ?x 3)\n    (index ?x))\n(<= (verticalFlip ?x 2 ?x 2)\n    (index ?x))\n(<= (verticalFlip ?x 3 ?x 1)\n    (index ?x))\n(<= (cell ?q ?x ?y)\n    (quadrant ?q)\n    (index ?x)\n    (index ?y))\n(<= (cellEmpty ?q ?x ?y)\n    (cell ?q ?x ?y)\n    (not (true (cellHolds ?q ?x ?y red)))\n    (not (true (cellHolds ?q ?x ?y black))))\n(<= boardOpen\n    (cellEmpty ?q ?x ?y))\n(index 1) (index 2) (index 3)\n(quadrant 1) (quadrant 2) (quadrant 3) (quadrant 4)\n(direction clockwise) (direction counterclockwise)\n(++  1 2) (++  2 3) (++  3 4) (++  4 5) (++  5 6)\n(+ 3 1 4) (+ 3 2 5) (+ 3 3 6)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on an 8-by-8 grid with coordinates ranging from 1 to 8 along both the x (horizontal) and y (vertical) axes. There are two players, White and Black, who alternate turns with White moving first. Initially, White's pieces occupy all cells in the first two rows (y=1 and y=2) across all columns (x=1 to 8), while Black's pieces occupy all cells in the last two rows (y=7 and y=8) across all columns. On a player's turn, they may either move one of their pieces or perform a noop (no operation) if it is the opponent's turn. Legal moves for White involve moving a piece forward by one cell vertically (from y to y+1) either straight ahead or diagonally by one cell horizontally (x to x±1), provided the destination cell is empty or not already occupied by another White piece; similarly, Black moves pieces forward by one cell vertically downward (from y to y−1) either straight ahead or diagonally by one cell horizontally (x to x±1), again only into empty cells or those not occupied by another Black piece. Moves cannot be made to cells occupied by friendly pieces, and the board boundaries (x and y values between 1 and 8) constrain movement. After a move, the piece occupies the new cell, and the previous cell becomes empty. Control switches to the other player after each move. Noops are only legal when it is not the player's turn, effectively passing control to the opponent. The game ends (terminal state) when either White occupies any cell on the last row (y=8), Black occupies any cell on the first row (y=1), or when one player has no pieces left on the board. Victory is awarded to White if White meets the winning condition or Black loses all pieces; Black wins if Black reaches the first row or White loses all pieces. The winning player receives a score of 100, while the losing player receives 0. This setup creates a strategic race where each player attempts to advance their pieces across the board while preventing the opponent from doing the same or eliminating their pieces.",
    "output": "(role white)\n(role black)\n(init (cellHolds 1 1 white))\n(init (cellHolds 2 1 white))\n(init (cellHolds 3 1 white))\n(init (cellHolds 4 1 white))\n(init (cellHolds 5 1 white))\n(init (cellHolds 6 1 white))\n(init (cellHolds 7 1 white))\n(init (cellHolds 8 1 white))\n(init (cellHolds 1 2 white))\n(init (cellHolds 2 2 white))\n(init (cellHolds 3 2 white))\n(init (cellHolds 4 2 white))\n(init (cellHolds 5 2 white))\n(init (cellHolds 6 2 white))\n(init (cellHolds 7 2 white))\n(init (cellHolds 8 2 white))\n(init (cellHolds 1 7 black))\n(init (cellHolds 2 7 black))\n(init (cellHolds 3 7 black))\n(init (cellHolds 4 7 black))\n(init (cellHolds 5 7 black))\n(init (cellHolds 6 7 black))\n(init (cellHolds 7 7 black))\n(init (cellHolds 8 7 black))\n(init (cellHolds 1 8 black))\n(init (cellHolds 2 8 black))\n(init (cellHolds 3 8 black))\n(init (cellHolds 4 8 black))\n(init (cellHolds 5 8 black))\n(init (cellHolds 6 8 black))\n(init (cellHolds 7 8 black))\n(init (cellHolds 8 8 black))\n(init (control white))\n(<= (legal white (move ?x ?y1 ?x ?y2))\n    (true (control white))\n    (true (cellHolds ?x ?y1 white))\n    (succ ?y1 ?y2)\n    (cellEmpty ?x ?y2))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cellHolds ?x1 ?y1 white))\n    (succ ?y1 ?y2)\n    (succ ?x1 ?x2)\n    (not (true (cellHolds ?x2 ?y2 white))))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cellHolds ?x1 ?y1 white))\n    (succ ?y1 ?y2)\n    (succ ?x2 ?x1)\n    (not (true (cellHolds ?x2 ?y2 white))))\n(<= (legal black (move ?x ?y1 ?x ?y2))\n    (true (control black))\n    (true (cellHolds ?x ?y1 black))\n    (succ ?y2 ?y1)\n    (cellEmpty ?x ?y2))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cellHolds ?x1 ?y1 black))\n    (succ ?y2 ?y1)\n    (succ ?x1 ?x2)\n    (not (true (cellHolds ?x2 ?y2 black))))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cellHolds ?x1 ?y1 black))\n    (succ ?y2 ?y1)\n    (succ ?x2 ?x1)\n    (not (true (cellHolds ?x2 ?y2 black))))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black noop)\n    (true (control white)))\n(<= (next (cellHolds ?x2 ?y2 ?player))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cellHolds ?x3 ?y3 ?state))\n    (true (cellHolds ?x3 ?y3 ?state))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x3 ?y3)\n    (distinctCell ?x2 ?y2 ?x3 ?y3))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= terminal\n    whiteWin)\n(<= terminal\n    blackWin)\n(<= (goal white 100)\n    blackWin)\n(<= (goal white 0)\n    (not blackWin))\n(<= (goal black 100)\n    whiteWin)\n(<= (goal black 0)\n    (not whiteWin))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (cellEmpty ?x ?y)\n    (cell ?x ?y)\n    (not (true (cellHolds ?x ?y white)))\n    (not (true (cellHolds ?x ?y black))))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= whiteWin\n    (index ?x)\n    (true (cellHolds ?x 8 white)))\n(<= blackWin\n    (index ?x)\n    (true (cellHolds ?x 1 black)))\n(<= whiteWin\n\t(not blackCell))\n(<= blackWin\n\t(not whiteCell))\n(<= whiteCell\n\t(cell ?x ?y)\n\t(true (cellHolds ?x ?y white)))\n(<= blackCell\n\t(cell ?x ?y)\n\t(true (cellHolds ?x ?y black)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(succ 1 2)  (succ 2 3)  (succ 3 4)  (succ 4 5)  (succ 5 6)  (succ 6 7)  (succ 7 8)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board composed of a network of cells labeled with coordinates such as a, a1, a2, a3, b, b1, b2, b3, and so forth up to h3, interconnected by bordering relationships that define their adjacency. The coordinate system does not follow a simple grid but rather a graph of cells connected by specified neighbor relations, allowing movement across one to four empty intermediate cells depending on the piece’s value. Two players, designated as \"light\" and \"dark,\" take turns alternately, with \"light\" moving first as indicated by the initial control state. The game begins in a setup phase during which each player places their pieces of various values onto specific valid initial locations on the board; these placements are legal only if the chosen cell is empty, is a valid starting location for that player, and the piece has not already been placed on the board. After the setup phase, the game transitions to the main phase where players move their pieces. Moves consist of selecting a piece of a given value belonging to the player and moving it to a new cell that is either empty or occupied by an opponent’s piece, following movement rules that depend on the piece’s value: a piece may move to an adjacent cell (distance one), or jump over one, two, or three empty intermediate cells, provided all landing and intermediate cells satisfy the emptiness and adjacency constraints. Captures occur when a piece moves onto a cell occupied by an opponent’s piece, causing that opponent’s piece to disappear from the board. Additionally, pieces may disappear if an opponent moves onto a cell previously occupied by the piece or vice versa. The game automatically tracks the first and last captures made by each player along with the values of the pieces involved, which factor into victory conditions. Players may also perform a noop action, but only when it is not their turn, effectively passing without moving. The game advances stepwise, incrementing a step counter each turn, with the control passing alternately between the two players. The game terminates when a player achieves victory by leaving the opponent with no legal moves, or by fulfilling specific victory conditions involving the values of the first and last captured pieces as defined by winning pairs, or when the step count reaches 100, resulting in a draw. Scoring awards 100 points to the victorious player, zero to the loser, and 50 points to each player if the game ends without a winner. Throughout play, implicit constraints enforce that pieces remain on the board cells, moves respect the adjacency and emptiness conditions, and no two pieces occupy the same cell simultaneously. The intricate set of bordering relationships and the variable movement distances defined by piece values create a complex strategic environment where players must carefully place and maneuver their pieces to capture opponents, avoid entrapment, and achieve the victory conditions.",
    "output": "(role light)\n(role dark)\n(opponent light dark)\n(opponent dark light)\n(bordering a a1)\n(bordering a a2)\n(bordering a a3)\n(bordering b b1)\n(bordering b b2)\n(bordering b b3)\n(bordering c c1)\n(bordering c c2)\n(bordering c c3)\n(bordering d d1)\n(bordering d d2)\n(bordering d d3)\n(bordering e e1)\n(bordering e e2)\n(bordering e e3)\n(bordering f f1)\n(bordering f f2)\n(bordering f f3)\n(bordering g g1)\n(bordering g g2)\n(bordering g g3)\n(bordering h h1)\n(bordering h h2)\n(bordering h h3)\n(bordering a1 a2)\n(bordering a1 a3)\n(bordering a2 a3)\n(bordering b1 b2)\n(bordering b1 b3)\n(bordering b2 b3)\n(bordering c1 c2)\n(bordering c1 c3)\n(bordering c2 c3)\n(bordering d1 d2)\n(bordering d1 d3)\n(bordering d2 d3)\n(bordering e1 e2)\n(bordering e1 e3)\n(bordering e2 e3)\n(bordering f1 f2)\n(bordering f1 f3)\n(bordering f2 f3)\n(bordering g1 g2)\n(bordering g1 g3)\n(bordering g2 g3)\n(bordering h1 h2)\n(bordering h1 h3)\n(bordering h2 h3)\n(bordering a2 c3)\n(bordering c3 b1)\n(bordering a3 c2)\n(bordering c2 d1)\n(bordering b2 e3)\n(bordering d3 g2)\n(bordering e1 f2)\n(bordering f2 h3)\n(bordering g1 f3)\n(bordering f3 h2)\n(bordering b3 c1)\n(bordering c1 d2)\n(bordering d2 g3)\n(bordering g3 f1)\n(bordering f1 e2)\n(bordering e2 b3)\n(<= (neighbors ?a ?b)\n    (bordering ?a ?b))\n(<= (neighbors ?a ?b)\n    (bordering ?b ?a))\n(<= (cellFilled ?x)\n    (role ?p)\n    (value ?v)\n    (true (piece ?p ?v ?x)))\n(<= (empty ?x)\n    (cell ?x)\n    (not (cellFilled ?x)))\n(init (control light))\n(<= (next (control light))\n    (true (control dark)))\n(<= (next (control dark))\n    (true (control light)))\n(<= (legal ?p noop)\n    (role ?p)\n    (not (true (control ?p))))\n(init (step 0))\n(<= (next (step ?xn))\n    (succ ?x ?xn)\n    (true (step ?x)))\n(validInitialLocation light a)\n(validInitialLocation light a1)\n(validInitialLocation light a2)\n(validInitialLocation light a3)\n(validInitialLocation light c)\n(validInitialLocation dark h)\n(validInitialLocation dark h1)\n(validInitialLocation dark h2)\n(validInitialLocation dark h3)\n(validInitialLocation dark f)\n(<= (onBoard ?p ?v)\n\t(cell ?x)\n    (true (piece ?p ?v ?x)))\n(<= (legal ?p (place ?v ?x))\n\t(cell ?x)\n\t(validInitialLocation ?p ?x)\n    (empty ?x)\n    (value ?v)\n    (not (onBoard ?p ?v))\n    (true (control ?p))\n    (true (phase setup)))\n(<= (next (piece ?p ?v ?x))\n    (does ?p (place ?v ?x)))\n(init (phase setup))\n(<= (next (phase setup))\n    (or (true (step 0))\n        (true (step 1))\n        (true (step 2))\n        (true (step 3))\n        (true (step 4))\n        (true (step 5))\n        (true (step 6))\n        (true (step 7))\n        (true (step 8))))\n(<= (legal ?p (move ?v ?xn))\n    (true (piece ?p ?v ?x))\n    (not (true (phase setup)))\n    (value ?v)\n    (cell ?xn)\n    (true (control ?p))\n    (canMoveTo ?p ?xn)\n    (canGoBetween ?v ?x ?xn))\n(<= (canMoveTo ?p ?xn)\n    (role ?p)\n    (empty ?xn))\n(<= (canMoveTo ?p ?xn)\n    (opponent ?p ?op)\n    (value ?v)\n    (true (piece ?op ?v ?xn)))\n(<= (canGoBetween 1 ?x ?xn)\n    (neighbors ?x ?xn))\n(<= (canGoBetween 2 ?x ?xn)\n    (cell ?a)\n    (empty ?a)\n    (neighbors ?x ?a)\n    (neighbors ?a ?xn)\n    (distinct ?x ?xn))\n(<= (canGoBetween 3 ?x ?xn)\n    (cell ?a)\n    (empty ?a)\n    (neighbors ?x ?a)\n    (distinct ?x ?b)\n    (cell ?b)\n    (empty ?b)\n    (neighbors ?a ?b)\n    (neighbors ?b ?xn)\n    (distinct ?x ?xn)\n    (distinct ?a ?xn))\n(<= (canGoBetween 123 ?x ?xn)\n    (or (canGoBetween 1 ?x ?xn)\n        (canGoBetween 2 ?x ?xn)\n        (canGoBetween 3 ?x ?xn)))\n(<= (canGoBetween 4 ?x ?xn)\n    (cell ?a)\n    (empty ?a)\n    (neighbors ?x ?a)\n    (neighbors ?a ?b)\n    (distinct ?x ?b)\n    (cell ?b)\n    (empty ?b)\n    (neighbors ?b ?c)\n    (distinct ?x ?c)\n    (distinct ?a ?c)\n    (cell ?c)\n    (empty ?c)\n    (neighbors ?c ?xn)\n    (distinct ?x ?xn)\n    (distinct ?a ?xn)\n    (distinct ?b ?xn))\n(<= (shouldDisappear ?p ?v ?x)\n    (role ?p)\n    (value ?v)\n    (cell ?x)\n    (opponent ?p ?p2)\n    (value ?v2)\n    (cell ?x2)\n    (or (does ?p2 (move ?v2 ?x))\n        (does ?p (move ?v ?x2))))\n(<= (next (piece ?p ?v ?x))\n    (true (piece ?p ?v ?x))\n    (opponent ?p ?p2)\n    (value ?v2)\n    (cell ?x2)\n    (not (shouldDisappear ?p ?v ?x)))\n(<= (next (piece ?p ?v ?x))\n    (does ?p (move ?v ?x)))\n(<= (hasFirstCapture ?p)\n    (value ?v)\n    (true (firstCapture ?p ?v)))\n(<= (next (firstCapture ?p ?v))\n    (role ?p)\n    (not (hasFirstCapture ?p))\n    (cell ?x)\n    (opponent ?p ?p2)\n    (does ?p (move ?v2 ?x))\n    (true (piece ?p2 ?v ?x)))\n(<= (next (firstCapture ?p ?v))\n    (true (firstCapture ?p ?v)))\n(<= (next (lastCapture ?p ?v))\n    (cell ?x)\n    (value ?v2)\n    (opponent ?p ?p2)\n    (does ?p (move ?v2 ?x))\n    (true (piece ?p2 ?v ?x)))\n(<= (justCaptured ?p)\n    (cell ?x)\n    (value ?v2)\n    (opponent ?p ?p2)\n    (does ?p (move ?v2 ?x))\n    (true (piece ?p2 ?v ?x)))\n(<= (next (lastCapture ?p ?v))\n    (true (lastCapture ?p ?v))\n    (not (justCaptured ?p)))\n(<= (hasLegalMove ?player)\n    (legal ?player (move ?v ?x)))\n(<= (hasLegalMove ?player)\n    (legal ?player (place ?v ?x)))\n(<= (hasLegalMove ?player)\n    (legal ?player noop))\n(<= (victory ?p)\n    (role ?p)\n    (opponent ?p ?q)\n    (not (hasLegalMove ?q)))\n(<= (victory ?p)\n    (role ?p)\n    (value ?v1)\n    (value ?v2)\n    (true (firstCapture ?p ?v1))\n    (true (lastCapture ?p ?v2))\n    (victoryCondition ?v1 ?v2))\n(<= (victoryCondition ?a ?b)\n    (victoryPair ?a ?b))\n(<= (victoryCondition ?a ?b)\n    (victoryPair ?b ?a))\n(victoryPair 1 3)\n(victoryPair 4 4)\n(victoryPair 1 123)\n(victoryPair 2 123)\n(victoryPair 3 123)\n(<= terminal\n    (role ?p)\n    (victory ?p))\n(<= (goal ?p 0)\n    (role ?p)\n    (opponent ?p ?p2)\n    (victory ?p2))\n(<= (goal ?p 100)\n    (role ?p)\n    (victory ?p))\n(<= terminal\n    (true (step 100)))\n(<= (goal ?p 50)\n    (role ?p)\n    (opponent ?p ?p2)\n    (not (victory ?p))\n    (not (victory ?p2)))\n(value 1) (value 2) (value 3) (value 123) (value 4)\n(cell a) (cell a1) (cell a2) (cell a3)\n(cell b) (cell b1) (cell b2) (cell b3)\n(cell c) (cell c1) (cell c2) (cell c3)\n(cell d) (cell d1) (cell d2) (cell d3)\n(cell e) (cell e1) (cell e2) (cell e3)\n(cell f) (cell f1) (cell f2) (cell f3)\n(cell g) (cell g1) (cell g2) (cell g3)\n(cell h) (cell h1) (cell h2) (cell h3)\n(succ  1  2) (succ  2  3) (succ  3  4) (succ  4  5) (succ  5  6)\n(succ  6  7) (succ  7  8) (succ  8  9) (succ  9 10) (succ 10 11)\n(succ 11 12) (succ 12 13) (succ 13 14) (succ 14 15) (succ 15 16)\n(succ 16 17) (succ 17 18) (succ 18 19) (succ 19 20) (succ 20 21)\n(succ 21 22) (succ 22 23) (succ 23 24) (succ 24 25) (succ 25 26)\n(succ 26 27) (succ 27 28) (succ 28 29) (succ 29 30) (succ 30 31)\n(succ 31 32) (succ 32 33) (succ 33 34) (succ 34 35) (succ 35 36)\n(succ 36 37) (succ 37 38) (succ 38 39) (succ 39 40) (succ 40 41)\n(succ 41 42) (succ 42 43) (succ 43 44) (succ 44 45) (succ 45 46)\n(succ 46 47) (succ 47 48) (succ 48 49) (succ 49 50) (succ 50 51)\n(succ 51 52) (succ 52 53) (succ 53 54) (succ 54 55) (succ 55 56)\n(succ 56 57) (succ 57 58) (succ 58 59) (succ 59 60) (succ 60 61)\n(succ 61 62) (succ 62 63) (succ 63 64) (succ 64 65) (succ 65 66)\n(succ 66 67) (succ 67 68) (succ 68 69) (succ 69 70) (succ 70 71)\n(succ 71 72) (succ 72 73) (succ 73 74) (succ 74 75) (succ 75 76)\n(succ 76 77) (succ 77 78) (succ 78 79) (succ 79 80) (succ 80 81)\n(succ 81 82) (succ 82 83) (succ 83 84) (succ 84 85) (succ 85 86)\n(succ 86 87) (succ 87 88) (succ 88 89) (succ 89 90) (succ 90 91)\n(succ 91 92) (succ 92 93) (succ 93 94) (succ 94 95) (succ 95 96)\n(succ 96 97) (succ 97 98) (succ 98 99) (succ 99 100) (succ 0 1)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on an 8-by-8 grid where each cell is identified by coordinates ranging from 1 to 8 along both the x (horizontal) and y (vertical) axes, with the origin presumed at the lower-left corner. The grid contains walls positioned along the edges between cells, blocking movement in specified directions, effectively creating barriers that players cannot cross. There are two player roles: the explorer and the mummy, who alternate turns starting with the explorer. At the start, the explorer is located at coordinate (8,1), the mummy at (1,1), and the exit is fixed at (8,8). The game state also tracks the current turn step, beginning at zero. On the explorer's turn, the player may choose to move one step in any of the four cardinal directions—north, south, east, or west—or opt to take no action (\"move1 nowhere\"). Movement is only legal if it does not cross a wall or leave the board; if a wall blocks the way or the move would exit the board limits, the explorer remains in place. On the mummy's turn, the player may move two steps sequentially, each in any cardinal direction, or choose to take no action (\"move2 nowhere nowhere\"). The mummy’s movement is similarly constrained by walls and board boundaries; if either step is blocked, the mummy does not move during that step. Turns alternate control between explorer and mummy, and the game state updates positions accordingly after each move. A key rule is that if at any time the explorer and the mummy occupy the same cell, the explorer is considered \"eaten,\" ending the game. Similarly, if the explorer reaches the exit cell, the game also ends. The game has a maximum of 50 steps; reaching this limit without either the explorer being eaten or reaching the exit also terminates the game. Victory conditions depend on these terminal scenarios: if the explorer reaches the exit without being eaten, the explorer wins with a maximum score of 100 and the mummy scores zero; if the explorer is eaten, the mummy wins with 100 points and the explorer zero; if the game ends after 50 steps with neither event occurring, both players receive partial scores of 50. Movement legality and game progression are rigorously enforced by the constraints on walls and board boundaries, ensuring that players cannot move off the grid or through walls, and the game state advances stepwise with clear turn control and termination rules.",
    "output": "(index 0)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(direction north)\n(direction south)\n(direction east)\n(direction west)\n(direction nowhere)\n(role explorer)\n(role mummy)\n(init (control explorer))\n(init (location mummy 1 1))\n(init (location explorer 8 1))\n(init (location exit 8 8))\n(init (step 0))\n(init (cell 1 1))\n(init (cell 1 2))\n(init (cell 1 3))\n(init (cell 1 4))\n(init (cell 1 5))\n(init (cell 1 6))\n(init (cell 1 7))\n(init (cell 1 8))\n(init (cell 2 1))\n(init (cell 2 2))\n(init (cell 2 3))\n(init (cell 2 4))\n(init (cell 2 5))\n(init (cell 2 6))\n(init (cell 2 7))\n(init (cell 2 8))\n(init (cell 3 1))\n(init (cell 3 2))\n(init (cell 3 3))\n(init (cell 3 4))\n(init (cell 3 5))\n(init (cell 3 6))\n(init (cell 3 7))\n(init (cell 3 8))\n(init (cell 4 1))\n(init (cell 4 2))\n(init (cell 4 3))\n(init (cell 4 4))\n(init (cell 4 5))\n(init (cell 4 6))\n(init (cell 4 7))\n(init (cell 4 8))\n(init (cell 5 1))\n(init (cell 5 2))\n(init (cell 5 3))\n(init (cell 5 4))\n(init (cell 5 5))\n(init (cell 5 6))\n(init (cell 5 7))\n(init (cell 5 8))\n(init (cell 6 1))\n(init (cell 6 2))\n(init (cell 6 3))\n(init (cell 6 4))\n(init (cell 6 5))\n(init (cell 6 6))\n(init (cell 6 7))\n(init (cell 6 8))\n(init (cell 7 1))\n(init (cell 7 2))\n(init (cell 7 3))\n(init (cell 7 4))\n(init (cell 7 5))\n(init (cell 7 6))\n(init (cell 7 7))\n(init (cell 7 8))\n(init (cell 8 1))\n(init (cell 8 2))\n(init (cell 8 3))\n(init (cell 8 4))\n(init (cell 8 5))\n(init (cell 8 6))\n(init (cell 8 7))\n(init (cell 8 8))\n(init (wall 4 1 east))\n(init (wall 4 1 north))\n(init (wall 1 2 north))\n(init (wall 2 2 north))\n(init (wall 1 3 east))\n(init (wall 3 3 east))\n(init (wall 2 4 east))\n(init (wall 3 4 east))\n(init (wall 3 5 east))\n(init (wall 3 5 north))\n(init (wall 2 5 north))\n(init (wall 2 6 east))\n(init (wall 3 6 north))\n(init (wall 2 8 east))\n(init (wall 4 6 north))\n(init (wall 4 7 east))\n(init (wall 5 7 east))\n(init (wall 4 4 east))\n(init (wall 5 4 east))\n(init (wall 8 7 north))\n(init (wall 6 1 north))\n(init (wall 6 2 north))\n(init (wall 6 2 east))\n(init (wall 6 3 east))\n(init (wall 6 4 east))\n(init (wall 6 6 north))\n(init (wall 7 4 north))\n(init (wall 7 3 east))\n(init (wall 1 0 north))\n(init (wall 2 0 north))\n(init (wall 3 0 north))\n(init (wall 4 0 north))\n(init (wall 5 0 north))\n(init (wall 6 0 north))\n(init (wall 7 0 north))\n(init (wall 8 0 north))\n(init (wall 1 8 north))\n(init (wall 2 8 north))\n(init (wall 3 8 north))\n(init (wall 4 8 north))\n(init (wall 5 8 north))\n(init (wall 6 8 north))\n(init (wall 7 8 north))\n(init (wall 8 8 north))\n(init (wall 0 1 east))\n(init (wall 0 2 east))\n(init (wall 0 3 east))\n(init (wall 0 4 east))\n(init (wall 0 5 east))\n(init (wall 0 6 east))\n(init (wall 0 7 east))\n(init (wall 0 8 east))\n(init (wall 8 1 east))\n(init (wall 8 2 east))\n(init (wall 8 3 east))\n(init (wall 8 4 east))\n(init (wall 8 5 east))\n(init (wall 8 6 east))\n(init (wall 8 7 east))\n(init (wall 8 8 east))\n(<= (legal explorer (move1 ?dir))\n(direction ?dir)\n(true (control explorer)))\n(<= (legal explorer (move1 nowhere))\n(true (control mummy)))\n(<= (legal mummy (move2 ?dir1 ?dir2))\n(direction ?dir1)\n(direction ?dir2)\n(true (control mummy)))\n(<= (legal mummy (move2 nowhere nowhere))\n(true (control explorer)))\n(<= (next (location explorer ?x2 ?y2))\n(true (location explorer ?x1 ?y1))\n(does explorer (move1 ?dir))\n(newlocation1 ?x1 ?y1 ?dir ?x2 ?y2))\n(<= (next (location mummy ?x2 ?y2))\n(true (location mummy ?x1 ?y1))\n(does mummy (move2 ?dir1 ?dir2))\n(newlocation2 ?x1 ?y1 ?dir1 ?dir2 ?x2 ?y2))\n(<= (next (location exit ?x ?y))\n(true (location exit ?x ?y)))\n(<= (next (cell ?x ?y))\n(true (cell ?x ?y)))\n(<= (next (wall ?x ?y ?z))\n(true (wall ?x ?y ?z)))\n(<= (next (step ?x))\n(true (step ?y))\n(succ ?y ?x))\n(<= (next (control explorer))\n(true (control mummy)))\n(<= (next (control mummy))\n(true (control explorer)))\n(<= eaten\n(true (location explorer ?x ?y))\n(true (location mummy ?x ?y)))\n(<= atexit\n(true (location explorer ?x ?y))\n(true (location exit ?x ?y)))\n(<= laststep\n(true (step 50)))\n(<= (newlocation1 ?x ?y nowhere ?x ?y)\n(index ?x)\n(index ?y))\n(<= (newlocation1 ?x ?y north ?x ?y)\n(true (wall ?x ?y north)))\n(<= (newlocation1 ?x ?y south ?x ?y)\n(succ ?down ?y)\n(true (wall ?x ?down north)))\n(<= (newlocation1 ?x ?y east ?x ?y)\n(true (wall ?x ?y east)))\n(<= (newlocation1 ?x ?y west ?x ?y)\n(succ ?left ?x)\n(true (wall ?left ?y east)))\n(<= (newlocation1 ?x ?y1 north ?x ?y2)\n(succ ?y1 ?y2)\n(index ?x)\n(not (true (wall ?x ?y1 north))))\n(<= (newlocation1 ?x ?y1 south ?x ?y2)\n(succ ?y2 ?y1)\n(index ?x)\n(not (true (wall ?x ?y2 north))))\n(<= (newlocation1 ?x1 ?y east ?x2 ?y)\n(succ ?x1 ?x2)\n(index ?y)\n(not (true (wall ?x1 ?y east))))\n(<= (newlocation1 ?x1 ?y west ?x2 ?y)\n(succ ?x2 ?x1)\n(index ?y)\n(not (true (wall ?x2 ?y east))))\n(<= (newlocation2 ?x1 ?y1 ?dir1 ?dir2 ?x3 ?y3)\n(newlocation1 ?x1 ?y1 ?dir1 ?x2 ?y2)\n(newlocation1 ?x2 ?y2 ?dir2 ?x3 ?y3))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(<= terminal laststep)\n(<= terminal eaten)\n(<= terminal atexit)\n(<= (goal explorer 100)\natexit\n(not eaten))\n(<= (goal explorer 50)\n(not atexit)\n(not eaten))\n(<= (goal explorer 0)\neaten)\n(<= (goal mummy 0)\natexit\n(not eaten))\n(<= (goal mummy 50)\n(not atexit)\n(not eaten))\n(<= (goal mummy 100)\neaten)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played between two players named white and black, who alternate turns in a fixed order beginning with white, then black, and so forth. The game proceeds in rounds, starting at round zero, and continues until a maximum of ten rounds is reached, at which point the game ends. The environment is abstract and does not specify a spatial coordinate system; instead, it uses an index ranging from 0 to 10 to represent discrete offer values that white can propose. At the start, both players have a score of zero, and white has control to make the first move. On white's turn, the only legal action is to offer a number between 0 and 10 inclusive, corresponding to the index, which represents a proposed division of a total value of 10. On black's subsequent turn, black must either accept or reject the offer made by white. If black accepts, the scores of both players are updated: white's score increases by the amount offered to white, and black's score increases by the complementary amount that sums with white's offer to 10. If black rejects, neither player's score changes. If it is not a player's turn to act, that player may perform a no-operation action (noop), which effectively passes control back to the other player without changing the game state. The control alternates between white and black after each action, ensuring turn-taking. The round number increments only after black completes their turn, signifying the completion of one full cycle of offers and responses. The game terminates automatically when the round count reaches the maximum of ten. The victory conditions are based on the final accumulated scores of the players: white's goal value equals white's total score, and black's goal value equals black's total score. Implicit constraints include that offers must be valid indices within the range 0 to 10, and that the sum of white's offer and black's corresponding share must always equal 10. There are no spatial or occupancy constraints beyond these numerical bounds. Overall, the game models a sequential bargaining scenario where white proposes a split of a fixed quantity, and black decides whether to accept or reject, influencing the final scores over a limited number of rounds.",
    "output": "(role white)\n(role black)\n(maxRounds 10)\n(init (whiteScore 0))\n(init (blackScore 0))\n(init (round 0))\n(init (control white))\n(<= (legal white (offer ?x1))\n    (index ?x1)\n    (true (control white)))\n(<= (legal black accept)\n    (true (control black)))\n(<= (legal black reject)\n    (true (control black)))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black noop)\n    (true (control white)))\n(<= (next (round ?x1))\n    (true (round ?x))\n    (true (control black))\n    (sum ?x 1 ?x1))\n(<= (next (round ?x))\n    (true (round ?x))\n    (true (control white)))\n(<= (next (offered ?x1 ?x2))\n    (sum ?x1 ?x2 10)\n    (does white (offer ?x2)))\n(<= (next (whiteScore ?xNext))\n    (true (whiteScore ?x))\n    (does black accept)\n    (true (offered ?score ?dontcare))\n    (sum ?x ?score ?xNext))\n(<= (next (blackScore ?xNext))\n    (true (blackScore ?x))\n    (does black accept)\n    (true (offered ?dontcare ?score))\n    (sum ?x ?score ?xNext))\n(<= (next (whiteScore ?x))\n    (true (whiteScore ?x))\n    (does black reject))\n(<= (next (blackScore ?x))\n    (true (blackScore ?x))\n    (does black reject))\n(<= (next (whiteScore ?x))\n    (true (whiteScore ?x))\n    (true (control white)))\n(<= (next (blackScore ?x))\n    (true (blackScore ?x))\n    (true (control white)))\n(<= (next (control black))\n    (true (control white)))\n(<= (next (control white))\n    (true (control black)))\n(<= terminal\n    (true (round ?x))\n    (maxRounds ?x))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(<= (sum ?x 0 ?x)\n    (succ ?x ?dontcare))\n(<= (sum ?xn 1 ?x)\n    (succ ?xn ?x))\n(<= (sum ?xn ?y ?x)\n    (index ?y)\n    (succ ?yless ?y)\n    (succ ?ylessless ?yless)\n    (succ ?x1 ?x)\n    (sum ?xn ?yless ?x1))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)\n(index 0)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 grid with columns labeled from 'a' through 'h' and rows numbered 1 through 8, where coordinates combine a file (column) and a rank (row). Two players, white and black, take alternating turns beginning with white. The initial setup places white pawns on the second rank across files a to h, a white king at d1, black pawns on the seventh rank across files a to h, and a black king at d8; the game starts at step 1 with control assigned to white. On a player's turn, they may perform a move action or, if no legal moves are available or the player has no remaining pieces, they may choose a noop action. A move is specified by indicating the starting cell coordinates (file and rank) and the target cell coordinates (file and rank). Moves are legal if, for white pawns, they move one rank forward (from rank y to y+1) either straight forward into an unoccupied cell or diagonally one file adjacent when capturing, without moving onto a cell occupied by another white piece; black pawns move similarly but one rank backward (from rank y to y−1), with the same occupancy restrictions. The kings for both colors may move one cell in any direction except directly backward (white kings cannot move to the previous rank, black kings cannot move to the next rank), provided the target cell is not occupied by a friendly piece. The coordinates must remain within the board boundaries, and moves must respect adjacency rules for files and ranks. After a move, the piece vacates its original cell and occupies the new one; any opponent piece on the destination cell is captured and removed from play, including capturing the opponent’s king, which is tracked as a captured state. The step count increments by one each turn. The game terminates if either king is captured, if a king reaches the opponent’s back rank (white king on rank 8 or black king on rank 1) while the opposing king is still on the board, or when the step count reaches 61. Victory is assigned to white if the white king reaches rank 8 without being captured or if the black king is captured; black wins similarly if the black king reaches rank 1 or the white king is captured. If none of these conditions are met by the end of the game, both players receive a draw score. The scoring awards 100 points to the winner, 0 to the loser, and 50 points to each player in case of a draw. The game enforces that no moves can place a piece on a square occupied by a friendly piece, and no piece may move outside the board. Turn control alternates strictly between the two players, and the noop action serves as a pass only when no other legal moves exist or the player has no pieces left.",
    "output": "(role white)\n(role black)\n(init (cell a 2 wp))\n(init (cell b 2 wp))\n(init (cell c 2 wp))\n(init (cell d 2 wp))\n(init (cell e 2 wp))\n(init (cell f 2 wp))\n(init (cell g 2 wp))\n(init (cell h 2 wp))\n(init (cell d 1 wk))\n(init (cell a 7 bp))\n(init (cell b 7 bp))\n(init (cell c 7 bp))\n(init (cell d 7 bp))\n(init (cell e 7 bp))\n(init (cell f 7 bp))\n(init (cell g 7 bp))\n(init (cell h 7 bp))\n(init (cell d 8 bk))\n(init (control white))\n(init (step 1))\n(<= (next (control white))\n\t(true (control black)))\n(<= (next (control black))\n\t(true (control white)))\n(<= (legal white noop)\n\t(true (control black)))\n(<= (legal black noop)\n\t(true (control white)))\n(<= (legal white noop)\n\t(not (hasAnyPiece white)))\n(<= (legal black noop)\n\t(not (hasAnyPiece black)))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasAnyLegalMove ?player)))\n(<= (hasAnyLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (legal ?player ?move)\n    (legal2 ?player ?move))\n(<= (legal2 white (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control white))\n\t(true (cell ?x1 ?y1 wp))\n\t(adjFile ?x1 ?x2)\n\t(nextRank ?y1 ?y2)\n\t(not (occupies ?x2 ?y2 white)))\n(<= (legal2 black (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control black))\n\t(true (cell ?x1 ?y1 bp))\n\t(adjFile ?x1 ?x2)\n\t(nextRank ?y2 ?y1)\n\t(not (occupies ?x2 ?y2 black)))\n(<= (legal2 white (move ?x ?y1 ?x ?y2))\n\t(true (control white))\n\t(true (cell ?x ?y1 wp))\n\t(file ?x)\n\t(nextRank ?y1 ?y2)\n\t(not (occupies ?x ?y2 white))\n\t(not (occupies ?x ?y2 black)))\n(<= (legal2 black (move ?x ?y1 ?x ?y2))\n\t(true (control black))\n\t(true (cell ?x ?y1 bp))\n\t(file ?x)\n\t(nextRank ?y2 ?y1)\n\t(not (occupies ?x ?y2 white))\n\t(not (occupies ?x ?y2 black)))\n(<= (legal2 white (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control white))\n\t(true (cell ?x1 ?y1 wk))\n\t(kingMove ?x1 ?y1 ?x2 ?y2)\n\t(not (nextRank ?y2 ?y1))\n\t(not (occupies ?x2 ?y2 white)))\n(<= (legal2 black (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control black))\n\t(true (cell ?x1 ?y1 bk))\n\t(kingMove ?x1 ?y1 ?x2 ?y2)\n\t(not (nextRank ?y1 ?y2))\n\t(not (occupies ?x2 ?y2 black)))\n(<= (occupies ?x ?y white)\n\t(or (true (cell ?x ?y wp))\n\t\t(true (cell ?x ?y wk))))\n(<= (occupies ?x ?y black)\n\t(or (true (cell ?x ?y bp))\n\t\t(true (cell ?x ?y bk))))\n(<= (hasAnyPiece ?player)\n\t(occupies ?x ?y ?player))\n(<= (next (step ?np1))\n\t(true (step ?n))\n\t(succ ?n ?np1))\n(<= (next (cell ?x ?y ?piece))\n\t(true (cell ?x ?y ?piece))\n\t(not (affected ?x ?y)))\n(<= (next (cell ?x2 ?y2 ?piece))\n\t(true (cell ?x1 ?y1 ?piece))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next whiteKingCaptured)\n\t(true (cell ?x2 ?y2 wk))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next blackKingCaptured)\n\t(true (cell ?x2 ?y2 bk))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next whiteKingCaptured)\n\t(true whiteKingCaptured))\n(<= (next blackKingCaptured)\n\t(true blackKingCaptured))\n(<= (affected ?x1 ?y1)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (affected ?x2 ?y2)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= whiteWins\n\t(not (true whiteKingCaptured))\n\t(true (cell ?x 8 wk)))\n(<= blackWins\n\t(not (true blackKingCaptured))\n\t(true (cell ?x 1 bk)))\n(<= terminal\n\twhiteWins)\n(<= terminal\n\tblackWins)\n(<= terminal\n\t(true (step 61)))\n(<= terminal\n\t(true whiteKingCaptured)\n\t(true blackKingCaptured))\n(<= (goal white 100)\n\twhiteWins)\n(<= (goal white 50)\n\t(not whiteWins)\n\t(not blackWins))\n(<= (goal white 0)\n\tblackWins)\n(<= (goal black 100)\n\tblackWins)\n(<= (goal black 50)\n\t(not whiteWins)\n\t(not blackWins))\n(<= (goal black 0)\n\twhiteWins)\n(nextRank 1 2)\n(nextRank 2 3)\n(nextRank 3 4)\n(nextRank 4 5)\n(nextRank 5 6)\n(nextRank 6 7)\n(nextRank 7 8)\n(<= (rank ?a)\n    (nextRank ?a ?b))\n(<= (rank ?b)\n    (nextRank ?a ?b))\n(nextFile a b)\n(nextFile b c)\n(nextFile c d)\n(nextFile d e)\n(nextFile e f)\n(nextFile f g)\n(nextFile g h)\n(<= (file ?a)\n    (nextFile ?a ?b))\n(<= (file ?b)\n    (nextFile ?a ?b))\n(<= (adjFile ?x0 ?x1)\n\t(nextFile ?x0 ?x1))\n(<= (adjFile ?x0 ?x1)\n\t(nextFile ?x1 ?x0))\n(<= (adjRank ?y0 ?y1)\n\t(nextRank ?y0 ?y1))\n(<= (adjRank ?y0 ?y1)\n\t(nextRank ?y1 ?y0))\n(<= (kingMove ?x ?y1 ?x ?y2)\n\t(file ?x)\n\t(adjRank ?y1 ?y2))\n(<= (kingMove ?x1 ?y ?x2 ?y)\n\t(adjFile ?x1 ?x2)\n\t(rank ?y))\n(<= (kingMove ?x1 ?y1 ?x2 ?y2)\n\t(adjFile ?x1 ?x2)\n\t(adjRank ?y1 ?y2))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a three-dimensional Sudoku-like grid composed of three layers, each containing a 3x3 arrangement of smaller 3x3 cells, resulting in a total of 27 cells per layer and 81 cells overall. The coordinate system identifies each cell by four indices: the first two specify the layer and the 3x3 block within that layer, while the last two denote the row and column within the block. There is a single player role named \"robot,\" who takes turns sequentially, though since there is only one role, the robot acts every turn. The initial state sets up a partially filled Sudoku grid with some cells containing digits from one to nine and others marked as blank, represented by the symbol \"b.\" On each turn, the robot may perform one action, which consists of placing a digit from one to nine into a blank cell. The action format explicitly specifies the cell's four indices and the digit to be placed. An action is legal only if the targeted cell is currently blank and if the digit does not violate Sudoku constraints: the digit must not already appear in the same row, column, or 3x3 square of the overall grid. Rows are defined across all blocks in the same row position, columns are defined across all blocks in the same column position, and squares correspond to the 3x3 blocks within each layer. When the robot performs a marking action, the state updates by assigning the chosen digit to the selected cell, replacing the blank. All other cells remain unchanged unless directly affected by this action. The game implicitly enforces board boundaries, limiting indices to 1 through 3 for layers, blocks, rows, and columns, and disallows placing digits in occupied cells or digits that conflict with existing ones in their row, column, or block. The game terminates when no further legal moves remain, that is, when there are no blank cells or no digits can be legally placed in any blank cell. Upon termination, if the grid is completely and correctly filled with no blanks remaining, the robot achieves a victory and receives a goal value of 100; otherwise, the goal is 0. If no moves are possible but blanks remain, the game is also considered terminal with a goal of 0. The robot may also effectively pass a turn by taking no action if no legal moves exist, as no explicit noop is specified but the absence of legal moves leads to termination. This game models the classic Sudoku puzzle in a layered format where the robot must fill all blank cells following standard Sudoku rules to win.",
    "output": "(role robot)\n  (init (cell 1 1 1 1 b))\n  (init (cell 1 1 1 2 b))\n  (init (cell 1 1 1 3 2))\n  (init (cell 1 1 2 1 b))\n  (init (cell 1 1 2 2 9))\n  (init (cell 1 1 2 3 b))\n  (init (cell 1 1 3 1 3))\n  (init (cell 1 1 3 2 b))\n  (init (cell 1 1 3 3 b))\n  (init (cell 1 2 1 1 8))\n  (init (cell 1 2 1 2 b))\n  (init (cell 1 2 1 3 5))\n  (init (cell 1 2 2 1 b))\n  (init (cell 1 2 2 2 b))\n  (init (cell 1 2 2 3 b))\n  (init (cell 1 2 3 1 b))\n  (init (cell 1 2 3 2 b))\n  (init (cell 1 2 3 3 b))\n  (init (cell 1 3 1 1 1))\n  (init (cell 1 3 1 2 b))\n  (init (cell 1 3 1 3 b))\n  (init (cell 1 3 2 1 b))\n  (init (cell 1 3 2 2 b))\n  (init (cell 1 3 2 3 b))\n  (init (cell 1 3 3 1 b))\n  (init (cell 1 3 3 2 b))\n  (init (cell 1 3 3 3 b))\n  (init (cell 2 1 1 1 b))\n  (init (cell 2 1 1 2 9))\n  (init (cell 2 1 1 3 b))\n  (init (cell 2 1 2 1 b))\n  (init (cell 2 1 2 2 6))\n  (init (cell 2 1 2 3 b))\n  (init (cell 2 1 3 1 b))\n  (init (cell 2 1 3 2 4))\n  (init (cell 2 1 3 3 b))\n  (init (cell 2 2 1 1 b))\n  (init (cell 2 2 1 2 b))\n  (init (cell 2 2 1 3 b))\n  (init (cell 2 2 2 1 b))\n  (init (cell 2 2 2 2 b))\n  (init (cell 2 2 2 3 b))\n  (init (cell 2 2 3 1 b))\n  (init (cell 2 2 3 2 5))\n  (init (cell 2 2 3 3 8))\n  (init (cell 2 3 1 1 b))\n  (init (cell 2 3 1 2 b))\n  (init (cell 2 3 1 3 b))\n  (init (cell 2 3 2 1 b))\n  (init (cell 2 3 2 2 b))\n  (init (cell 2 3 2 3 b))\n  (init (cell 2 3 3 1 b))\n  (init (cell 2 3 3 2 b))\n  (init (cell 2 3 3 3 1))\n  (init (cell 3 1 1 1 b))\n  (init (cell 3 1 1 2 8))\n  (init (cell 3 1 1 3 b))\n  (init (cell 3 1 2 1 b))\n  (init (cell 3 1 2 2 b))\n  (init (cell 3 1 2 3 b))\n  (init (cell 3 1 3 1 2))\n  (init (cell 3 1 3 2 b))\n  (init (cell 3 1 3 3 b))\n  (init (cell 3 2 1 1 3))\n  (init (cell 3 2 1 2 b))\n  (init (cell 3 2 1 3 b))\n  (init (cell 3 2 2 1 5))\n  (init (cell 3 2 2 2 b))\n  (init (cell 3 2 2 3 b))\n  (init (cell 3 2 3 1 b))\n  (init (cell 3 2 3 2 b))\n  (init (cell 3 2 3 3 b))\n  (init (cell 3 3 1 1 b))\n  (init (cell 3 3 1 2 b))\n  (init (cell 3 3 1 3 b))\n  (init (cell 3 3 2 1 1))\n  (init (cell 3 3 2 2 b))\n  (init (cell 3 3 2 3 b))\n  (init (cell 3 3 3 1 b))\n  (init (cell 3 3 3 2 b))\n  (init (cell 3 3 3 3 b))\n  (<= (legal robot (mark ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l b))\n      (digit ?x)\n      (not (row ?k ?l ?x))\n      (not (col ?i ?j ?x))\n      (not (square ?i ?k ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 3 ?k ?l ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 3 ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?i ?j ?k ?l ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?s ?i))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?t ?j))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?u ?k))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?v ?l))\n  (<= (goal robot 100) (not open))\n  (<= (goal robot 0) open)\n  (<= terminal (not playable))\n  (<= (filler ?x) (digit ?x))\n  (filler b)\n  (<= open (true (cell ?i ?j ?k ?l b)))\n  (<= playable (legal robot (mark ?i ?j ?k ?l ?x)))\n  (index 1)\n  (index 2)\n  (index 3)\n  (digit 1)\n  (digit 2)\n  (digit 3)\n  (digit 4)\n  (digit 5)\n  (digit 6)\n  (digit 7)\n  (digit 8)\n  (digit 9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on an 8-by-8 coordinate grid with coordinates numbered from 1 to 8 along both axes, forming the game board. Two players, designated as north and south, alternate turns, starting with north. The initial state sets the step counter to zero and initializes each player's capture count to zero. The board is populated with pieces belonging to each player: north controls pawns labeled np and kings labeled nk, while south controls pawns labeled sp and kings labeled sk. Pieces are positioned on specific cells at the start, with pawns and kings placed on predetermined rows and columns as per the initial configuration. During a player's turn, they may perform one legal action: either moving a piece or defending a cell. The \"noop\" or no-operation is implicitly represented by the defend action, which allows a player to maintain control over a piece's current cell without moving it. Legal moves require that the player owns the piece being moved, the origin and destination coordinates lie within the board boundaries, and the destination cell is not already owned by the same player. Moreover, the piece being moved must adhere to its movement rules: kings may move to any adjacent cell horizontally, vertically, or diagonally (within one step in any direction), while pawns may move only one step orthogonally (either one step in the x-direction or one step in the y-direction) but not diagonally, and the move must involve a change in position (the origin and destination cannot be the same cell). The board enforces occupancy and movement constraints such that no two pieces occupy the same cell, and no player may move onto a cell occupied by their own piece. After a move is executed, if the destination cell was occupied by an opponent's piece and that piece was not defended or moved away in the same turn, a capture is registered, incrementing the moving player's capture count by one. Defending a cell prevents captures on that cell during the opponent's next move. The game automatically advances the step counter by one after each turn. The game ends under any of three terminal conditions: when the step count reaches 30, when a player has no pieces left on the board, or when a player reaches a capture count of 10, corresponding to a maximum score. Players earn points based on the number of captures they have achieved, with each capture worth 10 points up to a maximum of 100 points. The player with the highest score or the last remaining pieces on the board is deemed the winner. Thus, gameplay involves strategic movement and defense of pieces within the bounded 8x8 grid, turn-by-turn advancement, and capture mechanics that influence scoring and ultimately determine victory.",
    "output": "(role north)\n(role south)\n(init (step 0))\n(init (capture_count north 0))\n(init (capture_count south 0))\n(init (cell 2 1 sp))\n(init (cell 3 1 sk))\n(init (cell 4 1 sk))\n(init (cell 5 1 sk))\n(init (cell 6 1 sk))\n(init (cell 7 1 sp))\n(init (cell 3 2 sp))\n(init (cell 4 2 sp))\n(init (cell 5 2 sp))\n(init (cell 6 2 sp))\n(init (cell 2 8 np))\n(init (cell 3 8 nk))\n(init (cell 4 8 nk))\n(init (cell 5 8 nk))\n(init (cell 6 8 nk))\n(init (cell 7 8 np))\n(init (cell 3 7 np))\n(init (cell 4 7 np))\n(init (cell 5 7 np))\n(init (cell 6 7 np))\n(init (cell 1 2 sp))\n(init (cell 1 3 sk))\n(init (cell 1 4 sk))\n(init (cell 1 5 sk))\n(init (cell 1 6 sk))\n(init (cell 1 7 sp))\n(init (cell 2 3 sp))\n(init (cell 2 4 sp))\n(init (cell 2 5 sp))\n(init (cell 2 6 sp))\n(init (cell 8 2 np))\n(init (cell 8 3 nk))\n(init (cell 8 4 nk))\n(init (cell 8 5 nk))\n(init (cell 8 6 nk))\n(init (cell 8 7 np))\n(init (cell 7 3 np))\n(init (cell 7 4 np))\n(init (cell 7 5 np))\n(init (cell 7 6 np))\n(<= (legal ?role (move ?x ?y ?u ?v))\n    (role ?role)\n    (coordinate ?u)\n    (coordinate ?v)\n    (owns ?role ?piece)\n    (true (cell ?x ?y ?piece))\n    (are_distinct ?x ?y ?u ?v)\n    (valid_move ?piece ?x ?y ?u ?v)\n    (not (cell_owned_by ?u ?v ?role)))\n(<= (cell_owned_by ?u ?v ?role)\n    (true (cell ?u ?v ?p))\n    (owns ?role ?p))\n(<= (legal ?role (defend ?x ?y))\n    (true (cell ?x ?y ?piece))\n    (owns ?role ?piece))\n(<= (next (cell ?x ?y ?piece))\n    (true (cell ?x ?y ?piece))\n    (not (someone_moves_from ?x ?y))\n    (not (someone_moves_to ?x ?y)))\n(<= (someone_moves_from ?x ?y)\n    (does ?r (move ?x ?y ?u ?v)))\n(<= (someone_moves_to ?u ?v)\n    (does ?r (move ?x ?y ?u ?v)))\n(<= (next (cell ?x ?y ?piece))\n    (true (cell ?x ?y ?piece))\n    (does ?role (defend ?x ?y)))\n(<= (next (cell ?x ?y ?piece))\n    (does ?role (move ?x0 ?y0 ?x ?y))\n    (true (cell ?x0 ?y0 ?piece))\n    (not (someone_defends ?x ?y))\n    (not (someone_different_moves_to ?role ?x ?y)))\n(<= (someone_defends ?x ?y)\n    (does ?owner (defend ?x ?y)))\n(<= (next (step ?b))\n    (true (step ?a))\n    (succ ?a ?b))\n(<= (next (capture_count ?role ?new_count))\n    (true (capture_count ?role ?old_count))\n    (did_capture ?role)\n    (succ ?old_count ?new_count))\n(<= (next (capture_count ?role ?count))\n    (true (capture_count ?role ?count))\n    (not (did_capture ?role)))\n(<= terminal\n    (true (step 30)))\n(<= terminal\n    (role ?role)\n    (not (any_cell_owned_by ?role)))\n(<= (any_cell_owned_by ?role)\n    (cell_owned_by ?x ?y ?role))\n(<= terminal\n    (role ?role)\n    (goal ?role 100))\n(<= (goal ?role ?payoff)\n    (true (capture_count ?role ?count))\n    (payoff ?count ?payoff))\n(owns south sp)\n(owns north np)\n(owns west wp)\n(owns east ep)\n(owns south sk)\n(owns north nk)\n(owns west wk)\n(owns east ek)\n(pawn sp)\n(pawn np)\n(pawn ep)\n(pawn wp)\n(king sk)\n(king nk)\n(king ek)\n(king wk)\n(payoff 0 0)\n(payoff 1 10)\n(payoff 2 20)\n(payoff 3 30)\n(payoff 4 40)\n(payoff 5 50)\n(payoff 6 60)\n(payoff 7 70)\n(payoff 8 80)\n(payoff 9 90)\n(payoff 10 100)\n(<= (valid_move ?piece ?x ?y ?u ?v)\n    (king ?piece)\n    (within_one ?x ?u)\n    (within_one ?y ?v))\n(<= (valid_move ?piece ?x ?y ?u ?y)\n    (pawn ?piece)\n    (within_one ?x ?u)\n    (coordinate ?y))\n(<= (valid_move ?piece ?x ?y ?x ?v)\n    (pawn ?piece)\n    (coordinate ?x)\n    (within_one ?y ?v))\n(<= (within_one ?x ?x)\n    (number ?x))\n(<= (within_one ?x ?u)\n    (succ ?x ?u))\n(<= (within_one ?x ?u)\n    (succ ?u ?x))\n(<= (are_distinct ?x1 ?y1 ?x2 ?y2)\n    (coordinate ?x1)\n    (coordinate ?x2)\n    (coordinate ?y1)\n    (coordinate ?y2)\n    (distinct ?x1 ?x2))\n(<= (are_distinct ?x1 ?y1 ?x2 ?y2)\n    (coordinate ?x1)\n    (coordinate ?x2)\n    (coordinate ?y1)\n    (coordinate ?y2)\n    (distinct ?y1 ?y2))\n(<= (did_capture ?role)\n    (does ?role (move ?x ?y ?u ?v))\n    (true (cell ?u ?v ?piece))\n    (owns ?opponent ?piece)\n    (not (does ?opponent (defend ?u ?v)))\n    (not (move_from ?opponent ?u ?v))\n    (not (someone_different_moves_to ?role ?u ?v)))\n(<= (did_capture ?defender)\n    (does ?attacker (move ?x ?y ?u ?v))\n    (does ?defender (defend ?u ?v)))\n(<= (move_from ?role ?u ?v)\n    (does ?role (move ?u ?v ?u2 ?v2)))\n(<= (someone_different_moves_to ?role ?u ?v)\n    (role ?role)\n    (role ?op2)\n    (distinct ?role ?op2)\n    (does ?op2 (move ?xx ?yy ?u ?v)))\n(<= (sum ?x 0 ?x)\n    (number ?x))\n(<= (sum ?a 1 ?b)\n    (succ ?a ?b))\n(<= (sum ?a 2 ?c)\n    (succ ?a ?b)\n    (succ ?b ?c))\n(<= (sum ?a 3 ?d)\n    (succ ?a ?b)\n    (succ ?b ?c)\n    (succ ?c ?d))\n(coordinate 1)\n(coordinate 2)\n(coordinate 3)\n(coordinate 4)\n(coordinate 5)\n(coordinate 6)\n(coordinate 7)\n(coordinate 8)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(number 0)\n(number 1)\n(number 2)\n(number 3)\n(number 4)\n(number 5)\n(number 6)\n(number 7)\n(number 8)\n(number 9)\n(number 10)\n(number 11)\n(number 12)\n(number 13)\n(number 14)\n(number 15)\n(number 16)\n(number 17)\n(number 18)\n(number 19)\n(number 20)\n(number 21)\n(number 22)\n(number 23)\n(number 24)\n(number 25)\n(number 26)\n(number 27)\n(number 28)\n(number 29)\n(number 30)\n(number 31)\n(number 32)\n(number 33)\n(number 34)\n(number 35)\n(number 36)\n(number 37)\n(number 38)\n(number 39)\n(number 40)\n(number 41)\n(number 42)\n(number 43)\n(number 44)\n(number 45)\n(number 46)\n(number 47)\n(number 48)\n(number 49)\n(number 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 5-by-5 grid with coordinates labeled from 1 to 5 along both rows and columns, where each cell can be identified by its row and column indices. There are three players named xplayer, oplayer, and zplayer who take turns in a fixed cyclic order starting with xplayer, followed by oplayer, then zplayer, and repeating this sequence. Initially, all cells on the board are empty, denoted by the symbol 'b', and control is given to xplayer to make the first move. On each turn, the player in control must either place their mark—x for xplayer, o for oplayer, and z for zplayer—on any empty cell by specifying the row and column coordinates of that cell, or they may perform a no-operation (noop) action if it is not their turn. A move to mark a cell is legal only if the chosen cell is currently empty and the player is the one in control. When a player marks a cell, that cell's state updates to contain the player's symbol; all other cells remain unchanged except for the previously empty cell that is now marked. Control then passes to the next player in the predefined turn order. The game enforces implicit constraints such that players cannot mark cells outside the 5x5 board boundaries, and no cell can be occupied by more than one mark at a time. The game terminates if any player achieves a four-in-a-row line—either horizontally across a row, vertically down a column, or diagonally across the board—or when there are no empty cells left to mark. The scoring system assigns 100 points to any player who forms such a four-in-a-row line, 66 points to a player who achieves a contiguous sequence of exactly three of their marks in a row, column, or diagonal without a four-in-a-row, 33 points if the player has no such lines but the game board is still active without others having formed lines, and 0 points if another player has formed a line while the player has not. The game thus emphasizes strategic placement to create longer sequences of marks, and the turn control and noop mechanism ensure orderly progression of moves among all three players.",
    "output": "(role xplayer)\n(role oplayer)\n(role zplayer)\n(init (cell 1 1 b))\n(init (cell 1 2 b))\n(init (cell 1 3 b))\n(init (cell 1 4 b))\n(init (cell 1 5 b))\n(init (cell 2 1 b))\n(init (cell 2 2 b))\n(init (cell 2 3 b))\n(init (cell 2 4 b))\n(init (cell 2 5 b))\n(init (cell 3 1 b))\n(init (cell 3 2 b))\n(init (cell 3 3 b))\n(init (cell 3 4 b))\n(init (cell 3 5 b))\n(init (cell 4 1 b))\n(init (cell 4 2 b))\n(init (cell 4 3 b))\n(init (cell 4 4 b))\n(init (cell 4 5 b))\n(init (cell 5 1 b))\n(init (cell 5 2 b))\n(init (cell 5 3 b))\n(init (cell 5 4 b))\n(init (cell 5 5 b))\n(init (control xplayer))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 1)\n(<= (next (cell ?m ?n ?s))\n    (does ?p (mark ?m ?n))\n    (sign ?p ?s))\n(<= (next (cell ?m ?n ?w))\n    (true (cell ?m ?n ?w))\n    (distinct ?w b))\n(<= (next (cell ?m ?n b))\n    (does ?w (mark ?j ?k))\n    (true (cell ?m ?n b))\n    (distinct ?n ?k))\n(<= (next (cell ?m ?n b))\n    (does ?w (mark ?j ?k))\n    (true (cell ?m ?n b))\n    (distinct ?m ?j))\n(<= (next (control zplayer))\n    (true (control oplayer)))\n(<= (next (control oplayer))\n    (true (control xplayer)))\n(<= (next (control xplayer))\n    (true (control zplayer)))\n(<= (row ?m ?x)\n    (true (cell ?m ?a ?x))\n    (succ ?a ?b)\n    (true (cell ?m ?b ?x))\n    (succ ?b ?c)\n    (true (cell ?m ?c ?x))\n    (succ ?c ?d)\n    (true (cell ?m ?d ?x)))\n(<= (column ?n ?x)\n    (true (cell ?a ?n ?x))\n    (succ ?a ?b)\n    (true (cell ?b ?n ?x))\n    (succ ?b ?c)\n    (true (cell ?c ?n ?x))\n    (succ ?c ?d)\n    (true (cell ?d ?n ?x)))\n(<= (diagonal ?x)\n    (true (cell ?a ?k ?x))\n    (succ ?a ?b)\n    (succ ?k ?l)\n    (true (cell ?b ?l ?x))\n    (succ ?b ?c)\n    (succ ?l ?m)\n    (true (cell ?c ?m ?x))\n    (succ ?c ?d)\n    (succ ?m ?n)\n    (true (cell ?d ?n ?x)))\n(<= (diagonal ?x)\n    (true (cell ?a ?k ?x))\n    (succ ?b ?a)\n    (succ ?k ?l)\n    (true (cell ?b ?l ?x))\n    (succ ?c ?b)\n    (succ ?l ?m)\n    (true (cell ?c ?m ?x))\n    (succ ?d ?c)\n    (succ ?m ?n)\n    (true (cell ?d ?n ?x)))\n(<= (line ?x) (row ?m ?x))\n(<= (line ?x) (column ?m ?x))\n(<= (line ?x) (diagonal ?x))\n(<= (row3 ?m ?x)\n    (true (cell ?m ?a ?x))\n    (succ ?a ?b)\n    (true (cell ?m ?b ?x))\n    (succ ?b ?c)\n    (true (cell ?m ?c ?x)))\n(<= (column3 ?n ?x)\n    (true (cell ?a ?n ?x))\n    (succ ?a ?b)\n    (true (cell ?b ?n ?x))\n    (succ ?b ?c)\n    (true (cell ?c ?n ?x)))\n(<= (diagonal3 ?x)\n    (true (cell ?a ?k ?x))\n    (succ ?a ?b)\n    (succ ?k ?l)\n    (true (cell ?b ?l ?x))\n    (succ ?b ?c)\n    (succ ?l ?m)\n    (true (cell ?c ?m ?x)))\n(<= (diagonal3 ?x)\n    (true (cell ?a ?k ?x))\n    (succ ?b ?a)\n    (succ ?k ?l)\n    (true (cell ?b ?l ?x))\n    (succ ?c ?b)\n    (succ ?l ?m)\n    (true (cell ?c ?m ?x)))\n(<= (line3 ?x) (row3 ?m ?x))\n(<= (line3 ?x) (column3 ?m ?x))\n(<= (line3 ?x) (diagonal3 ?x))\n(<= open\n    (true (cell ?m ?n b)))\n(<= (legal ?w (mark ?x ?y))\n    (true (cell ?x ?y b))\n    (true (control ?w)))\n(<= (legal ?p noop)\n    (role ?p)\n    (not (true (control ?p))))\n(<= (goal ?p 100)\n    (sign ?p ?s)\n    (line ?s))\n(<= (goal ?p 66)\n    (role ?p)\n    (sign ?p ?s)\n    (not (line ?s))\n    (line3 ?s))\n(<= (goal ?p 33)\n    (role ?p)\n    (sign ?p ?s)\n    (not (line x))\n    (not (line o))\n    (not (line z))\n    (not (line3 ?s)))\n(<= (goal ?p 0)\n    (role ?p)\n    (sign ?p ?s)\n    (not (line3 ?s))\n    (sign ?p1 ?s2)\n    (distinct ?p1 ?p)\n    (line ?s2))\n(<= terminal\n    (sign ?p ?s)\n    (line ?s))\n(<= terminal\n    (not open))\n(sign xplayer x)\n(sign oplayer o)\n(sign zplayer z)\n(<= (index ?x)\n    (succ ?x ?y))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a coordinate grid with nine columns and nine rows labeled c1 through c9, establishing a two-dimensional environment where positions and movements are defined by these coordinates. The game features three players, designated as top, right, and left, who take turns in an order implied by the roles listed. Initially, the top player starts at position c1 c1, the right player at c9 c9, and the left player at c1 c9. The board contains fixed walls placed between certain coordinate pairs, which act as barriers blocking movement between adjacent positions. On each turn, a player may either move or perform a noop (no operation). Movement actions are formatted as \"go\" followed by target coordinates and are only legal if the player is not currently at their goal position, the intended move leads to a possible next position based on allowed directional moves specific to each player, the path is not blocked by walls, and the move does not result in collisions with other players who might be moving into the same position simultaneously. If a player has reached their goal position or has no legal moves available, they must choose noop. Legal moves for each player differ: the top player can move left, right, down-left, or down-right; the right player can move up-right, down-left, up-left, or left; and the left player can move down-right, up-left, right, or up-right. Movement between coordinates respects adjacency relations defined by successor functions on coordinate labels, ensuring players move to adjacent squares only. When a move is executed without collision, the player's position updates to the new coordinates; if a collision occurs, the player's position remains the same. Walls can dynamically reorder based on player movement to maintain accurate blockage relations. The game tracks steps to goal for each player, incrementing the counter when a player moves closer to their goal without collision. The terminal conditions for the game are triggered when no player can perform a legal move or when the step count reaches 30. Victory scoring is determined by goal position reach and the number of steps taken: if only one player reaches their goal, their score depends on their steps relative to thresholds; if two players reach their goals, scores are assigned based on comparative steps; if all three reach their goals, scores depend on their relative steps to goal, with better performance rewarded higher. Players who fail to reach their goals receive low or zero scores. Implicit constraints in the game include the bounding of movements within the coordinate grid c1 to c9, prevention of movement through walls or onto occupied spaces causing collision, and adjacency requirements for valid moves. The goal positions for each player are defined as the last column for top (any coordinate c9), the first column for right (coordinate c1), and the diagonal positions for left (coordinates where column and row labels are equal). Overall, the game challenges players to navigate the board efficiently toward their respective goals while avoiding collisions and respecting walls, with scoring rewarding speed and successful goal attainment under the given constraints.",
    "output": "(role top)\n(role right)\n(role left)\n(init (pos top c1 c1))\n(init (pos right c9 c9))\n(init (pos left c1 c9))\n(init (wall c3 c5 c3 c6))\n(init (wall c3 c5 c4 c6))\n(init (wall c3 c6 c4 c6))\n(init (wall c3 c6 c3 c7))\n(init (wall c3 c6 c4 c7))\n(init (wall c4 c6 c4 c7))\n(init (wall c4 c6 c5 c7))\n(init (wall c3 c7 c4 c7))\n(init (wall c4 c7 c5 c7))\n(init (step s0))\n(<= (legal ?r (go ?x ?y))\n(true (pos ?r ?x1 ?y1))\n(possiblenextpos ?r ?x1 ?y1 ?x ?y)\n(not (blocked ?x1 ?y1 ?x ?y))\n(not (goalposreached ?r)))\n(<= (legal ?r noop)\n(goalposreached ?r))\n(<= (legal ?r noop)\n(true (pos ?r ?x1 ?y1))\n(not (exists_non_blocked_nextpos ?r ?x1 ?y1)))\n(<= (exists_non_blocked_nextpos ?r ?x1 ?y1)\n(possiblenextpos ?r ?x1 ?y1 ?x ?y)\n(not (blocked ?x1 ?y1 ?x ?y)))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(<= (next (steps_to_goal ?r ?s))\n(true (step ?s1))\n(succ ?s1 ?s)\n(does ?r (go ?x ?y))\n(goalpos ?r ?x ?y)\n(not (collision ?r)))\n(<= (next (steps_to_goal ?r ?s))\n(true (steps_to_goal ?r ?s)))\n(<= (next (pos ?r ?x ?y))\n(true (pos ?r ?x ?y))\n(collision ?r))\n(<= (next (pos ?r ?x ?y))\n(does ?r (go ?x ?y))\n(not (collision ?r)))\n(<= (next (pos ?r ?x ?y))\n(true (pos ?r ?x ?y))\n(does ?r noop))\n(<= (next (wall ?xa ?ya ?xb ?yb))\n(true (pos ?r ?x1 ?y1))\n(does ?r (go ?x2 ?y2))\n(reorder ?x1 ?y1 ?x2 ?y2 ?xa ?ya ?xb ?yb))\n(<= (next (wall ?x1 ?y1 ?x2 ?y2))\n(true (wall ?x1 ?y1 ?x2 ?y2)))\n(<= (collision ?r)\n(true (pos ?r ?x1 ?y1))\n(does ?r (go ?x ?y))\n(true (pos ?r2 ?x ?y))\n(does ?r2 (go ?x1 ?y1)))\n(<= (only_one_reached_goal ?r1)\n(goalposreached ?r1)\n(role ?r2)\n(distinct ?r1 ?r2)\n(not (goalposreached ?r2))\n(role ?r3)\n(distinct ?r1 ?r3)\n(distinct ?r2 ?r3)\n(not (goalposreached ?r3)))\n(<= (only_two_reached_goal ?r1 ?r2)\n(goalposreached ?r1)\n(role ?r2)\n(distinct ?r1 ?r2)\n(goalposreached ?r2)\n(role ?r3)\n(distinct ?r1 ?r3)\n(distinct ?r2 ?r3)\n(not (goalposreached ?r3)))\n(<= all_reached_goal\n(goalposreached top)\n(goalposreached right)\n(goalposreached left))\n(<= none_reached_goal\n(not (goalposreached top))\n(not (goalposreached right))\n(not (goalposreached left)))\n(<= (goal ?r 100)\n(only_one_reached_goal ?r)\n(true (steps_to_goal ?r s8)))\n(<= (goal ?r 90)\n(only_one_reached_goal ?r)\n(true (steps_to_goal ?r ?s))\n(smaller s8 ?s)\n(smaller ?s s16))\n(<= (goal ?r 80)\n(only_one_reached_goal ?r)\n(true (steps_to_goal ?r ?s))\n(smaller s15 ?s))\n(<= (goal ?r1 70)\n(only_two_reached_goal ?r1 ?r2)\n(true (steps_to_goal ?r1 ?s1))\n(true (steps_to_goal ?r2 ?s2))\n(smaller ?s1 ?s2))\n(<= (goal ?r1 60)\n(only_two_reached_goal ?r1 ?r2)\n(true (steps_to_goal ?r1 ?s))\n(true (steps_to_goal ?r2 ?s)))\n(<= (goal ?r1 50)\n(only_two_reached_goal ?r1 ?r2)\n(true (steps_to_goal ?r1 ?s1))\n(true (steps_to_goal ?r2 ?s2))\n(smaller ?s2 ?s1))\n(<= (goal ?r1 40)\nall_reached_goal\n(true (steps_to_goal ?r1 ?s1))\n(true (steps_to_goal ?r2 ?s2))\n(distinct ?r1 ?r2)\n(true (steps_to_goal ?r3 ?s3))\n(distinct ?r1 ?r3)\n(distinct ?r2 ?r3)\n(smaller ?s1 ?s2)\n(smaller ?s1 ?s3))\n(<= (goal ?r1 30)\nall_reached_goal\n(true (steps_to_goal ?r1 ?s1))\n(true (steps_to_goal ?r2 ?s2))\n(distinct ?r1 ?r2)\n(true (steps_to_goal ?r3 ?s3))\n(distinct ?r1 ?r3)\n(distinct ?r2 ?r3)\n(not (smaller ?s1 ?s2))\n(smaller ?s1 ?s3))\n(<= (goal ?r1 20)\nall_reached_goal\n(true (steps_to_goal ?r1 ?s1))\n(true (steps_to_goal ?r2 ?s2))\n(distinct ?r1 ?r2)\n(true (steps_to_goal ?r3 ?s3))\n(distinct ?r1 ?r3)\n(distinct ?r2 ?r3)\n(not (smaller ?s1 ?s2))\n(not (smaller ?s1 ?s3)))\n(<= (goal ?r 10)\nnone_reached_goal\n(role ?r))\n(<= (goal ?r 0)\n(not (goalposreached ?r))\n(role ?r)\n(role ?r1)\n(goalposreached ?r1))\n(<= terminal\n(not legal_go))\n(<= terminal\n(true (step s30)))\n(<= legal_go\n(legal ?r (go ?x ?y)))\n(<= (goalposreached ?r)\n(true (pos ?r ?x ?y))\n(goalpos ?r ?x ?y))\n(<= (goalpos top ?x c9)\n(coordinate ?x))\n(<= (goalpos right c1 ?y)\n(coordinate ?y))\n(<= (goalpos left ?x ?x)\n(coordinate ?x))\n(<= (goes ?r ?x1 ?y1 ?x2 ?y2)\n(true (pos ?r ?x1 ?y1))\n(does ?r (go ?x2 ?y2)))\n(<= (possiblenextpos top ?x1 ?y1 ?x2 ?y2)\n(moveleft ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos top ?x1 ?y1 ?x2 ?y2)\n(moveright ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos top ?x1 ?y1 ?x2 ?y2)\n(movedownleft ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos top ?x1 ?y1 ?x2 ?y2)\n(movedownright ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos right ?x1 ?y1 ?x2 ?y2)\n(moveupright ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos right ?x1 ?y1 ?x2 ?y2)\n(movedownleft ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos right ?x1 ?y1 ?x2 ?y2)\n(moveupleft ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos right ?x1 ?y1 ?x2 ?y2)\n(moveleft ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos left ?x1 ?y1 ?x2 ?y2)\n(movedownright ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos left ?x1 ?y1 ?x2 ?y2)\n(moveupleft ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos left ?x1 ?y1 ?x2 ?y2)\n(moveright ?x1 ?y1 ?x2 ?y2))\n(<= (possiblenextpos left ?x1 ?y1 ?x2 ?y2)\n(moveupright ?x1 ?y1 ?x2 ?y2))\n(<= (moveupright ?x ?y1 ?x ?y2)\n(distinct ?x ?y1)\n(nextcoord ?y2 ?y1)\n(coordinate ?x))\n(<= (moveright ?x1 ?y ?x2 ?y)\n(distinct ?x1 ?y)\n(nextcoord ?x1 ?x2)\n(coordinate ?y))\n(<= (movedownright ?x1 ?y1 ?x2 ?y2)\n(nextcoord ?x1 ?x2)\n(nextcoord ?y1 ?y2))\n(<= (movedownleft ?x ?y1 ?x ?y2)\n(nextcoord ?y1 ?y2)\n(coordinate ?x))\n(<= (moveleft ?x1 ?y ?x2 ?y)\n(nextcoord ?x2 ?x1)\n(coordinate ?y))\n(<= (moveupleft ?x1 ?y1 ?x2 ?y2)\n(nextcoord ?x2 ?x1)\n(nextcoord ?y2 ?y1))\n(<= (reorder ?x1 ?y1 ?x2 ?y2 ?x1 ?y1 ?x2 ?y2)\n(nextcoord ?x1 ?x2)\n(coordinate ?y1)\n(coordinate ?y2))\n(<= (reorder ?x1 ?y1 ?x2 ?y2 ?x1 ?y1 ?x2 ?y2)\n(nextcoord ?y1 ?y2)\n(coordinate ?x1)\n(coordinate ?x2))\n(<= (reorder ?x1 ?y1 ?x2 ?y2 ?x2 ?y2 ?x1 ?y1)\n(not (nextcoord ?x1 ?x2))\n(not (nextcoord ?y1 ?y2))\n(coordinate ?x1)\n(coordinate ?x2)\n(coordinate ?y1)\n(coordinate ?y2))\n(nextcoord c1 c2)\n(nextcoord c2 c3)\n(nextcoord c3 c4)\n(nextcoord c4 c5)\n(nextcoord c5 c6)\n(nextcoord c6 c7)\n(nextcoord c7 c8)\n(nextcoord c8 c9)\n(coordinate c1)\n(coordinate c2)\n(coordinate c3)\n(coordinate c4)\n(coordinate c5)\n(coordinate c6)\n(coordinate c7)\n(coordinate c8)\n(coordinate c9)\n(<= (blocked ?x1 ?y1 ?x2 ?y2)\n(true (wall ?x1 ?y1 ?x2 ?y2)))\n(<= (blocked ?x1 ?y1 ?x2 ?y2)\n(true (wall ?x2 ?y2 ?x1 ?y1)))\n(succ s0 s1)\n(succ s1 s2)\n(succ s2 s3)\n(succ s3 s4)\n(succ s4 s5)\n(succ s5 s6)\n(succ s6 s7)\n(succ s7 s8)\n(succ s8 s9)\n(succ s9 s10)\n(succ s10 s11)\n(succ s11 s12)\n(succ s12 s13)\n(succ s13 s14)\n(succ s14 s15)\n(succ s15 s16)\n(succ s16 s17)\n(succ s17 s18)\n(succ s18 s19)\n(succ s19 s20)\n(succ s20 s21)\n(succ s21 s22)\n(succ s22 s23)\n(succ s23 s24)\n(succ s24 s25)\n(succ s25 s26)\n(succ s26 s27)\n(succ s27 s28)\n(succ s28 s29)\n(succ s29 s30)\n(succ s30 s31)\n(succ s31 s32)\n(succ s32 s33)\n(succ s33 s34)\n(succ s34 s35)\n(succ s35 s36)\n(succ s36 s37)\n(succ s37 s38)\n(succ s38 s39)\n(succ s39 s40)\n(succ s40 s41)\n(succ s41 s42)\n(succ s42 s43)\n(succ s43 s44)\n(succ s44 s45)\n(succ s45 s46)\n(succ s46 s47)\n(succ s47 s48)\n(succ s48 s49)\n(succ s49 s50)\n(<= (smaller ?x ?y)\n(succ ?x ?y))\n(<= (smaller ?x ?y)\n(succ ?z ?y)\n(smaller ?x ?z))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played between two players, white and black, each taking turns in a simultaneous manner, where both players commit a certain number of armies at each step. The environment does not have a spatial coordinate system or board layout; rather, it operates on a numerical scale from 0 to 20 representing the armies each player has available to commit. Initially, both players start with a score of zero and 20 armies each. On every turn, both players simultaneously select a non-negative integer action named 'commit' that must not exceed the number of armies they currently have. The action format requires that the committed number be less than or equal to the player's current army count, ensuring no overcommitment. After both players commit their armies, the game updates the scores and armies: each player's score increases by a value dependent on whether their committed armies exceed the opponent's commitment, with a differential scoring mechanism awarding 5 points to the player who commits more armies in that turn or 1 point each if they commit equal amounts; the armies are then summed with the committed amounts, effectively replenishing them, which suggests a conceptual accumulation rather than depletion of armies, although the logic is somewhat atypical. The game continues until both players simultaneously commit zero armies, which triggers the finished state and ends the game. Throughout the game, commitment values must be within the integer range from 0 to 20, and no spatial positioning or occupancy conflicts exist since the game mechanics revolve solely around numerical commitments and score tracking. The terminal condition is reached when both players choose to commit zero, signaling the end of the game. The final scores for both players are their accumulated points from previous turns, with the player holding the higher score considered the winner. This game does not include a traditional noop move; however, committing zero armies effectively serves as a no-operation action that can lead to the game's termination when chosen by both players simultaneously.",
    "output": "(role white)\n(role black)\n(init (whiteScore 0))\n(init (blackScore 0))\n(init (whiteArmies 20))\n(init (blackArmies 20))\n(<= (legal white (commit ?x1))\n    (true (whiteArmies ?x2))\n    (gte ?x2 ?x1))\n(<= (legal black (commit ?x1))\n    (true (blackArmies ?x2))\n    (gte ?x2 ?x1))\n(<= (next (whiteScore ?xNext))\n    (true (whiteScore ?x))\n    (w1 ?score)\n    (sum ?x ?score ?xNext))\n(<= (next (blackScore ?xNext))\n    (true (blackScore ?x))\n    (b1 ?score)\n    (sum ?x ?score ?xNext))\n(<= (next (whiteArmies ?xNext))\n    (true (whiteArmies ?x))\n    (does white (commit ?x1))\n    (sum ?xNext ?x1 ?x))\n(<= (next (blackArmies ?xNext))\n    (true (blackArmies ?x))\n    (does black (commit ?x1))\n    (sum ?xNext ?x1 ?x))\n(<= (next finished)\n\t(does white (commit 0))\n    (does black (commit 0)))\n(<= terminal\n    (true finished))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(<= (w1 5)\n    (does white (commit ?x1))\n    (does black (commit ?y1))\n    (gt ?x1 ?y1))\n(<= (b1 0)\n    (does white (commit ?x1))\n    (does black (commit ?y1))\n    (gt ?x1 ?y1))\n(<= (w1 0)\n    (does black (commit ?x1))\n    (does white (commit ?y1))\n    (gt ?x1 ?y1))\n(<= (b1 5)\n    (does black (commit ?x1))\n    (does white (commit ?y1))\n    (gt ?x1 ?y1))\n(<= (w1 1)\n    (does white (commit ?x1))\n    (does black (commit ?x1)))\n(<= (b1 1)\n    (does white (commit ?x1))\n    (does black (commit ?x1)))\n(<= (sum ?x 0 ?x)\n    (or (succ ?x ?y) (succ ?y ?x)))\n(<= (sum ?x ?y ?z)\n    (succ ?y0 ?y)\n    (succ ?z0 ?z)\n    (sum ?x ?y0 ?z0))\n(<= (gt ?a ?b)\n    (index ?x)\n    (not (succ ?x 1))\n    (sum ?b ?x ?a))\n(<= (gte ?a ?b)\n    (index ?x)\n    (sum ?b ?x ?a))\n(index 0)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(index 11)\n(index 12)\n(index 13)\n(index 14)\n(index 15)\n(index 16)\n(index 17)\n(index 18)\n(index 19)\n(index 20)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a two-dimensional grid with coordinates running from 1 to 6 along both axes, defining the board’s boundaries. Four player roles exist: north, south, east, and west, who take turns in that order. The initial state sets the turn counter to zero and places specific pieces on the board: pawns and kings belonging to each player are arranged at designated coordinates near their respective edges. Each player owns a distinct set of pieces marked by role-specific prefixes. On their turn, a player may perform either a move or a defend action. A move consists of specifying a starting coordinate and a target coordinate within one unit of distance horizontally, vertically, or diagonally for kings, while pawns may move only one step horizontally or vertically, but not diagonally. Moves are only legal if the piece belongs to the acting player, the target cell is unoccupied by their own pieces, and the move alters the position. A defend action involves choosing a piece currently on the board that the player owns and electing to defend it, which affects capture logic. If no move or defend action is taken, the player effectively performs a noop implicitly. After an action, the game state updates accordingly: pieces remain in place unless moved; if a move targets a cell occupied by an opponent’s piece that is not defended, and no other player attempts to move to the same cell, the moving player captures that piece, incrementing their capture count. If the attacked piece is defended by its owner, the defender is credited with a capture instead. The turn counter increments by one after each turn. Implicit constraints include the board’s fixed 6x6 dimensions, the limitation of piece movement to adjacent coordinates as specified, and the rule that no two pieces of the same player can occupy the same cell. The game ends either when the step count reaches 40, when any player no longer owns any pieces on the board, or when a player reaches a capture count of 10. Victory is determined by scoring based on the number of opponent pieces captured: each capture increases a player’s payoff by 10 points, with a maximum payoff of 100. The player with the highest payoff or who reaches 100 points first wins, and elimination of a player’s pieces also triggers game termination. Thus, the game emphasizes strategic movement and defending to capture opponent pieces while managing positional constraints on a bounded grid through sequential turns among four distinct players.",
    "output": "(role north)\n(role south)\n(role east)\n(role west)\n(init (step 0))\n(init (capture_count north 0))\n(init (capture_count south 0))\n(init (capture_count east 0))\n(init (capture_count west 0))\n(init (cell 2 1 sp))\n(init (cell 3 1 sk))\n(init (cell 4 1 sk))\n(init (cell 5 1 sp))\n(init (cell 3 2 sp))\n(init (cell 4 2 sp))\n(init (cell 2 6 np))\n(init (cell 3 6 nk))\n(init (cell 4 6 nk))\n(init (cell 5 6 np))\n(init (cell 3 5 np))\n(init (cell 4 5 np))\n(init (cell 1 2 wp))\n(init (cell 1 3 wk))\n(init (cell 1 4 wk))\n(init (cell 1 5 wp))\n(init (cell 2 3 wp))\n(init (cell 2 4 wp))\n(init (cell 6 2 ep))\n(init (cell 6 3 ek))\n(init (cell 6 4 ek))\n(init (cell 6 5 ep))\n(init (cell 5 3 ep))\n(init (cell 5 4 ep))\n(<= (legal ?role (move ?x ?y ?u ?v))\n    (role ?role)\n    (coordinate ?u)\n    (coordinate ?v)\n    (owns ?role ?piece)\n    (true (cell ?x ?y ?piece))\n    (are_distinct ?x ?y ?u ?v)\n    (valid_move ?piece ?x ?y ?u ?v)\n    (not (cell_owned_by ?u ?v ?role)))\n(<= (cell_owned_by ?u ?v ?role)\n    (true (cell ?u ?v ?p))\n    (owns ?role ?p))\n(<= (legal ?role (defend ?x ?y))\n    (true (cell ?x ?y ?piece))\n    (owns ?role ?piece))\n(<= (next (cell ?x ?y ?piece))\n    (true (cell ?x ?y ?piece))\n    (not (someone_moves_from ?x ?y))\n    (not (someone_moves_to ?x ?y)))\n(<= (someone_moves_from ?x ?y)\n    (does ?r (move ?x ?y ?u ?v)))\n(<= (someone_moves_to ?u ?v)\n    (does ?r (move ?x ?y ?u ?v)))\n(<= (next (cell ?x ?y ?piece))\n    (true (cell ?x ?y ?piece))\n    (does ?role (defend ?x ?y)))\n(<= (next (cell ?x ?y ?piece))\n    (does ?role (move ?x0 ?y0 ?x ?y))\n    (true (cell ?x0 ?y0 ?piece))\n    (not (someone_defends ?x ?y))\n    (not (someone_different_moves_to ?role ?x ?y)))\n(<= (someone_defends ?x ?y)\n    (does ?owner (defend ?x ?y)))\n(<= (next (step ?b))\n    (true (step ?a))\n    (succ ?a ?b))\n(<= (next (capture_count ?role ?new_count))\n    (true (capture_count ?role ?old_count))\n    (did_capture ?role)\n    (succ ?old_count ?new_count))\n(<= (next (capture_count ?role ?count))\n    (true (capture_count ?role ?count))\n    (not (did_capture ?role)))\n(<= terminal\n    (true (step 40)))\n(<= terminal\n    (role ?role)\n    (not (any_cell_owned_by ?role)))\n(<= (any_cell_owned_by ?role)\n    (cell_owned_by ?x ?y ?role))\n(<= terminal\n    (role ?role)\n    (goal ?role 100))\n(<= (goal ?role ?payoff)\n    (true (capture_count ?role ?count))\n    (payoff ?count ?payoff))\n(owns south sp)\n(owns north np)\n(owns west wp)\n(owns east ep)\n(owns south sk)\n(owns north nk)\n(owns west wk)\n(owns east ek)\n(pawn sp)\n(pawn np)\n(pawn ep)\n(pawn wp)\n(king sk)\n(king nk)\n(king ek)\n(king wk)\n(payoff 0 0)\n(payoff 1 10)\n(payoff 2 20)\n(payoff 3 30)\n(payoff 4 40)\n(payoff 5 50)\n(payoff 6 60)\n(payoff 7 70)\n(payoff 8 80)\n(payoff 9 90)\n(payoff 10 100)\n(<= (valid_move ?piece ?x ?y ?u ?v)\n    (king ?piece)\n    (within_one ?x ?u)\n    (within_one ?y ?v))\n(<= (valid_move ?piece ?x ?y ?u ?y)\n    (pawn ?piece)\n    (within_one ?x ?u)\n    (coordinate ?y))\n(<= (valid_move ?piece ?x ?y ?x ?v)\n    (pawn ?piece)\n    (coordinate ?x)\n    (within_one ?y ?v))\n(<= (within_one ?x ?x)\n    (number ?x))\n(<= (within_one ?x ?u)\n    (succ ?x ?u))\n(<= (within_one ?x ?u)\n    (succ ?u ?x))\n(<= (are_distinct ?x1 ?y1 ?x2 ?y2)\n    (coordinate ?x1)\n    (coordinate ?x2)\n    (coordinate ?y1)\n    (coordinate ?y2)\n    (distinct ?x1 ?x2))\n(<= (are_distinct ?x1 ?y1 ?x2 ?y2)\n    (coordinate ?x1)\n    (coordinate ?x2)\n    (coordinate ?y1)\n    (coordinate ?y2)\n    (distinct ?y1 ?y2))\n(<= (did_capture ?role)\n    (does ?role (move ?x ?y ?u ?v))\n    (true (cell ?u ?v ?piece))\n    (owns ?opponent ?piece)\n    (not (does ?opponent (defend ?u ?v)))\n    (not (move_from ?opponent ?u ?v))\n    (not (someone_different_moves_to ?role ?u ?v)))\n(<= (did_capture ?defender)\n    (does ?attacker (move ?x ?y ?u ?v))\n    (does ?defender (defend ?u ?v)))\n(<= (move_from ?role ?u ?v)\n    (does ?role (move ?u ?v ?u2 ?v2)))\n(<= (someone_different_moves_to ?role ?u ?v)\n    (role ?role)\n    (role ?op2)\n    (distinct ?role ?op2)\n    (does ?op2 (move ?xx ?yy ?u ?v)))\n(<= (sum ?x 0 ?x)\n    (number ?x))\n(<= (sum ?a 1 ?b)\n    (succ ?a ?b))\n(<= (sum ?a 2 ?c)\n    (succ ?a ?b)\n    (succ ?b ?c))\n(<= (sum ?a 3 ?d)\n    (succ ?a ?b)\n    (succ ?b ?c)\n    (succ ?c ?d))\n(coordinate 1)\n(coordinate 2)\n(coordinate 3)\n(coordinate 4)\n(coordinate 5)\n(coordinate 6)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(number 0)\n(number 1)\n(number 2)\n(number 3)\n(number 4)\n(number 5)\n(number 6)\n(number 7)\n(number 8)\n(number 9)\n(number 10)\n(number 11)\n(number 12)\n(number 13)\n(number 14)\n(number 15)\n(number 16)\n(number 17)\n(number 18)\n(number 19)\n(number 20)\n(number 21)\n(number 22)\n(number 23)\n(number 24)\n(number 25)\n(number 26)\n(number 27)\n(number 28)\n(number 29)\n(number 30)\n(number 31)\n(number 32)\n(number 33)\n(number 34)\n(number 35)\n(number 36)\n(number 37)\n(number 38)\n(number 39)\n(number 40)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 7 by 7 board defined by coordinates from 1 to 7 along both the x and y axes, excluding the outermost rows and columns, effectively limiting playable positions to cells where both coordinates are between 2 and 6 inclusive. There are two players distinguished by colors: red and blue. Play alternates between these players, starting with red. Initially, a red piece is placed at cell (1,4) and a blue piece at (7,4), though these starting positions lie outside the playable area as defined by the onboard predicate; however, they represent the spawn points for each player. The game proceeds in discrete steps, beginning at step 1 and terminating after step 31. On each turn, the player in control may perform a legal move or choose to perform a noop action; noop is only legal if the player currently in control has no legal moves available or if it is the other player's turn. A move action is denoted by move x1 y1 x2 y2, indicating that a piece belonging to the current player moves from coordinates (x1,y1) to (x2,y2). For a move to be legal, the piece must be located at the source cell, and the destination cell must be either occupied by an opponent's piece in an orthogonal or diagonal direction or be an unoccupied cell reachable via an \"ell\"-shaped move resembling a knight's move in chess. The orthogonal moves connect cells differing by one unit in either x or y, diagonal moves connect cells differing by one unit in both x and y, and ell moves connect cells differing by two units in one coordinate and one unit in the other. Moves must remain within the onboard area, meaning that the destination cell must lie within the defined playable coordinates. The game enforces that a player cannot move onto a cell occupied by their own piece. When a move is made to a cell occupied by an opponent's piece, a capture occurs, incrementing the player's capture count by one. The control then switches to the other player as defined by a rotation relation. The game state updates by moving the piece to the destination cell and clearing the original cell, except for cases where spawning occurs, which can place a piece on a cell. The step counter increments after each move. The game ends when the step count reaches 31. Scoring is based on the total number of captures each player has made, with a linear scale where zero captures yield zero points and each capture increases the score by ten points up to a maximum of 100 points at ten captures; scores do not increase beyond ten captures. The player with the higher score at the end of the game is considered the winner. The game implicitly restricts movement and occupancy to within the board boundaries, forbids overlapping pieces of the same color, and requires that moves obey the specific geometric patterns described. No other explicit spawning rules are defined beyond the initial spawn points. Overall, the gameplay centers on moving pieces in orthogonal, diagonal, or knight-like patterns to capture opposing pieces, accumulating points, and alternating turns until the step limit is reached.",
    "output": "(role red)\n(role blue)\n(init (control red))\n(init (cell 1 4 red))\n(init (cell 7 4 blue))\n(init (step 1))\n(init (capture red 0))\n(init (capture blue 0))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasLegalMove ?player)))\n(<= (legal ?player noop)\n\t  (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player ?move)\n\t  (legal2 ?player ?move))\n(<= (hasLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(orthogonal ?x1 ?y1 ?x2 ?y2)\n\t(onboard ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?player2))\n\t(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(diagonal ?x1 ?y1 ?x2 ?y2)\n\t(onboard ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?player2))\n\t(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(ell ?x1 ?y1 ?x2 ?y2)\n\t(opencell ?x2 ?y2))\n(<= (next (control ?p2))\n\t(true (control ?p1))\n\t(rotation ?p1 ?p2))\n(<= (next (cell ?x2 ?y2 ?player))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?piece))\n\t(true (cell ?x ?y ?piece))\n\t(not (camefrom ?x ?y))\n\t(not (wentto ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n\t(spawns ?x ?y ?player))\n(<= (next (capture ?player ?count))\n\t(true (capture ?player ?count))\n\t(not (captured ?player)))\n(<= (next (capture ?player ?count2))\n\t(true (capture ?player ?count1))\n\t(captured ?player)\n\t(captureplus ?count1 ?count2))\n(<= (next (step ?t2))\n\t(true (step ?t1))\n\t(stepcount ?t1 ?t2))\n(<= terminal\n\t(true (step 31)))\n(<= (goal ?player ?goal)\n\t(true (capture ?player ?count))\n\t(scoremap ?count ?goal))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x1 ?x2)\n\t(index ?y))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x2 ?x1)\n\t(index ?y))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y1 ?y2))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y2 ?y1))\n(<= (opencell ?x ?y)\n\t(onboard ?x ?y)\n\t(not (true (cell ?x ?y red)))\n\t(not (true (cell ?x ?y blue))))\n(<= (onboard ?x ?y)\n\t(index ?x)\n\t(index ?y)\n\t(distinct ?x 1)\n\t(distinct ?x 7)\n\t(distinct ?y 1)\n\t(distinct ?y 7))\n(<= (camefrom ?x1 ?y1)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (wentto ?x2 ?y2)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (captured ?player)\n\t(true (control ?player))\n\t(wentto ?x ?y)\n\t(true (cell ?x ?y ?any)))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(plus 1 1 2)\n(plus 1 2 3)\n(plus 1 3 4)\n(plus 1 4 5)\n(plus 1 5 6)\n(plus 1 6 7)\n(plus 2 1 3)\n(plus 2 2 4)\n(plus 2 3 5)\n(plus 2 4 6)\n(plus 2 5 7)\n(rotation red blue)\n(rotation blue red)\n(spawns 1 4 red)\n(spawns 7 4 blue)\n(stepcount 1 2)\n(stepcount 2 3)\n(stepcount 3 4)\n(stepcount 4 5)\n(stepcount 5 6)\n(stepcount 6 7)\n(stepcount 7 8)\n(stepcount 8 9)\n(stepcount 9 10)\n(stepcount 10 11)\n(stepcount 11 12)\n(stepcount 12 13)\n(stepcount 13 14)\n(stepcount 14 15)\n(stepcount 15 16)\n(stepcount 16 17)\n(stepcount 17 18)\n(stepcount 18 19)\n(stepcount 19 20)\n(stepcount 20 21)\n(stepcount 21 22)\n(stepcount 22 23)\n(stepcount 23 24)\n(stepcount 24 25)\n(stepcount 25 26)\n(stepcount 26 27)\n(stepcount 27 28)\n(stepcount 28 29)\n(stepcount 29 30)\n(stepcount 30 31)\n(captureplus 0 1)\n(captureplus 1 2)\n(captureplus 2 3)\n(captureplus 3 4)\n(captureplus 4 5)\n(captureplus 5 6)\n(captureplus 6 7)\n(captureplus 7 8)\n(captureplus 8 9)\n(captureplus 9 10)\n(captureplus 10 10)\n(scoremap 0 0)\n(scoremap 1 10)\n(scoremap 2 20)\n(scoremap 3 30)\n(scoremap 4 40)\n(scoremap 5 50)\n(scoremap 6 60)\n(scoremap 7 70)\n(scoremap 8 80)\n(scoremap 9 90)\n(scoremap 10 100)\n(<= (lt ?n ?np1)\n    (distinct ?n ?np1)\n    (captureplus ?n ?np1))\n(<= (lt ?x ?z)\n    (distinct ?x ?z)\n    (captureplus ?x ?y)\n    (distinct ?x ?y)\n    (distinct ?y ?z)\n    (lt ?y ?z))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 10-by-10 grid where each cell is identified by coordinates ranging from 1 to 10 along both the x and y axes. There are two players, designated as white and black, who alternate taking turns. The initial setup places a white piece at cell (1,1) and a black piece at cell (10,10), with white having the first move control. Each turn consists of two phases: a move phase controlled by the player whose turn it is, followed by an attack phase controlled by the same player. During the move phase, the active player must move their piece according to a knight's move pattern—an L-shaped move similar to that in chess—such that the target cell is unoccupied by the opponent's piece. The move action is specified by the starting and ending cell coordinates of the piece being moved and is legal only if the moving player controls the piece at the starting cell and the target cell is not occupied by the opponent. After the move, control switches to the attack phase for the same player, during which the player may choose to perform an orthogonal or diagonal attack, or opt to do nothing (noop). An orthogonal attack targets an adjacent cell either horizontally or vertically, while a diagonal attack targets one adjacent cell diagonally. These attacks convert an opponent's piece in the targeted cell into an \"arrow,\" effectively neutralizing that piece. The attack actions are legal only if it is the attack phase for the acting player, and no conflict exists with the opponent's control. If the opponent controls either the move or attack phase, the player may also choose a noop action, effectively passing without making a move or attack. After the attack phase, control returns to the opponent's move phase, continuing the turn cycle. The board boundaries are strictly enforced; all moves and attacks must occur within cells numbered 1 through 10 in both dimensions. Pieces cannot move into or attack cells occupied by arrows, and no two pieces can occupy the same cell. The game ends when one player manages to have at least one cell occupied by an arrow while simultaneously still occupying a cell that the opponent also occupies with an arrow; more specifically, when there is a cell with an arrow and a cell occupied by the opponent's piece, the other player is declared the winner. Victory is awarded 100 points to the winning player and 0 to the loser. This means that a player's goal is to strategically maneuver their piece using knight moves and then attack orthogonally or diagonally to convert opposing pieces into arrows, thereby constraining the opponent's movement and achieving the terminal winning condition. The gameplay thus revolves around alternating between moving pieces in knight-like patterns and attacking adjacent cells, with the ability to pass turns during the opponent's control phases, all while respecting the 10x10 board limits and avoiding illegal moves onto occupied or out-of-bound cells.",
    "output": "(role white)\n(role black)\n(init (cell 1 1 white))\n(init (cell 10 10 black))\n(init (movecontrol white))\n(<= (legal ?role (move ?x1 ?y1 ?x2 ?y2))\n\t(true (movecontrol ?role))\n\t(true (cell ?x1 ?y1 ?role))\n\t(knightmove ?x1 ?y1 ?x2 ?y2)\n\t(opponent ?role ?opponent)\n\t(not (true (cell ?x2 ?y2 ?opponent))))\n(<= (legal ?role ortho)\n\t(true (attackcontrol ?role)))\n(<= (legal ?role diag)\n\t(true (attackcontrol ?role)))\n(<= (legal ?role noop)\n\t(true (attackcontrol ?opponent))\n\t(opponent ?opponent ?role))\n(<= (legal ?role noop)\n\t(true (movecontrol ?opponent))\n\t(opponent ?opponent ?role))\n(<= (next (attackcontrol ?opponent))\n\t(true (movecontrol ?role))\n\t(opponent ?role ?opponent))\n(<= (next (movecontrol ?role))\n\t(true (attackcontrol ?role)))\n(<= (next (cell ?x ?y ?state))\n\t(true (cell ?x ?y ?state))\n\t(does ?role ortho))\n(<= (next (cell ?x2 ?y2 arrow))\n\t(does ?role ortho)\n\t(opponent ?role ?opponent)\n\t(true (cell ?x1 ?y1 ?opponent))\n\t(orthogonal ?x1 ?y1 ?x2 ?y2))\n(<= (next (cell ?x ?y ?state))\n\t(true (cell ?x ?y ?state))\n\t(does ?role diag))\n(<= (next (cell ?x2 ?y2 arrow))\n\t(does ?role diag)\n\t(opponent ?role ?opponent)\n\t(true (cell ?x1 ?y1 ?opponent))\n\t(diagonal ?x1 ?y1 ?x2 ?y2))\n(<= (next (cell ?x ?y ?state))\n\t(true (cell ?x ?y ?state))\n\t(does ?role (move ?x1 ?y1 ?x2 ?y2))\n\t(distinctcell ?x ?y ?x1 ?y1))\n(<= (next (cell ?x1 ?y1 arrow))\n\t(does ?role (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x2 ?y2 ?role))\n\t(does ?role (move ?x1 ?y1 ?x2 ?y2)))\n(<= terminal\n\twhitewin)\n(<= terminal\n\tblackwin)\n(<= (goal white 100)\n\twhitewin)\n(<= (goal white 0)\n\tblackwin)\n(<= (goal black 100)\n\tblackwin)\n(<= (goal black 0)\n\twhitewin)\n(<= whitewin\n\t(true (cell ?x ?y black))\n\t(true (cell ?x ?y arrow)))\n(<= blackwin\n\t(true (cell ?x ?y white))\n\t(true (cell ?x ?y arrow)))\n(<= (knightmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y1 ?y2))\n(<= (knightmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y2 ?y1))\n(<= (knightmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y1 ?y2))\n(<= (knightmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y2 ?y1))\n(<= (knightmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (knightmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (knightmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (knightmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y1 ?y2))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y2 ?y1))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x1 ?x2)\n\t(index ?y))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x2 ?x1)\n\t(index ?y))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (onboard ?x ?y)\n\t(index ?x)\n\t(index ?y))\n(<= (distinctcell ?x1 ?y1 ?x2 ?y2)\n\t(onboard ?x1 ?y1)\n\t(onboard ?x2 ?y2)\n\t(distinct ?x1 ?x2))\n(<= (distinctcell ?x1 ?y1 ?x2 ?y2)\n\t(onboard ?x1 ?y1)\n\t(onboard ?x2 ?y2)\n\t(distinct ?y1 ?y2))\n(opponent white black)\n(opponent black white)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(plus 1 1 2)\n(plus 1 2 3)\n(plus 1 3 4)\n(plus 1 4 5)\n(plus 1 5 6)\n(plus 1 6 7)\n(plus 1 7 8)\n(plus 1 8 9)\n(plus 1 9 10)\n(plus 2 1 3)\n(plus 2 2 4)\n(plus 2 3 5)\n(plus 2 4 6)\n(plus 2 5 7)\n(plus 2 6 8)\n(plus 2 7 9)\n(plus 2 8 10)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game involves two players, designated as white and black, who alternate turns making moves within a maximum of 20 rounds, with the round count starting at zero. The game does not specify a spatial environment or coordinate system beyond the progression of rounds and scores. At the beginning, both players have a score of zero, and the round counter is set to zero. On each turn, both players simultaneously choose one of two possible actions: \"straight\" or \"swerve.\" These actions are legal as long as the current round number is less than the maximum of 20 rounds. The game advances the round count by one after each set of moves. The players’ scores change depending on the combination of their chosen actions in that round: if white goes straight while black swerves, white’s score increases by five and black’s by three; if black goes straight while white swerves, black’s score increases by five and white’s by three; if both swerve, both players gain four points; if both go straight, no scores change. The scoring increments occur only when the appropriate combinations of moves are made, and the scores never decrease. The game ends automatically when the round count reaches 20. At termination, each player’s goal value equals their final score, which serves as the victory criterion. There is no explicit mention of a spatial board, coordinates, or occupancy conflicts, and no \"noop\" or no-operation move is defined. The implicit constraints are that the game proceeds sequentially through rounds up to the maximum, moves must be chosen from the two specified actions, and scores update strictly according to the action combinations described. The player roles take turns simultaneously each round, and the game’s state consists solely of the current round and each player’s score, which evolve deterministically based on the players’ moves until the maximum rounds are reached and the final scores determine the outcome.",
    "output": "(role white)\n(role black)\n(maxRounds 20)\n(init (whiteScore 0))\n(init (blackScore 0))\n(init (round 0))\n(<= (legal black straight)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal black swerve)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal white straight)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (legal white swerve)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (next (round ?x1))\n    (true (round ?x))\n    (succ ?x ?x1))\n(<= (next (whiteScore ?x5))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?x4 ?x5)\n    (does white straight)\n    (does black swerve))\n(<= (next (blackScore ?x3))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (does white straight)\n    (does black swerve))\n(<= (next (blackScore ?x5))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?x4 ?x5)\n    (does black straight)\n    (does white swerve))\n(<= (next (whiteScore ?x3))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (does black straight)\n    (does white swerve))\n(<= (next (blackScore ?x4))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (does black swerve)\n    (does white swerve))\n(<= (next (whiteScore ?x4))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (does black swerve)\n    (does white swerve))\n(<= (next (blackScore ?x))\n    (true (blackScore ?x))\n    (does black straight)\n    (does white straight))\n(<= (next (whiteScore ?x))\n    (true (whiteScore ?x))\n    (does black straight)\n    (does white straight))\n(<= terminal\n\t(maxRounds ?x)\n    (true (round ?x)))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game takes place on a two-level board system with coordinates defined by indices 1 through 3 along both dimensions, effectively forming a 3x3 grid for each level. The smaller board consists of nine cells arranged in a 3x3 matrix where each cell can be empty or marked by either player 'x' or player 'o'. The larger board overlays this with an additional level of 3x3 grids, each containing its own 3x3 grid of cells, thus creating a nested board structure. The two players, named xplayer and oplayer, alternate turns starting with xplayer controlling both the small and large boards initially. On each turn, a player may either perform a marking action on the small board or play a move on the large board, depending on which board they currently control. The initial state has all small board cells empty and xplayer in control of both boards. Turn control alternates between the two players for both the small and large board actions. Players may also choose to pass by performing a noop action, which is always legal. Actions must conform to specific formats: marking a small cell is legal only if that cell is empty and the player currently controls the small board; playing a large board move involves specifying coordinates for the larger grid and the inner cell to mark, and is legal only if that cell is empty and either it is the first move or the move corresponds to the current board or the current board is closed (i.e., fully occupied). When a player marks a cell on the small board, that cell's state updates to the player's mark; similarly, playing on the large board updates the corresponding cell. Control switches to the opposing player after each move. The game enforces implicit constraints such as boundaries of the 3x3 grids at both levels, ensuring moves occur only within valid coordinates, and cells cannot be marked if already occupied. The game detects winning conditions by checking for any completed row, column, or diagonal of identical marks either on the small or the large boards. The game terminates when either player forms such a line on either board or when no empty cells remain on the respective board. Victory is scored by assigning 100 points to the player who completes a line, 0 points to the opponent, and 50 points to both if the board is full without a winning line. These goals are evaluated separately for the small and large boards, and the terminal condition arises from either board reaching a terminal state. Thus, the game combines nested board mechanics with turn-based marking, alternating control, and line-completion victory conditions on both small and large board levels.",
    "output": "( role xplayer)\n( role oplayer)\n( init ( cell_small 1 1 b ) )\n( init ( cell_small 1 2 b ) )\n( init ( cell_small 1 3 b ) )\n( init ( cell_small 2 1 b ) )\n( init ( cell_small 2 2 b ) )\n( init ( cell_small 2 3 b ) )\n( init ( cell_small 3 1 b ) )\n( init ( cell_small 3 2 b ) )\n( init ( cell_small 3 3 b ) )\n( init ( control_small xplayer ) )\n( init ( control_large xplayer ) )\n( index 1 )\n( index 2 )\n( index 3 )\n( <= ( next ( cell_small ?m ?n x ) ) ( does xplayer ( mark_small ?m ?n) ) ( true ( cell_small ?m ?n b ) ) )\n( <= ( next ( cell_small ?m ?n o ) ) ( does oplayer ( mark_small ?m ?n) ) ( true ( cell_small ?m ?n b ) ) )\n( <= ( next ( cell_small ?m ?n ?w ) ) ( true ( cell_small ?m ?n ?w ) ) ( distinct ?w b ) )\n( <= ( next ( cell_small ?m ?n b ) ) ( true ( cell_small ?m ?n b ) ) ( true ( control_small ?player ) ) ( not ( does ?player ( mark_small ?m ?n) ) ) )\n( <= ( next ( mark_large ?i ?j ?k ?l ?m ) ) ( role ?player ) ( does ?player ( play_large ?i ?j ?k ?l ?m ) ) )\n( <= ( next ( mark_large ?i ?j ?k ?l ?m ) ) ( true ( mark_large ?i ?j ?k ?l ?m ) ) )\n( <= ( next ( current_board ?k ?l ) ) ( role ?player ) ( does ?player ( play_large ?i ?j ?k ?l ?m ) ) )\n( <= ( next ( control_small oplayer ) ) ( true ( control_small xplayer ) ) )\n( <= ( next ( control_small xplayer ) ) ( true ( control_small oplayer ) ) )\n( <= ( next ( control_large xplayer ) ) ( true ( control_large oplayer ) ) )\n( <= ( next ( control_large oplayer) ) ( true ( control_large xplayer ) ) )\n( <= ( row_small ?m ?x ) ( true ( cell_small ?m 1 ?x ) )\n  ( true ( cell_small ?m 2 ?x ) ) ( true ( cell_small ?m 3 ?x ) ) )\n( <= ( col_small ?n ?x ) ( true ( cell_small 1 ?n ?x ) )\n  ( true ( cell_small 2 ?n ?x ) ) ( true ( cell_small 3 ?n ?x ) ) )\n( <= ( diag_small ?x ) ( true ( cell_small 1 1 ?x ) )\n  ( true ( cell_small 2 2 ?x ) ) ( true ( cell_small 3 3 ?x ) ) )\n( <= ( diag_small ?x ) ( true ( cell_small 1 3 ?x ) )\n  ( true ( cell_small 2 2 ?x ) ) ( true ( cell_small 3 1 ?x ) ) )\n( <= ( line_small ?x ) ( row_small ?m ?x ) )\n( <= ( line_small ?x ) ( col_small ?m ?x ) )\n( <= ( line_small ?x ) ( diag_small ?x ) )\n( <= open_small ( true ( cell_small ?m ?n b ) ) )\n( <= ( legal ?p noop) ( role ?p ) )\n( <= ( legal ?w ( mark_small ?x ?y ) ) ( true ( cell_small ?x ?y b ) ) ( true ( control_small ?w ) ) )\n( <= ( legal xplayer ( play_large ?i ?j ?k ?l x ) ) ( true ( control_large xplayer ) ) first_move_large ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal xplayer ( play_large ?i ?j ?k ?l x ) ) ( true ( control_large xplayer ) ) ( true ( current_board ?i ?j ) ) ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal xplayer ( play_large ?i ?j ?k ?l x ) ) ( true ( control_large xplayer ) ) cur_board_closed_large ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal oplayer ( play_large ?i ?j ?k ?l o ) ) ( true ( control_large oplayer ) ) first_move_large ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal oplayer ( play_large ?i ?j ?k ?l o ) ) ( true ( control_large oplayer ) ) ( true ( current_board ?i ?j ) ) ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( legal oplayer ( play_large ?i ?j ?k ?l o ) ) ( true ( control_large oplayer ) ) cur_board_closed_large ( empty_cell_large ?i ?j ?k ?l ) )\n( <= ( goal_small xplayer 100 ) ( line_small x ) )\n( <= ( goal_small xplayer 50 ) ( not ( line_small x ) )\n  ( not ( line_small o ) ) ( not open_small ) )\n( <= ( goal_small xplayer 0 ) ( line_small o ) )\n( <= ( goal_small oplayer 100 ) ( line_small o ) )\n( <= ( goal_small oplayer 50 ) ( not ( line_small x ) )\n  ( not ( line_small o ) ) ( not open_small ) )\n( <= ( goal_small oplayer 0 ) ( line_small x ) )\n( <= ( goal_large xplayer 0 ) ( not ( line_large x ) ) ( not ( line_large o ) ) open_large )\n( <= ( goal_large xplayer 100 ) ( line_large x ) )\n( <= ( goal_large xplayer 50 ) ( not ( line_large x ) ) ( not ( line_large o ) ) ( not open_large ) )\n( <= ( goal_large xplayer 0 ) ( line_large o ) )\n( <= ( goal_large oplayer 0 ) ( not ( line_large x ) ) ( not ( line_large o ) ) open_large )\n( <= ( goal_large oplayer 100 ) ( line_large o ) )\n( <= ( goal_large oplayer 50 ) ( not ( line_large x ) ) ( not ( line_large o ) ) ( not open_large ) )\n( <= ( goal_large oplayer 0 ) ( line_large x ) )\n( <= ( goal xplayer 100 ) ( goal_large xplayer 100 ) terminal_large )\n( <= ( goal xplayer 100 ) ( goal_small xplayer 100 ) terminal_small )\n( <= ( goal xplayer 50 ) ( goal_large xplayer 50 ) terminal_large )\n( <= ( goal xplayer 50 ) ( goal_small xplayer 50 ) terminal_small )\n( <= ( goal xplayer 0 ) ( goal_large xplayer 0 ) terminal_large )\n( <= ( goal xplayer 0 ) ( goal_small xplayer 0 ) terminal_small )\n( <= ( goal oplayer 100 ) ( goal_large oplayer 100 ) terminal_large )\n( <= ( goal oplayer 100 ) ( goal_small oplayer 100 ) terminal_small )\n( <= ( goal oplayer 50 ) ( goal_large oplayer 50 ) terminal_large )\n( <= ( goal oplayer 50 ) ( goal_small oplayer 50 ) terminal_small )\n( <= ( goal oplayer 0 ) ( goal_large oplayer 0 ) terminal_large )\n( <= ( goal oplayer 0 ) ( goal_small oplayer 0 ) terminal_small )\n( <= terminal_small ( line_small x ) )\n( <= terminal_small ( line_small o ) )\n( <= terminal_small ( not open_small ) )\n( <= ( empty_cell_large ?i ?j ?k ?l ) ( index ?i ) ( index ?j ) ( index ?k ) ( index ?l ) ( not ( true ( mark_large ?i ?j ?k ?l x ) ) ) ( not ( true ( mark_large ?i ?j ?k ?l o ) ) ) )\n( <= open_large ( index ?i ) ( index ?j ) ( index ?k ) ( index ?l ) ( empty_cell_large ?i ?j ?k ?l ) )\n( <= terminal_large ( line_large x ) )\n( <= terminal_large ( line_large o ) )\n( <= terminal_large ( not open_large ) )\n( <= terminal terminal_small )\n( <= terminal terminal_large )\n( <= ( row_large ?i ?j ?k ?m ) ( true ( mark_large ?i ?j ?k 1 ?m ) ) ( true ( mark_large ?i ?j ?k 2 ?m ) ) ( true ( mark_large ?i ?j ?k 3 ?m ) ) )\n( <= ( col_large ?i ?j ?k ?m ) ( true ( mark_large ?i ?j 1 ?k ?m ) ) ( true ( mark_large ?i ?j 2 ?k ?m ) ) ( true ( mark_large ?i ?j 3 ?k ?m ) ) )\n( <= ( diag_large ?i ?j ?m ) ( true ( mark_large ?i ?j 1 1 ?m ) ) ( true ( mark_large ?i ?j 2 2 ?m ) ) ( true ( mark_large ?i ?j 3 3 ?m ) ) )\n( <= ( diag_large ?i ?j ?m ) ( true ( mark_large ?i ?j 1 3 ?m ) ) ( true ( mark_large ?i ?j 2 2 ?m ) ) ( true ( mark_large ?i ?j 3 1 ?m ) ) )\n( <= ( line_large ?m ) ( index ?i ) ( index ?j ) ( index ?k ) ( row_large ?i ?j ?k ?m ) )\n( <= ( line_large ?m ) ( index ?i ) ( index ?j ) ( index ?k ) ( col_large ?i ?j ?k ?m ) )\n( <= ( line_large ?m ) ( index ?i ) ( index ?j ) ( diag_large ?i ?j ?m ) )\n( <= cur_board_closed_large ( true ( current_board ?i ?j ) ) ( not ( empty_cell_large ?i ?j 1 1 ) ) ( not ( empty_cell_large ?i ?j 1 2 ) ) ( not ( empty_cell_large ?i ?j 1 3 ) ) ( not ( empty_cell_large ?i ?j 2 1 ) ) ( not ( empty_cell_large ?i ?j 2 2 ) ) ( not ( empty_cell_large ?i ?j 2 3 ) ) ( not ( empty_cell_large ?i ?j 3 1 ) ) ( not ( empty_cell_large ?i ?j 3 2 ) ) ( not ( empty_cell_large ?i ?j 3 3 ) ) )\n( <= first_move_large ( not ( true ( current_board 1 1 ) ) ) ( not ( true ( current_board 1 2 ) ) ) ( not ( true ( current_board 1 3 ) ) ) ( not ( true ( current_board 2 1 ) ) ) ( not ( true ( current_board 2 2 ) ) ) ( not ( true ( current_board 2 3 ) ) ) ( not ( true ( current_board 3 1 ) ) ) ( not ( true ( current_board 3 2 ) ) ) ( not ( true ( current_board 3 3 ) ) ) )"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 4-by-4 grid with cells labeled from a1 to d4, organized such that columns run from 'a' to 'd' and rows from '1' to '4', with adjacency defined by cells being directly to the left or directly above another. Each cell is assigned a distinct color from red, green, yellow, and blue in a fixed pattern. There are two players, designated as white and black, who alternate turns starting with white. The initial configuration places the white player’s piece on cell a1, the black player's piece on cell d4, and all other cells are occupied by a neutral marker 'b'. Additionally, there are eight spots labeled s1 through s8, each associated with one of the four colors and initially owned by one of the players—white owns the red, green, yellow, and green spots s1 through s4, and black owns the yellow, yellow, blue, and blue spots s5 through s8. Two \"open\" slots named tw and tb start blank and are used to hold offers during the game. The game proceeds in discrete steps numbered from 1 to 10. On a player's turn, they may perform one of several legal actions: moving their piece from its current cell to an adjacent cell that is either directly left or above (in either direction) provided that the destination cell's color matches a spot owned by that player; offering a pair of spots (one owned by white and one owned by black) to be exchanged by placing them in the tw and tb open slots, respectively; accepting an offer when an offer is pending (i.e., when tw and tb contain non-blank spots); or passing. Moves result in the player's piece occupying the destination cell and the previous cell becoming neutral; offers place the selected spots into the open slots without changing the board; acceptance swaps the ownership of the two offered spots, updating the players’ spot ownership accordingly; passing leaves the state unchanged. Turn control alternates strictly between white and black each step. The game enforces implicit constraints such as the board boundaries which prevent moves outside the defined 4x4 grid and requires moves only between orthogonally adjacent cells. The noop mechanism is effectively represented by the pass action, allowing players to skip their turn if desired. The game terminates when either a player moves their piece onto cell a4, which immediately grants that player a victory with a score of 100, or when ten steps have elapsed without such an event, ending the game. The victory condition is solely determined by occupying cell a4; the player controlling that cell wins, while all other players receive zero points. Thus, the goal for each player is to maneuver their piece strategically across the board leveraging their spot ownership to move only onto cells matching colors of spots they own, potentially exchanging spots with the opponent through offers and acceptances to gain more advantageous movement options, all while aiming to reach cell a4 first or prevent the opponent from doing so within the allotted steps.",
    "output": "(role white)\n    (role black)\n    (init (cell a1 white))\n    (init (cell a2 b))\n    (init (cell a3 b))\n    (init (cell a4 b))\n    (init (cell b1 b))\n    (init (cell b2 b))\n    (init (cell b3 b))\n    (init (cell b4 b))\n    (init (cell c1 b))\n    (init (cell c2 b))\n    (init (cell c3 b))\n    (init (cell c4 b))\n    (init (cell d1 b))\n    (init (cell d2 b))\n    (init (cell d3 b))\n    (init (cell d4 black))\n    (init (open tw blank))\n    (init (open tb blank))\n    (init (spot s1 red))\n    (init (spot s2 red))\n    (init (spot s3 green))\n    (init (spot s4 green))\n    (init (spot s5 yellow))\n    (init (spot s6 yellow))\n    (init (spot s7 blue))\n    (init (spot s8 blue))\n    (init (control white))\n    (init (step 1))\n    (<= (next (cell ?y ?player))\n        (does ?player (move ?x ?y)))\n    (<= (next (cell ?x b))\n        (does ?player (move ?x ?y)))\n    (<= (next (cell ?z ?q))\n        (does ?player (move ?x ?y))\n        (true (cell ?z ?q))\n        (distinct ?z ?x)\n        (distinct ?z ?y))\n    (<= (next (cell ?x ?q))\n        (does ?player (offer ?t1 ?t2))\n        (true (cell ?x ?q)))\n    (<= (next (cell ?x ?q))\n        (does ?player accept)\n        (true (cell ?x ?q)))\n    (<= (next (cell ?x ?q))\n        (does white pass)\n        (does black pass)\n        (true (cell ?x ?q)))\n    (<= (next (open tw blank))\n        (does ?player (move ?x ?y)))\n    (<= (next (open tb blank))\n        (does ?player (move ?x ?y)))\n    (<= (next (open tw ?s1))\n        (does ?player (offer ?s1 ?s2)))\n    (<= (next (open tb ?s2))\n        (does ?player (offer ?s1 ?s2)))\n    (<= (next (open tw blank))\n        (does ?player accept))\n    (<= (next (open tb blank))\n        (does ?player accept))\n    (<= (next (open tw blank))\n        (does white pass))\n    (<= (next (open tb blank))\n        (does white pass))\n    (<= (next (spot ?s ?c))\n        (does ?player (move ?x ?y))\n        (true (spot ?s ?c)))\n    (<= (next (spot ?s ?c))\n        (does ?player (offer ?s1 ?s2))\n        (true (spot ?s ?c)))\n    (<= (next (spot ?s1 ?c))\n        (does ?player accept)\n        (true (open tw ?s1))\n        (true (open tb ?s2))\n        (true (spot ?s2 ?c)))\n    (<= (next (spot ?s2 ?c))\n        (does ?player accept)\n        (true (open tw ?s1))\n        (true (open tb ?s2))\n        (true (spot ?s1 ?c)))\n    (<= (next (spot ?s ?c))\n        (does ?player accept)\n        (true (spot ?s ?c))\n        (true (open tw ?s1))\n        (true (open tb ?s2))\n        (distinct ?s ?s1)\n        (distinct ?s ?s2))\n    (<= (next (spot ?s ?c))\n        (does white pass)\n        (does black pass)\n        (true (spot ?s ?c)))\n    (<= (next (control white))\n        (true (control black)))\n    (<= (next (control black))\n        (true (control white)))\n    (<= (next (step ?y))\n        (true (step ?x))\n        (successor ?x ?y))\n    (color a1 red)\n    (color a2 green)\n    (color a3 yellow)\n    (color a4 blue)\n    (color b1 blue)\n    (color b2 yellow)\n    (color b3 green)\n    (color b4 red)\n    (color c1 yellow)\n    (color c2 green)\n    (color c3 red)\n    (color c4 blue)\n    (color d1 blue)\n    (color d2 red)\n    (color d3 green)\n    (color d4 yellow)\n    (successor 1 2)\n    (successor 2 3)\n    (successor 3 4)\n    (successor 4 5)\n    (successor 5 6)\n    (successor 6 7)\n    (successor 7 8)\n    (successor 8 9)\n    (successor 9 10)\n    (<= (legal ?player (move ?x ?y))\n        (true (control ?player))\n        (true (cell ?x ?player))\n        (movable ?x ?y)\n        (movable ?x ?y)\n        (color ?y ?c)\n        (true (spot ?s ?c))\n        (owner ?s ?player))\n    (<= (legal ?player (offer ?s1 ?s2))\n        (true (control ?player))\n        (owner ?s1 white)\n        (owner ?s2 black))\n    (<= (legal ?player accept)\n        (true (control ?player))\n        (true (open tw ?c))\n        (distinct ?c blank))\n    (<= (legal ?player pass)\n    \t(role ?player))\n    (<= (movable ?x ?y)\n        (or (left ?x ?y) (left ?y ?x)))\n    (<= (movable ?x ?y)\n        (or (above ?x ?y) (above ?y ?x)))\n    (owner s1 white)\n    (owner s2 white)\n    (owner s3 white)\n    (owner s4 white)\n    (owner s5 black)\n    (owner s6 black)\n    (owner s7 black)\n    (owner s8 black)\n    (left a1 a2)\n    (left a2 a3)\n    (left a3 a4)\n    (left b1 b2)\n    (left b2 b3)\n    (left b3 b4)\n    (left c1 c2)\n    (left c2 c3)\n    (left c3 c4)\n    (left d1 d2)\n    (left d2 d3)\n    (left d3 d4)\n    (above a1 b1)\n    (above b1 c1)\n    (above c1 d1)\n    (above a2 b2)\n    (above b2 c2)\n    (above c2 d2)\n    (above a3 b3)\n    (above b3 c3)\n    (above c3 d3)\n    (above a4 b4)\n    (above b4 c4)\n    (above c4 d4)\n    (<= (goal ?player 100)\n        (true (cell a4 ?player))\n        (distinct ?player b))\n    (<= (goal ?player 0)\n        (true (cell ?x ?player))\n        (distinct ?x a4))\n    (<= terminal\n        (true (step 10)))\n    (<= terminal\n        (goal ?player 100))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a rectangular grid defined by rows labeled from 'a' to 'g' and columns labeled from 'c1' to 'c7', establishing a coordinate system where each position on the board is identified by a row and column pair. The sole player role is called \"jumper,\" and as there is only one player, turns proceed in a single-player sequence where the player repeatedly makes moves or chooses to perform no action if no legal moves are available. The initial state consists of pegs occupying all holes on the board except for the hole at row 'd' and column 'c4', which starts empty; the board thus begins nearly full with one vacant spot. The player takes turns by making a single move each turn, which involves jumping a peg over an adjacent peg into an empty hole directly on the other side; if no such moves exist, the game reaches a terminal state automatically. Each action is specified by the command \"jump\" followed by four coordinates: the starting row and column of the peg to be moved, and the destination row and column of the empty hole. A jump is legal only if the starting hole contains a peg, the destination hole is empty, and there is exactly one peg located between the start and destination positions either horizontally or vertically, with the intermediate position lying directly between them. The coordinate system enforces adjacency and directionality through successor and predecessor relations on both rows and columns, ensuring that jumps occur strictly over one intermediate peg in a straight line either along the same row or the same column, and no diagonal jumps are allowed. Executing a jump results in the peg at the starting hole moving to the destination hole, the intermediate peg being removed (the hole becoming empty), and the starting hole becoming empty; all other holes retain their previous state. The game automatically updates the state after each move, decrementing the count of pegs on the board. No overlapping is possible as pegs cannot occupy the same hole, and all moves must remain within the defined board boundaries. The game terminates when there are no more legal jumps available, indicating no further moves can be made. Scoring is based on the remaining number of pegs on the board: the player achieves the highest score of 100 points if a peg ends up in the central hole at row 'd' and column 'c4' with only one peg remaining, indicating an optimal solution; slightly lower scores are assigned for fewer pegs remaining but without the central peg, and progressively lower scores correspond to increasing numbers of pegs left on the board. If no pegs remain or the count exceeds certain thresholds, the score decreases accordingly down to zero, rewarding the player for minimizing the pegs through valid jumps and ideally ending with the final peg in the center hole.",
    "output": "(role jumper)\n   (init (hole a c3 peg))\n   (init (hole a c4 peg))\n   (init (hole a c5 peg))\n   (init (hole b c2 peg))\n   (init (hole b c3 peg))\n   (init (hole b c4 peg))\n   (init (hole b c5 peg))\n   (init (hole b c6 peg))\n   (init (hole c c1 peg))\n   (init (hole c c2 peg))\n   (init (hole c c3 peg))\n   (init (hole c c4 peg))\n   (init (hole c c5 peg))\n   (init (hole c c6 peg))\n   (init (hole c c7 peg))\n   (init (hole d c1 peg))\n   (init (hole d c2 peg))\n   (init (hole d c3 peg))\n   (init (hole d c4 empty))\n   (init (hole d c5 peg))\n   (init (hole d c6 peg))\n   (init (hole d c7 peg))\n   (init (hole e c1 peg))\n   (init (hole e c2 peg))\n   (init (hole e c3 peg))\n   (init (hole e c4 peg))\n   (init (hole e c5 peg))\n   (init (hole e c6 peg))\n   (init (hole e c7 peg))\n   (init (hole f c2 peg))\n   (init (hole f c3 peg))\n   (init (hole f c4 peg))\n   (init (hole f c5 peg))\n   (init (hole f c6 peg))\n   (init (hole g c3 peg))\n   (init (hole g c4 peg))\n   (init (hole g c5 peg))\n   (init (pegs s36))\n   (<= (next (pegs ?x))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (pegs ?y))\n       (succ ?x ?y))\n   (<= (next (hole ?sr ?sc empty))\n       (does jumper (jump ?sr ?sc ?dr ?dc)))\n   (<= (next (hole ?or ?oc empty))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (middle ?sr ?sc ?or ?oc ?dr ?dc))\n   (<= (next (hole ?dr ?dc peg))\n       (does jumper (jump ?sr ?sc ?dr ?dc)))\n   (<= (next (hole ?x ?y empty))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?x ?y empty))\n       (distinct ?x ?dr))\n   (<= (next (hole ?x ?y empty))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?x ?y empty))\n       (distinct ?y ?dc))\n   (<= (next (hole ?x ?y peg))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?x ?y peg))\n       (distinct ?x ?sr)\n       (middle ?sr ?sc ?or ?oc ?dr ?dc)\n       (distinct ?x ?or))\n   (<= (next (hole ?x ?y peg))\n       (does jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?x ?y peg))\n       (distinct ?y ?sc)\n       (middle ?sr ?sc ?or ?oc ?dr ?dc)\n       (distinct ?y ?oc))\n   (<= (middle ?row ?sc ?row ?oc ?row ?dc)\n       (pc ?sc ?oc)\n       (nc ?dc ?oc)\n       (row ?row))\n   (<= (middle ?row ?sc ?row ?oc ?row ?dc)\n       (nc ?sc ?oc)\n       (pc ?dc ?oc)\n       (row ?row))\n   (<= (middle ?sr ?col ?or ?col ?dr ?col)\n       (pr ?sr ?or)\n       (nr ?dr ?or)\n       (column ?col))\n   (<= (middle ?sr ?col ?or ?col ?dr ?col)\n       (nr ?sr ?or)\n       (pr ?dr ?or)\n       (column ?col))\n   (nc c1 c2)\n   (nc c2 c3)\n   (nc c3 c4)\n   (nc c4 c5)\n   (nc c5 c6)\n   (nc c6 c7)\n   (pc c2 c1)\n   (pc c3 c2)\n   (pc c4 c3)\n   (pc c5 c4)\n   (pc c6 c5)\n   (pc c7 c6)\n   (column c1)\n   (column c2)\n   (column c3)\n   (column c4)\n   (column c5)\n   (column c6)\n   (column c7)\n   (nr a b)\n   (nr b c)\n   (nr c d)\n   (nr d e)\n   (nr e f)\n   (nr f g)\n   (pr b a)\n   (pr c b)\n   (pr d c)\n   (pr e d)\n   (pr f e)\n   (pr g f)\n   (row a)\n   (row b)\n   (row c)\n   (row d)\n   (row e)\n   (row f)\n   (row g)\n   (<= (legal jumper (jump ?sr ?sc ?dr ?dc))\n       (true (hole ?sr ?sc peg))\n       (true (hole ?dr ?dc empty))\n       (middle ?sr ?sc ?or ?oc ?dr ?dc)\n       (true (hole ?or ?oc peg)))\n   (<= moveable\n       (true (hole ?sr ?sc peg))\n       (true (hole ?dr ?dc empty))\n       (middle ?sr ?sc ?or ?oc ?dr ?dc)\n       (true (hole ?or ?oc peg)))\n   (<= (goal jumper 100)\n       (true (hole d c4 peg))\n       (true (pegs s1)))\n   (<= (goal jumper 99)\n       (true (hole ?row ?col peg))\n       (true (pegs s1))\n       (distinct ?row d))\n   (<= (goal jumper 99)\n       (true (hole ?row ?col peg))\n       (true (pegs s1))\n       (distinct ?col c4))\n   (<= (goal jumper 100)\n       (true (pegs s2)))\n   (<= (goal jumper 90)\n       (true (pegs s3)))\n   (<= (goal jumper 80)\n       (true (pegs s4)))\n   (<= (goal jumper 70)\n       (true (pegs s5)))\n   (<= (goal jumper 60)\n       (true (pegs s6)))\n   (<= (goal jumper 50)\n       (true (pegs s7)))\n   (<= (goal jumper 40)\n       (true (pegs s8)))\n   (<= (goal jumper 30)\n       (true (pegs s9)))\n   (<= (goal jumper 20)\n       (true (pegs s10)))\n   (<= (goal jumper 10)\n       (true (pegs s11)))\n   (<= (goal jumper 0)\n       (true (pegs ?x))\n       (distinct ?x s11)\n       (distinct ?x s10)\n       (distinct ?x s9)\n       (distinct ?x s8)\n       (distinct ?x s7)\n       (distinct ?x s6)\n       (distinct ?x s5)\n       (distinct ?x s4)\n       (distinct ?x s3)\n       (distinct ?x s2)\n       (distinct ?x s1))\n   (succ s1 s2)\n   (succ s2 s3)\n   (succ s3 s4)\n   (succ s4 s5)\n   (succ s5 s6)\n   (succ s6 s7)\n   (succ s7 s8)\n   (succ s8 s9)\n   (succ s9 s10)\n   (succ s10 s11)\n   (succ s11 s12)\n   (succ s12 s13)\n   (succ s13 s14)\n   (succ s14 s15)\n   (succ s15 s16)\n   (succ s16 s17)\n   (succ s17 s18)\n   (succ s18 s19)\n   (succ s19 s20)\n   (succ s20 s21)\n   (succ s21 s22)\n   (succ s22 s23)\n   (succ s23 s24)\n   (succ s24 s25)\n   (succ s25 s26)\n   (succ s26 s27)\n   (succ s27 s28)\n   (succ s28 s29)\n   (succ s29 s30)\n   (succ s30 s31)\n   (succ s31 s32)\n   (succ s32 s33)\n   (succ s33 s34)\n   (succ s34 s35)\n   (succ s35 s36)\n   (<= terminal\n       (not moveable))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a three-dimensional grid consisting of 3 blocks arranged along the first dimension, each block containing 3 rows and 3 columns, and each cell within this 3x3 structure can hold a digit from 1 to 9 or be blank. The coordinate system uses four indices: the first two indices specify the block's position in a 3x3 arrangement (with values 1 to 3), and the last two indices specify the cell's row and column within that block (also from 1 to 3). There is a single player role called \"robot,\" who takes turns making moves in a sequential manner; since there is only one player, the turn order is trivially that player acting repeatedly. The game begins with a partially filled Sudoku-like board state where some cells hold digits and others are blank. On the robot's turn, it may perform a \"mark\" action, which involves placing a digit from 1 to 9 into a blank cell; this action is legal only if the chosen cell is currently blank and the digit does not already appear in the same row (across all blocks in that row), in the same column (across all blocks in that column), or in the same 3x3 \"square\" block. The player may also implicitly perform no operation if no legal move is possible, as moves must correspond to legal markings. Each mark action updates the cell's value to the chosen digit, changing the game state accordingly; all other cells remain unaffected. Implicit constraints include the fixed 3x3 grid structure within each block and the prohibition against repeating digits in rows, columns, and blocks, mirroring Sudoku rules, with the entire game board comprising multiple such blocks arranged in a 3x3 layout. The game terminates when no further legal moves are available, meaning no blank cells remain or no digit can be legally placed. The scoring is binary: the player receives a score of 100 if the board is completely filled with no blank cells, indicating a correctly completed puzzle, and a score of 0 otherwise. Thus, victory is achieved by successfully filling the entire board according to the Sudoku constraints encoded in the legality conditions.",
    "output": "(role robot)\n  (init (cell 1 1 1 1 9))\n  (init (cell 1 1 1 2 7))\n  (init (cell 1 1 1 3 b))\n  (init (cell 1 1 2 1 3))\n  (init (cell 1 1 2 2 b))\n  (init (cell 1 1 2 3 4))\n  (init (cell 1 1 3 1 b))\n  (init (cell 1 1 3 2 6))\n  (init (cell 1 1 3 3 5))\n  (init (cell 1 2 1 1 b))\n  (init (cell 1 2 1 2 2))\n  (init (cell 1 2 1 3 b))\n  (init (cell 1 2 2 1 5))\n  (init (cell 1 2 2 2 b))\n  (init (cell 1 2 2 3 6))\n  (init (cell 1 2 3 1 b))\n  (init (cell 1 2 3 2 8))\n  (init (cell 1 2 3 3 b))\n  (init (cell 1 3 1 1 b))\n  (init (cell 1 3 1 2 b))\n  (init (cell 1 3 1 3 b))\n  (init (cell 1 3 2 1 b))\n  (init (cell 1 3 2 2 b))\n  (init (cell 1 3 2 3 b))\n  (init (cell 1 3 3 1 b))\n  (init (cell 1 3 3 2 b))\n  (init (cell 1 3 3 3 b))\n  (init (cell 2 1 1 1 b))\n  (init (cell 2 1 1 2 b))\n  (init (cell 2 1 1 3 5))\n  (init (cell 2 1 2 1 8))\n  (init (cell 2 1 2 2 b))\n  (init (cell 2 1 2 3 2))\n  (init (cell 2 1 3 1 9))\n  (init (cell 2 1 3 2 b))\n  (init (cell 2 1 3 3 b))\n  (init (cell 2 2 1 1 b))\n  (init (cell 2 2 1 2 b))\n  (init (cell 2 2 1 3 2))\n  (init (cell 2 2 2 1 b))\n  (init (cell 2 2 2 2 4))\n  (init (cell 2 2 2 3 b))\n  (init (cell 2 2 3 1 3))\n  (init (cell 2 2 3 2 b))\n  (init (cell 2 2 3 3 b))\n  (init (cell 2 3 1 1 b))\n  (init (cell 2 3 1 2 b))\n  (init (cell 2 3 1 3 8))\n  (init (cell 2 3 2 1 7))\n  (init (cell 2 3 2 2 b))\n  (init (cell 2 3 2 3 5))\n  (init (cell 2 3 3 1 1))\n  (init (cell 2 3 3 2 b))\n  (init (cell 2 3 3 3 b))\n  (init (cell 3 1 1 1 b))\n  (init (cell 3 1 1 2 b))\n  (init (cell 3 1 1 3 b))\n  (init (cell 3 1 2 1 b))\n  (init (cell 3 1 2 2 b))\n  (init (cell 3 1 2 3 b))\n  (init (cell 3 1 3 1 b))\n  (init (cell 3 1 3 2 b))\n  (init (cell 3 1 3 3 b))\n  (init (cell 3 2 1 1 b))\n  (init (cell 3 2 1 2 6))\n  (init (cell 3 2 1 3 b))\n  (init (cell 3 2 2 1 2))\n  (init (cell 3 2 2 2 b))\n  (init (cell 3 2 2 3 8))\n  (init (cell 3 2 3 1 b))\n  (init (cell 3 2 3 2 3))\n  (init (cell 3 2 3 3 b))\n  (init (cell 3 3 1 1 8))\n  (init (cell 3 3 1 2 4))\n  (init (cell 3 3 1 3 b))\n  (init (cell 3 3 2 1 1))\n  (init (cell 3 3 2 2 b))\n  (init (cell 3 3 2 3 9))\n  (init (cell 3 3 3 1 b))\n  (init (cell 3 3 3 2 2))\n  (init (cell 3 3 3 3 7))\n  (<= (legal robot (mark ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l b))\n      (digit ?x)\n      (not (row ?k ?l ?x))\n      (not (col ?i ?j ?x))\n      (not (square ?i ?k ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 3 ?k ?l ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 3 ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?i ?j ?k ?l ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?s ?i))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?t ?j))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?u ?k))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?v ?l))\n  (<= (goal robot 100) (not open))\n  (<= (goal robot 0) open)\n  (<= terminal (not playable))\n  (<= (filler ?x) (digit ?x))\n  (filler b)\n  (<= open (true (cell ?i ?j ?k ?l b)))\n  (<= playable (legal robot (mark ?i ?j ?k ?l ?x)))\n  (index 1)\n  (index 2)\n  (index 3)\n  (digit 1)\n  (digit 2)\n  (digit 3)\n  (digit 4)\n  (digit 5)\n  (digit 6)\n  (digit 7)\n  (digit 8)\n  (digit 9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 4-by-4 grid with coordinates labeled from 'a' to 'd' horizontally and from 1 to 4 vertically, where the columns proceed in order a, b, c, d and rows proceed numerically from 1 to 4. Two players, White and Black, alternate turns, with White moving first, controlling the white pieces initially. The initial board setup places the white king at c1, the white rook at d1, the black king at a4, and all other cells are empty. The game proceeds in steps, starting at step 1 and incrementing by one each turn, with the game terminating either when 10 steps have been completed or when a player is stuck and unable to move. On White's turn, the player may move either the white king or the white rook to an unoccupied cell that is not restricted, following the movement rules for kings (one square adjacent horizontally, vertically, or diagonally) and rooks (any number of squares along a clear row or column without jumping over obstructing pieces). White can only move pieces from cells they occupy to empty cells that are not marked as restricted. On Black's turn, the black king may move one square similarly but only to empty cells that are neither attacked nor guarded; \"attacked\" cells are those threatened by the white rook along clear rows or columns, and \"guarded\" cells are those adjacent to the white king. Black may only move the black king to safe squares that are neither attacked nor guarded. If it is not a player's turn, they may pass by performing a noop action, which is legal only when it is the opponent's turn. Moves are specified by indicating the piece moved, its current coordinates, and the destination coordinates. After a move, the piece's position updates accordingly, the previously occupied cell becomes empty, and all other cells remain unchanged unless directly affected by the move. Control alternates between White and Black each turn, and the step counter increases by one. The game enforces implicit constraints such as staying within board boundaries, ensuring that no two pieces occupy the same cell, and respecting the adjacency and linear movement relations described. The black king is considered in check if it occupies a cell attacked by the white rook or adjacent to the white king's control, and the game ends with a checkmate condition if the black king is in check and has no legal moves, or if the black king is stuck with no legal moves. White wins by delivering checkmate, scoring 100 points, while Black wins by avoiding checkmate, scoring 100 points if checkmate does not occur. The game terminates either at checkmate, if the black king is stuck with no moves, or after 10 steps have elapsed.",
    "output": "(role white)\n(role black)\n(init (cell a 1 b))\n(init (cell a 2 b))\n(init (cell a 3 b))\n(init (cell a 4 bk))\n(init (cell b 1 b))\n(init (cell b 2 b))\n(init (cell b 3 b))\n(init (cell b 4 b))\n(init (cell c 1 wk))\n(init (cell c 2 b))\n(init (cell c 3 b))\n(init (cell c 4 b))\n(init (cell d 1 wr))\n(init (cell d 2 b))\n(init (cell d 3 b))\n(init (cell d 4 b))\n(init (control white))\n(init (step 1))\n(<= (next (cell ?x ?y ?p))\n(does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?u ?v b))\n(does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?w ?z b))\n(true (cell ?w ?z b))\n(does ?player (move ?p ?u ?v ?x ?y))\n(or (distinct ?w ?x) (distinct ?z ?y)))\n(<= (next (cell ?w ?z ?q))\n(does ?player (move ?p ?u ?v ?x ?y))\n(true (cell ?w ?z ?q))\n(distinct ?p ?q)\n(distinct ?q b))\n(<= (next (control white))\n(true (control black)))\n(<= (next (control black))\n(true (control white)))\n(<= (next (step ?y))\n(succ ?x ?y)\n(true (step ?x)))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(<= (legal white (move wk ?u ?v ?x ?y))\n(kingmove ?u ?v ?x ?y)\n(true (control white))\n(true (cell ?u ?v wk))\n(true (cell ?x ?y b))\n(not (restricted ?x ?y)))\n(<= (legal white (move wr ?u ?v ?x ?y))\n(rookmove ?u ?v ?x ?y)\n(true (control white))\n(true (cell ?u ?v wr))\n(true (cell ?x ?y b))\n(not (restricted ?x ?y)))\n(<= (legal white noop)\n(true (control black)))\n(<= (legal black (move bk ?u ?v ?x ?y))\n(kingmove ?u ?v ?x ?y)\n(true (control black))\n(true (cell ?u ?v bk))\n(true (cell ?x ?y b))\n(not (attacked bk ?x ?y))\n(not (guarded ?x ?y)))\n(<= (legal black noop)\n(true (control white)))\n(<= (kingmove ?u ?v ?u ?y)\n(or (adjacent ?v ?y) (adjacent ?y ?v))\n(coordinate ?u))\n(<= (kingmove ?u ?v ?x ?v)\n(or (nextcolumn ?u ?x) (nextcolumn ?x ?u))\n(coordinate ?v))\n(<= (kingmove ?u ?v ?x ?y)\n(or (nextcolumn ?u ?x) (nextcolumn ?x ?u))\n(or (adjacent ?v ?y) (adjacent ?y ?v)))\n(<= (rookmove ?u ?v ?u ?y)\n(clearcolumn wr ?u ?v ?y))\n(<= (rookmove ?u ?v ?u ?y)\n(clearcolumn wr ?u ?y ?v))\n(<= (rookmove ?u ?v ?x ?v)\n(clearrow wr ?u ?x ?v))\n(<= (rookmove ?u ?v ?x ?v)\n(clearrow wr ?x ?u ?v))\n(<= checkmate\ncheck\nstuck)\n(<= check\n(true (cell ?u ?v bk))\n(attacked bk ?u ?v))\n(<= stuck\n(not canmove))\n(<= canmove\n(kingmove ?u ?v ?x ?y)\n(true (cell ?u ?v bk))\n(true (cell ?x ?y b))\n(not (attacked bk ?x ?y))\n(not (guarded ?x ?y)))\n(<= (restricted ?x ?y)\n(kingmove ?u ?v ?x ?y)\n(true (cell ?u ?v bk)))\n(<= (guarded ?x ?y)\n(kingmove ?u ?v ?x ?y)\n(true (cell ?u ?v wk)))\n(<= (attacked ?p ?u ?w)\n(clearcolumn ?p ?u ?v ?w)\n(true (cell ?u ?v wr)))\n(<= (attacked ?p ?u ?v)\n(clearcolumn ?p ?u ?v ?w)\n(true (cell ?u ?w wr)))\n(<= (attacked ?p ?u ?v)\n(clearrow ?p ?u ?x ?v)\n(true (cell ?x ?v wr)))\n(<= (attacked ?p ?u ?v)\n(clearrow ?p ?x ?u ?v)\n(true (cell ?x ?v wr)))\n(<= (clearcolumn ?p ?x ?y1 ?y2)\n(adjacent ?y1 ?y2)\n(coordinate ?x)\n(piece ?p))\n(<= (clearcolumn ?p ?x ?y1 ?y3)\n(adjacent ?y1 ?y2)\n(adjacent ?y2 ?y3)\n(or (true (cell ?x ?y2 b)) (true (cell ?x ?y2 ?p)))\n(piece ?p))\n(<= (clearcolumn ?p ?x ?y1 ?y4)\n(adjacent ?y1 ?y2)\n(adjacent ?y2 ?y3)\n(adjacent ?y3 ?y4)\n(or (true (cell ?x ?y2 b)) (true (cell ?x ?y2 ?p)))\n(or (true (cell ?x ?y3 b)) (true (cell ?x ?y3 ?p)))\n(piece ?p))\n(<= (clearrow ?p ?x1 ?x2 ?y)\n(nextcolumn ?x1 ?x2)\n(coordinate ?y)\n(piece ?p))\n(<= (clearrow ?p ?x1 ?x3 ?y)\n(nextcolumn ?x1 ?x2)\n(nextcolumn ?x2 ?x3)\n(or (true (cell ?x2 ?y b)) (true (cell ?x2 ?y ?p)))\n(piece ?p))\n(<= (clearrow ?p ?x1 ?x4 ?y)\n(or (true (cell ?x2 ?y b)) (true (cell ?x2 ?y ?p)))\n(or (true (cell ?x3 ?y b)) (true (cell ?x3 ?y ?p)))\n(nextcolumn ?x1 ?x2)\n(nextcolumn ?x3 ?x4)\n(nextcolumn ?x2 ?x3)\n(piece ?p))\n(adjacent 1 2)\n(adjacent 2 3)\n(adjacent 3 4)\n(nextcolumn a b)\n(nextcolumn b c)\n(nextcolumn c d)\n(coordinate 1)\n(coordinate 2)\n(coordinate 3)\n(coordinate 4)\n(coordinate a)\n(coordinate b)\n(coordinate c)\n(coordinate d)\n(piece wk)\n(piece bk)\n(piece wr)\n(<= (goal white 100)\ncheckmate)\n(<= (goal white 0)\n(not checkmate))\n(<= (goal black 100)\n(not checkmate))\n(<= (goal black 0)\ncheckmate)\n(<= terminal\n(true (step 10)))\n(<= terminal\nstuck)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 7-by-7 grid where coordinates are indexed from 1 to 7 both horizontally and vertically. Four players take part in the game, each assigned a distinct role named red, yellow, blue, and green, and they take turns in a fixed rotational order: red moves first, followed by yellow, then blue, and finally green, after which the cycle repeats. The initial setup places a single piece for each player at specific coordinates: red's piece starts at (1,4), yellow's at (4,1), blue's at (7,4), and green's at (4,7). The game begins with red in control and the turn counter set to one. During a player's turn, if they have any legal moves, they must make exactly one; if no legal moves are available, the player may perform a noop action, effectively passing their turn. A move action is specified by four coordinates: the starting cell (x1, y1) and the destination cell (x2, y2), representing moving one piece from the former to the latter. Moves are legal only if the player controls a piece at the starting cell, it is their turn, and the destination cell is reachable via certain defined movement patterns. Specifically, a piece can move to an orthogonally or diagonally adjacent cell if it is occupied by an opponent's piece, provided that the destination is not on the outermost rows or columns (i.e., neither x nor y equals 1 or 7). Alternatively, a piece can move in an \"ell\" shape—defined as moving two spaces in one direction and one space perpendicular to that—onto an empty cell that is also not on the border of the board. Moves cannot land on the board's edges, and a player cannot move onto a cell occupied by their own piece. When a move is made onto a cell occupied by an opponent's piece, that piece is captured and removed from play, decreasing the opponent's piece count, while the moving player maintains or increases their piece count if they spawn a new piece at the starting position. The turn control passes to the next player according to the rotation sequence after each move. The step counter increments by one every turn. The game ends either when any player forms a line of three of their pieces in a row, column, or diagonal within the central 3-by-3 area defined by coordinates 3 to 5 in both axes, or when the step counter reaches 33, whichever occurs first. Victory is awarded fully with a score of 100 points to any player who achieves such a line. If the game ends without any player forming a line, the score for each player is based on the number of pieces they have remaining on the board, mapped to a value with 1 piece worth 10 points, 2 pieces 20 points, and so forth, up to a maximum of 99 points for 10 or more pieces. Overall, players strategically maneuver their single pieces around the board avoiding edges, capturing opponent pieces by moving orthogonally or diagonally onto them, or moving in \"ell\" shaped patterns to empty cells, aiming to create a three-in-a-row in the central grid or to outlast others by maintaining the greatest number of pieces by the end of the 33rd step, with the turn order strictly cycling through red, yellow, blue, and green.",
    "output": "(role red)\n(role yellow)\n(role blue)\n(role green)\n(init (control red))\n(init (cell 1 4 red))\n(init (cell 4 1 yellow))\n(init (cell 7 4 blue))\n(init (cell 4 7 green))\n(init (pieces red 1))\n(init (pieces yellow 1))\n(init (pieces blue 1))\n(init (pieces green 1))\n(init (step 1))\n(<= (legal ?player noop)\n\t(role ?player)\n\t(not (true (control ?player))))\n(<= (legal ?player ?move)\n    (legal2 ?player ?move))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasLegalMove ?player)))\n(<= (hasLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(moveto ?x1 ?y1 ?x2 ?y2 ?player))\n(<= (captureto ?x1 ?y1 ?x2 ?y2)\n(orthogonal ?x1 ?y1 ?x2 ?y2))\n(<= (captureto ?x1 ?y1 ?x2 ?y2)\n(diagonal ?x1 ?y1 ?x2 ?y2))\n(<= (moveto ?x1 ?y1 ?x2 ?y2 ?player)\n(captureto ?x1 ?y1 ?x2 ?y2)\n(true (cell ?x2 ?y2 ?player2))\n(distinct ?player ?player2)\n(distinct ?x2 1)\n(distinct ?x2 7)\n(distinct ?y2 1)\n(distinct ?y2 7)\n(role ?player))\n(<= (moveto ?x1 ?y1 ?x2 ?y2 ?player)\n(ell ?x1 ?y1 ?x2 ?y2)\n(distinct ?x2 1)\n(distinct ?x2 7)\n(distinct ?y2 1)\n(distinct ?y2 7)\n(not (any_cell ?x2 ?y2))\n(role ?player))\n(<= (next (control ?p2))\n(true (control ?p1))\n(rotation ?p1 ?p2))\n(<= (next (cell ?x2 ?y2 ?player))\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?piece))\n(true (cell ?x ?y ?piece))\n(not (camefrom ?x ?y))\n(not (wentto ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n(spawns ?x ?y ?player))\n(<= (next (step ?t2))\n(true (step ?t1))\n(succ ?t1 ?t2))\n(<= (next (pieces ?p ?n))\n(spawned ?p)\n(true (pieces ?p ?n1))\n(succ ?n1 ?n))\n(<= (next (pieces ?p ?n))\n(captured ?p)\n(true (pieces ?p ?n1))\n(succ ?n ?n1))\n(<= (next (pieces ?p ?n))\n(true (pieces ?p ?n))\n(not (spawned ?p))\n(not (captured ?p)))\n(<= (captured ?p)\n(does ?p2 (move ?x1 ?y1 ?x2 ?y2))\n(true (cell ?x2 ?y2 ?p))\n(distinct ?p2 ?p))\n(<= (spawned ?p)\n(does ?p (move ?x1 ?y1 ?x2 ?y2))\n(spawns ?x1 ?y1 ?p))\n(<= terminal\n(role ?player)\n(line ?player))\n(<= terminal\n(true (step 33)))\n(<= (goal ?player ?v)\n(role ?player)\n(not (line ?player))\n(true (pieces ?player ?n))\n(pieces_value_map ?n ?v))\n(<= (goal ?player 100)\n(role ?player)\n(line ?player))\n(pieces_value_map 0 0)\n(pieces_value_map 1 10)\n(pieces_value_map 2 20)\n(pieces_value_map 3 30)\n(pieces_value_map 4 40)\n(pieces_value_map 5 50)\n(pieces_value_map 6 60)\n(pieces_value_map 7 70)\n(pieces_value_map 8 80)\n(pieces_value_map 9 90)\n(pieces_value_map 10 99)\n(pieces_value_map 11 99)\n(pieces_value_map 12 99)\n(pieces_value_map 13 99)\n(pieces_value_map 14 99)\n(pieces_value_map 15 99)\n(pieces_value_map 16 99)\n(pieces_value_map 17 99)\n(pieces_value_map 18 99)\n(pieces_value_map 19 99)\n(pieces_value_map 20 99)\n(pieces_value_map 21 99)\n(pieces_value_map 22 99)\n(pieces_value_map 23 99)\n(pieces_value_map 24 99)\n(pieces_value_map 25 99)\n(pieces_value_map 26 99)\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n(adjacent1 ?x1 ?x2)\n(index ?y))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n(adjacent1 ?y1 ?y2)\n(index ?x))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(adjacent1 ?x1 ?x2)\n(adjacent1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(adjacent2 ?x1 ?x2)\n(adjacent1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(adjacent2 ?y1 ?y2)\n(adjacent1 ?x1 ?x2))\n(<= (any_cell ?x ?y)\n(true (cell ?x ?y ?p)))\n(<= (camefrom ?x1 ?y1)\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (wentto ?x2 ?y2)\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (line ?player)\n(row ?player))\n(<= (line ?player)\n(column ?player))\n(<= (line ?player)\n(diag ?player))\n(<= (row ?player)\n(true (cell 3 3 ?player))\n(true (cell 4 3 ?player))\n(true (cell 5 3 ?player)))\n(<= (row ?player)\n(true (cell 3 4 ?player))\n(true (cell 4 4 ?player))\n(true (cell 5 4 ?player)))\n(<= (row ?player)\n(true (cell 3 5 ?player))\n(true (cell 4 5 ?player))\n(true (cell 5 5 ?player)))\n(<= (column ?player)\n(true (cell 3 3 ?player))\n(true (cell 3 4 ?player))\n(true (cell 3 5 ?player)))\n(<= (column ?player)\n(true (cell 4 3 ?player))\n(true (cell 4 4 ?player))\n(true (cell 4 5 ?player)))\n(<= (column ?player)\n(true (cell 5 3 ?player))\n(true (cell 5 4 ?player))\n(true (cell 5 5 ?player)))\n(<= (diag ?player)\n(true (cell 3 3 ?player))\n(true (cell 4 4 ?player))\n(true (cell 5 5 ?player)))\n(<= (diag ?player)\n(true (cell 3 5 ?player))\n(true (cell 4 4 ?player))\n(true (cell 5 3 ?player)))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(plus1 1 2)\n(plus1 2 3)\n(plus1 3 4)\n(plus1 4 5)\n(plus1 5 6)\n(plus1 6 7)\n(<= (adjacent1 ?x1 ?x2)\n(plus1 ?x1 ?x2))\n(<= (adjacent1 ?x1 ?x2)\n(plus1 ?x2 ?x1))\n(plus2 1 3)\n(plus2 2 4)\n(plus2 3 5)\n(plus2 4 6)\n(plus2 5 7)\n(<= (adjacent2 ?x1 ?x2)\n(plus2 ?x1 ?x2))\n(<= (adjacent2 ?x1 ?x2)\n(plus2 ?x2 ?x1))\n(rotation red yellow)\n(rotation yellow blue)\n(rotation blue green)\n(rotation green red)\n(spawns 1 4 red)\n(spawns 4 1 yellow)\n(spawns 7 4 blue)\n(spawns 4 7 green)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 grid where the columns are labeled from 'a' to 'h' and the rows from 1 to 8, establishing a coordinate system that identifies each cell uniquely by a letter-number pair. There are two players, White and Black, who alternate turns, with White beginning the game in control. The initial state places mostly empty cells denoted by 'b', except for certain cells containing white pawns ('wp') and black pawns ('bp') positioned in specific rows and columns: white pawns occupy cells c2 and e2, while black pawns are at d7 and f7. On each turn, the player in control performs exactly one move action, which involves moving a pawn of their color from one cell (identified by coordinates u and v) to another cell (identified by coordinates x and y). This action is legal only if it involves moving a pawn currently occupying the source cell, and it does not attempt to move onto the opponent's back row unless the pawn is of the opposing color. The move updates the state by clearing the pawn from the original cell and placing it onto the target cell, provided that the target cell is within the board boundaries and unoccupied. Notably, if a white pawn reaches row 8 or a black pawn reaches row 1, it does not remain as a pawn in the subsequent state, reflecting a constraint that prevents pawns from existing on the opponent's back rank. Turn control alternates automatically after each move, and the game continues until a terminal condition is met, though such conditions are not explicitly defined in the given rules. There is no explicit noop action described, so players must make a legal move each turn. Victory criteria or scoring is not specified within the provided information.",
    "output": "(role white)\n(role black)\n(init (cell a 1 b))\n(init (cell a 2 b))\n(init (cell a 3 b))\n(init (cell a 4 b))\n(init (cell a 5 b))\n(init (cell a 6 b))\n(init (cell a 7 b))\n(init (cell a 8 b))\n(init (cell b 1 b))\n(init (cell b 2 b))\n(init (cell b 3 b))\n(init (cell b 4 b))\n(init (cell b 5 b))\n(init (cell b 6 b))\n(init (cell b 7 b))\n(init (cell b 8 b))\n(init (cell c 1 b))\n(init (cell c 2 wp))\n(init (cell c 3 b))\n(init (cell c 4 b))\n(init (cell c 5 b))\n(init (cell c 6 b))\n(init (cell c 7 b))\n(init (cell c 8 b))\n(init (cell d 1 b))\n(init (cell d 2 b))\n(init (cell d 3 b))\n(init (cell d 4 b))\n(init (cell d 5 b))\n(init (cell d 6 b))\n(init (cell d 7 bp))\n(init (cell d 8 b))\n(init (cell e 1 b))\n(init (cell e 2 wp))\n(init (cell e 3 b))\n(init (cell e 4 b))\n(init (cell e 5 b))\n(init (cell e 6 b))\n(init (cell e 7 b))\n(init (cell e 8 b))\n(init (cell f 1 b))\n(init (cell f 2 b))\n(init (cell f 3 b))\n(init (cell f 4 b))\n(init (cell f 5 b))\n(init (cell f 6 b))\n(init (cell f 7 bp))\n(init (cell f 8 b))\n(init (cell g 1 b))\n(init (cell g 2 b))\n(init (cell g 3 b))\n(init (cell g 4 b))\n(init (cell g 5 b))\n(init (cell g 6 b))\n(init (cell g 7 b))\n(init (cell g 8 b))\n(init (cell h 1 b))\n(init (cell h 2 b))\n(init (cell h 3 b))\n(init (cell h 4 b))\n(init (cell h 5 b))\n(init (cell h 6 b))\n(init (cell h 7 b))\n(init (cell h 8 b))\n(init (control white))\n(<= (next (cell ?u ?v b))\n    (does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?x ?y ?p))\n    (does ?player (move ?p ?u ?v ?x ?y))\n    (or (distinct ?p wp) (distinct ?y 8))\n    (or (distinct ?p bp) (distinct ?y 1)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on two separate 4-by-4 grid boards, each with coordinates ranging from 1 to 4 in both the x (horizontal) and y (vertical) directions. Each board is identified as either board 1 or board 2, and each cell within the boards can be referenced by its board number and its x and y coordinates. The game features two players with distinct roles: the \"crosser\" and the \"blocker,\" who alternate turns in a fixed order. Initially, all cells on both boards are empty, marked as blank. During a turn, a player can perform a marking action where they select one cell from board 1 and one cell from board 2 simultaneously, marking the chosen cell on board 1 and the chosen cell on board 2 according to their role. For the crosser, the mark is \"crosser,\" and for the blocker, it is \"blk\" (blocked). Such a marking move is only legal if the targeted cells on both boards are currently blank. The game enforces that the crosser and blocker cannot mark the same cell simultaneously; that is, the cells chosen by each player for marking must be distinct on each board. After both players have made their marking moves in a round, the game state updates accordingly: the cells marked by the blocker become blocked on the first and second boards, and the cells marked by the crosser become marked as crosser on the respective boards, except when the crosser’s cell coincides with the blocker’s marked cell, in which case the crosser’s mark does not replace the blocker’s. If a cell is neither marked by the crosser nor the blocker in a turn, it retains its previous state. The game continues until a terminal condition is met, which occurs if the crosser manages to create a continuous bridge of four connected crosser-marked cells running consecutively from the first column to the fourth column on either board 1 or board 2, or if there are no blank cells left on either board, indicating no further moves are possible. Continuity between cells is defined by adjacency in the coordinate system, where connected cells have coordinates that are consecutive either horizontally, vertically, or diagonally as specified by a continuity relation. Scoring is determined based on these terminal conditions: if the crosser succeeds in creating a bridge on both boards, the crosser scores 100 points; if a bridge is formed on only one board, the crosser scores 50 points; otherwise, the crosser scores 0. The blocker’s score is inversely related to the crosser’s success: the blocker earns 100 points if the crosser fails to form any bridge and no blank cells remain on either board, 50 points if the crosser forms a bridge on exactly one board, and 0 points if the crosser completes bridges on both boards. The game enforces implicit constraints such as the requirement that all moves occur within the bounds of the 4-by-4 grids, that each move must involve distinct cells for the crosser and blocker within the same turn, and that no overlapping markings are permitted on the same cell in a single turn. Players may choose to pass their turn by not marking new cells, effectively performing a no-operation, but the game progresses only through marking actions that adhere to the legality conditions described. The ultimate goal for the crosser is to forge uninterrupted paths of crosser marks across a board’s columns to achieve victory, while the blocker aims to prevent such paths and maintain or create blocked cells that hinder the crosser’s progress.",
    "output": "(role crosser)\n(role blocker)\n(init (cell1 1 1 b))\n(init (cell1 1 2 b))\n(init (cell1 1 3 b))\n(init (cell1 1 4 b))\n(init (cell1 2 1 b))\n(init (cell1 2 2 b))\n(init (cell1 2 3 b))\n(init (cell1 2 4 b))\n(init (cell1 3 1 b))\n(init (cell1 3 2 b))\n(init (cell1 3 3 b))\n(init (cell1 3 4 b))\n(init (cell1 4 1 b))\n(init (cell1 4 2 b))\n(init (cell1 4 3 b))\n(init (cell1 4 4 b))\n(init (cell2 1 1 b))\n(init (cell2 1 2 b))\n(init (cell2 1 3 b))\n(init (cell2 1 4 b))\n(init (cell2 2 1 b))\n(init (cell2 2 2 b))\n(init (cell2 2 3 b))\n(init (cell2 2 4 b))\n(init (cell2 3 1 b))\n(init (cell2 3 2 b))\n(init (cell2 3 3 b))\n(init (cell2 3 4 b))\n(init (cell2 4 1 b))\n(init (cell2 4 2 b))\n(init (cell2 4 3 b))\n(init (cell2 4 4 b))\n(<= (legal ?who (mark ?x1 ?y1 ?x2 ?y2))\n    (role ?who)\n    (true (cell1 ?x1 ?y1 b))\n    (true (cell2 ?x2 ?y2 b)))\n(<= (next (cell1 ?x1 ?y1 blk))\n    (does blocker (mark ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell1 ?xC1 ?yC1 crosser))\n    (does crosser (mark ?xC1 ?yC1 ?xC2 ?yC2))\n    (does blocker (mark ?xB1 ?yB1 ?xB2 ?yB2))\n    (distinctCell ?xC1 ?yC1 ?xB1 ?yB1))\n(<= (next (cell1 ?x ?y ?mark))\n    (true (cell1 ?x ?y ?mark))\n    (does blocker (mark ?xB1 ?yB1 ?xB2 ?yB2))\n    (does crosser (mark ?xC1 ?yC1 ?xC2 ?yC2))\n    (distinctCell ?x ?y ?xB1 ?yB1)\n    (distinctCell ?x ?y ?xC1 ?yC1))\n(<= (next (cell2 ?x2 ?y2 blk))\n    (does blocker (mark ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell2 ?xC2 ?yC2 crosser))\n    (does crosser (mark ?xC1 ?yC1 ?xC2 ?yC2))\n    (does blocker (mark ?xB1 ?yB1 ?xB2 ?yB2))\n    (distinctCell ?xC2 ?yC2 ?xB2 ?yB2))\n(<= (next (cell2 ?x ?y ?mark))\n    (true (cell2 ?x ?y ?mark))\n    (does blocker (mark ?xB1 ?yB1 ?xB2 ?yB2))\n    (does crosser (mark ?xC1 ?yC1 ?xC2 ?yC2))\n    (distinctCell ?x ?y ?xB2 ?yB2)\n    (distinctCell ?x ?y ?xC2 ?yC2))\n(<= terminal\n    bridge1)\n(<= terminal\n    bridge2)\n(<= terminal\n    (not open1))\n(<= terminal\n    (not open2))\n(<= (goal blocker 100)\n    goalBlocker1-100\n    goalBlocker2-100)\n(<= (goal blocker 50)\n    goalBlocker1-100\n    goalBlocker2-0)\n(<= (goal blocker 50)\n    goalBlocker1-0\n    goalBlocker2-100)\n(<= (goal blocker 0)\n    goalBlocker1-0\n    goalBlocker2-0)\n(<= (goal crosser 100)\n    goalCrosser1-100\n    goalCrosser2-100)\n(<= (goal crosser 50)\n    goalCrosser1-100\n    goalCrosser2-0)\n(<= (goal crosser 50)\n    goalCrosser1-0\n    goalCrosser2-100)\n(<= (goal crosser 0)\n    goalCrosser1-0\n    goalCrosser2-0)\n(<= bridge1\n    (true (cell1 1 ?a crosser))\n    (cont ?a ?b)\n    (true (cell1 2 ?b crosser))\n    (cont ?b ?c)\n    (true (cell1 3 ?c crosser))\n    (cont ?c ?d)\n    (true (cell1 4 ?d crosser)))\n(<= bridge2\n    (true (cell2 1 ?a crosser))\n    (cont ?a ?b)\n    (true (cell2 2 ?b crosser))\n    (cont ?b ?c)\n    (true (cell2 3 ?c crosser))\n    (cont ?c ?d)\n    (true (cell2 4 ?d crosser)))\n(<= open1\n    (true (cell1 ?m ?n b)))\n(<= open2\n    (true (cell2 ?m ?n b)))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= goalBlocker1-100\n    (not bridge1)\n    (not open1))\n(<= goalBlocker1-0\n    bridge1)\n(<= goalBlocker1-0\n    open1)\n(<= goalBlocker2-100\n    (not bridge2)\n    (not open2))\n(<= goalBlocker2-0\n    bridge2)\n(<= goalBlocker2-0\n    open2)\n(<= goalCrosser1-100\n    bridge1)\n(<= goalCrosser1-0\n    (not bridge1))\n(<= goalCrosser2-100\n    bridge2)\n(<= goalCrosser2-0\n    (not bridge2))\n(cont 1 1)\n(cont 2 2)\n(cont 3 3)\n(cont 4 4)\n(cont 1 2)\n(cont 2 3)\n(cont 3 4)\n(cont 2 1)\n(cont 3 2)\n(cont 4 3)\n(cell 1 1) (cell 2 1) (cell 3 1) (cell 4 1)\n(cell 1 2) (cell 2 2) (cell 3 2) (cell 4 2)\n(cell 1 3) (cell 2 3) (cell 3 3) (cell 4 3)\n(cell 1 4) (cell 2 4) (cell 3 4) (cell 4 4)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game unfolds on a grid-based board environment consisting of two separate boards labeled 1 and 2, each with columns numbered from 1 to 8 along the horizontal axis and rows numbered from 1 to 6 along the vertical axis, forming an 8-by-6 coordinate system where the x-coordinate ranges from 1 to 8 and the y-coordinate ranges from 1 to 6. Two players participate in the game, designated as red and black, who alternate turns with red moving first on board 1 and black following on board 2. The initial state grants control to the red player on board 1 and to the black player on board 2, establishing the turn order and starting positions. During each turn, a player may perform exactly one action, which consists of dropping a piece into one of the columns of the current board under their control, specified by the command \"drop\" followed by the target column number and the board number. An action is legal only if it is the acting player’s turn on the specified board and the selected column is open, meaning that its topmost cell (row 6) is empty and can accept a new piece. Pieces fall to the lowest available position within the chosen column; if the column is empty, the piece occupies the bottom cell (row 1), otherwise it occupies the nearest open cell above the highest occupied cell in that column. After a piece is placed, the cell state updates to reflect the presence of the player's piece, and control switches to the opposing player on the same board, ensuring strict alternation of turns. Players have no explicit \"noop\" action; they must drop a piece into an open column during their turn. The game has implicit constraints such as the board boundaries limiting legal coordinates to columns 1 through 8 and rows 1 through 6, and occupancy conflicts preventing placing a piece in a cell already occupied by either player. The game terminates when either player forms a horizontal, vertical, or diagonal line of four consecutive pieces on their board—this line is detected by checking sequences of four adjacent cells where all are occupied by the same player—or when no columns remain open on either board, indicating the board is full. Scoring is determined at termination: a player who achieves a four-in-a-row line alone is awarded a perfect score of 100 points, while if both players achieve lines simultaneously, both receive a score of 50 points. If the game ends with no lines formed and the board is full, both players receive 50 points; if one player has formed a line and the other has not, the line-forming player gets 100 points and the other 0. Conversely, if the game terminates with no lines and still open columns, both players receive zero points. The objective is to create a line of four of one's own pieces on the player's designated board before the opponent does or before the board fills up, with victory awarded accordingly based on the final scoring.",
    "output": "(role red)\n(role black)\n(init (control red 1))\n(init (control black 2))\n(<= (legal red (drop ?x ?board))\n    (true (control red ?board))\n    (columnOpen ?x ?board))\n(<= (legal black (drop ?x ?board))\n    (true (control black ?board))\n    (columnOpen ?x ?board))\n(<= (next (cell ?x 1 ?board ?player))\n    (does ?player (drop ?x ?board))\n    (columnEmpty ?x ?board))\n(<= (next (cell ?x ?y2 ?board ?player))\n    (does ?player (drop ?x ?board))\n    (cellOpen ?x ?y2 ?board)\n    (succ ?y1 ?y2)\n    (not (cellOpen ?x ?y1 ?board)))\n(<= (next (cell ?x ?y ?board ?player))\n    (true (cell ?x ?y ?board ?player)))\n(<= (next (control red ?board))\n    (true (control black ?board)))\n(<= (next (control black ?board))\n    (true (control red ?board)))\n(<= terminal\n    (line red))\n(<= terminal\n    (line black))\n(<= terminal\n    (not boardOpen))\n(<= (goal red 100)\n    (line red)\n    (not (line black)))\n(<= (goal red 50)\n    (not (line red))\n    (not (line black))\n    (not boardOpen))\n(<= (goal red 0)\n    (line black)\n    (not (line red)))\n(<= (goal red 0)\n    (not (line red))\n    (not (line black))\n    boardOpen)\n(<= (goal ?player 50)\n    (role ?player)\n    (line red)\n    (line black))\n(<= (goal black 100)\n    (line black)\n    (not (line red)))\n(<= (goal black 50)\n    (not (line red))\n    (not (line black))\n    (not boardOpen))\n(<= (goal black 0)\n    (line red)\n    (not (line black)))\n(<= (goal black 0)\n    (not (line red))\n    (not (line black))\n    boardOpen)\n(<= (cellOpen ?x ?y ?board)\n    (x ?x)\n    (y ?y)\n    (board ?board)\n    (not (true (cell ?x ?y ?board red)))\n    (not (true (cell ?x ?y ?board black))))\n(<= (columnOpen ?x ?board)\n    (cellOpen ?x 6 ?board))\n(<= (columnEmpty ?x ?board)\n    (cellOpen ?x 1 ?board))\n(<= boardOpen\n    (x ?x)\n    (columnOpen ?x ?board))\n(<= (line ?player)\n    (true (cell ?x1 ?y ?board ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (true (cell ?x2 ?y ?board ?player))\n    (true (cell ?x3 ?y ?board ?player))\n    (true (cell ?x4 ?y ?board ?player)))\n(<= (line ?player)\n    (true (cell ?x ?y1 ?board ?player))\n    (succ ?y1 ?y2)\n    (succ ?y2 ?y3)\n    (succ ?y3 ?y4)\n    (true (cell ?x ?y2 ?board ?player))\n    (true (cell ?x ?y3 ?board ?player))\n    (true (cell ?x ?y4 ?board ?player)))\n(<= (line ?player)\n    (true (cell ?x1 ?y1 ?board ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?y1 ?y2)\n    (succ ?y2 ?y3)\n    (succ ?y3 ?y4)\n    (true (cell ?x2 ?y2 ?board ?player))\n    (true (cell ?x3 ?y3 ?board ?player))\n    (true (cell ?x4 ?y4 ?board ?player)))\n(<= (line ?player)\n    (true (cell ?x1 ?y4 ?board ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?y3 ?y4)\n    (succ ?y2 ?y3)\n    (succ ?y1 ?y2)\n    (true (cell ?x2 ?y3 ?board ?player))\n    (true (cell ?x3 ?y2 ?board ?player))\n    (true (cell ?x4 ?y1 ?board ?player)))\n(board 1) (board 2)\n(succ 1 2) (succ 2 3) (succ 3 4) (succ 4 5) (succ 5 6) (succ 6 7) (succ 7 8)\n(x 1) (x 2) (x 3) (x 4) (x 5) (x 6) (x 7) (x 8)\n(y 1) (y 2) (y 3) (y 4) (y 5) (y 6)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a 5-by-5 grid defined by coordinates ranging from 1 to 5 in both the horizontal (x) and vertical (y) directions, with each cell initially assigned a numeric value between 1 and 5 and a color, either 'e' (empty) or 'b' (blocked). There is a single player role who takes turns performing actions sequentially, with the game starting at step zero. On each turn, the player must choose an action of the form \"write x y value color,\" where x and y specify the coordinates of the cell to modify, value is a numeric value between 1 and 5, and color is either 'e' or 'b'. An action is legal if it writes the 'b' color into a cell currently marked as 'e' and that cell is adjacent to other 'e'-colored cells horizontally or vertically with certain counting conditions related to consecutive values; alternatively, writing 'e' into a cell currently marked 'b' is allowed. The player can also effectively pass by choosing an action that does not change any cell state (a noop). After each action, the state updates so that the targeted cell reflects the newly written value and color while all other cells retain their previous states. The game automatically increments the step counter after each move. The board imposes constraints such as adjacency requirements for color changes and the preservation of cell occupancy rules, ensuring no conflicting color assignments occur and that numeric values maintain certain count relationships along rows and columns. The game terminates either after 100 steps have been taken or when all cells from (1,1) to (4,5) and from (1,1) to (5,4) satisfy a condition involving differences in cell values and colors according to specified recursive rules. The player's goal is to avoid reaching step 100, where a terminal state yields a minimal score of 1; otherwise, if the game ends before step 100, the player achieves a maximum score of 100, reflecting successful management of the board’s constraints and progression.",
    "output": "(role player)\n(init(cell 1 1 5 e))\n(init(cell 1 2 5 e))\n(init(cell 1 3 2 e))\n(init(cell 1 4 2 e))\n(init(cell 1 5 3 e))\n(init(cell 2 1 3 e))\n(init(cell 2 2 4 e))\n(init(cell 2 3 5 e))\n(init(cell 2 4 2 e))\n(init(cell 2 5 1 e))\n(init(cell 3 1 3 e))\n(init(cell 3 2 1 e))\n(init(cell 3 3 3 e))\n(init(cell 3 4 3 e))\n(init(cell 3 5 5 e))\n(init(cell 4 1 1 e))\n(init(cell 4 2 5 e))\n(init(cell 4 3 5 e))\n(init(cell 4 4 4 e))\n(init(cell 4 5 2 e))\n(init(cell 5 1 4 e))\n(init(cell 5 2 5 e))\n(init(cell 5 3 1 e))\n(init(cell 5 4 5 e))\n(init(cell 5 5 4 e))\n(init(step 0))\n(<= (next (cell ?x ?y ?value b))\n\t(does player (write ?x ?y ?value b)))\n(<= (next (cell ?x ?y ?value e))\n\t(does player (write ?x ?y ?value e)))\n(<= (next (cell ?x ?y ?value ?color))\n      (true (cell ?x ?y ?value ?color))\n      (does player (write ?a ?b ?value2 ?color2))\n      (or (distinct ?x ?a)(distinct ?y ?b)))\n(<= (legal player (write ?x ?y ?value e))\n\t(true(cell ?x ?y ?value b)))\n(<= (legal player (write ?x ?y ?value b))\n\t(true(cell ?x ?y ?value e))\n\t(neighbours ?x ?y e)\n\t(count_val ?x ?y ?count1)\n\t(count_val1 ?x ?y ?count2)\n\t(or (bigger ?count1 1) (bigger ?count2 1) )\n)\n(<= (count_val ?x ?y ?count)\n\t(true(cell ?x ?y ?value ?color))\n\t(count_hor ?x 1 ?value ?count)\n)\n(<= (count_val1 ?x ?y ?count)\n\t(true(cell ?x ?y ?value ?color))\n\t(count_ver 1 ?y ?value ?count)\n)\n(<= (count_hor ?x ?y ?value ?count)\n\t(true(cell ?x ?y ?value e))\n\t(succ ?y ?y1)\n\t(count_hor ?x ?y1 ?value ?count1)\n\t(succ ?count1 ?count)\n)\n(<= (count_hor ?x ?y ?value ?count)\n\t(true(cell ?x ?y ?value1 ?color))\n\t(distinct ?value ?value1)\n\t(succ ?y ?y1)\n\t(count_hor ?x ?y1 ?value ?count)\n)\n(<= (count_hor ?x ?y ?value ?count)\n\t(true(cell ?x ?y ?value b))\n\t(succ ?y ?y1)\n\t(count_hor ?x ?y1 ?value ?count)\n)\n(<= (count_hor ?x 5 ?value 1)\n\t(true(cell ?x 5 ?value e))\n)\n(<= (count_hor ?x 5 ?value 0)\n\t(true(cell ?x 5 ?value b))\n)\n(<= (count_hor ?x 5 ?value 0)\n\t(true(cell ?x 5 ?value1 ?color))\n\t(distinct ?value ?value1)\n\t(succ ?value ?value2)\n)\n(<= (count_ver 5 ?y ?value 1)\n\t(true(cell 5 ?y ?value e))\n)\n(<= (count_ver 5 ?y ?value 0)\n\t(true(cell 5 ?y ?value b))\n)\n(<= (count_ver 5 ?y ?value 0)\n\t(true(cell 5 ?y ?value1 ?color))\n\t(distinct ?value ?value1)\n\t(succ ?value ?value2)\n)\n(<= (count_ver ?x ?y ?value ?count)\n\t(true(cell ?x ?y ?value e))\n\t(succ ?x ?x1)\n\t(count_ver ?x1 ?y ?value ?count1)\n\t(succ ?count1 ?count)\n)\n(<= (count_ver ?x ?y ?value ?count)\n\t(true(cell ?x ?y ?value1 ?color))\n\t(distinct ?value ?value1)\n\t(succ ?x ?x1)\n\t(count_ver ?x1 ?y ?value ?count)\n)\n(<= (count_ver ?x ?y ?value ?count)\n\t(true(cell ?x ?y ?value b))\n\t(succ ?x ?x1)\n\t(count_ver ?x1 ?y ?value ?count)\n)\n(<= (neighbours ?x ?y e)\n\t(hor ?x ?y e)\n\t(ver ?x ?y e)\n)\n(<= (hor ?x 1 e)\n\t(true(cell ?x 2 ?value e))\n )\n(<= (hor ?x 5 e)\n\t(true(cell ?x 4 ?value e))\n )\n(<= (hor ?x ?y e)\n\t(succ ?y1 ?y)\n\t(succ ?y ?y2)\n\t(true(cell ?x ?y1 ?value e))\n\t(true(cell ?x ?y2 ?value1 e))\n )\n(<= (ver ?x ?y e)\n\t(succ ?x1 ?x)\n\t(succ ?x ?x2)\n\t(true(cell ?x1 ?y ?value e))\n\t(true(cell ?x2 ?y ?value1 e))\n )\n(<= (ver 1 ?y e)\n\t(true(cell 2 ?y ?value e))\n )\n(<= (ver 5 ?y e)\n\t(true(cell 4 ?y ?value e))\n )\n(<= (diff ?x ?y)\n\t(true (cell ?x ?y ?v b)) )\n(<= (diff ?x ?y)\n\t(true (cell ?x ?y ?v1 e))\n\t(succ ?x ?x1)\n\t(diff_aux ?x1 ?y ?v1) )\n(<= (diff_aux ?x ?y ?v)\n\t(true (cell ?x ?y ?v1 e))\n\t(distinct ?v ?v1)\n\t(succ ?x ?x1)\n\t(diff_aux ?x1 ?y ?v) )\n(<= (diff_aux ?x ?y ?v)\n\t(true (cell ?x ?y ?v1 b))\n\t(succ ?x ?x1)\n\t(diff_aux ?x1 ?y ?v) )\n(<= (diff_aux ?x ?y ?v)\n\t(succ ?x 7)\n\t(succ ?y ?y1)\n\t(succ ?v ?v1)\n)\n(<= (diff1 ?x ?y)\n\t(true (cell ?x ?y ?v b)) )\n(<= (diff1 ?x ?y)\n\t(true (cell ?x ?y ?v1 e))\n\t(succ ?y ?y1)\n\t(diff_aux1 ?x ?y1 ?v1) )\n(<= (diff_aux1 ?x ?y ?v)\n\t(true (cell ?x ?y ?v1 e))\n\t(distinct ?v ?v1)\n\t(succ ?y ?y1)\n\t(diff_aux1 ?x ?y1 ?v) )\n(<= (diff_aux1 ?x ?y ?v)\n\t(true (cell ?x ?y ?v1 b))\n\t(succ ?y ?y1)\n\t(diff_aux1 ?x ?y1 ?v) )\n(<= (diff_aux1 ?x ?y ?v)\n\t(succ ?y 7)\n\t(succ ?x ?x1)\n\t(succ ?v ?v1)\n)\n(<= (bigger ?x ?y)\n\t(succ ?y ?x)\n)\n(<=(bigger ?x ?y)\n\t(succ ?y ?y1)\n\t(bigger ?x ?y1)\n)\n(<= (next (step ?y))\n\t(true (step ?x))\n\t(succ ?x ?y))\n(<=  terminal\n\t(true (step 100)) )\n(<= terminal\n\t(diff 1 1)\n\t(diff 2 1)\n\t(diff 3 1)\n\t(diff 4 1)\n\t(diff 1 2)\n\t(diff 2 2)\n\t(diff 3 2)\n\t(diff 4 2)\n\t(diff 1 3)\n\t(diff 2 3)\n\t(diff 3 3)\n\t(diff 4 3)\n\t(diff 1 4)\n\t(diff 2 4)\n\t(diff 3 4)\n\t(diff 4 4)\n\t(diff 1 5)\n\t(diff 2 5)\n\t(diff 3 5)\n\t(diff 4 5)\n\t(diff1 1 1)\n\t(diff1 1 2)\n\t(diff1 1 3)\n\t(diff1 1 4)\n\t(diff1 2 1)\n\t(diff1 2 2)\n\t(diff1 2 3)\n\t(diff1 2 4)\n\t(diff1 3 1)\n\t(diff1 3 2)\n\t(diff1 3 3)\n\t(diff1 3 4)\n\t(diff1 4 1)\n\t(diff1 4 2)\n\t(diff1 4 3)\n\t(diff1 4 4)\n\t(diff1 5 1)\n\t(diff1 5 2)\n\t(diff1 5 3)\n\t(diff1 5 4)\n)\n(<= (goal player 100)\n\t(not(true(step 100)))\n)\n(<= (goal player 1)\n\t\t(true(step 100))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played by a single player role named \"robot\" in a discrete environment representing the configuration of a Rubik's Cube with pieces called \"cubies\" positioned and oriented in a three-dimensional spatial system implicitly defined by the cube's usual structure of corner and edge cubies. The initial state sets the cube pieces in specific positions and orientations, each cubie identified by color codes, and the step counter initialized to zero. The robot takes turns sequentially, with each turn allowing the player to either perform a turn action or do nothing via a noop action. The turn action consists of selecting one of six possible moves—up, down, left, right, front, or back—and a rotation angle of either 90, 180, or 270 degrees; these moves correspond to standard face rotations on the cube. A turn is legal if the robot chooses one of these moves with a valid angle or chooses noop; noop preserves the current state without changing positions or orientations. Executing a turn updates the position of each cubie according to the specified move and rotation angle, where the position transformation is defined by a sequence of \"after\" relations mapping the old position to a new one through intermediate states depending on the rotation angle. Similarly, cubie orientations are updated automatically for corner pieces by adding orientation increments affected by the move, repeated for multiple steps if the angle is greater than 90 degrees, while for edge pieces a flip operation toggles orientation states under certain moves, and orientations remain unchanged if the cubie is unaffected by the move or if the player does noop. The cube's state includes implicit constraints such as fixed boundaries corresponding to the cube's faces and the adjacency relationships between cubies that govern how positions transform under moves; cubies cannot occupy invalid positions outside the cube’s layout. The step counter increments by one after each action, tracking the progression of turns. The game terminates either when all cubies are correctly positioned and oriented—meaning each cubie matches its solved position with zero orientation offset—or when the step count reaches 50 turns, whichever comes first. The victory scoring criterion is the number of cubies correctly solved at the end of the game, with the maximum score being 100 if all cubies are correctly aligned. Throughout the game, the robot aims to perform sequences of legal turns to manipulate the cube towards the solved state, balancing efficient moves within the 50-turn limit to maximize the correctness of cubies at termination.",
    "output": "(role robot)\n(init (step 0))\n(init (cubie yo wo))\n(init (cubie bo wg))\n(init (cubie wo wr))\n(init (cubie yb wb))\n(init (cubie gr yb))\n(init (cubie wr yr))\n(init (cubie yr yg))\n(init (cubie go yo))\n(init (cubie br bo))\n(init (cubie yg br))\n(init (cubie wb gr))\n(init (cubie wg go))\n(init (cubie ygo wbo))\n(init (cubie wbr wbr))\n(init (cubie ybo wgr))\n(init (cubie ybr wgo))\n(init (cubie wgr ybo))\n(init (cubie ygr ybr))\n(init (cubie wgo ygr))\n(init (cubie wbo ygo))\n(init (cubieorient wb 1))\n(init (cubieorient wg 1))\n(init (cubieorient wo 1))\n(init (cubieorient wr 0))\n(init (cubieorient yb 0))\n(init (cubieorient yg 0))\n(init (cubieorient yo 1))\n(init (cubieorient yr 0))\n(init (cubieorient bo 1))\n(init (cubieorient br 0))\n(init (cubieorient go 0))\n(init (cubieorient gr 1))\n(init (cubieorient wbo wrb))\n(init (cubieorient wbr wbr))\n(init (cubieorient wgo 0))\n(init (cubieorient wgr br))\n(init (cubieorient ybo br))\n(init (cubieorient ybr wr))\n(init (cubieorient ygo wbr))\n(init (cubieorient ygr wb))\n(<= (legal robot (turn ?dir 90))\n    (move ?dir))\n(<= (legal robot (turn ?dir 180))\n    (move ?dir))\n(<= (legal robot (turn ?dir 270))\n    (move ?dir))\n(legal robot noop)\n(<= (next (cubie ?cubie ?new))\n    (does robot (turn ?move 90))\n    (true (cubie ?cubie ?old))\n    (after ?move ?old ?new))\n(<= (next (cubie ?cubie ?new))\n    (does robot (turn ?move 180))\n    (true (cubie ?cubie ?old))\n    (after ?move ?old ?mid)\n    (after ?move ?mid ?new))\n(<= (next (cubie ?cubie ?new))\n    (does robot (turn ?move 270))\n    (true (cubie ?cubie ?old))\n    (after ?move ?old ?mid1)\n    (after ?move ?mid1 ?mid2)\n    (after ?move ?mid2 ?new))\n(<= (next (cubie ?cubie ?pos))\n    (does robot (turn ?move ?angle))\n    (true (cubie ?cubie ?pos))\n    (unaffected ?pos ?move))\n(<= (next (cubie ?cubie ?pos))\n    (does robot noop)\n    (true (cubie ?cubie ?pos)))\n(<= (next (cubieorient ?cubie ?new))\n    (does robot (turn ?move 90))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (corner ?cubie)\n    (affected ?oldpos ?move)\n    (moveorienteffect ?move ?addition)\n    (cornerorientadd ?old ?addition ?new))\n(<= (next (cubieorient ?cubie ?new))\n    (does robot (turn ?move 180))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (corner ?cubie)\n    (affected ?oldpos ?move)\n    (moveorienteffect ?move ?addition)\n    (cornerorientadd ?old ?addition ?mid)\n    (cornerorientadd ?mid ?addition ?new))\n(<= (next (cubieorient ?cubie ?new))\n    (does robot (turn ?move 270))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (corner ?cubie)\n    (affected ?oldpos ?move)\n    (moveorienteffect ?move ?addition)\n    (cornerorientadd ?old ?addition ?mid1)\n    (cornerorientadd ?mid1 ?addition ?mid2)\n    (cornerorientadd ?mid2 ?addition ?new))\n(<= (next (cubieorient ?cubie ?new))\n    (does robot (turn ?move ?angle))\n    (distinct ?angle 180)\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (edge ?cubie)\n    (affected ?oldpos ?move)\n    (flip ?old ?new))\n(<= (next (cubieorient ?cubie ?old))\n    (does robot (turn ?move 180))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (edge ?cubie))\n(<= (next (cubieorient ?cubie ?old))\n    (does robot (turn ?move ?angle))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?pos))\n    (unaffected ?pos ?move))\n(<= (next (cubieorient ?cubie ?old))\n    (does robot noop)\n    (true (cubieorient ?cubie ?old)))\n(<= (next (step ?np1))\n    (true (step ?n))\n    (succ ?n ?np1))\n(flip 0 1)\n(flip 1 0)\n(after u wbo wbr)\n(after u wbr wgr)\n(after u wgr wgo)\n(after u wgo wbo)\n(after u wb wr)\n(after u wr wg)\n(after u wg wo)\n(after u wo wb)\n(after d ybr ybo)\n(after d ybo ygo)\n(after d ygo ygr)\n(after d ygr ybr)\n(after d yr yb)\n(after d yb yo)\n(after d yo yg)\n(after d yg yr)\n(after f wgr wbr)\n(after f wbr ybr)\n(after f ybr ygr)\n(after f ygr wgr)\n(after f wr br)\n(after f br yr)\n(after f yr gr)\n(after f gr wr)\n(after b wgo ygo)\n(after b ygo ybo)\n(after b ybo wbo)\n(after b wbo wgo)\n(after b wo go)\n(after b go yo)\n(after b yo bo)\n(after b bo wo)\n(after l wgo wgr)\n(after l wgr ygr)\n(after l ygr ygo)\n(after l ygo wgo)\n(after l wg gr)\n(after l gr yg)\n(after l yg go)\n(after l go wg)\n(after r wbo ybo)\n(after r ybo ybr)\n(after r ybr wbr)\n(after r wbr wbo)\n(after r wb bo)\n(after r bo yb)\n(after r yb br)\n(after r br wb)\n(moveorienteffect f wb)\n(moveorienteffect b wb)\n(moveorienteffect u br)\n(moveorienteffect d br)\n(moveorienteffect l wr)\n(moveorienteffect r wr)\n(cornerorientadd 0 wb wb)\n(cornerorientadd 0 br br)\n(cornerorientadd 0 wr wr)\n(cornerorientadd wb wb 0)\n(cornerorientadd wb br wbr)\n(cornerorientadd wb wr wrb)\n(cornerorientadd br wb wrb)\n(cornerorientadd br br 0)\n(cornerorientadd br wr wbr)\n(cornerorientadd wr wb wbr)\n(cornerorientadd wr br wrb)\n(cornerorientadd wr wr 0)\n(cornerorientadd wbr wb wr)\n(cornerorientadd wbr br wb)\n(cornerorientadd wbr wr br)\n(cornerorientadd wrb wb br)\n(cornerorientadd wrb br wr)\n(cornerorientadd wrb wr wb)\n(<= (affected ?pos ?move)\n    (after ?move ?pos ?nextpos))\n(<= (unaffected ?pos ?move)\n    (position ?pos)\n    (move ?move)\n    (not (affected ?pos ?move)))\n(move u)\n(move d)\n(move l)\n(move r)\n(move f)\n(move b)\n(corner wbo)\n(corner wbr)\n(corner wgo)\n(corner wgr)\n(corner ybo)\n(corner ybr)\n(corner ygo)\n(corner ygr)\n(edge wb)\n(edge wg)\n(edge wo)\n(edge wr)\n(edge yb)\n(edge yg)\n(edge yo)\n(edge yr)\n(edge bo)\n(edge br)\n(edge go)\n(edge gr)\n(<= (position ?p)\n    (corner ?p))\n(<= (position ?p)\n    (edge ?p))\n(csuc 0 wbo)\n(csuc wbo wbr)\n(csuc wbr wgo)\n(csuc wgo wgr)\n(csuc wgr ybo)\n(csuc ybo ybr)\n(csuc ybr ygo)\n(csuc ygo ygr)\n(csuc ygr wb)\n(csuc wb wg)\n(csuc wg wo)\n(csuc wo wr)\n(csuc wr yb)\n(csuc yb yg)\n(csuc yg yo)\n(csuc yo yr)\n(csuc yr bo)\n(csuc bo br)\n(csuc br go)\n(csuc go gr)\n(<= (correct ?cubie)\n    (true (cubie ?cubie ?cubie))\n    (true (cubieorient ?cubie 0)))\n(correctcount 0 0)\n(<= (correctcount ?next ?np5)\n    (csuc ?prev ?next)\n    (correct ?next)\n    (correctcount ?prev ?n)\n    (plus5 ?n ?np5))\n(<= (correctcount ?next ?n)\n    (csuc ?prev ?next)\n    (not (correct ?next))\n    (correctcount ?prev ?n))\n(<= (totalcorrect ?n)\n    (correctcount gr ?n))\n(<= terminal\n    (totalcorrect 100))\n(<= terminal\n    (true (step 50)))\n(<= (goal robot 0)\n    (not terminal))\n(<= (goal robot ?n)\n    terminal\n    (totalcorrect ?n))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(plus5 0 5)\n(plus5 5 10)\n(plus5 10 15)\n(plus5 15 20)\n(plus5 20 25)\n(plus5 25 30)\n(plus5 30 35)\n(plus5 35 40)\n(plus5 40 45)\n(plus5 45 50)\n(plus5 50 55)\n(plus5 55 60)\n(plus5 60 65)\n(plus5 65 70)\n(plus5 70 75)\n(plus5 75 80)\n(plus5 80 85)\n(plus5 85 90)\n(plus5 90 95)\n(plus5 95 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 10-by-10 grid with coordinates running from 1 to 10 along both the horizontal (x) and vertical (y) axes, forming a square board where each cell can be identified by a pair of indices (x, y). Two players participate, designated as white and black, who alternate turns in a fixed order starting with white. Initially, four white pieces occupy cells at coordinates (1,4), (4,1), (7,1), and (10,4), while four black pieces are placed at (1,7), (4,10), (7,10), and (10,7). The game proceeds in a cycle of two phases per player: a move phase followed by a fire phase. On a player's move phase, they may either move one of their pieces or choose to take no action (noop) if it is currently their opponent’s turn to move. Similarly, during the fire phase, a player may fire an arrow or opt for noop when it is the opponent’s fire phase. Moves involve relocating a piece from one occupied cell to another unoccupied cell along an open, unobstructed path in one of eight possible directions—north, northeast, east, southeast, south, southwest, west, or northwest. The path must be continuous and free from obstacles, with adjacency defined by moving to the next index in the specified direction; multiple sequential steps along the same direction are permitted as long as no intervening cells are occupied. The fire action involves shooting an arrow from the piece's current position (just moved in the preceding move phase) along a similarly unobstructed path to an unoccupied target cell, which then becomes marked with an arrow, effectively blocking it for future moves or fires. Occupied cells include those containing any player’s piece or arrows. After a move, the piece vacates its original cell and occupies the new cell, while the fired arrow occupies its target cell. Turns alternate between move and fire phases within the same player and then switch to the opponent. The game terminates when the player whose turn it is to move has no legal moves available, signaling the end of the game. Victory is determined by the presence or absence of legal moves: the player who can still move when the opponent cannot is awarded a score of 100, while the player with no legal moves receives a score of 0. This scoring reflects the win-loss outcome, with no intermediate scoring. Implicit constraints include the board boundaries limiting coordinates to between 1 and 10, the inability to move or fire through or onto occupied cells, and the necessity for moves and fires to follow valid directional paths defined by the adjacency relations between indices. The game thus involves strategic movement and firing to control space, block opponent pieces, and ultimately restrict the opponent’s mobility to achieve victory.",
    "output": "(role white)\n(role black)\n(init (cell 1 4 white))\n(init (cell 4 1 white))\n(init (cell 7 1 white))\n(init (cell 10 4 white))\n(init (cell 1 7 black))\n(init (cell 4 10 black))\n(init (cell 7 10 black))\n(init (cell 10 7 black))\n(init (turn white move))\n(<= (legal white noop)\n    (true (turn black ?any)))\n(<= (legal black noop)\n    (true (turn white ?any)))\n(<= (legal ?player ?move)\n    (legalMove ?player ?move))\n(<= (legalMove ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (turn ?player move))\n    (true (cell ?x1 ?y1 ?player))\n    (dir ?dir)\n    (openPath ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (legalMove ?player (fire ?x2 ?y2))\n    (true (turn ?player fire))\n    (true (justMoved ?x1 ?y1))\n    (dir ?dir)\n    (openPath ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (openPath ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2)))\n(<= (openPath ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (not (occupied ?x2 ?y2))\n    (openPath ?x2 ?y2 ?x3 ?y3 ?dir))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?any)))\n(<= (next (turn ?player fire))\n    (true (turn ?player move)))\n(<= (next (turn ?opponent move))\n    (true (turn ?player fire))\n    (opponent ?player ?opponent))\n(<= (next (cell ?x2 ?y2 ?player))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?player))\n    (true (cell ?x ?y ?player))\n    (not (vacated ?x ?y)))\n(<= (vacated ?x1 ?y1)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (justMoved ?x2 ?y2))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y arrow))\n    (does ?player (fire ?x ?y)))\n(<= terminal\n    (true (turn ?player ?any))\n    (not (anyLegalMove ?player)))\n(<= (anyLegalMove ?player)\n    (legal ?player ?move))\n(<= (goal ?player 0)\n    (true (turn ?player ?any)))\n(<= (goal ?player 100)\n    (true (turn ?opponent ?any))\n    (opponent ?opponent ?player))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(nextIndex 1 2)\n(nextIndex 2 3)\n(nextIndex 3 4)\n(nextIndex 4 5)\n(nextIndex 5 6)\n(nextIndex 6 7)\n(nextIndex 7 8)\n(nextIndex 8 9)\n(nextIndex 9 10)\n(nextIndex 10 1)\n(opponent white black)\n(opponent black white)\n(dir n)\n(dir ne)\n(dir e)\n(dir se)\n(dir s)\n(dir sw)\n(dir w)\n(dir nw)\n(<= (oneInDir ?x ?y1 ?x ?y2 n)\n    (index ?x)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x1 ?y1 ?x2 ?y2 ne)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x1 ?y ?x2 ?y e)\n    (nextIndex ?x1 ?x2)\n    (index ?y))\n(<= (oneInDir ?x1 ?y2 ?x2 ?y1 se)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x ?y2 ?x ?y1 s)\n    (index ?x)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x2 ?y2 ?x1 ?y1 sw)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (oneInDir ?x2 ?y ?x1 ?y w)\n    (nextIndex ?x1 ?x2)\n    (index ?y))\n(<= (oneInDir ?x2 ?y1 ?x1 ?y2 nw)\n    (nextIndex ?x1 ?x2)\n    (nextIndex ?y1 ?y2))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (dir ?dir)\n    (queenMoveDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (queenMoveDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (queenMoveDir ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (queenMoveDir ?x2 ?y2 ?x3 ?y3 ?dir))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 10-by-10 grid with coordinates ranging from 1 to 10 along both the horizontal (x) and vertical (y) axes, where each cell is identified by an (x, y) pair. There are two players, White and Black, who alternate turns, with White starting the game in control. At the start, White has four pieces placed at coordinates (4,1), (7,1), (1,4), and (10,4), while Black’s four pieces are initially positioned at (1,7), (10,7), (4,10), and (7,10). On a player’s turn, if they have control, they may either perform a move action or choose to do nothing (noop) if it is not their turn; noop actions are only legal for players not currently in control. A legal move action consists of selecting one of the player’s own pieces at a starting cell (x1, y1), moving that piece along a queen-like trajectory (combining rook and bishop moves) to an unoccupied cell (x2, y2), and optionally shooting an arrow from the piece’s new position to a third distinct unoccupied cell (x3, y3); alternatively, the arrow shot may be omitted by specifying the arrow’s target as the same cell as the moved piece’s original location, effectively not placing an arrow. Movement and arrow shooting must follow queen moves that do not pass through any occupied cells, with the arrow’s path checked ignoring the piece’s original cell but not ignoring any other obstacles. The queen moves encompass horizontal, vertical, and diagonal directions, each advancing step-by-step through empty cells within the board boundaries. Cells are considered empty if they contain no white piece, no black piece, and no arrow. After executing a move, the piece relocates to the destination cell (x2, y2), an arrow marker is placed at the arrow target cell (x3, y3), and the original cell (x1, y1) becomes empty. Control then passes to the opposing player. The game forbids placing pieces or arrows outside the 1-to-10 coordinate range or onto occupied cells. The game terminates when the player whose turn it is has no legal moves available; at this point, that player loses and receives a score of zero, while the opponent scores 100, establishing the victory condition as rendering the opponent unable to move. The scoring reflects a binary outcome where making a move is neutral (goal 0) and being unable to move yields defeat (goal 0) for that player and victory (goal 100) for the other. Thus, players alternate moving their pieces in queen-like fashion, optionally firing an arrow shot that blocks cells, and the game continues until one player is immobilized, determining the winner.",
    "output": "(role white)\n(role black)\n(init (location  4  1 white))\n(init (location  7  1 white))\n(init (location  1  4 white))\n(init (location 10  4 white))\n(init (location  1  7 black))\n(init (location 10  7 black))\n(init (location  4 10 black))\n(init (location  7 10 black))\n(init (control white))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n    (true (control ?player))\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?x2 ?y2)\n    (emptyCell ?x2 ?y2)\n    (queenMoveIgnoring ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (emptyCell ?x3 ?y3))\n(<= (legal ?player (play ?x1 ?y1 ?x2 ?y2 ?x1 ?y1))\n    (true (control ?player))\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?x2 ?y2)\n    (emptyCell ?x2 ?y2))\n(<= (next (location ?x ?y ?state))\n    (true (location ?x ?y ?state))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n    (distinctCell ?x ?y ?x1 ?y1))\n(<= (next (location ?x2 ?y2 ?player))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)))\n(<= (next (location ?x3 ?y3 arrow))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)))\n(<= (next (control black))\n    (true (control white)))\n(<= (next (control white))\n    (true (control black)))\n(<= terminal\n    (not (legalMove white)))\n(<= terminal\n    (not (legalMove black)))\n(<= (goal white 100)\n    (not (legalMove white)))\n(<= (goal white 0)\n    (legalMove white))\n(<= (goal black 100)\n    (not (legalMove black)))\n(<= (goal black 0)\n    (legalMove black))\n(<= (legalMove ?player)\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?xAny ?yAny)\n    (emptyCell ?xAny ?yAny))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (rookMove ?x1 ?y1 ?x2 ?y2))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (bishopMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (horizontalMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (horizontalMove ?x2 ?y2 ?x1 ?y1))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (verticalMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (verticalMove ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMove ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMove ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMove ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMove ?x2 ?y2 ?x1 ?y1))\n(<= (horizontalMove ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (emptyCell ?x2 ?y)\n    (horizontalMove ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMove ?x1 ?y ?x2 ?y)\n    (++ ?x1 ?x2)\n    (index ?y))\n(<= (verticalMove ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (emptyCell ?x ?y2)\n    (verticalMove ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMove ?x ?y1 ?x ?y2)\n    (++ ?y1 ?y2)\n    (index ?x))\n(<= (diagonalUpMove ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (emptyCell ?x2 ?y2)\n    (diagonalUpMove ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMove ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2))\n(<= (diagonalDownMove ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (emptyCell ?x2 ?y2)\n    (diagonalDownMove ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMove ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1))\n(<= (queenMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (queenMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (emptyCell ?x2 ?y)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMoveIgnoring ?x2 ?y ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (horizontalMoveIgnoring ?x2 ?y ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y ?x2 ?y)\n    (++ ?x1 ?x2)\n    (index ?y)\n    (cell ?xIg ?yIg))\n(<= (verticalMoveIgnoring ?xIg ?yIg ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (emptyCell ?x ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMoveIgnoring ?x ?y2 ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (verticalMoveIgnoring ?x ?y2 ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMoveIgnoring ?xIg ?yIg ?x ?y1 ?x ?y2)\n    (++ ?y1 ?y2)\n    (index ?x)\n    (cell ?xIg ?yIg))\n(<= (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (emptyCell ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMoveIgnoring ?x2 ?y2 ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (diagonalUpMoveIgnoring ?x2 ?y2 ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (cell ?xIg ?yIg))\n(<= (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (emptyCell ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMoveIgnoring ?x2 ?y2 ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (diagonalDownMoveIgnoring ?x2 ?y2 ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (cell ?xIg ?yIg))\n(<= (emptyCell ?x ?y)\n    (cell ?x ?y)\n    (not (true (location ?x ?y white)))\n    (not (true (location ?x ?y black)))\n\t(not (true (location ?x ?y arrow))))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8) (index 9) (index 10)\n(++ 1 2)  (++ 2 3)  (++ 3 4)  (++ 4 5)  (++ 5 6)  (++ 6 7)  (++ 7 8)  (++ 8 9)  (++ 9 10)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid defined by rows labeled from 'a' through 'i' and columns numbered from 1 through 9, with certain positions marked as out of bounds to create an irregular board shape. The board includes three types of lines: horizontal rows, vertical columns, and special diagonal-like vertical lines identified by labels such as 'a5', 'a6', up to 'e9', each encompassing specific cells on the board. Two players, red and blue, alternate turns starting with red having the initial control. On a player's turn, they may either place their marker on a cell or perform a noop (no operation) move if it is not their turn. A placement action consists of specifying the row and column coordinates, and is legal only if the chosen cell is within bounds and unoccupied by either player's marker. After a placement, the cell becomes occupied by the placing player's marker, and the control switches to the other player. The game maintains counts of markers placed by each player along various lines. When a player places a marker on a cell that belongs to a particular line, the count for that line and player increments by one. In addition to line counts, the game tracks the number of lines in which a player is one marker short of achieving a majority, where majority thresholds vary per line and are predefined by the game's parameters. A player’s goal is to secure a majority in at least five lines in any two of the three categories: letter lines (rows), number lines (columns), or vertical lines (the special diagonals). The game reaches a terminal state when a player achieves this condition, winning with a score of 100, while the opponent scores zero. Throughout the game, moves must respect the board boundaries and avoid placing markers in occupied or out-of-bounds cells. The sequence of play continues with players alternating turns, placing markers or passing when it is not their turn, until one player fulfills the victory criteria by attaining majorities in the requisite lines.",
    "output": "(role red)\n  (role blue)\n  (init (control red))\n  (init (lastcontrol red))\n  (<= (init (line_count ?id ?r 0))\n      (line_id ?id)\n      (role ?r))\n  (<= (init (num_letter_lines ?r 0))\n      (role ?r))\n  (<= (init (num_number_lines ?r 0))\n      (role ?r))\n  (<= (init (num_vertical_lines ?r 0))\n      (role ?r))\n  (<= (legal ?r (place ?m ?n))\n      (true (control ?r))\n      (row ?m)\n      (col ?n)\n      (not (true (cell ?m ?n red)))\n      (not (true (cell ?m ?n blue)))\n      (not (oob ?m ?n)))\n  (<= (legal red noop)\n      (true (control blue)))\n  (<= (legal blue noop)\n      (true (control red)))\n  (<= (next (cell ?m ?n ?r))\n      (does ?r (place ?m ?n)))\n  (<= (next (cell ?m ?n ?r))\n      (true (cell ?m ?n ?r)))\n  (<= (next (lastcontrol ?r))\n      (true (control ?r)))\n  (<= (next (control red))\n      (true (lastcontrol blue)))\n  (<= (next (control blue))\n      (true (lastcontrol red)))\n  (<= (next (line_count ?id ?r ?count))\n      (true (line_count ?id ?r ?count)))\n  (<= (next (line_count ?id ?r ?count))\n      (true (line_count ?id ?r ?prev))\n      (succ ?prev ?count)\n      (does ?r (place ?m ?n))\n      (in_line ?id ?m ?n))\n  (<= (next (num_letter_lines ?r ?count))\n      (true (num_letter_lines ?r ?count)))\n  (<= (next (num_letter_lines ?r ?count))\n      (true (num_letter_lines ?r ?prev))\n      (succ ?prev ?count)\n      (does ?r (place ?m ?n))\n      (in_line ?id ?m ?n)\n      (row ?id)\n      (one_short_of_line_majority ?id ?r))\n  (<= (next (num_number_lines ?r ?count))\n      (true (num_number_lines ?r ?count)))\n  (<= (next (num_number_lines ?r ?count))\n      (true (num_number_lines ?r ?prev))\n      (succ ?prev ?count)\n      (does ?r (place ?m ?n))\n      (in_line ?id ?m ?n)\n      (col ?id)\n      (one_short_of_line_majority ?id ?r))\n  (<= (next (num_vertical_lines ?r ?count))\n      (true (num_vertical_lines ?r ?count)))\n  (<= (next (num_vertical_lines ?r ?count))\n      (true (num_vertical_lines ?r ?prev))\n      (succ ?prev ?count)\n      (does ?r (place ?m ?n))\n      (in_line ?id ?m ?n)\n      (ver ?id)\n      (one_short_of_line_majority ?id ?r))\n  (<= (goal ?r 100)\n      (role ?r)\n      (majority_numbers ?r)\n      (majority_letters ?r))\n  (<= (goal ?r 100)\n      (role ?r)\n      (majority_numbers ?r)\n      (majority_verticals ?r))\n  (<= (goal ?r 100)\n      (role ?r)\n      (majority_letters ?r)\n      (majority_verticals ?r))\n  (<= (goal ?r 0)\n      (role ?r)\n      (not (goal ?r 100)))\n  (<= terminal\n      (role ?r)\n      (goal ?r 100))\n  (<= (line_id ?id)\n      (row ?id))\n  (<= (line_id ?id)\n      (col ?id))\n  (<= (line_id ?id)\n      (ver ?id))\n  (<= (in_line ?m ?m ?n)\n      (row ?m)\n      (col ?n))\n  (<= (in_line ?n ?m ?n)\n      (row ?m)\n      (col ?n))\n  (<= (in_line ?id ?m ?n)\n      (in_ver ?id ?m ?n))\n  (<= (has_line_majority ?id ?r)\n      (true (line_count ?id ?r ?count))\n      (maj ?id ?count))\n  (<= (one_short_of_line_majority ?id ?r)\n      (maj ?id ?maj_req)\n      (succ ?one_short ?maj_req)\n      (true (line_count ?id ?r ?one_short))\n      (not (true (line_count ?id ?r ?maj_req))))\n  (<= (majority_letters ?r)\n      (true (num_letter_lines ?r 5)))\n  (<= (majority_numbers ?r)\n      (true (num_number_lines ?r 5)))\n  (<= (majority_verticals ?r)\n      (true (num_vertical_lines ?r 5)))\n  (row a)\n  (row b)\n  (row c)\n  (row d)\n  (row e)\n  (row f)\n  (row g)\n  (row h)\n  (row i)\n  (col 1)\n  (col 2)\n  (col 3)\n  (col 4)\n  (col 5)\n  (col 6)\n  (col 7)\n  (col 8)\n  (col 9)\n  (ver a5)\n  (ver a6)\n  (ver a7)\n  (ver a8)\n  (ver a9)\n  (ver b9)\n  (ver c9)\n  (ver d9)\n  (ver e9)\n  (in_ver a5 a 5)\n  (in_ver a5 b 4)\n  (in_ver a5 c 3)\n  (in_ver a5 d 2)\n  (in_ver a5 e 1)\n  (in_ver a6 a 6)\n  (in_ver a6 b 5)\n  (in_ver a6 c 4)\n  (in_ver a6 d 3)\n  (in_ver a6 e 2)\n  (in_ver a6 f 1)\n  (in_ver a7 a 7)\n  (in_ver a7 b 6)\n  (in_ver a7 c 5)\n  (in_ver a7 d 4)\n  (in_ver a7 e 3)\n  (in_ver a7 f 2)\n  (in_ver a7 g 1)\n  (in_ver a8 a 8)\n  (in_ver a8 b 7)\n  (in_ver a8 c 6)\n  (in_ver a8 d 5)\n  (in_ver a8 e 4)\n  (in_ver a8 f 3)\n  (in_ver a8 g 2)\n  (in_ver a8 h 1)\n  (in_ver a9 a 9)\n  (in_ver a9 b 8)\n  (in_ver a9 c 7)\n  (in_ver a9 d 6)\n  (in_ver a9 e 5)\n  (in_ver a9 f 4)\n  (in_ver a9 g 3)\n  (in_ver a9 h 2)\n  (in_ver a9 i 1)\n  (in_ver b9 b 9)\n  (in_ver b9 c 8)\n  (in_ver b9 d 7)\n  (in_ver b9 e 6)\n  (in_ver b9 f 5)\n  (in_ver b9 g 4)\n  (in_ver b9 h 3)\n  (in_ver b9 i 2)\n  (in_ver c9 c 9)\n  (in_ver c9 d 8)\n  (in_ver c9 e 7)\n  (in_ver c9 f 6)\n  (in_ver c9 g 5)\n  (in_ver c9 h 4)\n  (in_ver c9 i 3)\n  (in_ver d9 d 9)\n  (in_ver d9 e 8)\n  (in_ver d9 f 7)\n  (in_ver d9 g 6)\n  (in_ver d9 h 5)\n  (in_ver d9 i 4)\n  (in_ver e9 e 9)\n  (in_ver e9 f 8)\n  (in_ver e9 g 7)\n  (in_ver e9 h 6)\n  (in_ver e9 i 5)\n  (oob a 1)\n  (oob a 2)\n  (oob a 3)\n  (oob a 4)\n  (oob b 1)\n  (oob b 2)\n  (oob b 3)\n  (oob c 1)\n  (oob c 2)\n  (oob d 1)\n  (oob f 9)\n  (oob g 8)\n  (oob g 9)\n  (oob h 7)\n  (oob h 8)\n  (oob h 9)\n  (oob i 6)\n  (oob i 7)\n  (oob i 8)\n  (oob i 9)\n  (oob b 8)\n  (oob d 6)\n  (oob e 2)\n  (oob e 4)\n  (oob f 5)\n  (oob h 5)\n  (maj a 3)\n  (maj b 3)\n  (maj c 4)\n  (maj d 4)\n  (maj e 4)\n  (maj f 4)\n  (maj g 4)\n  (maj h 3)\n  (maj i 3)\n  (maj 1 3)\n  (maj 2 3)\n  (maj 3 4)\n  (maj 4 4)\n  (maj 5 4)\n  (maj 6 4)\n  (maj 7 4)\n  (maj 8 3)\n  (maj 9 3)\n  (maj a5 3)\n  (maj a6 3)\n  (maj a7 4)\n  (maj a8 4)\n  (maj a9 4)\n  (maj b9 4)\n  (maj c9 4)\n  (maj d9 3)\n  (maj e9 3)\n  (num 0)\n  (num 1)\n  (num 2)\n  (num 3)\n  (num 4)\n  (num 5)\n  (num 6)\n  (num 7)\n  (succ 0 1)\n  (succ 1 2)\n  (succ 2 3)\n  (succ 3 4)\n  (succ 4 5)\n  (succ 5 6)\n  (succ 6 7)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a grid defined by rows labeled r1 through r7 and columns labeled c1 through c9, forming a 7-by-9 coordinate system where each cell is identified by a column-row pair such as c6 r4. The environment includes various cell types: blank spaces (denoted as b), walls, points, and an exit cell. The snake player is the sole participant and takes turns exclusively. Initially, multiple cells are set with specific contents including walls, points, blank spaces, and one exit cell, and the snake’s head and tail positions both start at cell c6 r4 with zero points and step count zero. On each turn, the snake may legally move one cell in one of four directions—up, down, left, or right—provided the destination cell is either blank, a point, or the exit, thus preventing movement onto walls or outside the board boundaries. Moves are encoded as actions specifying the direction of movement, and the game enforces that only moves into permissible adjacent cells are legal. The snake's position updates to the new cell after a move, and the tail position updates alternately on even moves, effectively simulating the snake's body movement by clearing the tail cell if it no longer occupies it. Collecting a point cell triggers an automatic score increment, with points scored increasing from 0 up to a maximum of 100 according to a predefined scale depending on the number of points collected. The environment prohibits overlapping occupancy by the snake and walls, and all movements must remain within the grid. The game terminates if the snake reaches the exit cell, if fifty steps have been taken, or if no legal moves remain for the snake. Victory or scoring is determined by the number of points collected upon exiting; if the snake reaches the exit, the final score corresponds to the points collected, otherwise a score of zero is awarded. Thus, the player controls the snake to navigate the grid, avoid walls, collect points, and reach the exit within a limited number of steps while maximizing their score.",
    "output": "(role snake)\n(init (cell c1 r1 b))\n(init (cell c2 r1 b))\n(init (cell c3 r1 b))\n(init (cell c4 r1 wall))\n(init (cell c5 r1 b))\n(init (cell c6 r1 b))\n(init (cell c7 r1 wall))\n(init (cell c8 r1 point))\n(init (cell c9 r1 b))\n(init (cell c1 r2 wall))\n(init (cell c2 r2 wall))\n(init (cell c3 r2 point))\n(init (cell c4 r2 wall))\n(init (cell c5 r2 b))\n(init (cell c6 r2 b))\n(init (cell c7 r2 b))\n(init (cell c8 r2 b))\n(init (cell c9 r2 b))\n(init (cell c1 r3 b))\n(init (cell c2 r3 b))\n(init (cell c3 r3 b))\n(init (cell c4 r3 wall))\n(init (cell c5 r3 wall))\n(init (cell c6 r3 wall))\n(init (cell c7 r3 b))\n(init (cell c8 r3 wall))\n(init (cell c9 r3 wall))\n(init (cell c1 r4 point))\n(init (cell c2 r4 wall))\n(init (cell c3 r4 b))\n(init (cell c4 r4 b))\n(init (cell c5 r4 b))\n(init (cell c6 r4 b))\n(init (cell c7 r4 b))\n(init (cell c8 r4 b))\n(init (cell c9 r4 b))\n(init (cell c1 r5 wall))\n(init (cell c2 r5 wall))\n(init (cell c3 r5 b))\n(init (cell c4 r5 wall))\n(init (cell c5 r5 wall))\n(init (cell c6 r5 b))\n(init (cell c7 r5 wall))\n(init (cell c8 r5 b))\n(init (cell c9 r5 wall))\n(init (cell c1 r6 b))\n(init (cell c2 r6 wall))\n(init (cell c3 r6 exit))\n(init (cell c4 r6 b))\n(init (cell c5 r6 b))\n(init (cell c6 r6 point))\n(init (cell c7 r6 wall))\n(init (cell c8 r6 b))\n(init (cell c9 r6 b))\n(init (cell c1 r7 b))\n(init (cell c2 r7 wall))\n(init (cell c3 r7 wall))\n(init (cell c4 r7 wall))\n(init (cell c5 r7 wall))\n(init (cell c6 r7 b))\n(init (cell c7 r7 wall))\n(init (cell c8 r7 b))\n(init (cell c9 r7 b))\n(init (step 0))\n(init (pos c6 r4))\n(init (tailpos c6 r4))\n(init (points 0))\n(<= (nextcell ?x ?y1 mov_up ?x ?y2)\n(rowinc ?y2 ?y1)\n(column ?x))\n(<= (nextcell ?x ?y1 mov_down ?x ?y2)\n(rowinc ?y1 ?y2)\n(column ?x))\n(<= (nextcell ?x1 ?y mov_left ?x2 ?y)\n(colinc ?x2 ?x1)\n(row ?y))\n(<= (nextcell ?x1 ?y mov_right ?x2 ?y)\n(colinc ?x1 ?x2)\n(row ?y))\n(rowinc r1 r2) (rowinc r2 r3) (rowinc r3 r4) (rowinc r4 r5) (rowinc r5 r6) (rowinc r6 r7) (rowinc r7 r1)\n(row r1) (row r2) (row r3) (row r4) (row r5) (row r6) (row r7)\n(colinc c1 c2) (colinc c2 c3) (colinc c3 c4) (colinc c4 c5) (colinc c5 c6) (colinc c6 c7) (colinc c7 c8) (colinc c8 c9) (colinc c9 c1)\n(column c1) (column c2) (column c3) (column c4) (column c5) (column c6) (column c7) (column c8) (column c9)\n(<= (legal snake ?move)\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn)\n(maymove ?xn ?yn))\n(<= (maymove ?x ?y)\n(or\n(true (cell ?x ?y b))\n(true (cell ?x ?y point))\n(true (cell ?x ?y exit))\n))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(<= (next (cell ?x ?y ?move))\n(does snake ?move)\n(true (pos ?x ?y)))\n(<= (next (pos ?xn ?yn))\n(does snake ?move)\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn))\n(<= (next evenmove) (not (true evenmove)))\n(<= (next (tailpos ?x ?y))\n(not (true evenmove))\n(true (tailpos ?x ?y)))\n(<= (next (tailpos ?xn ?yn))\n(true evenmove)\n(true (tailpos ?x ?y))\n(true (cell ?x ?y ?move))\n(nextcell ?x ?y ?move ?xn ?yn))\n(<= (next (cell ?x ?y b))\n(true evenmove)\n(true (tailpos ?x ?y))\n(not (true (pos ?x ?y))))\n(<= (next (cell ?x ?y ?sym))\n(true (cell ?x ?y ?sym))\n(not (true (pos ?x ?y)))\n(or\n(not (true evenmove))\n(not (true (tailpos ?x ?y)))))\n(<= (next (points ?n1))\n(true (points ?n))\ndoscore\n(succ ?n ?n1))\n(<= (next (points ?n))\n(true (points ?n))\n(not doscore))\n(<= doscore\n(true (pos ?x ?y))\n(true (cell ?x ?y point)))\n(score 0 0)\n(score 1 85)\n(score 2 90)\n(score 3 95)\n(score 4 100)\n(<= (goal snake ?s)\n(true (points ?n))\n(true (pos ?x ?y))\n(true (cell ?x ?y exit))\n(score ?n ?s))\n(<= (goal snake 0)\n(true (pos ?x ?y))\n(not (true (cell ?x ?y exit))))\n(<= terminal\n(true (pos ?x ?y))\n(true (cell ?x ?y exit)))\n(<= terminal\n(true (step 50)))\n(<= terminal\n(not exists_legal))\n(<= exists_legal\n(legal snake ?move))\n(<= (smaller ?x ?y)\n(succ ?x ?y))\n(<= (smaller ?x ?z)\n(succ ?y ?z)\n(smaller ?x ?y))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game takes place on an 8x8 grid defined by the coordinates a through h along both the horizontal (x) and vertical (y) axes, forming a square board with cells identified by pairs such as (a,a), (b,c), and so forth. There are two players, designated as \"x\" and \"o,\" who alternate turns, with player \"x\" starting the game initially in control. Each cell on the board begins in an unoccupied state, marked by \"b\" for blank, and initially, every cell is blank. On a player's turn, they may perform an action to mark a single empty cell with their symbol (\"x\" or \"o\"), thereby claiming that position. The format of an action is a mark command specifying the coordinates of the cell the player wishes to claim, and this move is legal only if the cell is currently blank and it is the acting player's turn. Alternatively, if it is not a player's turn, their only legal action is a noop, representing a pass or no operation. After a player marks a cell, control passes to the other player automatically. The state updates by changing the marked cell from blank to the player's symbol, while all other cells remain as they were unless marked anew. The board’s boundaries are implicitly enforced, as only coordinates from a to h are valid, and no cell may be occupied by more than one mark. The game ends when either player achieves a line of exactly five of their own marks consecutively in any row, column, or along either of the two diagonal directions, or when no empty cells remain on the board, resulting in a terminal state. A line of five is defined by five contiguous cells along one of these directions, with each adjacent pair of cells connected by their sequential coordinates (e.g., a to b, b to c, etc.). Victory is awarded to the player who first forms such a five-in-a-row line, granting them a perfect score of 100 points, while the opponent receives zero. If no such line exists and the board is full, both players receive a score of 50 points, indicating a draw or stalemate. This structure ensures a strategic contest where players strive to outmaneuver each other by claiming contiguous sequences of cells before the opponent, carefully managing the spatial relationships and timing of their moves within the confines of the square grid.",
    "output": "(role x)\n(role o)\n(init (cell a a b))\n(init (cell b a b))\n(init (cell c a b))\n(init (cell d a b))\n(init (cell e a b))\n(init (cell f a b))\n(init (cell g a b))\n(init (cell h a b))\n(init (cell a b b))\n(init (cell b b b))\n(init (cell c b b))\n(init (cell d b b))\n(init (cell e b b))\n(init (cell f b b))\n(init (cell g b b))\n(init (cell h b b))\n(init (cell a c b))\n(init (cell b c b))\n(init (cell c c b))\n(init (cell d c b))\n(init (cell e c b))\n(init (cell f c b))\n(init (cell g c b))\n(init (cell h c b))\n(init (cell a d b))\n(init (cell b d b))\n(init (cell c d b))\n(init (cell d d b))\n(init (cell e d b))\n(init (cell f d b))\n(init (cell g d b))\n(init (cell h d b))\n(init (cell a e b))\n(init (cell b e b))\n(init (cell c e b))\n(init (cell d e b))\n(init (cell e e b))\n(init (cell f e b))\n(init (cell g e b))\n(init (cell h e b))\n(init (cell a f b))\n(init (cell b f b))\n(init (cell c f b))\n(init (cell d f b))\n(init (cell e f b))\n(init (cell f f b))\n(init (cell g f b))\n(init (cell h f b))\n(init (cell a g b))\n(init (cell b g b))\n(init (cell c g b))\n(init (cell d g b))\n(init (cell e g b))\n(init (cell f g b))\n(init (cell g g b))\n(init (cell h g b))\n(init (cell a h b))\n(init (cell b h b))\n(init (cell c h b))\n(init (cell d h b))\n(init (cell e h b))\n(init (cell f h b))\n(init (cell g h b))\n(init (cell h h b))\n(init (control x))\n(<= (next (control ?r))\n    (does ?r noop))\n(<= (next (cell ?x ?y ?r))\n(does ?r (mark ?x ?y)))\n(<= (next (cell ?x ?y ?c))\n(true (cell ?x ?y ?c))\n(does ?r (mark ?x1 ?y1))\n(or (distinct ?x ?x1)\n(distinct ?y ?y1)))\n(<= (legal ?r (mark ?x ?y))\n    (true (control ?r))\n    (true (cell ?x ?y b))\n)\n(<= (legal ?r noop)\n(role ?r)\n(not (true (control ?r))))\n(<= (goal ?r 100)\n(conn5 ?r))\n(<= (goal x 0)\n(conn5 o))\n(<= (goal o 0)\n(conn5 x))\n(<= (goal x 50)\n(not exists_line_of_five))\n(<= (goal o 50)\n(not exists_line_of_five))\n(<= terminal\nexists_line_of_five)\n(<= terminal\n(not exists_empty_cell))\n(<= exists_empty_cell\n(true (cell ?x ?y b)))\n(<= exists_line_of_five\n(role ?r)\n(conn5 ?r))\n(<= (conn5 ?r)\n(or (col ?r) (row ?r) (diag1 ?r) (diag2 ?r)))\n(<= (row ?r)\n    (true (cell ?a ?y ?r))\n(nextcol ?a ?b)\n    (true (cell ?b ?y ?r))\n(nextcol ?b ?c)\n    (true (cell ?c ?y ?r))\n(nextcol ?c ?d)\n    (true (cell ?d ?y ?r))\n(nextcol ?d ?e)\n    (true (cell ?e ?y ?r)))\n(<= (col ?r)\n    (true (cell ?x ?a ?r))\n(nextcol ?a ?b)\n    (true (cell ?x ?b ?r))\n(nextcol ?b ?c)\n    (true (cell ?x ?c ?r))\n(nextcol ?c ?d)\n    (true (cell ?x ?d ?r))\n(nextcol ?d ?e)\n    (true (cell ?x ?e ?r)))\n(<= (diag1 ?r)\n    (true (cell ?x1 ?y1 ?r))\n(nextcol ?x1 ?x2)\n(nextcol ?y1 ?y2)\n    (true (cell ?x2 ?y2 ?r))\n(nextcol ?x2 ?x3)\n(nextcol ?y2 ?y3)\n    (true (cell ?x3 ?y3 ?r))\n(nextcol ?x3 ?x4)\n(nextcol ?y3 ?y4)\n    (true (cell ?x4 ?y4 ?r))\n(nextcol ?x4 ?x5)\n(nextcol ?y4 ?y5)\n    (true (cell ?x5 ?y5 ?r)))\n(<= (diag2 ?r)\n    (true (cell ?x1 ?y5 ?r))\n(nextcol ?x1 ?x2)\n(nextcol ?y4 ?y5)\n    (true (cell ?x2 ?y4 ?r))\n(nextcol ?x2 ?x3)\n(nextcol ?y3 ?y4)\n    (true (cell ?x3 ?y3 ?r))\n(nextcol ?x3 ?x4)\n(nextcol ?y2 ?y3)\n    (true (cell ?x4 ?y2 ?r))\n(nextcol ?x4 ?x5)\n(nextcol ?y1 ?y2)\n    (true (cell ?x5 ?y1 ?r)))\n(nextcol a b)\n(nextcol b c)\n(nextcol c d)\n(nextcol d e)\n(nextcol e f)\n(nextcol f g)\n(nextcol g h)\n(coordinate a)\n(coordinate b)\n(coordinate c)\n(coordinate d)\n(coordinate e)\n(coordinate f)\n(coordinate g)\n(coordinate h)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid with coordinates ranging from 1 to 6 along both the horizontal (x) and vertical (y) axes, forming a 6-by-6 board. There are two players, designated as white and black, who alternate turns starting with white. Initially, the white player’s pieces occupy all cells in the first and second rows (y=1 and y=2), while the black player’s pieces occupy all cells in the fifth and sixth rows (y=5 and y=6). On a player's turn, they may move one of their own pieces according to specific movement rules or choose to take no action (noop) if it is not their turn. White pieces move forward by increasing their y-coordinate by one, while black pieces move forward by decreasing their y-coordinate by one, reflecting their opposing directions. Moves may be directly forward in the same column into an empty cell or diagonally forward by one column to the left or right, provided the destination cell is not occupied by a piece of the same color. The movement must respect board boundaries and cannot land on a cell occupied by a friendly piece; however, moving into a cell occupied by an opposing piece is not allowed either, as indicated by the move legality conditions. If a player is not in control (i.e., it is the opponent’s turn), their only legal action is noop, effectively passing the turn. After a legal move, the piece relocates to the new cell, and the previous cell becomes empty, with control passing to the opposing player. The game ends when either a white piece reaches any cell in the topmost row (y=6), or a black piece reaches any cell in the bottom row (y=1), or when one player has no pieces remaining on the board. Victory is awarded to the player who achieves these conditions, granting them a full score of 100, while the opponent receives zero. Thus, the game revolves around advancing pieces forward into the opponent’s territory without violating movement constraints, with the objective of either reaching the opponent’s baseline first or completely eliminating the opponent’s pieces.",
    "output": "(role white)\n(role black)\n(init (cell 1 1 white))\n(init (cell 2 1 white))\n(init (cell 3 1 white))\n(init (cell 4 1 white))\n(init (cell 5 1 white))\n(init (cell 6 1 white))\n(init (cell 1 2 white))\n(init (cell 2 2 white))\n(init (cell 3 2 white))\n(init (cell 4 2 white))\n(init (cell 5 2 white))\n(init (cell 6 2 white))\n(init (cell 1 5 black))\n(init (cell 2 5 black))\n(init (cell 3 5 black))\n(init (cell 4 5 black))\n(init (cell 5 5 black))\n(init (cell 6 5 black))\n(init (cell 1 6 black))\n(init (cell 2 6 black))\n(init (cell 3 6 black))\n(init (cell 4 6 black))\n(init (cell 5 6 black))\n(init (cell 6 6 black))\n(init (control white))\n(<= (legal white (move ?x ?y1 ?x ?y2))\n    (true (control white))\n    (true (cell ?x ?y1 white))\n    (plusplus ?y1 ?y2)\n    (cellEmpty ?x ?y2))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cell ?x1 ?y1 white))\n    (plusplus ?y1 ?y2)\n    (plusplus ?x1 ?x2)\n    (not (true (cell ?x2 ?y2 white))))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cell ?x1 ?y1 white))\n    (plusplus ?y1 ?y2)\n    (plusplus ?x2 ?x1)\n    (not (true (cell ?x2 ?y2 white))))\n(<= (legal black (move ?x ?y1 ?x ?y2))\n    (true (control black))\n    (true (cell ?x ?y1 black))\n    (plusplus ?y2 ?y1)\n    (cellEmpty ?x ?y2))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cell ?x1 ?y1 black))\n    (plusplus ?y2 ?y1)\n    (plusplus ?x1 ?x2)\n    (not (true (cell ?x2 ?y2 black))))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cell ?x1 ?y1 black))\n    (plusplus ?y2 ?y1)\n    (plusplus ?x2 ?x1)\n    (not (true (cell ?x2 ?y2 black))))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black noop)\n    (true (control white)))\n(<= (next (cell ?x2 ?y2 ?player))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x3 ?y3 ?state))\n    (true (cell ?x3 ?y3 ?state))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x3 ?y3)\n    (distinctCell ?x2 ?y2 ?x3 ?y3))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= terminal\n    whiteWin)\n(<= terminal\n    blackWin)\n(<= (goal white 100)\n    whiteWin)\n(<= (goal white 0)\n    (not whiteWin))\n(<= (goal black 100)\n    blackWin)\n(<= (goal black 0)\n    (not blackWin))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (cellEmpty ?x ?y)\n    (cell ?x ?y)\n    (not (true (cell ?x ?y white)))\n    (not (true (cell ?x ?y black))))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= whiteWin\n    (index ?x)\n    (true (cell ?x 6 white)))\n(<= blackWin\n    (index ?x)\n    (true (cell ?x 1 black)))\n(<= whiteWin\n\t(not blackCell))\n(<= blackWin\n\t(not whiteCell))\n(<= whiteCell\n\t(cell ?x ?y)\n\t(true (cell ?x ?y white)))\n(<= blackCell\n\t(cell ?x ?y)\n\t(true (cell ?x ?y black)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6)\n(plusplus 1 2)  (plusplus 2 3)  (plusplus 3 4)  (plusplus 4 5)  (plusplus 5 6)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid-based environment consisting of two overlapping boards: a smaller 3x3 tic-tac-toe board with coordinates ranging from 1 to 3 on both axes, and a larger 4x4 board also indexed from 1 to 4 on both axes. There are two players, named \"xcplayer\" and \"obplayer,\" who alternate turns in a strict sequence, starting with \"xcplayer\" as indicated by the initial control state. Each cell on both boards can be in one of several states: blank (denoted by \"b\"), marked by \"x\" (associated with \"xcplayer\"), or marked by \"o\" (associated with \"obplayer\"). Initially, all cells in the 3x3 board are blank, and control is assigned to \"xcplayer.\" On their turn, a player may perform one of two types of actions: they can either mark an unoccupied blank cell on the board corresponding to their role or choose a noop (no-operation) action when it is not their turn and the current tic is not finished. Marking a cell is only legal if the chosen cell is blank and the player currently has control; noop actions are legal only for the player who does not currently have control and when the tic is unfinished. Once a move is made, the cell's state updates to reflect the player's mark, and control passes to the other player. A reset action is also available but only when a tic is finished and no tic score has yet been recorded. The game detects lines of three identical marks horizontally, vertically, or diagonally on the 3x3 board, which constitutes a finished tic. Scores for each player in a tic are assigned as 50 points for a winning line, 25 points for a draw (no lines for either player and no open cells), and 0 points for losing lines. The tic scores accumulate over the course of the game. On the larger 4x4 board, a \"bridge\" is defined as a contiguous chain of four \"xcplayer\" marks connected through predefined adjacent coordinates, forming a specific pattern across rows and columns. The presence or absence of this bridge affects the scoring for the block phase; if the bridge exists, \"xcplayer\" scores 50 points and \"obplayer\" scores 0, otherwise the scores are reversed. The game ends when both a tic score has been recorded (indicating the tic is finished) and the block phase is finished, which occurs either when the bridge is established or when no blank cells remain on the 4x4 board. At termination, each player's final score is the sum of their accumulated tic scores and their block phase score. The player with the higher total score is the winner. Implicit constraints include the bounded coordinate systems for rows and columns on both boards, the exclusivity of cell occupancy (a cell cannot be marked more than once), and the alternation of control ensuring proper turn-taking. No moves are legal on occupied cells or out-of-bounds coordinates. The game thus combines a classic tic-tac-toe mechanic with an overlaying strategic placement on a larger grid, culminating in a composite scoring system that rewards success in both phases.",
    "output": "(role xcplayer)\n(role obplayer)\n(init (cell 1 1 b))\n(init (cell 1 2 b))\n(init (cell 1 3 b))\n(init (cell 2 1 b))\n(init (cell 2 2 b))\n(init (cell 2 3 b))\n(init (cell 3 1 b))\n(init (cell 3 2 b))\n(init (cell 3 3 b))\n(init (control xcplayer))\n(<= (next (cellb 1 1 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 1 2 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 1 3 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 1 4 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 2 1 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 2 2 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 2 3 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 2 4 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 3 1 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 3 2 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 3 3 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 3 4 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 4 1 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 4 2 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 4 3 b)) (does ?p reset) (role ?p))\n(<= (next (cellb 4 4 b)) (does ?p reset) (role ?p))\n(<= (next (ticscores ?x ?y)) (does ?p reset) (role ?p) (finishedtic ?x ?y))\n(<= (next (ticscores ?x ?y)) (true (ticscores ?x ?y)))\n(<= (next (cell ?m ?n x))\n(does xcplayer (mark ?m ?n))\n(true (cell ?m ?n b))\n(not reseted))\n(<= (next (cell ?m ?n o))\n(does obplayer (mark ?m ?n))\n(true (cell ?m ?n b))\n(not reseted))\n(<= (next (cell ?m ?n ?w))\n(true (cell ?m ?n ?w))\n(distinct ?w b)\n(not reseted))\n(<= (next (cell ?m ?n b))\n(does ?w (mark ?j ?k))\n(true (cell ?m ?n b))\n(or (distinct ?m ?j) (distinct ?n ?k))\n(not reseted))\n(<= (next (control xcplayer))\n(true (control obplayer))\n(not reseted))\n(<= (next (control obplayer))\n(true (control xcplayer))\n(not reseted))\n(<= (row ?m ?x)\n(true (cell ?m 1 ?x))\n(true (cell ?m 2 ?x))\n(true (cell ?m 3 ?x)))\n(<= (column ?n ?x)\n(true (cell 1 ?n ?x))\n(true (cell 2 ?n ?x))\n(true (cell 3 ?n ?x)))\n(<= (diagonal ?x)\n(true (cell 1 1 ?x))\n(true (cell 2 2 ?x))\n(true (cell 3 3 ?x)))\n(<= (diagonal ?x)\n(true (cell 1 3 ?x))\n(true (cell 2 2 ?x))\n(true (cell 3 1 ?x)))\n(<= (line ?x)\n(row ?m ?x))\n(<= (line ?x)\n(column ?m ?x))\n(<= (line ?x)\n(diagonal ?x))\n(<= open\n(true (cell ?m ?n b)))\n(<= reseted\n(does ?p reset))\n(<= ticscorz\n(true (ticscores ?x ?y)))\n(<= (legal ?w (mark ?x ?y))\n(not fintic)\n(true (cell ?x ?y b))\n(true (control ?w)))\n(<= (legal xcplayer noop)\n(not fintic)\n(true (control obplayer)))\n(<= (legal obplayer noop)\n(not fintic)\n(true (control xcplayer)))\n(<= (legal ?r reset)\n(role ?r)\nfintic\n(not ticscorz))\n(<= (goaltic xcplayer 50)\n(line x))\n(<= (goaltic xcplayer 25)\n(not (line x))\n(not (line o))\n(not open))\n(<= (goaltic xcplayer 0)\n(line o))\n(<= (goaltic obplayer 50)\n(line o))\n(<= (goaltic obplayer 25)\n(not (line x))\n(not (line o))\n(not open))\n(<= (goaltic obplayer 0)\n(line x))\n(<= fintic\n(finishedtic ?x ?y))\n(<= (finishedtic ?x ?y)\n(line x)\n(goaltic xcplayer ?x)\n(goaltic obplayer ?y))\n(<= (finishedtic ?x ?y)\n(line o)\n(goaltic xcplayer ?x)\n(goaltic obplayer ?y))\n(<= (finishedtic ?x ?y)\n(not open)\n(goaltic xcplayer ?x)\n(goaltic obplayer ?y))\n(<= (next (cellb ?m ?n blk))\n(does obplayer (mark ?m ?n))\n(true (cellb ?m ?n b)))\n(<= (next (cellb ?m ?n xcplayer))\n(does xcplayer (mark ?m ?n))\n(not (does obplayer (mark ?m ?n)))\n(true (cellb ?m ?n b)))\n(<= (next (cellb ?m ?n ?x))\n(true (cellb ?m ?n ?x))\n(distinct ?x b))\n(<= (next (cellb ?m ?n b))\n(true (cellb ?m ?n b))\n(not (does obplayer (mark ?m ?n)))\n(not (does xcplayer (mark ?m ?n))))\n(cont 1 1)\n(cont 2 2)\n(cont 3 3)\n(cont 4 4)\n(cont 1 2)\n(cont 2 3)\n(cont 3 4)\n(cont 2 1)\n(cont 3 2)\n(cont 4 3)\n(<= bridge\n(true (cellb 1 ?a xcplayer))\n(cont ?a ?b)\n(true (cellb 2 ?b xcplayer))\n(cont ?b ?c)\n(true (cellb 3 ?c xcplayer))\n(cont ?c ?d)\n(true (cellb 4 ?d xcplayer)))\n(<= openb\n(true (cellb ?m ?n b)))\n(<= (legal ?who (mark ?x ?y))\n(not finishedbloc)\n(true (cellb ?x ?y b))\n(role ?who))\n(<= (goalbloc xcplayer 50)\nbridge)\n(<= (goalbloc obplayer 0)\nbridge)\n(<= (goalbloc xcplayer 0)\n(not bridge))\n(<= (goalbloc obplayer 50)\n(not bridge))\n(<= finishedbloc\nbridge)\n(<= finishedbloc\n(not openb))\n(<= terminal\nticscorz\nfinishedbloc)\n(<= (goal xcplayer ?x)\n(true (ticscores ?xc ?ob))\n(goalbloc xcplayer ?y)\n(sum ?xc ?y ?x))\n(<= (goal obplayer ?x)\n(true (ticscores ?xc ?ob))\n(goalbloc obplayer ?y)\n(sum ?ob ?y ?x))\n(sum 0 0 0)\n(sum 0 25 25)\n(sum 0 50 50)\n(sum 25 0 25)\n(sum 25 25 50)\n(sum 25 50 75)\n(sum 50 0 50)\n(sum 50 25 75)\n(sum 50 50 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a two-dimensional board with coordinates defined by columns labeled 1 through 20 along the horizontal axis (x-axis) and rows labeled 1 through 20 along the vertical axis (y-axis). There are two players, red and black, who alternate turns beginning with the red player in control at the initial state. On a player's turn, they may either perform a drop action or choose to do nothing (noop). However, a noop is only legal for a player when it is the other player's turn to move, effectively preventing them from acting out of turn. The drop action involves placing a piece into one of the columns, specifically into the lowest unoccupied row within that column; this is only legal if the column is open, meaning the topmost cell (row 20) of that column is free. When a piece is dropped into an empty column, it occupies the bottom cell (row 1) of that column. If the column already contains pieces, the new piece occupies the next available cell directly above the highest occupied cell, ensuring stacking from bottom to top. Pieces cannot be placed outside the board boundaries or in occupied cells. After each move, the control switches to the opposing player. The game continues until a terminal condition is met, which occurs if either player forms a line of four consecutive pieces horizontally, vertically, or diagonally, or if the board is completely filled with no open columns remaining. Lines are defined as sequences of four adjacent cells in any of these directions occupied by the same player's pieces. Upon reaching a terminal state, the player who formed the line is awarded a full score of 100, the opposing player receives zero. If no lines are formed and the board is full, both players receive a score of 50, representing a draw. If the game ends prematurely with the board still open and no line formed, the player whose opponent formed a line gains zero, while the other player also receives zero, indicating an incomplete or ongoing game state. Thus, the game's objective is to strategically drop pieces into columns to create a four-in-a-row sequence before the opponent does or before the board becomes entirely filled.",
    "output": "(role red)\n(role black)\n(init (control red))\n(<= (legal red noop)\n    (true (control black)))\n(<= (legal red (drop ?x))\n    (true (control red))\n    (columnOpen ?x))\n(<= (legal black noop)\n    (true (control red)))\n(<= (legal black (drop ?x))\n    (true (control black))\n    (columnOpen ?x))\n(<= (next (cell ?x 1 ?player))\n    (does ?player (drop ?x))\n\t  (columnEmpty ?x))\n(<= (next (cell ?x ?y2 ?player))\n    (does ?player (drop ?x))\n    (cellOpen ?x ?y2)\n    (succ ?y1 ?y2)\n    (not (cellOpen ?x ?y1)))\n(<= (next (cell ?x ?y ?player))\n    (true (cell ?x ?y ?player)))\n(<= (next (control red))\n    (true (control black)))\n(<= (next (control black))\n    (true (control red)))\n(<= terminal\n    (line red))\n(<= terminal\n    (line black))\n(<= terminal\n    (not boardOpen))\n(<= (goal red 100)\n    (line red))\n(<= (goal red 50)\n    (not (line red))\n    (not (line black))\n    (not boardOpen))\n(<= (goal red 0)\n    (line black))\n(<= (goal red 0)\n    (not (line red))\n    (not (line black))\n    boardOpen)\n(<= (goal black 100)\n    (line black))\n(<= (goal black 50)\n    (not (line red))\n    (not (line black))\n    (not boardOpen))\n(<= (goal black 0)\n    (line red))\n(<= (goal black 0)\n    (not (line red))\n    (not (line black))\n    boardOpen)\n(<= (cellOpen ?x ?y)\n    (x ?x)\n    (y ?y)\n    (not (true (cell ?x ?y red)))\n    (not (true (cell ?x ?y black))))\n(<= (columnOpen ?x)\n    (cellOpen ?x 20))\n(<= (columnEmpty ?x)\n    (cellOpen ?x 1))\n(<= boardOpen\n    (x ?x)\n    (columnOpen ?x))\n(<= (line ?player)\n    (true (cell ?x1 ?y ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (true (cell ?x2 ?y ?player))\n    (true (cell ?x3 ?y ?player))\n    (true (cell ?x4 ?y ?player)))\n(<= (line ?player)\n    (true (cell ?x ?y1 ?player))\n    (succ ?y1 ?y2)\n    (succ ?y2 ?y3)\n    (succ ?y3 ?y4)\n    (true (cell ?x ?y2 ?player))\n    (true (cell ?x ?y3 ?player))\n    (true (cell ?x ?y4 ?player)))\n(<= (line ?player)\n    (true (cell ?x1 ?y1 ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?y1 ?y2)\n    (succ ?y2 ?y3)\n    (succ ?y3 ?y4)\n    (true (cell ?x2 ?y2 ?player))\n    (true (cell ?x3 ?y3 ?player))\n    (true (cell ?x4 ?y4 ?player)))\n(<= (line ?player)\n    (true (cell ?x1 ?y4 ?player))\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?y3 ?y4)\n    (succ ?y2 ?y3)\n    (succ ?y1 ?y2)\n    (true (cell ?x2 ?y3 ?player))\n    (true (cell ?x3 ?y2 ?player))\n    (true (cell ?x4 ?y1 ?player)))\n(succ 1 2) (succ 2 3) (succ 3 4) (succ 4 5) (succ 5 6) (succ 6 7) (succ 7 8) (succ 8 9) (succ 9 10) (succ 10 11) (succ 11 12) (succ 12 13) (succ 13 14) (succ 14 15) (succ 15 16) (succ 16 17) (succ 17 18) (succ 18 19) (succ 19 20)\n(x 1) (x 2) (x 3) (x 4) (x 5) (x 6) (x 7) (x 8) (x 9) (x 10) (x 11) (x 12) (x 13) (x 14) (x 15) (x 16) (x 17) (x 18) (x 19) (x 20)\n(y 1) (y 2) (y 3) (y 4) (y 5) (y 6) (y 7) (y 8) (y 9) (y 10) (y 11) (y 12) (y 13) (y 14) (y 15) (y 16) (y 17) (y 18) (y 19) (y 20)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid defined by nine rows labeled from 'a' to 'i' and nine columns numbered from 1 to 9, forming a coordinate system where positions are specified by a row and column pair. There are two players, player1 and player2, who alternate turns beginning with player1. Each player uses a distinct marker color, with player1 initially using red and player2 blue. The initial state sets the control to player1, the step counter at 1, and allows player2 the option to swap markers once during the game. On a player's turn, if it is their control phase, they may place their marker on any unoccupied cell within the board's boundaries, meaning the cell must not already hold a red or blue marker, and the coordinates must be valid rows and columns. Player2 has an additional legal move option on their turn to swap marker colors with player1, but this can only be done once per game and only if the swap option remains available. When it is not a player's turn, they may legally perform a noop action, effectively passing. Executing a placement action updates the state by marking the chosen cell with the player's marker color and advances the step number. The control alternates each turn between the players. The game tracks connected cells of the same color, where a cell is considered connected to another if they are adjacent either horizontally, vertically, or diagonally, as defined by neighboring rows and columns. Connections propagate through placed markers, and if a newly placed marker is adjacent to an existing connected group of the same color, the connection extends to include the new placement. The swap action changes the marker colors each player is using, swapping red and blue markers between the two players, and this also disables further swaps. The game terminates when a player achieves a winning path: for the red marker, this is a continuous connected path linking the top row 'a' to the bottom row 'i', and for the blue marker, a continuous connected path joining the leftmost column 1 to the rightmost column 9. The victory condition awards 100 points to the player whose marker color forms such a connecting path; if neither player meets this condition, the game is not terminal. The board boundaries implicitly restrict placements to the defined rows and columns, and occupancy rules prevent placing markers on already occupied cells. The alternating turn structure, the optional swap by player2, the adjacency rules for connectivity, and the terminal win conditions for continuous paths across the board define the strategic and procedural framework of the game.",
    "output": "(role player1)\n  (role player2)\n  (init (control player1))\n  (init (step 1))\n  (init (usingMarker player1 red))\n  (init (usingMarker player2 blue))\n  (init canSwap)\n  (<= (legal ?r (place ?x ?y))\n      (true (control ?r))\n      (row ?x)\n      (col ?y)\n      (not (true (cell ?x ?y red)))\n      (not (true (cell ?x ?y blue))))\n  (<= (legal player2 swap)\n      (true (control player2))\n      (true canSwap))\n  (<= (legal player1 noop)\n      (true (control player2)))\n  (<= (legal player2 noop)\n      (true (control player1)))\n  (<= (next (cell ?x ?y ?m))\n      (does ?r (place ?x ?y))\n      (true (usingMarker ?r ?m)))\n  (<= (next (cell ?x ?y ?m))\n      (true (cell ?x ?y ?m)))\n  (<= (next (step ?a))\n      (true (step ?b))\n      (succ ?b ?a))\n  (<= (next (color ?k ?m))\n      (true (step ?k))\n      (true (control ?r))\n      (true (usingMarker ?r ?m)))\n  (<= (next (color ?k ?m))\n      (true (color ?k ?m)))\n  (<= (next (connected ?k ?x ?y))\n      (does ?r (place ?x ?y))\n      (true (step ?k)))\n  (<= (next (connected ?k ?x ?y))\n      (transfer ?e)\n      (true (connected ?e ?x ?y))\n      (true (step ?k)))\n  (<= (next (connected ?k ?x ?y))\n      (true (connected ?k ?x ?y))\n      (not (transfer ?k)))\n  (<= (next (control player1))\n      (true (control player2)))\n  (<= (next (control player2))\n      (true (control player1)))\n  (<= (transfer ?k)\n      (does ?r (place ?x ?y))\n      (true (usingMarker ?r ?m))\n      (true (color ?k ?m))\n      (true (connected ?k ?v ?w))\n      (adjacent ?x ?y ?v ?w))\n  (<= (next canSwap)\n      (true canSwap)\n      (does player2 noop))\n  (<= (next (usingMarker ?r ?m))\n      (true (usingMarker ?r ?m))\n      (not (does player2 swap)))\n  (<= (next (usingMarker player1 blue))\n      (does player2 swap))\n  (<= (next (usingMarker player2 red))\n      (does player2 swap))\n  (<= (goal ?r 100)\n      (true (usingMarker ?r red))\n      redpath)\n  (<= (goal ?r 100)\n      (true (usingMarker ?r blue))\n      bluepath)\n  (<= (goal ?r 0)\n      (role ?r)\n      (not (goal ?r 100)))\n  (<= terminal redpath)\n  (<= terminal bluepath)\n  (<= (adjacent ?j ?k ?j ?n)\n      (nextcol ?k ?n)\n      (row ?j))\n  (<= (adjacent ?j ?k ?j ?n)\n      (nextcol ?n ?k)\n      (row ?j))\n  (<= (adjacent ?j ?k ?m ?k)\n      (nextrow ?j ?m)\n      (col ?k))\n  (<= (adjacent ?j ?k ?m ?k)\n      (nextrow ?m ?j)\n      (col ?k))\n  (<= (adjacent ?j ?k ?m ?n)\n      (nextrow ?m ?j)\n      (nextcol ?k ?n))\n  (<= (adjacent ?j ?k ?m ?n)\n      (nextrow ?j ?m)\n      (nextcol ?n ?k))\n  (<= redpath\n      (true (connected ?k a ?i))\n      (true (connected ?k i ?j))\n      (true (color ?k red)))\n  (<= bluepath\n      (true (connected ?k ?i 1))\n      (true (connected ?k ?j 9))\n      (true (color ?k blue)))\n  (marker red)\n  (marker blue)\n  (row a)\n  (row b)\n  (row c)\n  (row d)\n  (row e)\n  (row f)\n  (row g)\n  (row h)\n  (row i)\n  (col 1)\n  (col 2)\n  (col 3)\n  (col 4)\n  (col 5)\n  (col 6)\n  (col 7)\n  (col 8)\n  (col 9)\n  (nextrow a b)\n  (nextrow b c)\n  (nextrow c d)\n  (nextrow d e)\n  (nextrow e f)\n  (nextrow f g)\n  (nextrow g h)\n  (nextrow h i)\n  (nextcol 1 2)\n  (nextcol 2 3)\n  (nextcol 3 4)\n  (nextcol 4 5)\n  (nextcol 5 6)\n  (nextcol 6 7)\n  (nextcol 7 8)\n  (nextcol 8 9)\n  (succ 1 2)\n  (succ 2 3)\n  (succ 3 4)\n  (succ 4 5)\n  (succ 5 6)\n  (succ 6 7)\n  (succ 7 8)\n  (succ 8 9)\n  (succ 9 10)\n  (succ 10 11)\n  (succ 11 12)\n  (succ 12 13)\n  (succ 13 14)\n  (succ 14 15)\n  (succ 15 16)\n  (succ 16 17)\n  (succ 17 18)\n  (succ 18 19)\n  (succ 19 20)\n  (succ 20 21)\n  (succ 21 22)\n  (succ 22 23)\n  (succ 23 24)\n  (succ 24 25)\n  (succ 25 26)\n  (succ 26 27)\n  (succ 27 28)\n  (succ 28 29)\n  (succ 29 30)\n  (succ 30 31)\n  (succ 31 32)\n  (succ 32 33)\n  (succ 33 34)\n  (succ 34 35)\n  (succ 35 36)\n  (succ 36 37)\n  (succ 37 38)\n  (succ 38 39)\n  (succ 39 40)\n  (succ 40 41)\n  (succ 41 42)\n  (succ 42 43)\n  (succ 43 44)\n  (succ 44 45)\n  (succ 45 46)\n  (succ 46 47)\n  (succ 47 48)\n  (succ 48 49)\n  (succ 49 50)\n  (succ 50 51)\n  (succ 51 52)\n  (succ 52 53)\n  (succ 53 54)\n  (succ 54 55)\n  (succ 55 56)\n  (succ 56 57)\n  (succ 57 58)\n  (succ 58 59)\n  (succ 59 60)\n  (succ 60 61)\n  (succ 61 62)\n  (succ 62 63)\n  (succ 63 64)\n  (succ 64 65)\n  (succ 65 66)\n  (succ 66 67)\n  (succ 67 68)\n  (succ 68 69)\n  (succ 69 70)\n  (succ 70 71)\n  (succ 71 72)\n  (succ 72 73)\n  (succ 73 74)\n  (succ 74 75)\n  (succ 75 76)\n  (succ 76 77)\n  (succ 77 78)\n  (succ 78 79)\n  (succ 79 80)\n  (succ 80 81)\n  (succ 81 82)\n  (succ 82 83)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a hexagonal-like grid with coordinates labeled from a1 to g7, arranged in rows and columns with specific adjacency relations defined between cells horizontally, vertically, and diagonally. There is a single player role named \"robot,\" who takes turns alone in the game. The initial state sets various cells on the board as either blank or containing numbered tokens, with some cells filled with specific numbers such as 37 at a2, 17 at c3, and so forth, while other cells start blank. On each turn, the robot may either place a new numbered token onto a blank cell or choose to quit, effectively ending the game. The placement action must specify a target cell and a number to place; this action is legal only if the cell is currently blank, the number is unused on the board, and the number is flanked by adjacent or absent numbers in the numeric sequence—specifically, the chosen number must be adjacent in value to other numbers already on or near the target cell or to numbers absent from the board but adjacent to the cell. The robot can also opt to quit, which triggers the finished state. When the robot places a number, the game state updates by marking that cell with the new number and marking the number as used; cells not targeted by the placement remain unchanged. If the robot quits, the finished state becomes true, and the game ends. The game also ends automatically when the board is completely filled with no blank cells remaining. Throughout play, the robot cannot place numbers outside the bounds of defined coordinates, must respect adjacency constraints both spatially on the board and numerically between numbers, and cannot place a number on an occupied cell. The terminal conditions are met either when the board is completely filled with numbers or when the robot chooses to quit, signaling the game's conclusion. Scoring is binary: if any blank cells remain when the game ends, the robot scores zero; if the board is fully filled with no blanks, the robot scores 100, indicating victory. Thus, the robot's objective is to fill the board with a sequence of numbers placed according to adjacency and numeric succession rules before quitting or before the board fills entirely, achieving a perfect filling for maximum score.",
    "output": "(role robot)\n(init (cell a1 blank))\n(init (cell a2 37))\n(init (cell a3 blank))\n(init (cell a4 blank))\n(init (cell b1 blank))\n(init (cell b2 blank))\n(init (cell b3 blank))\n(init (cell b4 blank))\n(init (cell b5 blank))\n(init (cell c1 blank))\n(init (cell c2 blank))\n(init (cell c3 17))\n(init (cell c4 blank))\n(init (cell c5 10))\n(init (cell c6 blank))\n(init (cell d1 blank))\n(init (cell d2  2))\n(init (cell d3 blank))\n(init (cell d4 blank))\n(init (cell d5 12))\n(init (cell d6 31))\n(init (cell d7 blank))\n(init (cell e2  1))\n(init (cell e3 blank))\n(init (cell e4 blank))\n(init (cell e5 15))\n(init (cell e6 blank))\n(init (cell e7 30))\n(init (cell f3 22))\n(init (cell f4 blank))\n(init (cell f5 blank))\n(init (cell f6 blank))\n(init (cell f7 blank))\n(init (cell g4 24))\n(init (cell g5 blank))\n(init (cell g6 blank))\n(init (cell g7 blank))\n(<= (legal robot (place ?c ?n1))\n    (true (cell ?c blank))\n    (unused ?n1)\n    (succ ?n0 ?n1)\n    (succ ?n1 ?n2)\n    (absent_or_adjacent ?n0 ?c)\n    (absent_or_adjacent ?n2 ?c))\n(<= (unused ?n)\n    (number ?n)\n    (not (used ?n)))\n(<= (used ?n)\n    (true (cell ?c ?n)))\n(<= (absent_or_adjacent ?n ?c)\n    (coord ?c)\n    (unused ?n))\n(<= (absent_or_adjacent ?n ?c1)\n    (true (cell ?c2 ?n))\n    (adjacent ?c1 ?c2))\n(legal robot quit)\n(<= (next (cell ?c ?n))\n    (true (cell ?c ?n))\n    (number ?n))\n(<= (next (cell ?c1 blank))\n    (true (cell ?c1 blank))\n    (does robot (place ?c2 ?n))\n    (distinct ?c1 ?c2))\n(<= (next (cell ?c blank))\n    (true (cell ?c blank))\n    (does robot quit))\n(<= (next (cell ?c ?n))\n    (does robot (place ?c ?n)))\n(<= (next finished)\n    (does robot quit))\n(<= terminal\n    filled)\n(<= filled\n    (not anyblank))\n(<= anyblank\n    (true (cell ?c blank)))\n(<= terminal\n    (true finished))\n(<= (goal robot 0)\n    (true (cell ?c blank)))\n(<= (goal robot 100)\n    (not (goal robot 0)))\n(<= (number ?n)\n    (succ ?n ?m))\n(<= (number ?m)\n    (succ ?n ?m))\n(<= (adjacent ?c1 ?c2)\n    (adj ?c1 ?c2))\n(<= (adjacent ?c1 ?c2)\n    (adj ?c2 ?c1))\n(coord  a1)\n(coord  a2)\n(coord  a3)\n(coord  a4)\n(coord  b1)\n(coord  b2)\n(coord  b3)\n(coord  b4)\n(coord  b5)\n(coord  c1)\n(coord  c2)\n(coord  c3)\n(coord  c4)\n(coord  c5)\n(coord  c6)\n(coord  d1)\n(coord  d2)\n(coord  d3)\n(coord  d4)\n(coord  d5)\n(coord  d6)\n(coord  d7)\n(coord  e2)\n(coord  e3)\n(coord  e4)\n(coord  e5)\n(coord  e6)\n(coord  e7)\n(coord  f3)\n(coord  f4)\n(coord  f5)\n(coord  f6)\n(coord  f7)\n(coord  g4)\n(coord  g5)\n(coord  g6)\n(coord  g7)\n(adj a1 a2)\n(adj a2 a3)\n(adj a3 a4)\n(adj b1 b2)\n(adj b2 b3)\n(adj b3 b4)\n(adj b4 b5)\n(adj c1 c2)\n(adj c2 c3)\n(adj c3 c4)\n(adj c4 c5)\n(adj c5 c6)\n(adj d1 d2)\n(adj d2 d3)\n(adj d3 d4)\n(adj d4 d5)\n(adj d5 d6)\n(adj d6 d7)\n(adj e2 e3)\n(adj e3 e4)\n(adj e4 e5)\n(adj e5 e6)\n(adj e6 e7)\n(adj f3 f4)\n(adj f4 f5)\n(adj f5 f6)\n(adj f6 f7)\n(adj g4 g5)\n(adj g5 g6)\n(adj g6 g7)\n(adj a1 b1)\n(adj b1 c1)\n(adj c1 d1)\n(adj a2 b2)\n(adj b2 c2)\n(adj c2 d2)\n(adj d2 e2)\n(adj a3 b3)\n(adj b3 c3)\n(adj c3 d3)\n(adj d3 e3)\n(adj e3 f3)\n(adj a4 b4)\n(adj b4 c4)\n(adj c4 d4)\n(adj d4 e4)\n(adj e4 f4)\n(adj f4 g4)\n(adj b5 c5)\n(adj c5 d5)\n(adj d5 e5)\n(adj e5 f5)\n(adj f5 g5)\n(adj c6 d6)\n(adj d6 e6)\n(adj e6 f6)\n(adj f6 g6)\n(adj d7 e7)\n(adj e7 f7)\n(adj f7 g7)\n(adj a4 b5)\n(adj b5 c6)\n(adj c6 d7)\n(adj a3 b4)\n(adj b4 c5)\n(adj c5 d6)\n(adj d6 e7)\n(adj a2 b3)\n(adj b3 c4)\n(adj c4 d5)\n(adj d5 e6)\n(adj e6 f7)\n(adj a1 b2)\n(adj b2 c3)\n(adj c3 d4)\n(adj d4 e5)\n(adj e5 f6)\n(adj f6 g7)\n(adj b1 c2)\n(adj c2 d3)\n(adj d3 e4)\n(adj e4 f5)\n(adj f5 g6)\n(adj c1 d2)\n(adj d2 e3)\n(adj e3 f4)\n(adj f4 g5)\n(adj d1 e2)\n(adj e2 f3)\n(adj f3 g4)\n(succ  1  2)\n(succ  2  3)\n(succ  3  4)\n(succ  4  5)\n(succ  5  6)\n(succ  6  7)\n(succ  7  8)\n(succ  8  9)\n(succ  9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 11-row by 11-column board, with rows labeled from r1 to r11 and columns from c1 to c11, where certain boundary connections define adjacency between rows and columns. The coordinate system uses these row and column identifiers to specify cells on the board. There are two players, designated as \"x\" and \"o,\" who alternate turns, with player \"x\" taking the first move. The initial state sets all board cells to be blank, and each player begins with a certain number of \"quad\" and \"white\" resources—specifically, each player starts with 20 quad units and 7 white units. On a player's turn, they may perform one of two actions: \"mark\" or \"block,\" each targeting a specific blank cell on the board. The \"mark\" action places the player's mark (\"x\" or \"o\") on a blank cell, while the \"block\" action changes a blank cell to a white state, consuming one white resource from the acting player. A player can only \"block\" if they have at least one white resource left; otherwise, the action is illegal. The \"mark\" action reduces the player's quad resource count by one, while \"block\" decreases their white resource count by one. After a \"mark\" action, control passes to the opposing player; after a \"block\" action, the same player retains control and may act again. When it is not a player's turn, they must pass with a \"noop\" action, which is always legal if the other player is currently in control. The game enforces that all actions target cells within the board boundaries and only blank cells can be marked or blocked; cells already occupied by \"x,\" \"o,\" or white cannot be chosen. The game recognizes squares of four cells defined by adjacent rows and columns to detect winning conditions. A player wins if they form a square of four cells all marked with their own symbol (\"x\" or \"o\"), or if they form an \"open quad\"—a square with three cells marked by the player and one blank cell—provided the opponent has not already won and the board is not open to further moves. The game ends when there is a win, a loss, or no open moves remain. The scoring system awards 100 points for an outright win, 95 or 5 points for achieving the open quad condition depending on the player, and varying points based on the comparative number of white resources remaining if no winning or losing condition holds. A loss yields zero points, and the game terminates immediately upon reaching any terminal condition. This structure ensures a strategic balance between placing marks to form winning configurations and using blocks to limit opponent options, all within the constraints of resource management and board occupancy.",
    "output": "(role x)\n(role o)\n(init (quad x 20))\n(init (quad o 20))\n(init (white x 7))\n(init (white o 7))\n(init (cell r1 c2 b))\n(init (cell r1 c3 b))\n(init (cell r1 c4 b))\n(init (cell r1 c5 b))\n(init (cell r1 c6 b))\n(init (cell r1 c7 b))\n(init (cell r1 c8 b))\n(init (cell r1 c9 b))\n(init (cell r1 c10 b))\n(init (cell r2 c1 b))\n(init (cell r2 c2 b))\n(init (cell r2 c3 b))\n(init (cell r2 c4 b))\n(init (cell r2 c5 b))\n(init (cell r2 c6 b))\n(init (cell r2 c7 b))\n(init (cell r2 c8 b))\n(init (cell r2 c9 b))\n(init (cell r2 c10 b))\n(init (cell r2 c11 b))\n(init (cell r3 c1 b))\n(init (cell r3 c2 b))\n(init (cell r3 c3 b))\n(init (cell r3 c4 b))\n(init (cell r3 c5 b))\n(init (cell r3 c6 b))\n(init (cell r3 c7 b))\n(init (cell r3 c8 b))\n(init (cell r3 c9 b))\n(init (cell r3 c10 b))\n(init (cell r3 c11 b))\n(init (cell r4 c1 b))\n(init (cell r4 c2 b))\n(init (cell r4 c3 b))\n(init (cell r4 c4 b))\n(init (cell r4 c5 b))\n(init (cell r4 c6 b))\n(init (cell r4 c7 b))\n(init (cell r4 c8 b))\n(init (cell r4 c9 b))\n(init (cell r4 c10 b))\n(init (cell r4 c11 b))\n(init (cell r5 c1 b))\n(init (cell r5 c2 b))\n(init (cell r5 c3 b))\n(init (cell r5 c4 b))\n(init (cell r5 c5 b))\n(init (cell r5 c6 b))\n(init (cell r5 c7 b))\n(init (cell r5 c8 b))\n(init (cell r5 c9 b))\n(init (cell r5 c10 b))\n(init (cell r5 c11 b))\n(init (cell r6 c1 b))\n(init (cell r6 c2 b))\n(init (cell r6 c3 b))\n(init (cell r6 c4 b))\n(init (cell r6 c5 b))\n(init (cell r6 c6 b))\n(init (cell r6 c7 b))\n(init (cell r6 c8 b))\n(init (cell r6 c9 b))\n(init (cell r6 c10 b))\n(init (cell r6 c11 b))\n(init (cell r7 c1 b))\n(init (cell r7 c2 b))\n(init (cell r7 c3 b))\n(init (cell r7 c4 b))\n(init (cell r7 c5 b))\n(init (cell r7 c6 b))\n(init (cell r7 c7 b))\n(init (cell r7 c8 b))\n(init (cell r7 c9 b))\n(init (cell r7 c10 b))\n(init (cell r7 c11 b))\n(init (cell r8 c1 b))\n(init (cell r8 c2 b))\n(init (cell r8 c3 b))\n(init (cell r8 c4 b))\n(init (cell r8 c5 b))\n(init (cell r8 c6 b))\n(init (cell r8 c7 b))\n(init (cell r8 c8 b))\n(init (cell r8 c9 b))\n(init (cell r8 c10 b))\n(init (cell r8 c11 b))\n(init (cell r9 c1 b))\n(init (cell r9 c2 b))\n(init (cell r9 c3 b))\n(init (cell r9 c4 b))\n(init (cell r9 c5 b))\n(init (cell r9 c6 b))\n(init (cell r9 c7 b))\n(init (cell r9 c8 b))\n(init (cell r9 c9 b))\n(init (cell r9 c10 b))\n(init (cell r9 c11 b))\n(init (cell r10 c1 b))\n(init (cell r10 c2 b))\n(init (cell r10 c3 b))\n(init (cell r10 c4 b))\n(init (cell r10 c5 b))\n(init (cell r10 c6 b))\n(init (cell r10 c7 b))\n(init (cell r10 c8 b))\n(init (cell r10 c9 b))\n(init (cell r10 c10 b))\n(init (cell r10 c11 b))\n(init (cell r11 c2 b))\n(init (cell r11 c3 b))\n(init (cell r11 c4 b))\n(init (cell r11 c5 b))\n(init (cell r11 c6 b))\n(init (cell r11 c7 b))\n(init (cell r11 c8 b))\n(init (cell r11 c9 b))\n(init (cell r11 c10 b))\n(init (control x))\n(ncol c1 c2)\n(ncol c2 c3)\n(ncol c3 c4)\n(ncol c4 c5)\n(ncol c5 c6)\n(ncol c6 c7)\n(ncol c7 c8)\n(ncol c8 c9)\n(ncol c9 c10)\n(ncol c10 c11)\n(nrow r1 r2)\n(nrow r2 r3)\n(nrow r3 r4)\n(nrow r4 r5)\n(nrow r5 r6)\n(nrow r6 r7)\n(nrow r7 r8)\n(nrow r8 r9)\n(nrow r9 r10)\n(nrow r10 r11)\n(<= (prow ?x ?y) (nrow ?y ?x))\n(<= (pcol ?x ?y) (ncol ?y ?x))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(<= (legal ?player (mark ?x ?y)) (true (cell ?x ?y b)) (true (control ?player)))\n(<= (legal ?player (block ?x ?y)) (true (cell ?x ?y b)) (true (control ?player)) (true (white ?player ?c)) (distinct ?c 0))\n(<= (legal x noop) (true (control o)))\n(<= (legal o noop) (true (control x)))\n(<= (next (cell ?m ?n ?p)) (does ?p (mark ?m ?n)))\n(<= (next (cell ?m ?n w)) (does ?p (block ?m ?n)))\n(<= (next (cell ?m ?n ?p)) (true (cell ?m ?n ?p)) (distinct ?p b))\n(<= (next (cell ?m ?n b)) (does ?W (mark ?j ?k)) (true(cell ?m ?n b)) (distinct ?m ?j))\n(<= (next (cell ?m ?n b)) (does ?W (mark ?j ?k)) (true(cell ?m ?n b)) (distinct ?n ?k))\n(<= (next (cell ?m ?n b)) (does ?W (block ?j ?k)) (true(cell ?m ?n b)) (distinct ?m ?j))\n(<= (next (cell ?m ?n b)) (does ?W (block ?j ?k)) (true(cell ?m ?n b)) (distinct ?n ?k))\n(<= (next (quad ?p ?c)) (true (control ?q)) (true (quad ?p ?c)) (distinct ?p ?q))\n(<= (next (white ?p ?c)) (true (control ?q)) (true (white ?p ?c)) (distinct ?p ?q))\n(<= (next (quad ?p ?c)) (does ?p (mark ?j ?k)) (true (quad ?p ?c1)) (succ ?c ?c1))\n(<= (next (white ?p ?c)) (does ?p (block ?j ?k)) (true (white ?p ?c1)) (succ ?c ?c1))\n(<= (next (quad ?p ?c)) (does ?p (block ?j ?k)) (true (quad ?p ?c)))\n(<= (next (white ?p ?c)) (does ?p (mark ?j ?k)) (true (white ?p ?c)))\n(<= (next (control x)) (does o (mark ?j ?k)) (true (control o)))\n(<= (next (control o)) (does x (mark ?j ?k)) (true (control x)))\n(<= (next (control ?p)) (does ?p (block ?j ?k)) (true (control ?p)))\n(<= (square ?x1 ?y1 ?x1 ?y2 ?x2 ?y1 ?x2 ?y2) (ncol ?y1 ?y2) (nrow ?x1 ?x2))\n(<= (square ?x1 ?y1 ?x1 ?y2 ?x2 ?y1 ?x2 ?y2) (ncol ?y3 ?y2) (nrow ?x3 ?x2) (square ?x1 ?y1 ?x1 ?y3 ?x3 ?y1 ?x3 ?y3))\n(<= (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4) (prow ?x2p ?x2) (ncol ?y3n ?y3) (prow ?x4p ?x4) (ncol ?y4n ?y4)\n   (square ?x1 ?y1 ?x2p ?y2 ?x3 ?y3n ?x4p ?y4n))\n(<= win\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= lose\n   (true (cell ?x1 ?y1 o)) (true (cell ?x2 ?y2 o))\n   (true (cell ?x3 ?y3 o)) (true (cell ?x4 ?y4 o))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 b))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 b))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 x)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 b)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= winByOpenQuad\n   (not lose)\n   (not open)\n   (true (cell ?x1 ?y1 b)) (true (cell ?x2 ?y2 x))\n   (true (cell ?x3 ?y3 x)) (true (cell ?x4 ?y4 x))\n   (square ?x1 ?y1 ?x2 ?y2 ?x3 ?y3 ?x4 ?y4))\n(<= open\n   (true (quad ?p ?c)) (distinct ?c 0))\n(<= (more ?x 0) (succ ?y ?x))\n(<= (more ?x ?y) (succ ?x1 ?x) (succ ?y1 ?y) (more ?x1 ?y1))\n(<= morewhite (true (white x ?a)) (true (white o ?b)) (more ?a ?b))\n(<= lesswhite (true (white x ?a)) (true (white o ?b)) (more ?b ?a))\n(<= equalwhite (true (white x ?a)) (true (white o ?a)))\n(<= (goal x 100) win)\n(<= (goal x 95)  (not win) winByOpenQuad)\n(<= (goal x 90)  (not win) (not winByOpenQuad) (not lose) (not open) morewhite)\n(<= (goal x 50)  (not win) (not winByOpenQuad) (not lose) (not open) equalwhite)\n(<= (goal x 10)  (not win) (not winByOpenQuad) (not lose) (not open) lesswhite)\n(<= (goal x 0)   lose)\n(<= (goal o 100) lose)\n(<= (goal o 90)  (not win) (not winByOpenQuad) (not lose) (not open) lesswhite)\n(<= (goal o 50)  (not win) (not winByOpenQuad) (not lose) (not open) equalwhite)\n(<= (goal o 10)  (not win) (not winByOpenQuad) (not lose) (not open) morewhite)\n(<= (goal o 5)   (not win) winByOpenQuad)\n(<= (goal o 0)   win)\n(<= terminal win)\n(<= terminal lose)\n(<= terminal (not open))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board consisting of a set of coordinates arranged in a grid with labeled cells such as a1, a2, a3, b1, b2, b3, b4, c1, c2, c3, c4, c5, d1, d2, d3, d4, e1, e2, and e3, where adjacency between cells is defined both horizontally, vertically, and diagonally according to specified adjacency relations. The environment uses a coordinate system where each cell may be either blank or occupied by a number from 1 to 19, with an initial state placing certain numbers in specific cells and others left blank. There is a single player role called \"robot,\" which takes turns performing actions in a sequence that continues until the game reaches a terminal state. On each turn, the robot may either place a number in a blank cell or choose to quit. The no-operation (noop) mechanism is represented by the \"quit\" action, which ends the game and triggers the terminal condition. Each action by the robot must be legal, and a placement action is legal only if it places an unused number into a currently blank cell, where this number must be consecutive to numbers already on the board and must be positioned in a cell that is either adjacent or absent relative to the cells containing the predecessor and successor numbers, ensuring a continuous sequence. Specifically, the number to place must be such that there exists a predecessor number one less and a successor number one greater, and these numbers must either be unused or occupy cells adjacent to the target cell, maintaining a proximity constraint around the placement. The state updates after each action include marking the chosen cell with the newly placed number and marking that number as used, while all other cells remain unchanged unless the robot quits, which triggers the finished state. The implicit constraints enforce that numbers must be placed within the boundaries of the defined board coordinates, maintaining adjacency rules and preventing overlapping, as only blank cells may receive new numbers. The game terminates either when all cells are filled with numbers or when the robot decides to quit voluntarily. The scoring system awards the robot zero points if there remain any blank cells at the end of the game, and 100 points if the board is entirely filled, reflecting successful completion. Thus, the game challenges the robot to place numbers in a consecutive sequence across the board's cells, respecting adjacency and occupancy rules, until the board is fully populated or the robot opts to end the game.",
    "output": "(role robot)\n(init (cell a1 blank))\n(init (cell a2 blank))\n(init (cell a3  1))\n(init (cell b1 blank))\n(init (cell b2 blank))\n(init (cell b3  3))\n(init (cell b4  6))\n(init (cell c1 blank))\n(init (cell c2 blank))\n(init (cell c3 blank))\n(init (cell c4 blank))\n(init (cell c5  7))\n(init (cell d1 blank))\n(init (cell d2 12))\n(init (cell d3 blank))\n(init (cell d4 blank))\n(init (cell e1 19))\n(init (cell e2 10))\n(init (cell e3 blank))\n(<= (legal robot (place ?c ?n1))\n    (true (cell ?c blank))\n    (unused ?n1)\n    (succ ?n0 ?n1)\n    (succ ?n1 ?n2)\n    (absent_or_adjacent ?n0 ?c)\n    (absent_or_adjacent ?n2 ?c))\n(<= (unused ?n)\n    (number ?n)\n    (not (used ?n)))\n(<= (used ?n)\n    (true (cell ?c ?n)))\n(<= (absent_or_adjacent ?n ?c)\n    (coord ?c)\n    (unused ?n))\n(<= (absent_or_adjacent ?n ?c1)\n    (true (cell ?c2 ?n))\n    (adjacent ?c1 ?c2))\n(legal robot quit)\n(<= (next (cell ?c ?n))\n    (true (cell ?c ?n))\n    (number ?n))\n(<= (next (cell ?c1 blank))\n    (true (cell ?c1 blank))\n    (does robot (place ?c2 ?n))\n    (distinct ?c1 ?c2))\n(<= (next (cell ?c blank))\n    (true (cell ?c blank))\n    (does robot quit))\n(<= (next (cell ?c ?n))\n    (does robot (place ?c ?n)))\n(<= (next finished)\n    (does robot quit))\n(<= terminal\n    filled)\n(<= filled\n    (not anyblank))\n(<= anyblank\n    (true (cell ?c blank)))\n(<= terminal\n    (true finished))\n(<= (goal robot 0)\n    (true (cell ?c blank)))\n(<= (goal robot 100)\n    (not (goal robot 0)))\n(<= (number ?n)\n    (succ ?n ?m))\n(<= (number ?m)\n    (succ ?n ?m))\n(<= (adjacent ?c1 ?c2)\n    (adj ?c1 ?c2))\n(<= (adjacent ?c1 ?c2)\n    (adj ?c2 ?c1))\n(coord  a1)\n(coord  a2)\n(coord  a3)\n(coord  b1)\n(coord  b2)\n(coord  b3)\n(coord  b4)\n(coord  c1)\n(coord  c2)\n(coord  c3)\n(coord  c4)\n(coord  c5)\n(coord  d1)\n(coord  d2)\n(coord  d3)\n(coord  d4)\n(coord  e1)\n(coord  e2)\n(coord  e3)\n(adj a1 a2)\n(adj a2 a3)\n(adj b1 b2)\n(adj b2 b3)\n(adj b3 b4)\n(adj c1 c2)\n(adj c2 c3)\n(adj c3 c4)\n(adj c4 c5)\n(adj d1 d2)\n(adj d2 d3)\n(adj d3 d4)\n(adj e1 e2)\n(adj e2 e3)\n(adj a1 b1)\n(adj b1 c1)\n(adj a2 b2)\n(adj b2 c2)\n(adj c2 d1)\n(adj a3 b3)\n(adj b3 c3)\n(adj c3 d2)\n(adj d2 e1)\n(adj b4 c4)\n(adj c4 d3)\n(adj d3 e2)\n(adj c5 d4)\n(adj d4 e3)\n(adj a3 b3)\n(adj b3 c5)\n(adj a2 b3)\n(adj b3 c4)\n(adj c4 d4)\n(adj a1 b2)\n(adj b2 c3)\n(adj c3 d3)\n(adj d3 e3)\n(adj b1 c2)\n(adj c2 d2)\n(adj d2 e2)\n(adj c1 d1)\n(adj d1 e1)\n(succ  1  2)\n(succ  2  3)\n(succ  3  4)\n(succ  4  5)\n(succ  5  6)\n(succ  6  7)\n(succ  7  8)\n(succ  8  9)\n(succ  9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played between two players designated as white and black, with a maximum of 20 rounds defining the length of the game. The environment is abstract and does not specify a spatial coordinate system; instead, the focus is on scoring and turn progression. The game begins with both players' scores initialized to zero and the round counter set to zero. Players alternate turns, each choosing an action from one of two possible directions: left or right. On each turn, a player must select a legal direction, provided the current round number has not reached the maximum limit of 20 rounds; if the maximum round is reached, no further moves are legal, and the game terminates. Actions are represented simply by the player's choice of direction, and for an action to be legal, the player must be either white or black, and the chosen direction must be one of the two allowed directions. After both players have made their moves in a round, the round counter increments by one. The scoring mechanism depends on the combined choices of both players each round: if both players select the same direction, the score of each player increases by five points; if their directions differ, scores remain unchanged. There are implicit constraints ensuring that no moves are legal once the maximum round count is reached, effectively bounding the game's duration. The game ends when the round count reaches 20, at which point the final scores determine each player's goal value, which corresponds directly to their accumulated scores. The game’s objective is to maximize the individual player's score accumulated over the rounds, with the final score reflecting the player's success. There is no explicit mention of a \"noop\" or no-operation action, so players must always select either left or right on their turn until the game ends. Overall, the game involves straightforward turn-taking, direction selection, and score accumulation over a fixed number of rounds, with termination occurring strictly at round 20 and victory determined by the final scores achieved.",
    "output": "(role white)\n(role black)\n(maxRounds 20)\n(init (whiteScore 0))\n(init (blackScore 0))\n(init (round 0))\n(<= (legal ?r ?d)\n    (role ?r)\n    (direction ?d)\n\t(maxRounds ?x)\n    (not (true (round ?x))))\n(<= (next (round ?x1))\n    (true (round ?x))\n    (succ ?x ?x1))\n(<= (next (whiteScore ?x5))\n    (true (whiteScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?x4 ?x5)\n    (direction ?d)\n    (does white ?d)\n    (does black ?d))\n(<= (next (blackScore ?x5))\n    (true (blackScore ?x))\n    (succ ?x ?x1)\n    (succ ?x1 ?x2)\n    (succ ?x2 ?x3)\n    (succ ?x3 ?x4)\n    (succ ?x4 ?x5)\n    (direction ?d)\n    (does white ?d)\n    (does black ?d))\n(<= (next (blackScore ?x))\n    (true (blackScore ?x))\n    (does black left)\n    (does white right))\n(<= (next (blackScore ?x))\n    (true (blackScore ?x))\n    (does black right)\n    (does white left))\n(<= (next (whiteScore ?x))\n    (true (whiteScore ?x))\n    (does black left)\n    (does white right))\n(<= (next (whiteScore ?x))\n    (true (whiteScore ?x))\n    (does black right)\n    (does white left))\n(<= terminal\n\t(maxRounds ?x)\n    (true (round ?x)))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(direction left)\n(direction right)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This is a two-player game played on a 7x7 board with coordinates ranging from 1 to 7 on both the x (horizontal) and y (vertical) axes, but with the outermost rows and columns (1 and 7) excluded from play, effectively restricting moves to the inner 5x5 area where both x and y coordinates are not equal to 1 or 7. The two players are designated as red and blue, with red taking the first turn. Initially, the red player controls the game, and each player has a single piece placed at fixed starting positions: the red piece is located at coordinate (1,4) and the blue piece at coordinate (7,4), though these positions fall outside the playable inner area, indicating that pieces spawn there but moves occur within the inner board. The game proceeds in alternating turns controlled by the players in rotation, with control passing from red to blue and vice versa after each move. On a player's turn, they may either perform a move or, if no legal moves are available, pass by performing a noop action; however, noop is only legal if it is not that player’s turn to move or if the player cannot make any legal moves during their turn.\n\nMoves are specified by four integers indicating the piece’s starting coordinates (x1, y1) and ending coordinates (x2, y2). A move is legal if the player controls the turn, the piece to be moved belongs to the player, and the destination cell is either occupied by an opponent's piece or is an unoccupied cell within the playable area. Movement can be orthogonal (one step up, down, left, or right), diagonal (one step diagonally), or in an L-shaped pattern resembling a knight's move in chess (two steps along one axis and one step along the other). Moves must stay strictly within the board boundaries, avoiding the outermost rows and columns. A player may capture an opponent’s piece by moving into its occupied cell; this action increases that player’s capture count by one. The game state updates automatically after each move: the piece is moved to its new location, the control passes to the opposing player, the step counter increments by one, and if a capture occurred, the capturing player's count increases accordingly. The game keeps track of the number of steps taken, starting at step one and ending when step 31 is reached, which triggers the terminal state and concludes the game.\n\nA player’s goal is to maximize their capture count by the end of the game. Victory is awarded to the player with the higher capture count, granting that player a score of 100, while the opponent receives zero. If both players have equal capture counts at the end, both receive a score of 50, indicating a draw. Implicit constraints enforce that pieces cannot occupy the same cell simultaneously except when capturing occurs, and moves must conform to the allowed movement patterns while staying within the inner playable board. The game thus involves strategic movement and capturing with a limited number of steps, alternating turns between red and blue, aiming to outcapture the opponent before the 31st step ends the play.",
    "output": "(role red)\n(role blue)\n(init (control red))\n(init (cell 1 4 red))\n(init (cell 7 4 blue))\n(init (step 1))\n(init (capture red 0))\n(init (capture blue 0))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player ?move)\n\t(legal2 ?player ?move))\n(<= (anylegalmove ?player)\n\t(legal2 ?player ?move))\n(<= (legal ?player noop)\n\t(true (control ?player))\n\t(not (anylegalmove ?player)))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(orthogonal ?x1 ?y1 ?x2 ?y2)\n\t(onboard ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?player2))\n\t(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(diagonal ?x1 ?y1 ?x2 ?y2)\n\t(onboard ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?player2))\n\t(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(ell ?x1 ?y1 ?x2 ?y2)\n\t(opencell ?x2 ?y2))\n(<= (next (control ?p2))\n\t(true (control ?p1))\n\t(rotation ?p1 ?p2))\n(<= (next (cell ?x2 ?y2 ?player))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?piece))\n\t(true (cell ?x ?y ?piece))\n\t(not (camefrom ?x ?y))\n\t(not (wentto ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n\t(spawns ?x ?y ?player))\n(<= (next (capture ?player ?count))\n\t(true (capture ?player ?count))\n\t(not (captured ?player)))\n(<= (next (capture ?player ?count2))\n\t(true (capture ?player ?count1))\n\t(captured ?player)\n\t(captureplus ?count1 ?count2))\n(<= (next (step ?t2))\n\t(true (step ?t1))\n\t(stepcount ?t1 ?t2))\n(<= terminal\n\t(true (step 31)))\n(<= (goal ?player 100)\n\t(true (capture ?player ?count1))\n\t(true (capture ?opponent ?count2))\n\t(distinct ?player ?opponent)\n\t(lt ?count2 ?count1))\n(<= (goal ?player 50)\n\t(true (capture ?player ?count))\n\t(true (capture ?opponent ?count))\n\t(distinct ?player ?opponent))\n(<= (goal ?player 0)\n\t(true (capture ?player ?count1))\n\t(true (capture ?opponent ?count2))\n\t(distinct ?player ?opponent)\n\t(lt ?count1 ?count2))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x1 ?x2)\n\t(index ?y))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x2 ?x1)\n\t(index ?y))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y1 ?y2))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y2 ?y1))\n(<= (opencell ?x ?y)\n\t(onboard ?x ?y)\n\t(not (true (cell ?x ?y red)))\n\t(not (true (cell ?x ?y blue))))\n(<= (onboard ?x ?y)\n\t(index ?x)\n\t(index ?y)\n\t(distinct ?x 1)\n\t(distinct ?x 7)\n\t(distinct ?y 1)\n\t(distinct ?y 7))\n(<= (camefrom ?x1 ?y1)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (wentto ?x2 ?y2)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (captured ?player)\n\t(true (control ?player))\n\t(wentto ?x ?y)\n\t(true (cell ?x ?y ?any)))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(plus 1 1 2)\n(plus 1 2 3)\n(plus 1 3 4)\n(plus 1 4 5)\n(plus 1 5 6)\n(plus 1 6 7)\n(plus 2 1 3)\n(plus 2 2 4)\n(plus 2 3 5)\n(plus 2 4 6)\n(plus 2 5 7)\n(rotation red blue)\n(rotation blue red)\n(spawns 1 4 red)\n(spawns 7 4 blue)\n(stepcount 1 2)\n(stepcount 2 3)\n(stepcount 3 4)\n(stepcount 4 5)\n(stepcount 5 6)\n(stepcount 6 7)\n(stepcount 7 8)\n(stepcount 8 9)\n(stepcount 9 10)\n(stepcount 10 11)\n(stepcount 11 12)\n(stepcount 12 13)\n(stepcount 13 14)\n(stepcount 14 15)\n(stepcount 15 16)\n(stepcount 16 17)\n(stepcount 17 18)\n(stepcount 18 19)\n(stepcount 19 20)\n(stepcount 20 21)\n(stepcount 21 22)\n(stepcount 22 23)\n(stepcount 23 24)\n(stepcount 24 25)\n(stepcount 25 26)\n(stepcount 26 27)\n(stepcount 27 28)\n(stepcount 28 29)\n(stepcount 29 30)\n(stepcount 30 31)\n(captureplus 0 1)\n(captureplus 1 2)\n(captureplus 2 3)\n(captureplus 3 4)\n(captureplus 4 5)\n(captureplus 5 6)\n(captureplus 6 7)\n(captureplus 7 8)\n(captureplus 8 9)\n(captureplus 9 10)\n(captureplus 10 11)\n(captureplus 11 12)\n(captureplus 12 13)\n(captureplus 13 14)\n(captureplus 14 14)\n(<= (lt ?n ?np1)\n    (distinct ?n ?np1)\n    (captureplus ?n ?np1))\n(<= (lt ?x ?z)\n    (distinct ?x ?z)\n    (captureplus ?x ?y)\n    (distinct ?x ?y)\n    (distinct ?y ?z)\n    (lt ?y ?z))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is set in a two-dimensional coordinate system where positions are defined by x and y coordinates, and directions are indicated by headings that can be north, east, south, or west. The environment features two players, each controlling a ship with roles identified as ship. Both players take turns simultaneously, as there is only one role, ship, that performs actions per step. The initial state sets both ships at position (10,10) facing north, with northward and eastward speeds of 3 and 2 respectively, and the game step counter initialized to 1. On each turn, the player controlling the ship chooses one action from a set that includes nine possible combined maneuvers labeled thrustThrust, thrustClock, thrustCounter, clockThrust, clockClock, clockCounter, counterThrust, counterClock, and counterCounter, each representing a combination of thrusting or turning clockwise or counterclockwise. The actions are formatted as do followed by one of these move commands, and legality depends on being one of these predefined moves available to the ship role. When an action is executed, the ship’s heading updates according to whether the move involves thrusting (which maintains heading), turning clockwise, or turning counterclockwise, with heading changes following a fixed cyclic order: north to east to south to west and back to north for clockwise turns, and the reverse for counterclockwise. Speed components north-speed and east-speed are adjusted depending on the heading and the move chosen; thrust moves increase or decrease speed in the direction of the heading, while turning moves keep the speeds unchanged. The ship’s position updates by adding the current east-speed to the x-coordinate and the north-speed to the y-coordinate using a modular addition system that wraps values in a defined range from 1 to 20. The game step counter increments automatically each turn. There is no explicit noop action, but since only specified moves are legal, a player must choose one of the nine moves each turn. Implicit constraints include the map boundaries defined by the modular arithmetic on coordinates, meaning positions wrap around when exceeding bounds; this ensures continuous movement on a toroidal grid. The ships’ speeds range between -3 and 3 northward and eastward, with predefined increment and decrement steps. The game terminates when either ship comes to a complete stop (both north-speed and east-speed zero), or when 50 steps have elapsed, indicated by the step counter reaching 50. Victory and scoring depend on whether ships have stopped and their location relative to a planet at (15,5). A ship that has stopped exactly at the planet’s coordinates earns the maximum score of 100, while stopping elsewhere yields 50 points; if a ship has not stopped, it scores zero. The final score for the single ship player is a function of the two ships’ goals, combining their respective scores in a predefined manner that yields values of 0, 25, 50, 75, or 100 based on the combination of individual ship scores. In summary, the game challenges players to maneuver their ships through thrust and turning actions on a bounded but wrapping coordinate grid, managing speeds and headings to bring their ship to rest at a designated planetary location within a limited number of steps to maximize their score.",
    "output": "(role ship)\n(init (x1 10))\n(init (y1 10))\n(init (heading1 north))\n(init (north-speed1 3))\n(init (east-speed1  2))\n(init (x2 10))\n(init (y2 10))\n(init (heading2 north))\n(init (north-speed2 3))\n(init (east-speed2  2))\n(init (step 1))\n(legal ship (do thrustThrust))\n(legal ship (do thrustClock))\n(legal ship (do thrustCounter))\n(legal ship (do clockThrust))\n(legal ship (do clockClock))\n(legal ship (do clockCounter))\n(legal ship (do counterThrust))\n(legal ship (do counterClock))\n(legal ship (do counterCounter))\n(<= (next (heading1 ?h))\n    (true (heading1 ?h))\n    (does ship (do ?move))\n    (game1Thrust ?move))\n(<= (next (heading1 ?dir2))\n    (does ship (do ?move))\n    (game1Counter ?move)\n    (true (heading1 ?dir1))\n    (nextCounter ?dir1 ?dir2))\n(<= (next (heading1 ?dir2))\n    (does ship (do ?move))\n    (game1Clock ?move)\n    (true (heading1 ?dir1))\n    (nextClock ?dir1 ?dir2))\n(<= (next (north-speed1 ?s))\n    (true (north-speed1 ?s))\n    (does ship (do ?move))\n    (game1Clock ?move))\n(<= (next (north-speed1 ?s))\n    (true (north-speed1 ?s))\n    (does ship (do ?move))\n    (game1Counter ?move))\n(<= (next (north-speed1 ?s))\n    (true (north-speed1 ?s))\n    (true (heading1 east)))\n(<= (next (north-speed1 ?s))\n    (true (north-speed1 ?s))\n    (true (heading1 west)))\n(<= (next (north-speed1 ?s2))\n    (true (north-speed1 ?s1))\n    (true (heading1 north))\n    (does ship (do ?move))\n    (game1Thrust ?move)\n    (speed+ ?s1 ?s2))\n(<= (next (north-speed1 ?s2))\n    (true (north-speed1 ?s1))\n    (true (heading1 south))\n    (does ship (do ?move))\n    (game1Thrust ?move)\n    (speed- ?s1 ?s2))\n(<= (next (east-speed1 ?s))\n    (true (east-speed1 ?s))\n    (does ship (do ?move))\n    (game1Clock ?move))\n(<= (next (east-speed1 ?s))\n    (true (east-speed1 ?s))\n    (does ship (do ?move))\n    (game1Counter ?move))\n(<= (next (east-speed1 ?s))\n    (true (east-speed1 ?s))\n    (true (heading1 north)))\n(<= (next (east-speed1 ?s))\n    (true (east-speed1 ?s))\n    (true (heading1 south)))\n(<= (next (east-speed1 ?s2))\n    (true (east-speed1 ?s1))\n    (true (heading1 east))\n    (does ship (do ?move))\n    (game1Thrust ?move)\n    (speed+ ?s1 ?s2))\n(<= (next (east-speed1 ?s2))\n    (true (east-speed1 ?s1))\n    (true (heading1 west))\n    (does ship (do ?move))\n    (game1Thrust ?move)\n    (speed- ?s1 ?s2))\n(<= (next (x1 ?new))\n    (true (x1 ?old))\n    (true (east-speed1 ?s))\n    (map+ ?old ?s ?new))\n(<= (next (y1 ?new))\n    (true (y1 ?old))\n    (true (north-speed1 ?s))\n    (map+ ?old ?s ?new))\n(<= (next (heading2 ?h))\n    (true (heading2 ?h))\n    (does ship (do ?move))\n    (game2Thrust ?move))\n(<= (next (heading2 ?dir2))\n    (does ship (do ?move))\n    (game2Counter ?move)\n    (true (heading2 ?dir1))\n    (nextCounter ?dir1 ?dir2))\n(<= (next (heading2 ?dir2))\n    (does ship (do ?move))\n    (game2Clock ?move)\n    (true (heading2 ?dir1))\n    (nextClock ?dir1 ?dir2))\n(<= (next (north-speed2 ?s))\n    (true (north-speed2 ?s))\n    (does ship (do ?move))\n    (game2Clock ?move))\n(<= (next (north-speed2 ?s))\n    (true (north-speed2 ?s))\n    (does ship (do ?move))\n    (game2Counter ?move))\n(<= (next (north-speed2 ?s))\n    (true (north-speed2 ?s))\n    (true (heading2 east)))\n(<= (next (north-speed2 ?s))\n    (true (north-speed2 ?s))\n    (true (heading2 west)))\n(<= (next (north-speed2 ?s2))\n    (true (north-speed2 ?s1))\n    (true (heading2 north))\n    (does ship (do ?move))\n    (game2Thrust ?move)\n    (speed+ ?s1 ?s2))\n(<= (next (north-speed2 ?s2))\n    (true (north-speed2 ?s1))\n    (true (heading2 south))\n    (does ship (do ?move))\n    (game2Thrust ?move)\n    (speed- ?s1 ?s2))\n(<= (next (east-speed2 ?s))\n    (true (east-speed2 ?s))\n    (does ship (do ?move))\n    (game2Clock ?move))\n(<= (next (east-speed2 ?s))\n    (true (east-speed2 ?s))\n    (does ship (do ?move))\n    (game2Counter ?move))\n(<= (next (east-speed2 ?s))\n    (true (east-speed2 ?s))\n    (true (heading2 north)))\n(<= (next (east-speed2 ?s))\n    (true (east-speed2 ?s))\n    (true (heading2 south)))\n(<= (next (east-speed2 ?s2))\n    (true (east-speed2 ?s1))\n    (true (heading2 east))\n    (does ship (do ?move))\n    (game2Thrust ?move)\n    (speed+ ?s1 ?s2))\n(<= (next (east-speed2 ?s2))\n    (true (east-speed2 ?s1))\n    (true (heading2 west))\n    (does ship (do ?move))\n    (game2Thrust ?move)\n    (speed- ?s1 ?s2))\n(<= (next (x2 ?new))\n    (true (x2 ?old))\n    (true (east-speed2 ?s))\n    (map+ ?old ?s ?new))\n(<= (next (y2 ?new))\n    (true (y2 ?old))\n    (true (north-speed2 ?s))\n    (map+ ?old ?s ?new))\n(<= (next (step ?n++))\n    (true (step ?n))\n    (succ ?n ?n++))\n(<= terminal\n    stopped1)\n(<= terminal\n    stopped2)\n(<= terminal\n    timeout)\n(<= (goal ship 100)\n    goal1-100\n    goal2-100)\n(<= (goal ship 75)\n    goal1-100\n    goal2-50)\n(<= (goal ship 75)\n    goal1-50\n    goal2-100)\n(<= (goal ship 50)\n    goal1-50\n    goal2-50)\n(<= (goal ship 50)\n\tgoal1-100\n\tgoal2-0)\n(<= (goal ship 50)\n\tgoal1-0\n\tgoal2-100)\n(<= (goal ship 25)\n    goal1-50\n    goal2-0)\n(<= (goal ship 25)\n    goal1-0\n    goal2-50)\n(<= (goal ship 0)\n    goal1-0\n    goal2-0)\n(<= stopped1\n    (true (north-speed1 0))\n    (true (east-speed1 0)))\n(<= stopped2\n    (true (north-speed2 0))\n    (true (east-speed2 0)))\n(<= atPlanet1\n    (true (x1 15))\n    (true (y1  5)))\n(<= atPlanet2\n    (true (x2 15))\n    (true (y2  5)))\n(<= goal1-100\n    stopped1\n    atPlanet1)\n(<= goal1-50\n    stopped1\n    (not atPlanet1))\n(<= goal1-0\n    (not stopped1))\n(<= goal2-100\n    stopped2\n    atPlanet2)\n(<= goal2-50\n    stopped2\n    (not atPlanet2))\n(<= goal2-0\n    (not stopped2))\n(<= timeout\n    (true (step 50)))\n(map+ 20 -3 17) (map+ 20 -2 18) (map+ 20 -1 19) (map+ 20 0 20) (map+ 20 1  1) (map+ 20 2  2) (map+ 20 3  3)\n(map+ 19 -3 16) (map+ 19 -2 17) (map+ 19 -1 18) (map+ 19 0 19) (map+ 19 1 20) (map+ 19 2  1) (map+ 19 3  2)\n(map+ 18 -3 15) (map+ 18 -2 16) (map+ 18 -1 17) (map+ 18 0 18) (map+ 18 1 19) (map+ 18 2 20) (map+ 18 3  1)\n(map+ 17 -3 14) (map+ 17 -2 15) (map+ 17 -1 16) (map+ 17 0 17) (map+ 17 1 18) (map+ 17 2 19) (map+ 17 3 20)\n(map+ 16 -3 13) (map+ 16 -2 14) (map+ 16 -1 15) (map+ 16 0 16) (map+ 16 1 17) (map+ 16 2 18) (map+ 16 3 19)\n(map+ 15 -3 12) (map+ 15 -2 13) (map+ 15 -1 14) (map+ 15 0 15) (map+ 15 1 16) (map+ 15 2 17) (map+ 15 3 18)\n(map+ 14 -3 11) (map+ 14 -2 12) (map+ 14 -1 13) (map+ 14 0 14) (map+ 14 1 15) (map+ 14 2 16) (map+ 14 3 17)\n(map+ 13 -3 10) (map+ 13 -2 11) (map+ 13 -1 12) (map+ 13 0 13) (map+ 13 1 14) (map+ 13 2 15) (map+ 13 3 16)\n(map+ 12 -3  9) (map+ 12 -2 10) (map+ 12 -1 11) (map+ 12 0 12) (map+ 12 1 13) (map+ 12 2 14) (map+ 12 3 15)\n(map+ 11 -3  8) (map+ 11 -2  9) (map+ 11 -1 10) (map+ 11 0 11) (map+ 11 1 12) (map+ 11 2 13) (map+ 11 3 14)\n(map+ 10 -3  7) (map+ 10 -2  8) (map+ 10 -1  9) (map+ 10 0 10) (map+ 10 1 11) (map+ 10 2 12) (map+ 10 3 13)\n(map+  9 -3  6) (map+  9 -2  7) (map+  9 -1  8) (map+  9 0  9) (map+  9 1 10) (map+  9 2 11) (map+  9 3 12)\n(map+  8 -3  5) (map+  8 -2  6) (map+  8 -1  7) (map+  8 0  8) (map+  8 1  9) (map+  8 2 10) (map+  8 3 11)\n(map+  7 -3  4) (map+  7 -2  5) (map+  7 -1  6) (map+  7 0  7) (map+  7 1  8) (map+  7 2  9) (map+  7 3 10)\n(map+  6 -3  3) (map+  6 -2  4) (map+  6 -1  5) (map+  6 0  6) (map+  6 1  7) (map+  6 2  8) (map+  6 3  9)\n(map+  5 -3  2) (map+  5 -2  3) (map+  5 -1  4) (map+  5 0  5) (map+  5 1  6) (map+  5 2  7) (map+  5 3  8)\n(map+  4 -3  1) (map+  4 -2  2) (map+  4 -1  3) (map+  4 0  4) (map+  4 1  5) (map+  4 2  6) (map+  4 3  7)\n(map+  3 -3 10) (map+  3 -2  1) (map+  3 -1  2) (map+  3 0  3) (map+  3 1  4) (map+  3 2  5) (map+  3 3  6)\n(map+  2 -3  9) (map+  2 -2 10) (map+  2 -1  1) (map+  2 0  2) (map+  2 1  3) (map+  2 2  4) (map+  2 3  5)\n(map+  1 -3  8) (map+  1 -2  9) (map+  1 -1 10) (map+  1 0  1) (map+  1 1  2) (map+  1 2  3) (map+  1 3  4)\n(speed+ -3 -2) (speed+ -2 -1) (speed+ -1 0) (speed+ 0  1) (speed+  1  2) (speed+  2  3) (speed+  3  3)\n(speed-  3  2) (speed-  2  1) (speed-  1 0) (speed- 0 -1) (speed- -1 -2) (speed- -2 -3) (speed- -3 -3)\n(nextCounter north west)\n(nextCounter west south)\n(nextCounter south east)\n(nextCounter east north)\n(nextClock north east)\n(nextClock east south)\n(nextClock south west)\n(nextClock west north)\n(game1Thrust thrustThrust)    (game2Thrust  thrustThrust)\n(game1Thrust thrustClock)     (game2Clock   thrustClock)\n(game1Thrust thrustCounter)   (game2Counter thrustCounter)\n(game1Clock clockThrust)      (game2Thrust  clockThrust)\n(game1Clock clockClock)       (game2Clock   clockClock)\n(game1Clock clockCounter)     (game2Counter clockCounter)\n(game1Counter counterThrust)  (game2Thrust  counterThrust)\n(game1Counter counterClock)   (game2Clock   counterClock)\n(game1Counter counterCounter) (game2Counter counterCounter)\n(succ  1  2) (succ  2  3) (succ  3  4) (succ  4  5) (succ  5  6)\n(succ  6  7) (succ  7  8) (succ  8  9) (succ  9 10) (succ 10 11)\n(succ 11 12) (succ 12 13) (succ 13 14) (succ 14 15) (succ 15 16)\n(succ 16 17) (succ 17 18) (succ 18 19) (succ 19 20) (succ 20 21)\n(succ 21 22) (succ 22 23) (succ 23 24) (succ 24 25) (succ 25 26)\n(succ 26 27) (succ 27 28) (succ 28 29) (succ 29 30) (succ 30 31)\n(succ 31 32) (succ 32 33) (succ 33 34) (succ 34 35) (succ 35 36)\n(succ 36 37) (succ 37 38) (succ 38 39) (succ 39 40) (succ 40 41)\n(succ 41 42) (succ 42 43) (succ 43 44) (succ 44 45) (succ 45 46)\n(succ 46 47) (succ 47 48) (succ 48 49) (succ 49 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 9-by-9 grid, with rows and columns indexed from 1 to 9, forming the coordinate system for the board. There is a single player role called sudokuPlayer who takes turns sequentially to place marks on the board. The initial state consists of some cells possibly already marked with numbers from 1 to 9, while the rest are empty. On each turn, the sudokuPlayer must perform exactly one action of placing a valid mark—an integer from 1 to 9—into an empty cell identified by its row and column coordinates. This action is legal only if the chosen cell is currently empty, meaning it has no mark assigned yet. There is no explicit noop or pass action; the player must make a move by filling an empty cell on every turn. Each action updates the state by marking the specified cell with the chosen number, and all previously placed marks persist unchanged. Implicit constraints of the game include that all moves must remain within the 9-by-9 board boundaries, and no cell may be marked more than once. The game's progression continues until there are no empty cells left on the board, at which point the game reaches a terminal state. Victory is achieved if the completed board satisfies Sudoku rules: every row, every column, and each of the nine distinct 3-by-3 sub-squares must contain each digit from 1 through 9 exactly once. If these conditions hold, the player receives a goal value of 100, indicating a win; otherwise, the goal value is 0. Thus, the game is a solitary puzzle where the player sequentially fills the board according to Sudoku rules, aiming to produce a fully completed and valid Sudoku solution by the time all cells are filled.",
    "output": "(role sudokuPlayer)\n(<= (legal sudokuPlayer (play ?i ?j ?m))\n    (validMark ?m)\n    (emptyCell ?i ?j))\n(<= (next (mark ?i ?j ?m))\n    (does sudokuPlayer (play ?i ?j ?m)))\n(<= (next (mark ?i ?j ?m))\n    (true (mark ?i ?j ?m)))\n(<= emptyCellExists\n\t(emptyCell ?i ?j))\n(<= terminal\n    (not emptyCellExists))\n(<= (goal sudokuPlayer 100)\n    victoryState)\n(<= (goal sudokuPlayer 0)\n    (not victoryState))\n(<= (exactlyFirst ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (eq ?z ?x1)\n    (index ?x2)\n    (index ?x3)\n    (index ?x4)\n    (index ?x5)\n    (index ?x6)\n    (index ?x7)\n    (index ?x8)\n    (index ?x9)\n    (not (eq ?z ?x2))\n    (not (eq ?z ?x3))\n    (not (eq ?z ?x4))\n    (not (eq ?z ?x5))\n    (not (eq ?z ?x6))\n    (not (eq ?z ?x7))\n    (not (eq ?z ?x8))\n    (not (eq ?z ?x9)))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x2 ?x1 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x3 ?x1 ?x2 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x4 ?x1 ?x2 ?x3 ?x5 ?x6 ?x7 ?x8 ?x9))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x5 ?x1 ?x2 ?x3 ?x4 ?x6 ?x7 ?x8 ?x9))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x6 ?x1 ?x2 ?x3 ?x4 ?x5 ?x7 ?x8 ?x9))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x7 ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x8 ?x9))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x8 ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x9))\n(<= (exactlyOne ?z ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8 ?x9)\n    (exactlyFirst ?z ?x9 ?x1 ?x2 ?x3 ?x4 ?x5 ?x6 ?x7 ?x8))\n(<= (goodRow ?i)\n    (true (mark ?i 1 ?m1))\n    (true (mark ?i 2 ?m2))\n    (true (mark ?i 3 ?m3))\n    (true (mark ?i 4 ?m4))\n    (true (mark ?i 5 ?m5))\n    (true (mark ?i 6 ?m6))\n    (true (mark ?i 7 ?m7))\n    (true (mark ?i 8 ?m8))\n    (true (mark ?i 9 ?m9))\n    (exactlyOne 1 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 2 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 3 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 4 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 5 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 6 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 7 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 8 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 9 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9))\n(<= (goodColumn ?i)\n    (true (mark 1 ?i ?m1))\n    (true (mark 2 ?i ?m2))\n    (true (mark 3 ?i ?m3))\n    (true (mark 4 ?i ?m4))\n    (true (mark 5 ?i ?m5))\n    (true (mark 6 ?i ?m6))\n    (true (mark 7 ?i ?m7))\n    (true (mark 8 ?i ?m8))\n    (true (mark 9 ?i ?m9))\n    (exactlyOne 1 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 2 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 3 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 4 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 5 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 6 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 7 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 8 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 9 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9))\n(<= (goodSquare ?i ?j)\n    (succ ?i ?i2)\n    (succ ?j ?j2)\n    (succ ?i2 ?i3)\n    (succ ?j2 ?j3)\n    (true (mark ?i ?j ?m1))\n    (true (mark ?i ?j2 ?m2))\n    (true (mark ?i ?j3 ?m3))\n    (true (mark ?i2 ?j ?m4))\n    (true (mark ?i2 ?j2 ?m5))\n    (true (mark ?i2 ?j3 ?m6))\n    (true (mark ?i3 ?j ?m7))\n    (true (mark ?i3 ?j2 ?m8))\n    (true (mark ?i3 ?j3 ?m9))\n    (exactlyOne 1 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 2 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 3 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 4 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 5 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 6 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 7 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 8 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9)\n    (exactlyOne 9 ?m1 ?m2 ?m3 ?m4 ?m5 ?m6 ?m7 ?m8 ?m9))\n(<= victoryState\n    (goodRow 1)\n    (goodRow 2)\n    (goodRow 3)\n    (goodRow 4)\n    (goodRow 5)\n    (goodRow 6)\n    (goodRow 7)\n    (goodRow 8)\n    (goodRow 9)\n    (goodColumn 1)\n    (goodColumn 2)\n    (goodColumn 3)\n    (goodColumn 4)\n    (goodColumn 5)\n    (goodColumn 6)\n    (goodColumn 7)\n    (goodColumn 8)\n    (goodColumn 9)\n    (goodSquare 1 1)\n    (goodSquare 1 4)\n    (goodSquare 1 7)\n    (goodSquare 4 1)\n    (goodSquare 4 4)\n    (goodSquare 4 7)\n    (goodSquare 7 1)\n    (goodSquare 7 4)\n    (goodSquare 7 7))\n(<= (emptyCell ?i ?j)\n    (index ?i)\n    (index ?j)\n    (not (true (mark ?i ?j 1)))\n    (not (true (mark ?i ?j 2)))\n    (not (true (mark ?i ?j 3)))\n    (not (true (mark ?i ?j 4)))\n    (not (true (mark ?i ?j 5)))\n    (not (true (mark ?i ?j 6)))\n    (not (true (mark ?i ?j 7)))\n    (not (true (mark ?i ?j 8)))\n    (not (true (mark ?i ?j 9))))\n(<= (validMark ?x)\n    (index ?x))\n(index 1) (index 2) (index 3)\n(index 4) (index 5) (index 6)\n(index 7) (index 8) (index 9)\n(eq 1 1) (eq 2 2) (eq 3 3)\n(eq 4 4) (eq 5 5) (eq 6 6)\n(eq 7 7) (eq 8 8) (eq 9 9)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a uniquely shaped board composed of multiple labeled cells arranged in rows and columns with indices ranging from a1 to i1, including intermediate cells such as b1, c3, d4, and so on, with certain cells designated as reserved. The coordinate system uses these alphanumeric indices to identify individual cells. There are four players in the game, each associated with a distinct role and color: yellow, green, blue, and magenta. The players take turns in a fixed cyclical order starting with yellow, followed by green, then blue, and finally magenta, after which the cycle repeats. Initially, the board is populated with each player's stones placed on specific cells: red stones occupy a1, b1, and b2; magenta stones occupy c1, c2, and d1; yellow stones are on c6, c7, and d6; blue stones are at f1, g1, and g2; green stones occupy f6, g6, and g7; and teal stones are on h1, h2, and i1. The yellow player begins in control, and the game step count starts at one.\n\nOn a player's turn, they may perform exactly one action which can be either a move or a noop (no operation). A move action involves specifying a starting cell containing one of the player's stones and a destination cell to which the stone will be moved. Moves are legal only when the player has control and the move satisfies certain adjacency and occupancy rules defined by directional relationships called \"car\" and \"cdr,\" which depend on the player's role and the connectivity between cells. In particular, moves require traversing through a chain of occupied and empty cells following these directional relationships, ensuring that stones move along valid paths without violating board boundaries or overlapping other stones. If a player has no legal move available or it is not their turn, they may perform a noop action to pass. After a move, the stone is transferred from the starting cell to the destination cell, and the starting cell becomes unoccupied. The control passes to the next player in the turn order after every move or noop.\n\nThe game employs implicit constraints such as the requirement that moves must follow specific directional car and cdr relationships between cells linked by paths defined for each player’s color, and stones cannot move onto occupied cells. The board's boundaries and reserved cells restrict movement and initial placement. Automatic events include updating the control to the next player and incrementing the step count after each turn. The game terminates either after 60 steps have been completed or if two players simultaneously achieve a condition where all their respective target stones occupy their designated cells.\n\nVictory and scoring criteria depend on how many of a player's stones occupy their designated target cells, which are grouped into sets of three specific cells for each player color, such as f1, g1, and g2 for yellow, or c1, c2, and d1 for green. If a player occupies all three target cells, they are considered to have all stones in place; occupying two is considered some stones; one stone; and none if they occupy no target cells. The player who first achieves having all stones in place is considered the first and awarded maximum points. After the first player is determined, other players receive points according to whether they have all, some, one, or no stones in their target cells, with a descending point scale from 100 down to zero. If the game ends after 60 steps without a first player being determined, players receive points similarly based on how many of their stones occupy target cells at that time. The game thus rewards players for occupying their target cells and finishing first, with points assigned accordingly.",
    "output": "(role yellow)\n(role green)\n(role blue)\n(role magenta)\n(index a1)\n(index b1) (index b2)\n(index c1) (index c2) (index c3) (index c4) (index c5) (index c6) (index c7)\n(index d1) (index d2) (index d3) (index d4) (index d5) (index d6)\n(index e1) (index e2) (index e3) (index e4) (index e5)\n(index f1) (index f2) (index f3) (index f4) (index f5) (index f6)\n(index g1) (index g2) (index g3) (index g4) (index g5) (index g6) (index g7)\n(index h1) (index h2)\n(index i1)\n(reserved a1)\n(reserved b1)\n(reserved b2)\n(reserved h1)\n(reserved h2)\n(reserved i1)\n(init (cell a1 red))\n(init (cell b1 red))\n(init (cell b2 red))\n(init (cell c1 magenta))\n(init (cell c2 magenta))\n(init (cell c6 yellow))\n(init (cell c7 yellow))\n(init (cell d1 magenta))\n(init (cell d6 yellow))\n(init (cell f1 blue))\n(init (cell f6 green))\n(init (cell g1 blue))\n(init (cell g2 blue))\n(init (cell g6 green))\n(init (cell g7 green))\n(init (cell h1 teal))\n(init (cell h2 teal))\n(init (cell i1 teal))\n(init (control yellow))\n(init (step 1))\n(<= (next (cell ?e ?player))\n    (does ?player (move ?b ?e)))\n(<= (next (cell ?x ?z))\n    (true (cell ?x ?z))\n    (not (affected ?x)))\n(<= (affected ?x)\n    (does ?player (move ?x ?z)))\n(<= (next (control green))\n    (true (control yellow)))\n(<= (next (control blue))\n    (true (control green)))\n(<= (next (control magenta))\n    (true (control blue)))\n(<= (next (control yellow))\n    (true (control magenta)))\n(<= (next (first yellow))\n    (stones yellow all)\n    (not (stones blue all))\n    (not (stones green all))\n    (not (stones magenta all)))\n(<= (next (first green))\n    (stones green all)\n    (not (stones blue all))\n    (not (stones yellow all))\n    (not (stones magenta all)))\n(<= (next (first blue))\n    (stones blue all)\n    (not (stones yellow all))\n    (not (stones green all))\n    (not (stones magenta all)))\n(<= (next (first magenta))\n    (stones magenta all)\n    (not (stones blue all))\n    (not (stones green all))\n    (not (stones yellow all)))\n(<= (next (first ?player))\n    (role ?player)\n    (true (first ?player)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (succ ?x ?y))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(<= (legal ?player (move ?b ?e))\n    (true (control ?player))\n    (movable ?player ?b ?e))\n(<= (legal ?player noop)\n    (true (control ?player2))\n    (distinct ?player ?player2)\n    (role ?player))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasAnyLegalMove ?player)))\n(<= (hasAnyLegalMove ?player)\n    (movable ?player ?b ?e))\n(<= (occupied ?c)\n    (true (cell ?c ?p)))\n(<= (empty ?c)\n    (index ?c)\n    (not (occupied ?c)))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?e)\n    (empty ?e))\n(<= (car yellow ?b ?e)\n    (caryellow ?b ?e))\n(<= (car green ?b ?e)\n    (carmagenta ?e ?b))\n(<= (car blue ?b ?e)\n    (caryellow ?e ?b))\n(<= (car magenta ?b ?e)\n    (carmagenta ?b ?e))\n(<= (cdr yellow ?b ?e)\n    (cdryellow ?b ?e))\n(<= (cdr green ?b ?e)\n    (cdrmagenta ?e ?b))\n(<= (cdr blue ?b ?e)\n    (cdryellow ?e ?b))\n(<= (cdr magenta ?b ?e)\n    (cdrmagenta ?b ?e))\n(carmagenta c1 d1)\n(carmagenta d1 e1)\n(carmagenta c2 d2)\n(carmagenta e1 f2)\n(carmagenta d2 e2)\n(carmagenta c3 d3)\n(carmagenta f2 g3)\n(carmagenta e2 f3)\n(carmagenta d3 e3)\n(carmagenta c4 d4)\n(carmagenta f3 g4)\n(carmagenta e3 f4)\n(carmagenta d4 e4)\n(carmagenta c5 d5)\n(carmagenta f4 g5)\n(carmagenta e4 f5)\n(carmagenta d5 e5)\n(carmagenta f5 g6)\n(carmagenta e5 f6)\n(carmagenta f6 g7)\n(cdrmagenta c1 c2)\n(cdrmagenta d1 d2)\n(cdrmagenta c2 c3)\n(cdrmagenta e1 e2)\n(cdrmagenta d2 d3)\n(cdrmagenta c3 c4)\n(cdrmagenta f2 f3)\n(cdrmagenta e2 e3)\n(cdrmagenta d3 d4)\n(cdrmagenta c4 c5)\n(cdrmagenta g3 g4)\n(cdrmagenta f3 f4)\n(cdrmagenta e3 e4)\n(cdrmagenta d4 d5)\n(cdrmagenta g4 g5)\n(cdrmagenta f4 f5)\n(cdrmagenta e4 e5)\n(cdrmagenta g5 g6)\n(cdrmagenta f5 f6)\n(cdrmagenta g6 g7)\n(caryellow c7 c6)\n(caryellow c6 c5)\n(caryellow d6 d5)\n(caryellow c5 c4)\n(caryellow d5 d4)\n(caryellow e5 e4)\n(caryellow c4 c3)\n(caryellow d4 d3)\n(caryellow e4 e3)\n(caryellow f5 f4)\n(caryellow g5 g4)\n(caryellow d3 d2)\n(caryellow e3 e2)\n(caryellow f4 f3)\n(caryellow e2 e1)\n(caryellow f3 f2)\n(caryellow g4 g3)\n(caryellow f2 f1)\n(caryellow g3 g2)\n(caryellow g2 g1)\n(cdryellow c7 d6)\n(cdryellow c6 d5)\n(cdryellow d6 e5)\n(cdryellow c5 d4)\n(cdryellow d5 e4)\n(cdryellow e5 f5)\n(cdryellow c4 d3)\n(cdryellow d4 e3)\n(cdryellow e4 f4)\n(cdryellow f5 g5)\n(cdryellow c3 d2)\n(cdryellow d3 e2)\n(cdryellow e3 f3)\n(cdryellow f4 g4)\n(cdryellow d2 e1)\n(cdryellow e2 f2)\n(cdryellow f3 g3)\n(cdryellow e1 f1)\n(cdryellow f2 g2)\n(cdryellow f1 g1)\n(<= (goal ?player 100)\n    (true (first ?player)))\n(<= (goal ?player 75)\n    (stones ?player all)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 50)\n    (stones ?player some)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 25)\n    (stones ?player one)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 0)\n    (stones ?player none)\n    (true (first ?player2))\n    (distinct ?player ?player2))\n(<= (goal ?player 100)\n    (true (step 60))\n    (stones ?player all)\n    (not finished))\n(<= (goal ?player 50)\n    (true (step 60))\n    (stones ?player some)\n    (not finished))\n(<= (goal ?player 25)\n    (true (step 60))\n    (stones ?player one)\n    (not finished))\n(<= (goal ?player 0)\n    (true (step 60))\n    (stones ?player none)\n    (not finished))\n(<= finished\n    (true (first ?player)))\n(toCount yellow f1 g1 g2)\n(toCount green c1 c2 d1)\n(toCount blue c6 c7 d6)\n(toCount magenta f6 g6 g7)\n(<= (stones ?player all)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player some)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player some)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player some)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player one)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player one)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player one)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player none)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= terminal\n    (true (step 60)))\n(<= terminal\n    (stones ?player1 all)\n    (stones ?player2 all)\n    (distinct ?player1 ?player2))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game unfolds on a board defined by a coordinate system consisting of rows labeled r1 through r7 and columns labeled c1 through c9, arranged in a toroidal fashion where rows and columns wrap around cyclically; this means that moving beyond the last row or column cycles back to the first. Each cell on the board can be in one of several states: blank (b), wall, point, or exit. The initial configuration specifies various cells as walls, points, exits, or blank spaces. The single player role is \"snake,\" who takes turns alone in sequential order, with the game step counter starting at zero. The snake occupies a position on the board initially at column c6, row r4, which also marks its tail position at the start, and the player begins with zero points.\n\nOn each turn, the snake may perform one of four possible movement actions: moving up, down, left, or right. These moves are legal only if the cell adjacent in the chosen direction is within the board boundaries (considering the toroidal wrapping) and is occupied by either a blank space, a point, or the exit; walls are impassable. The rules define the adjacency relationships explicitly, specifying how each move translates the snake's position to the neighboring cell. If no legal move is available, the player cannot act, effectively a no-operation scenario where the game advances without change.\n\nWhen the snake executes a move, several state changes occur automatically. The snake's head position updates to the new cell, and the tail position advances in a pattern controlled by an \"evenmove\" toggle that determines whether the tail moves forward or remains stationary, effectively simulating the snake's growth or movement. If the snake moves onto a cell containing a point, a scoring event triggers, incrementing the player's points by one according to a predefined scoring scale where points from zero to four correspond to scores ranging from zero to one hundred, incrementally increasing by five per point. The cell previously occupied by the tail becomes blank, and cells previously occupied by the snake remain marked appropriately to track its body segments. The snake cannot move into walls or outside the board, and occupancy conflicts prevent movement into cells already occupied in a way that violates the rules.\n\nThe game terminates when one of three conditions is met: the snake reaches a cell designated as the exit, the step counter reaches fifty turns, or no legal moves remain for the snake. The victory condition is based on the snake's points and whether it has reached the exit; if the snake occupies the exit cell at termination, the player's score corresponds to the current points collected, mapped to a final score between zero and one hundred as per the scoring scale. If the snake does not reach the exit, the score is zero. Overall, the game challenges the snake to collect points scattered across the board while navigating around walls and eventually reach the exit within a limited number of moves, balancing growth and movement within the toroidal grid environment.",
    "output": "(role snake)\n(init (cell c1 r1 b))\n(init (cell c2 r1 b))\n(init (cell c3 r1 b))\n(init (cell c4 r1 wall))\n(init (cell c5 r1 b))\n(init (cell c6 r1 b))\n(init (cell c7 r1 wall))\n(init (cell c8 r1 point))\n(init (cell c9 r1 b))\n(init (cell c1 r2 wall))\n(init (cell c2 r2 wall))\n(init (cell c3 r2 point))\n(init (cell c4 r2 wall))\n(init (cell c5 r2 b))\n(init (cell c6 r2 b))\n(init (cell c7 r2 b))\n(init (cell c8 r2 b))\n(init (cell c9 r2 b))\n(init (cell c1 r3 b))\n(init (cell c2 r3 b))\n(init (cell c3 r3 b))\n(init (cell c4 r3 wall))\n(init (cell c5 r3 wall))\n(init (cell c6 r3 wall))\n(init (cell c7 r3 b))\n(init (cell c8 r3 wall))\n(init (cell c9 r3 wall))\n(init (cell c1 r4 point))\n(init (cell c2 r4 wall))\n(init (cell c3 r4 b))\n(init (cell c4 r4 b))\n(init (cell c5 r4 b))\n(init (cell c6 r4 b))\n(init (cell c7 r4 b))\n(init (cell c8 r4 b))\n(init (cell c9 r4 b))\n(init (cell c1 r5 wall))\n(init (cell c2 r5 wall))\n(init (cell c3 r5 b))\n(init (cell c4 r5 wall))\n(init (cell c5 r5 wall))\n(init (cell c6 r5 b))\n(init (cell c7 r5 wall))\n(init (cell c8 r5 b))\n(init (cell c9 r5 wall))\n(init (cell c1 r6 b))\n(init (cell c2 r6 wall))\n(init (cell c3 r6 exit))\n(init (cell c4 r6 b))\n(init (cell c5 r6 b))\n(init (cell c6 r6 point))\n(init (cell c7 r6 wall))\n(init (cell c8 r6 b))\n(init (cell c9 r6 b))\n(init (cell c1 r7 b))\n(init (cell c2 r7 wall))\n(init (cell c3 r7 wall))\n(init (cell c4 r7 wall))\n(init (cell c5 r7 wall))\n(init (cell c6 r7 b))\n(init (cell c7 r7 wall))\n(init (cell c8 r7 b))\n(init (cell c9 r7 b))\n(init (step 0))\n(init (pos c6 r4))\n(init (tailpos c6 r4))\n(init (points 0))\n(<= (nextcell ?x ?y1 mov_up ?x ?y2)\n(rowinc ?y2 ?y1)\n(column ?x))\n(<= (nextcell ?x ?y1 mov_down ?x ?y2)\n(rowinc ?y1 ?y2)\n(column ?x))\n(<= (nextcell ?x1 ?y mov_left ?x2 ?y)\n(colinc ?x2 ?x1)\n(row ?y))\n(<= (nextcell ?x1 ?y mov_right ?x2 ?y)\n(colinc ?x1 ?x2)\n(row ?y))\n(rowinc r1 r2) (rowinc r2 r3) (rowinc r3 r4) (rowinc r4 r5) (rowinc r5 r6) (rowinc r6 r7) (rowinc r7 r1)\n(row r1) (row r2) (row r3) (row r4) (row r5) (row r6) (row r7)\n(colinc c1 c2) (colinc c2 c3) (colinc c3 c4) (colinc c4 c5) (colinc c5 c6) (colinc c6 c7) (colinc c7 c8) (colinc c8 c9) (colinc c9 c1)\n(column c1) (column c2) (column c3) (column c4) (column c5) (column c6) (column c7) (column c8) (column c9)\n(<= (legal snake ?move)\n    (true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn)\n(maymove ?xn ?yn))\n(<= (maymove ?x ?y)\n    (or\n(true (cell ?x ?y b))\n(true (cell ?x ?y point))\n(true (cell ?x ?y exit))\n))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(<= (next (cell ?x ?y ?move))\n(does snake ?move)\n(true (pos ?x ?y)))\n(<= (next (pos ?xn ?yn))\n    (does snake ?move)\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn))\n(<= (next evenmove) (not (true evenmove)))\n(<= (next (tailpos ?x ?y))\n    (not (true evenmove))\n(true (tailpos ?x ?y)))\n(<= (next (tailpos ?xn ?yn))\n    (true evenmove)\n(true (tailpos ?x ?y))\n(true (cell ?x ?y ?move))\n(nextcell ?x ?y ?move ?xn ?yn))\n(<= (next (cell ?x ?y b))\n(true evenmove)\n(true (tailpos ?x ?y)))\n(<= (next (cell ?x ?y ?sym))\n    (true (cell ?x ?y ?sym))\n(not (true (pos ?x ?y)))\n(or\n(not (true evenmove))\n(not (true (tailpos ?x ?y)))))\n(<= (next (points ?n1))\n    (true (points ?n))\ndoscore\n(succ ?n ?n1))\n(<= (next (points ?n))\n    (true (points ?n))\n(not doscore))\n(<= doscore\n(true (pos ?x ?y))\n(true (cell ?x ?y point)))\n(score 0 0)\n(score 1 85)\n(score 2 90)\n(score 3 95)\n(score 4 100)\n(<= (goal snake ?s)\n(true (points ?n))\n(true (pos ?x ?y))\n(true (cell ?x ?y exit))\n(score ?n ?s))\n(<= (goal snake 0)\n(true (pos ?x ?y))\n(not (true (cell ?x ?y exit))))\n(<= terminal\n(true (pos ?x ?y))\n(true (cell ?x ?y exit)))\n(<= terminal\n(true (step 50)))\n(<= terminal\n(not exists_legal))\n(<= exists_legal\n(legal snake ?move))\n(<= (smaller ?x ?y)\n(succ ?x ?y))\n(<= (smaller ?x ?z)\n(succ ?y ?z)\n(smaller ?x ?y))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set within a three-dimensional grid environment composed of cells identified by four indices: the first two indices range over 1 to 3 and represent a higher-level subdivision of the board, while the last two indices also range over 1 to 3 and specify positions within these subdivisions, effectively creating a 3x3 grid of 3x3 subgrids, totaling 81 cells. Each cell can hold either a blank marker or a digit from 1 to 9. The single player role, named \"robot,\" takes turns marking an empty cell with a digit. The initial state is defined by a partially filled grid where some cells contain digits while others are blank. On each turn, the robot may perform exactly one action of the form \"mark i j k l x,\" where the indices i, j, k, and l identify a specific cell, and x is the digit to place in that cell. An action is legal only if the target cell is currently blank, and the digit x does not already appear in the same row (the cells with the same k and l indices across all i and j), the same column (cells with the same i and j indices but varying k and l), or the same 3x3 square identified by i and k indices in combination with the j index fixed to 1, 2, or 3, depending on the subdivision, enforcing Sudoku-like constraints within this complex structure. Each action updates the state by placing the digit x in the specified cell, replacing the blank marker. The game automatically detects whether any blank cells remain; if none remain, the game terminates and the robot receives a goal value of 100, indicating victory, otherwise the goal is 0 and play continues. The game ends when no legal moves are available, i.e., when no blank cells can be filled without violating the constraints. There is no explicit noop action since the robot must place a digit each turn if possible. The coordinate system, therefore, enforces a spatial and logical structure resembling Sudoku extended into a multi-layered 3x3 cell arrangement, with implicit constraints preventing duplicate digits within rows, columns, and these defined squares. The robot's objective is to fill all blank cells legally to complete the puzzle and maximize its score, achieving a perfect solution for a maximum reward.",
    "output": "(role robot)\n  (init (cell 1 1 1 1 b))\n  (init (cell 1 1 1 2 1))\n  (init (cell 1 1 1 3 5))\n  (init (cell 1 1 2 1 4))\n  (init (cell 1 1 2 2 b))\n  (init (cell 1 1 2 3 b))\n  (init (cell 1 1 3 1 6))\n  (init (cell 1 1 3 2 7))\n  (init (cell 1 1 3 3 b))\n  (init (cell 1 2 1 1 b))\n  (init (cell 1 2 1 2 b))\n  (init (cell 1 2 1 3 b))\n  (init (cell 1 2 2 1 7))\n  (init (cell 1 2 2 2 b))\n  (init (cell 1 2 2 3 1))\n  (init (cell 1 2 3 1 b))\n  (init (cell 1 2 3 2 b))\n  (init (cell 1 2 3 3 b))\n  (init (cell 1 3 1 1 b))\n  (init (cell 1 3 1 2 b))\n  (init (cell 1 3 1 3 b))\n  (init (cell 1 3 2 1 b))\n  (init (cell 1 3 2 2 3))\n  (init (cell 1 3 2 3 b))\n  (init (cell 1 3 3 1 5))\n  (init (cell 1 3 3 2 b))\n  (init (cell 1 3 3 3 b))\n  (init (cell 2 1 1 1 b))\n  (init (cell 2 1 1 2 b))\n  (init (cell 2 1 1 3 1))\n  (init (cell 2 1 2 1 8))\n  (init (cell 2 1 2 2 b))\n  (init (cell 2 1 2 3 5))\n  (init (cell 2 1 3 1 4))\n  (init (cell 2 1 3 2 b))\n  (init (cell 2 1 3 3 b))\n  (init (cell 2 2 1 1 b))\n  (init (cell 2 2 1 2 8))\n  (init (cell 2 2 1 3 b))\n  (init (cell 2 2 2 1 b))\n  (init (cell 2 2 2 2 b))\n  (init (cell 2 2 2 3 b))\n  (init (cell 2 2 3 1 b))\n  (init (cell 2 2 3 2 5))\n  (init (cell 2 2 3 3 b))\n  (init (cell 2 3 1 1 b))\n  (init (cell 2 3 1 2 b))\n  (init (cell 2 3 1 3 2))\n  (init (cell 2 3 2 1 6))\n  (init (cell 2 3 2 2 b))\n  (init (cell 2 3 2 3 3))\n  (init (cell 2 3 3 1 7))\n  (init (cell 2 3 3 2 b))\n  (init (cell 2 3 3 3 b))\n  (init (cell 3 1 1 1 b))\n  (init (cell 3 1 1 2 b))\n  (init (cell 3 1 1 3 3))\n  (init (cell 3 1 2 1 b))\n  (init (cell 3 1 2 2 8))\n  (init (cell 3 1 2 3 b))\n  (init (cell 3 1 3 1 b))\n  (init (cell 3 1 3 2 b))\n  (init (cell 3 1 3 3 b))\n  (init (cell 3 2 1 1 b))\n  (init (cell 3 2 1 2 b))\n  (init (cell 3 2 1 3 b))\n  (init (cell 3 2 2 1 3))\n  (init (cell 3 2 2 2 b))\n  (init (cell 3 2 2 3 9))\n  (init (cell 3 2 3 1 b))\n  (init (cell 3 2 3 2 b))\n  (init (cell 3 2 3 3 b))\n  (init (cell 3 3 1 1 b))\n  (init (cell 3 3 1 2 6))\n  (init (cell 3 3 1 3 7))\n  (init (cell 3 3 2 1 b))\n  (init (cell 3 3 2 2 b))\n  (init (cell 3 3 2 3 2))\n  (init (cell 3 3 3 1 1))\n  (init (cell 3 3 3 2 3))\n  (init (cell 3 3 3 3 b))\n  (<= (legal robot (mark ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l b))\n      (digit ?x)\n      (not (row ?k ?l ?x))\n      (not (col ?i ?j ?x))\n      (not (square ?i ?k ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 3 ?k ?l ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 3 ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?i ?j ?k ?l ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?s ?i))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?t ?j))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?u ?k))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?v ?l))\n  (<= (goal robot 100) (not open))\n  (<= (goal robot 0) open)\n  (<= terminal (not playable))\n  (<= (filler ?x) (digit ?x))\n  (filler b)\n  (<= open (true (cell ?i ?j ?k ?l b)))\n  (<= playable (legal robot (mark ?i ?j ?k ?l ?x)))\n  (index 1)\n  (index 2)\n  (index 3)\n  (digit 1)\n  (digit 2)\n  (digit 3)\n  (digit 4)\n  (digit 5)\n  (digit 6)\n  (digit 7)\n  (digit 8)\n  (digit 9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a grid defined by coordinates where the x and y indices range over the values 1 and 2, forming a 2x2 board for each series indexed by z, which can be 0, 1, or 2. The environment tracks the state of each cell on this board, with cell states represented by integers from 0 to 4, where 0 signifies no light and 4 signifies a freshly pressed light. There is a single player role named \"robot,\" who takes turns performing actions. The game begins with all cells in all series initialized to state 0, and the step counter set to 0. Each turn, the robot may choose to perform a press action targeting a specific series and cell coordinate, specified as (press z x y) where z is the series, and x and y are the cell coordinates, both of which must be valid indices (1 or 2) and the targeted series must match the current game series state. This press action is the only legal move for the player, effectively serving as the primary means to interact with the game; there is no explicit noop action, so the player must always choose a press within the legal constraints. When a cell is pressed, its state immediately becomes 4 on the next state update, indicating it has been activated. In subsequent steps, the cell's state automatically decreases by one each turn, cycling from 4 down to 3, then 2, then 1, and finally back to 0, representing a fading light effect. Cells that are at state 0 remain at 0 unless pressed again. The game advances the global step counter by one each turn, and the seriesGame variable progresses from 0 to 1 at step 20, and from 1 to 2 at step 40, indicating a change in the active series at these milestones. The game terminates automatically after 60 steps have been completed. A key implicit constraint is the fixed 2x2 board size for each series, with no possibility to press outside these coordinates. The game tracks whether a series has been \"won,\" which occurs when all four cells in that series are lit, meaning their states are at least 1 (on). Specifically, the condition for a series to be considered won is that all four cells at coordinates (1,1), (1,2), (2,1), and (2,2) within that series have a cell state greater than 0. Victory is achieved if any of the series 0, 1, or 2 is won by the time the game ends, granting the robot a goal score of 100; otherwise, the goal score is 0. Thus, the player's objective is to press cells in such a way as to keep all four cells in at least one series lit simultaneously before the terminal step 60 is reached. The progression of lights fading over time requires the player to judiciously time presses to maintain lights on all four cells in a series long enough to claim victory.",
    "output": "(role robot)\n(init (cell 0 1 1 0))\n(init (cell 0 1 2 0))\n(init (cell 0 2 1 0))\n(init (cell 0 2 2 0))\n(init (cell 1 1 1 0))\n(init (cell 1 1 2 0))\n(init (cell 1 2 1 0))\n(init (cell 1 2 2 0))\n(init (cell 2 1 1 0))\n(init (cell 2 1 2 0))\n(init (cell 2 2 1 0))\n(init (cell 2 2 2 0))\n(init (step 0))\n(init (seriesGame 0))\n(<= (legal robot (press ?z ?x ?y))\n\t(index ?x)\n\t(index ?y)\n\t(true (seriesGame ?z)))\n(<= (next (cell ?z ?x ?y 4))\n\t(does robot (press ?z ?x ?y)))\n(<= (next (cell ?z ?x ?y 3))\n\t(true (cell ?z ?x ?y 4)))\n(<= (next (cell ?z ?x ?y 2))\n\t(true (cell ?z ?x ?y 3)))\n(<= (next (cell ?z ?x ?y 1))\n\t(true (cell ?z ?x ?y 2)))\n(<= (next (cell ?z ?x ?y 0))\n\t(true (cell ?z ?x ?y 1)))\n(<= (next (cell ?z ?x ?y 0))\n\t(true (cell ?z ?x ?y 0)))\n(<= (next (won ?z))\n    (true (won ?z)))\n(<= (next (step ?x))\n    (true (step ?y))\n    (successor ?y ?x))\n(<= (next (seriesGame 1))\n    (true (step 20)))\n(<= (next (seriesGame 2))\n    (true (step 40)))\n(<= (next (seriesGame ?x))\n    (true (seriesGame ?x))\n    (not (true (step 20)))\n    (not (true (step 40))))\n(<= (next (won ?z))\n    (lightsOn ?z))\n(<= terminal\n    (true (step 60)))\n(<= (goal robot 100)\n\twonAGame)\n(<= (goal robot 0)\n    (not wonAGame))\n(<= wonAGame\n    (true (won 0)))\n(<= wonAGame\n    (true (won 1)))\n(<= wonAGame\n    (true (won 2)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 1)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 2)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 3)))\n(<= (on ?z ?x ?y)\n\t(true (cell ?z ?x ?y 4)))\n(<= (lightsOn ?z)\n\t(on ?z 1 1)\n\t(on ?z 1 2)\n\t(on ?z 2 1)\n\t(on ?z 2 2))\n(index 1) (index 2)\n  (successor 0 1)\n  (successor 1 2)\n  (successor 2 3)\n  (successor 3 4)\n  (successor 4 5)\n  (successor 5 6)\n  (successor 6 7)\n  (successor 7 8)\n  (successor 8 9)\n  (successor 9 10)\n  (successor 10 11)\n  (successor 11 12)\n  (successor 12 13)\n  (successor 13 14)\n  (successor 14 15)\n  (successor 15 16)\n  (successor 16 17)\n  (successor 17 18)\n  (successor 18 19)\n  (successor 19 20)\n  (successor 20 21)\n  (successor 21 22)\n  (successor 22 23)\n  (successor 23 24)\n  (successor 24 25)\n  (successor 25 26)\n  (successor 26 27)\n  (successor 27 28)\n  (successor 28 29)\n  (successor 29 30)\n  (successor 30 31)\n  (successor 31 32)\n  (successor 32 33)\n  (successor 33 34)\n  (successor 34 35)\n  (successor 35 36)\n  (successor 36 37)\n  (successor 37 38)\n  (successor 38 39)\n  (successor 39 40)\n  (successor 40 41)\n  (successor 41 42)\n  (successor 42 43)\n  (successor 43 44)\n  (successor 44 45)\n  (successor 45 46)\n  (successor 46 47)\n  (successor 47 48)\n  (successor 48 49)\n  (successor 49 50)\n  (successor 50 51)\n  (successor 51 52)\n  (successor 52 53)\n  (successor 53 54)\n  (successor 54 55)\n  (successor 55 56)\n  (successor 56 57)\n  (successor 57 58)\n  (successor 58 59)\n  (successor 59 60)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a grid-based board defined by coordinates ranging from 1 to 8 for both x and y axes, with each cell identified by its (x, y) position. The environment includes specific pellet locations scattered throughout the grid and certain blocked passages that prevent movement north or east between adjacent cells, effectively creating walls. The game features three player roles: Pacman, Blinky, and Inky, with turns alternating between Pacman and the ghosts collectively (Blinky and Inky). Initially, Pacman is controlled first and begins at position (5,3), while Blinky and Inky start at positions (4,6) and (5,6) respectively. On each turn, the player in control may choose to move in one of the four directions—north, south, east, or west—or opt for a noop move (move nowhere) if it is not their turn to act, ensuring turn-based control is respected. Moves are legal only if the destination cell is within the board boundaries, not blocked by walls, and adjacent to the current position in the chosen direction; no moves onto occupied cells by other characters are explicitly forbidden but ghosts and Pacman can occupy the same cell, which triggers capture. When Pacman moves onto a cell containing a pellet, that pellet is collected and removed from the board, incrementing the collected count; if there is no pellet in the destination cell, the collected count remains the same. The control alternates each turn between Pacman and the ghosts, ensuring a strict turn order. The game terminates if Pacman is captured by either Blinky or Inky occupying the same cell, if all pellets have been collected (35 pellets total), or if 100 steps have elapsed. Scoring for Pacman is based on the number of pellets collected, mapped to a score scale where collecting all 35 pellets yields a maximum score of 100. The ghosts score zero if they fail to capture Pacman and 100 if they succeed in capturing him. Movement legality is carefully determined by adjacency, absence of blocking walls, and board boundaries, with special rules preventing movement through walls or outside the grid. Overall, the game combines strategic movement on a constrained grid with turn-based control, pellet collection, and capture mechanics to determine victory conditions and scoring.",
    "output": "(role pacman)\n(role blinky)\n(role inky)\n(init (control pacman))\n(init (location pacman 5 3))\n(init (location blinky 4 6))\n(init (location inky   5 6))\n(pelletLocation 3 1)\n(pelletLocation 4 1)\n(pelletLocation 5 1)\n(pelletLocation 6 1)\n(pelletLocation 3 2)\n(pelletLocation 6 2)\n(pelletLocation 1 3)\n(pelletLocation 2 3)\n(pelletLocation 3 3)\n(pelletLocation 4 3)\n(pelletLocation 6 3)\n(pelletLocation 7 3)\n(pelletLocation 8 3)\n(pelletLocation 1 4)\n(pelletLocation 3 4)\n(pelletLocation 6 4)\n(pelletLocation 8 4)\n(pelletLocation 1 5)\n(pelletLocation 3 5)\n(pelletLocation 6 5)\n(pelletLocation 8 5)\n(pelletLocation 1 6)\n(pelletLocation 2 6)\n(pelletLocation 3 6)\n(pelletLocation 6 6)\n(pelletLocation 7 6)\n(pelletLocation 8 6)\n(pelletLocation 3 7)\n(pelletLocation 6 7)\n(pelletLocation 3 8)\n(pelletLocation 4 8)\n(pelletLocation 5 8)\n(pelletLocation 6 8)\n(<= (init (location pellet ?x ?y))\n    (pelletLocation ?x ?y))\n(blockedNorthCell 4 1)\n(blockedNorthCell 5 1)\n(blockedNorthCell 1 2)\n(blockedNorthCell 2 2)\n(blockedNorthCell 4 2)\n(blockedNorthCell 5 2)\n(blockedNorthCell 7 2)\n(blockedNorthCell 8 2)\n(blockedNorthCell 2 3)\n(blockedNorthCell 4 3)\n(blockedNorthCell 5 3)\n(blockedNorthCell 7 3)\n(blockedNorthCell 2 5)\n(blockedNorthCell 4 5)\n(blockedNorthCell 5 5)\n(blockedNorthCell 7 5)\n(blockedNorthCell 1 6)\n(blockedNorthCell 2 6)\n(blockedNorthCell 4 6)\n(blockedNorthCell 5 6)\n(blockedNorthCell 7 6)\n(blockedNorthCell 8 6)\n(blockedNorthCell 4 7)\n(blockedNorthCell 5 7)\n(<= (init (blockedNorth ?x ?y))\n    (blockedNorthCell ?x ?y))\n(blockedEastCell 1 4)\n(blockedEastCell 1 5)\n(blockedEastCell 2 1)\n(blockedEastCell 2 2)\n(blockedEastCell 2 4)\n(blockedEastCell 2 5)\n(blockedEastCell 2 7)\n(blockedEastCell 2 8)\n(blockedEastCell 3 2)\n(blockedEastCell 3 4)\n(blockedEastCell 3 5)\n(blockedEastCell 3 7)\n(blockedEastCell 5 2)\n(blockedEastCell 5 4)\n(blockedEastCell 5 5)\n(blockedEastCell 5 7)\n(blockedEastCell 6 1)\n(blockedEastCell 6 2)\n(blockedEastCell 6 4)\n(blockedEastCell 6 5)\n(blockedEastCell 6 7)\n(blockedEastCell 6 8)\n(blockedEastCell 7 4)\n(blockedEastCell 7 5)\n(<= (init (blockedEast ?x ?y))\n    (blockedEastCell ?x ?y))\n(init (collected 0))\n(init (step 1))\n(<= (legal pacman (move ?dir))\n    (true (control pacman))\n    (true (location pacman ?x ?y))\n    (legalStep ?dir ?x ?y)\n    (distinct ?dir nowhere))\n(<= (legal pacman (move nowhere))\n    (not (true (control pacman))))\n(<= (legal ?ghost (move ?dir))\n    (ghost ?ghost)\n    (true (control ghosts))\n    (true (location ?ghost ?x ?y))\n    (legalStep ?dir ?x ?y)\n    (distinct ?dir nowhere))\n(<= (legal ?ghost (move nowhere))\n    (ghost ?ghost)\n    (not (true (control ghosts))))\n(<= (next (control pacman))\n    (true (control ghosts)))\n(<= (next (control ghosts))\n    (true (control pacman)))\n(<= (next (location pellet ?xP ?yP))\n    (true (location pellet ?xP ?yP))\n    (true (location pacman ?xPM1 ?yPM1))\n    (does pacman (move ?dir))\n    (nextCell ?dir ?xPM1 ?yPM1 ?xPM2 ?yPM2)\n    (distinctCell ?xP ?yP ?xPM2 ?yPM2))\n(<= (next (collected ?nplusplus))\n    (true (location pacman ?x1 ?y1))\n    (does pacman (move ?dir))\n    (nextCell ?dir ?x1 ?y1 ?x2 ?y2)\n    (true (location pellet ?x2 ?y2))\n    (true (collected ?n))\n    (succ ?n ?nplusplus))\n(<= (next (collected ?n))\n    (true (location pacman ?x1 ?y1))\n    (does pacman (move ?dir))\n    (nextCell ?dir ?x1 ?y1 ?x2 ?y2)\n    (not (true (location pellet ?x2 ?y2)))\n    (true (collected ?n)))\n(<= (next (blockedNorth ?x ?y))\n    (true (blockedNorth ?x ?y)))\n(<= (next (blockedEast ?x ?y))\n    (true (blockedEast ?x ?y)))\n(<= (next (location ?char ?x2 ?y2))\n    (movable ?char)\n    (true (location ?char ?x1 ?y1))\n    (does ?char (move ?dir))\n    (nextCell ?dir ?x1 ?y1 ?x2 ?y2))\n(<= (next (step ?nplusplus))\n    (true (step ?n))\n    (succ ?n ?nplusplus))\n(<= terminal\n    captured)\n(<= terminal\n    noPellets)\n(<= terminal\n    timeout)\n(<= (goal pacman ?g)\n    (true (collected ?n))\n    (scoreMap ?n ?g))\n(<= (goal blinky 0)\n    (true (location pacman ?xP ?yP))\n    (true (location blinky ?xB ?yB))\n    (distinctCell ?xP ?yP ?xB ?yB))\n(<= (goal blinky 100)\n    (true (location pacman ?x ?y))\n    (true (location blinky ?x ?y)))\n(<= (goal inky 0)\n    (true (location pacman ?xP ?yP))\n    (true (location inky ?xI ?yI))\n    (distinctCell ?xP ?yP ?xI ?yI))\n(<= (goal inky 100)\n    (true (location pacman ?x ?y))\n    (true (location inky ?x ?y)))\n(<= (legalStep north ?x ?y)\n    (plusplus ?y ?yNew)\n    (cell ?x ?yNew)\n    (not (blocked ?x ?y ?x ?yNew)))\n(<= (legalStep south ?x ?y)\n    (minusminus ?y ?yNew)\n    (cell ?x ?yNew)\n    (not (blocked ?x ?y ?x ?yNew)))\n(<= (legalStep east ?x ?y)\n    (plusplus ?x ?xNew)\n    (cell ?xNew ?y)\n    (not (blocked ?x ?y ?xNew ?y)))\n(<= (legalStep west ?x ?y)\n    (minusminus ?x ?xNew)\n    (cell ?xNew ?y)\n    (not (blocked ?x ?y ?xNew ?y)))\n(<= (legalStep nowhere ?x ?y)\n    (cell ?x ?y))\n(<= (nextCell north ?x ?y ?x ?yNew)\n    (index ?x)\n    (plusplus ?y ?yNew))\n(<= (nextCell south ?x ?y ?x ?yNew)\n    (index ?x)\n    (minusminus ?y ?yNew))\n(<= (nextCell east ?x ?y ?xNew ?y)\n    (index ?y)\n    (plusplus ?x ?xNew))\n(<= (nextCell west ?x ?y ?xNew ?y)\n    (index ?y)\n    (minusminus ?x ?xNew))\n(<= (nextCell nowhere ?x ?y ?x ?y)\n    (cell ?x ?y))\n(<= (blocked ?x ?y1 ?x ?y2)\n    (true (blockedNorth ?x ?y1))\n    (plusplus ?y1 ?y2))\n(<= (blocked ?x ?y2 ?x ?y1)\n    (true (blockedNorth ?x ?y1))\n    (plusplus ?y1 ?y2))\n(<= (blocked ?x1 ?y ?x2 ?y)\n    (true (blockedEast ?x1 ?y))\n    (plusplus ?x1 ?x2))\n(<= (blocked ?x2 ?y ?x1 ?y)\n    (true (blockedEast ?x1 ?y))\n    (plusplus ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n\t(cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n\t(cell ?x1 ?y1)\n\t(cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= captured\n    (true (location pacman ?x ?y))\n    (true (location blinky ?x ?y)))\n(<= captured\n    (true (location pacman ?x ?y))\n    (true (location inky   ?x ?y)))\n(<= noPellets\n    (true (collected 35)))\n(<= timeout\n    (true (step 100)))\n(movable pacman)\n(movable blinky)\n(movable inky)\n(ghost blinky)\n(ghost inky)\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(cell 1 8) (cell 2 8) (cell 3 8) (cell 4 8) (cell 5 8) (cell 6 8) (cell 7 8) (cell 8 8)\n(cell 1 7) (cell 2 7) (cell 3 7) (cell 4 7) (cell 5 7) (cell 6 7) (cell 7 7) (cell 8 7)\n(cell 1 6) (cell 2 6) (cell 3 6) (cell 4 6) (cell 5 6) (cell 6 6) (cell 7 6) (cell 8 6)\n(cell 1 5) (cell 2 5) (cell 3 5) (cell 4 5) (cell 5 5) (cell 6 5) (cell 7 5) (cell 8 5)\n(cell 1 4) (cell 2 4) (cell 3 4) (cell 4 4) (cell 5 4) (cell 6 4) (cell 7 4) (cell 8 4)\n(cell 1 3) (cell 2 3) (cell 3 3) (cell 4 3) (cell 5 3) (cell 6 3) (cell 7 3) (cell 8 3)\n(cell 1 2) (cell 2 2) (cell 3 2) (cell 4 2) (cell 5 2) (cell 6 2) (cell 7 2) (cell 8 2)\n(cell 1 1) (cell 2 1) (cell 3 1) (cell 4 1) (cell 5 1) (cell 6 1) (cell 7 1) (cell 8 1)\n(plusplus 1 2) (plusplus 2 3) (plusplus 3 4) (plusplus 4 5) (plusplus 5 6) (plusplus 6 7) (plusplus 7 8)\n(minusminus 8 7) (minusminus 7 6) (minusminus 6 5) (minusminus 5 4) (minusminus 4 3) (minusminus 3 2) (minusminus 2 1)\n(succ  0  1) (succ  1  2) (succ  2  3) (succ  3  4) (succ  4   5)\n(succ  5  6) (succ  6  7) (succ  7  8) (succ  8  9) (succ  9  10)\n(succ 10 11) (succ 11 12) (succ 12 13) (succ 13 14) (succ 14  15)\n(succ 15 16) (succ 16 17) (succ 17 18) (succ 18 19) (succ 19  20)\n(succ 20 21) (succ 21 22) (succ 22 23) (succ 23 24) (succ 24  25)\n(succ 25 26) (succ 26 27) (succ 27 28) (succ 28 29) (succ 29  30)\n(succ 30 31) (succ 31 32) (succ 32 33) (succ 33 34) (succ 34  35)\n(succ 35 36) (succ 36 37) (succ 37 38) (succ 38 39) (succ 39  40)\n(succ 40 41) (succ 41 42) (succ 42 43) (succ 43 44) (succ 44  45)\n(succ 45 46) (succ 46 47) (succ 47 48) (succ 48 49) (succ 49  50)\n(succ 50 51) (succ 51 52) (succ 52 53) (succ 53 54) (succ 54  55)\n(succ 55 56) (succ 56 57) (succ 57 58) (succ 58 59) (succ 59  60)\n(succ 60 61) (succ 61 62) (succ 62 63) (succ 63 64) (succ 64  65)\n(succ 65 66) (succ 66 67) (succ 67 68) (succ 68 69) (succ 69  70)\n(succ 70 71) (succ 71 72) (succ 72 73) (succ 73 74) (succ 74  75)\n(succ 75 76) (succ 76 77) (succ 77 78) (succ 78 79) (succ 79  80)\n(succ 80 81) (succ 81 82) (succ 82 83) (succ 83 84) (succ 84  85)\n(succ 85 86) (succ 86 87) (succ 87 88) (succ 88 89) (succ 89  90)\n(succ 90 91) (succ 91 92) (succ 92 93) (succ 93 94) (succ 94  95)\n(succ 95 96) (succ 96 97) (succ 97 98) (succ 98 99) (succ 99 100)\n(scoreMap  0   0)\n(scoreMap  1   2)\n(scoreMap  2   4)\n(scoreMap  3   6)\n(scoreMap  4   8)\n(scoreMap  5  10)\n(scoreMap  6  12)\n(scoreMap  7  14)\n(scoreMap  8  16)\n(scoreMap  9  18)\n(scoreMap 10  20)\n(scoreMap 11  23)\n(scoreMap 12  26)\n(scoreMap 13  29)\n(scoreMap 14  32)\n(scoreMap 15  35)\n(scoreMap 16  38)\n(scoreMap 17  41)\n(scoreMap 18  44)\n(scoreMap 19  47)\n(scoreMap 20  50)\n(scoreMap 21  53)\n(scoreMap 22  56)\n(scoreMap 23  59)\n(scoreMap 24  62)\n(scoreMap 25  65)\n(scoreMap 26  68)\n(scoreMap 27  71)\n(scoreMap 28  74)\n(scoreMap 29  77)\n(scoreMap 30  80)\n(scoreMap 31  83)\n(scoreMap 32  86)\n(scoreMap 33  89)\n(scoreMap 34  95)\n(scoreMap 35 100)\n(<= (reachableCell ?x ?y)\n    (pelletLocation ?x ?y))\n(reachableCell 5 3)\n(reachableCell 4 6)\n(reachableCell 5 6)\n(dir north)\n(dir south)\n(dir east)\n(dir west)\n(dir nowhere)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a uniquely indexed board with positions labeled from a1 through i1, arranged in a pattern that includes rows with varying numbers of cells, such as row c containing seven cells from c1 to c7, and row i containing a single cell i1. The coordinate system is based on these alphanumeric indices that denote cells on the board. Six players, identified by the colors red, yellow, green, teal, blue, and magenta, participate in the game. They take turns in a fixed cyclic order starting with red, then yellow, followed by green, teal, blue, magenta, and back to red. The initial state places several pieces belonging to each player on specific cells distributed across the board; for example, red occupies a1, b1, and b2, magenta occupies c1, c2, and d1, and so forth, with the first move designated to the red side and the game step counter starting at one. On each turn, the player whose turn it is may either perform a move action or choose to do nothing (noop). The move action involves moving a piece from one cell to another, with moves being legal only if they correspond to a sequence of one to four jumps over occupied adjacent cells according to player-specific movement patterns defined by relations analogous to \"car\" and \"cdr\" moves that specify allowed directions and distances. A jump requires an occupied intermediate cell and an empty destination cell, and moves must adhere to these adjacency and occupancy constraints. The game enforces board boundaries implicitly through the defined \"car\" and \"cdr\" relations, which restrict movements to valid neighboring cells. After a move, the piece is relocated to the target cell, and the original cell is vacated; any other cells not directly affected by the move retain their states. Turn control automatically advances to the next player in the cycle after each move or noop, and the step counter increments with each completed turn. The game terminates either when the step counter reaches 55 or when all six players have exactly three stones on their designated target cells, which are predefined specific triples of cells unique to each player. Scoring is determined by the total number of stones placed on these target cells collectively by all players, with a goal mapping translating the number of stones into a numeric score, where achieving 18 stones yields the highest score of 100 and fewer stones correspond to proportionally lower scores. The objective is therefore to strategically move pieces to occupy these target cells efficiently within the allowed moves and turns, with the victory conditions tied to the accumulation of stones in these key positions by the end of the game.",
    "output": "(role party)\n(side red)\n(side yellow)\n(side green)\n(side teal)\n(side blue)\n(side magenta)\n(<= (doubleCdrOrCar ?s ?c1 ?c3)\n    (cdr ?s ?c1 ?c2)\n    (cdr ?s ?c2 ?c3))\n(<= (doubleCdrOrCar ?s ?c1 ?c3)\n    (car ?s ?c1 ?c2)\n    (car ?s ?c2 ?c3))\n(index a1)\n(index b1) (index b2)\n(index c1) (index c2) (index c3) (index c4) (index c5) (index c6) (index c7)\n(index d1) (index d2) (index d3) (index d4) (index d5) (index d6)\n(index e1) (index e2) (index e3) (index e4) (index e5)\n(index f1) (index f2) (index f3) (index f4) (index f5) (index f6)\n(index g1) (index g2) (index g3) (index g4) (index g5) (index g6) (index g7)\n(index h1) (index h2)\n(index i1)\n(init (cell a1 red))\n(init (cell b1 red))\n(init (cell b2 red))\n(init (cell c1 magenta))\n(init (cell c2 magenta))\n(init (cell c6 yellow))\n(init (cell c7 yellow))\n(init (cell d1 magenta))\n(init (cell d6 yellow))\n(init (cell f1 blue))\n(init (cell f6 green))\n(init (cell g1 blue))\n(init (cell g2 blue))\n(init (cell g6 green))\n(init (cell g7 green))\n(init (cell h1 teal))\n(init (cell h2 teal))\n(init (cell i1 teal))\n(init (sideToMove red))\n(init (step 1))\n(<= (next (cell ?e ?side))\n    (does party (move ?b ?e))\n    (true (cell ?b ?side)))\n(<= (next (cell ?x ?z))\n    (true (cell ?x ?z))\n    (not (affected ?x)))\n(<= (affected ?x)\n    (does party (move ?x ?z)))\n(<= (next (sideToMove yellow))\n    (true (sideToMove red)))\n(<= (next (sideToMove green))\n    (true (sideToMove yellow)))\n(<= (next (sideToMove teal))\n    (true (sideToMove green)))\n(<= (next (sideToMove blue))\n    (true (sideToMove teal)))\n(<= (next (sideToMove magenta))\n    (true (sideToMove blue)))\n(<= (next (sideToMove red))\n    (true (sideToMove magenta)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (succ ?x ?y))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(<= (sum ?x 0 ?x)\n    (succ ?x ?y))\n(<= (sum ?x ?y ?z)\n    (succ ?x ?xp1)\n    (succ ?ym1 ?y)\n    (sum ?xp1 ?ym1 ?z))\n(<= (legal party (move ?b ?e))\n    (true (sideToMove ?player))\n    (movable ?player ?b ?e))\n(legal party noop)\n(<= (occupied ?c)\n    (true (cell ?c ?p)))\n(<= (empty ?c)\n    (index ?c)\n    (not (occupied ?c)))\n(<= (jumpable ?player ?b ?e)\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?e)\n    (empty ?e))\n(<= (jumpable ?player ?b ?e)\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (jumpable ?player ?b ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (jumpable ?player ?b ?x)\n    (jumpable ?player ?x ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (jumpable ?player ?b ?x)\n    (jumpable ?player ?x ?y)\n    (jumpable ?player ?y ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (jumpable ?player ?b ?x)\n    (jumpable ?player ?x ?y)\n    (jumpable ?player ?y ?z)\n    (jumpable ?player ?z ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?e)\n    (empty ?e))\n(<= (car red ?b ?e)\n    (carred ?b ?e))\n(<= (car yellow ?b ?e)\n    (caryellow ?b ?e))\n(<= (car green ?b ?e)\n    (carmagenta ?e ?b))\n(<= (car teal ?b ?e)\n    (carred ?e ?b))\n(<= (car blue ?b ?e)\n    (caryellow ?e ?b))\n(<= (car magenta ?b ?e)\n    (carmagenta ?b ?e))\n(<= (cdr red ?b ?e)\n    (cdrred ?b ?e))\n(<= (cdr yellow ?b ?e)\n    (cdryellow ?b ?e))\n(<= (cdr green ?b ?e)\n    (cdrmagenta ?e ?b))\n(<= (cdr teal ?b ?e)\n    (cdrred ?e ?b))\n(<= (cdr blue ?b ?e)\n    (cdryellow ?e ?b))\n(<= (cdr magenta ?b ?e)\n    (cdrmagenta ?b ?e))\n(carmagenta c1 d1)\n(carmagenta d1 e1)\n(carmagenta c2 d2)\n(carmagenta e1 f2)\n(carmagenta d2 e2)\n(carmagenta c3 d3)\n(carmagenta f2 g3)\n(carmagenta e2 f3)\n(carmagenta d3 e3)\n(carmagenta c4 d4)\n(carmagenta f3 g4)\n(carmagenta e3 f4)\n(carmagenta d4 e4)\n(carmagenta c5 d5)\n(carmagenta f4 g5)\n(carmagenta e4 f5)\n(carmagenta d5 e5)\n(carmagenta f5 g6)\n(carmagenta e5 f6)\n(carmagenta f6 g7)\n(cdrmagenta c1 c2)\n(cdrmagenta d1 d2)\n(cdrmagenta c2 c3)\n(cdrmagenta e1 e2)\n(cdrmagenta d2 d3)\n(cdrmagenta c3 c4)\n(cdrmagenta f2 f3)\n(cdrmagenta e2 e3)\n(cdrmagenta d3 d4)\n(cdrmagenta c4 c5)\n(cdrmagenta g3 g4)\n(cdrmagenta f3 f4)\n(cdrmagenta e3 e4)\n(cdrmagenta d4 d5)\n(cdrmagenta g4 g5)\n(cdrmagenta f4 f5)\n(cdrmagenta e4 e5)\n(cdrmagenta g5 g6)\n(cdrmagenta f5 f6)\n(cdrmagenta g6 g7)\n(carred a1 b1)\n(carred b1 c3)\n(carred b2 c4)\n(carred c3 d2)\n(carred c4 d3)\n(carred c5 d4)\n(carred d2 e1)\n(carred d3 e2)\n(carred d4 e3)\n(carred d5 e4)\n(carred e2 f2)\n(carred e3 f3)\n(carred e4 f4)\n(carred e5 f5)\n(carred f3 g3)\n(carred f4 g4)\n(carred f5 g5)\n(carred g4 h1)\n(carred g5 h2)\n(carred h2 i1)\n(cdrred a1 b2)\n(cdrred b1 c4)\n(cdrred b2 c5)\n(cdrred c3 d3)\n(cdrred c4 d4)\n(cdrred c5 d5)\n(cdrred d2 e2)\n(cdrred d3 e3)\n(cdrred d4 e4)\n(cdrred d5 e5)\n(cdrred e1 f2)\n(cdrred e2 f3)\n(cdrred e3 f4)\n(cdrred e4 f5)\n(cdrred f2 g3)\n(cdrred f3 g4)\n(cdrred f4 g5)\n(cdrred g3 h1)\n(cdrred g4 h2)\n(cdrred h1 i1)\n(caryellow c7 c6)\n(caryellow c6 c5)\n(caryellow d6 d5)\n(caryellow c5 c4)\n(caryellow d5 d4)\n(caryellow e5 e4)\n(caryellow c4 c3)\n(caryellow d4 d3)\n(caryellow e4 e3)\n(caryellow f5 f4)\n(caryellow g5 g4)\n(caryellow d3 d2)\n(caryellow e3 e2)\n(caryellow f4 f3)\n(caryellow e2 e1)\n(caryellow f3 f2)\n(caryellow g4 g3)\n(caryellow f2 f1)\n(caryellow g3 g2)\n(caryellow g2 g1)\n(cdryellow c7 d6)\n(cdryellow c6 d5)\n(cdryellow d6 e5)\n(cdryellow c5 d4)\n(cdryellow d5 e4)\n(cdryellow e5 f5)\n(cdryellow c4 d3)\n(cdryellow d4 e3)\n(cdryellow e4 f4)\n(cdryellow f5 g5)\n(cdryellow c3 d2)\n(cdryellow d3 e2)\n(cdryellow e3 f3)\n(cdryellow f4 g4)\n(cdryellow d2 e1)\n(cdryellow e2 f2)\n(cdryellow f3 g3)\n(cdryellow e1 f1)\n(cdryellow f2 g2)\n(cdryellow f1 g1)\n(toCount red h1 h2 i1)\n(toCount yellow f1 g1 g2)\n(toCount green c1 c2 d1)\n(toCount teal a1 b1 b2)\n(toCount blue c6 c7 d6)\n(toCount magenta f6 g6 g7)\n(<= (stones ?player 3)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 2)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 2)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 2)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 1)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 1)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 1)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 0)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= (totalStones ?total)\n    (stones red ?a)\n    (stones yellow ?b)\n    (sum ?a ?b ?sub1)\n    (stones green ?c)\n    (sum ?sub1 ?c ?sub2)\n    (stones teal ?d)\n    (sum ?sub2 ?d ?sub3)\n    (stones blue ?e)\n    (sum ?sub3 ?e ?sub4)\n    (stones magenta ?f)\n    (sum ?sub4 ?f ?total))\n(<= (goal party ?goal)\n    (totalStones ?n)\n    (goalMap ?n ?goal))\n(goalMap 18 100)\n(goalMap 17 90)\n(goalMap 16 80)\n(goalMap 15 70)\n(goalMap 14 60)\n(goalMap 13 50)\n(goalMap 12 45)\n(goalMap 11 40)\n(goalMap 10 35)\n(goalMap 9 30)\n(goalMap 8 25)\n(goalMap 7 20)\n(goalMap 6 15)\n(goalMap 5 10)\n(goalMap 4 5)\n(goalMap 3 0)\n(goalMap 2 0)\n(goalMap 1 0)\n(goalMap 0 0)\n(<= terminal\n    (true (step 55)))\n(<= terminal\n    (stones red 3)\n    (stones yellow 3)\n    (stones green 3)\n    (stones teal 3)\n    (stones blue 3)\n    (stones magenta 3))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on two distinct 3-position stacks, each consisting of positions labeled a, b, and c, arranged as part of two separate subgames, with the first subgame involving positions a1, b1, and c1, and the second subgame involving a2, b2, and c2; these positions serve as locations where pieces can be stacked or unstacked, with base positions marked as tables. The coordinate system distinguishes these two subgames by indexing positions with suffixes 1 or 2, representing the first and second subgame respectively. There is a single player role named \"robot,\" who takes all turns sequentially, starting from an initial state where positions b1 and c1 are clear except for c1 being on a1, and similarly b2 and c2 are clear with c2 on a2, and all a and b positions are tables. The game progresses in discrete steps from 1 to 4, with the step number incrementing automatically after each action. On each turn, the robot must perform one move chosen from four possible move types—ss (stack-stack), su (stack-unstack), us (unstack-stack), and uu (unstack-unstack)—each involving moving a piece from one position in either the first or second subgame to another position also in one of the subgames, with the action format being (do <move> ?x1 ?y1 ?x2 ?y2) where ?x1 and ?y1 are source coordinates in the first subgame and ?x2 and ?y2 in the second, or vice versa, depending on the move type. Legality of each move depends on the positions involved belonging to their respective subgames, the source and destination positions satisfying stacking or unstacking conditions, and the involved positions being clear or occupied appropriately; for example, stacking requires the destination to be a clear table position distinct from the source, and unstacking requires the source to be on top of another piece and clear. The game enforces occupancy constraints such that only one piece can occupy a position at a time, and pieces can only be placed on tables or on top of other pieces within their subgame. After each legal move, the state updates the on, clear, and table relations for both subgames accordingly, reflecting the movement of pieces and clearing or occupying positions; the step counter increments automatically. The game terminates either when four steps have been completed or when both subgames achieve a full stack with a1 supporting b1 which supports c1, and a2 supporting b2 which supports c2. Scoring is determined by whether each subgame attains this full stacked configuration: if both subgames reach full stacks, the robot scores 100 points; if only one subgame achieves this, the score is 50; if neither does, the score is 0. The robot must thus strategically manipulate the pieces across both subgames within four moves to maximize its score by creating these complete stacks or partial successes.",
    "output": "(role robot)\n  (init (clear b1))\n  (init (clear c1))\n  (init (on c1 a1))\n  (init (table a1))\n  (init (table b1))\n  (init (clear b2))\n  (init (clear c2))\n  (init (on c2 a2))\n  (init (table a2))\n  (init (table b2))\n  (init (step 1))\n  (<= (legal robot (do ss ?x1 ?y1 ?x2 ?y2))\n      (partOfGame1 ?x1)\n      (partOfGame1 ?y1)\n      (partOfGame2 ?x2)\n      (partOfGame2 ?y2)\n      (legalStack ?x1 ?y1)\n      (legalStack ?x2 ?y2))\n  (<= (legal robot (do su ?x1 ?y1 ?x2 ?y2))\n      (partOfGame1 ?x1)\n      (partOfGame1 ?y1)\n      (partOfGame2 ?x2)\n      (partOfGame2 ?y2)\n      (legalStack ?x1 ?y1)\n      (legalUnstack ?x2 ?y2))\n  (<= (legal robot (do us ?x1 ?y1 ?x2 ?y2))\n      (partOfGame1 ?x1)\n      (partOfGame1 ?y1)\n      (partOfGame2 ?x2)\n      (partOfGame2 ?y2)\n      (legalUnstack ?x1 ?y1)\n      (legalStack ?x2 ?y2))\n  (<= (legal robot (do uu ?x1 ?y1 ?x2 ?y2))\n      (partOfGame1 ?x1)\n      (partOfGame1 ?y1)\n      (partOfGame2 ?x2)\n      (partOfGame2 ?y2)\n      (legalUnstack ?x1 ?y1)\n      (legalUnstack ?x2 ?y2))\n  (<= (next (on ?x ?y))\n      (does robot (do ?move ?x ?y ?d1 ?d2))\n      (game1Stack ?move))\n  (<= (next (on ?x ?y))\n      (partOfGame1 ?x)\n      (partOfGame1 ?y)\n      (does robot (do ?move ?u ?v ?d1 ?d2))\n      (game1Stack ?move)\n      (true (on ?x ?y)))\n  (<= (next (table ?x))\n      (partOfGame1 ?x)\n      (does robot (do ?move ?u ?v ?d1 ?d2))\n      (game1Stack ?move)\n      (true (table ?x))\n      (distinct ?u ?x))\n  (<= (next (clear ?y))\n      (partOfGame1 ?y)\n      (does robot (do ?move ?u ?v ?d1 ?d2))\n      (game1Stack ?move)\n      (true (clear ?y))\n      (distinct ?v ?y))\n  (<= (next (on ?x ?y))\n      (partOfGame1 ?x)\n      (partOfGame1 ?y)\n      (does robot (do ?move ?u ?v ?d1 ?d2))\n      (game1Unstack ?move)\n      (true (on ?x ?y))\n      (distinct ?u ?x))\n  (<= (next (table ?x))\n      (does robot (do ?move ?x ?y ?d1 ?d2))\n      (game1Unstack ?move))\n  (<= (next (table ?x))\n      (partOfGame1 ?x)\n      (does robot (do ?move ?u ?v ?d1 ?d2))\n      (game1Unstack ?move)\n      (true (table ?x)))\n  (<= (next (clear ?y))\n      (does robot (do ?move ?x ?y ?d1 ?d2))\n      (game1Unstack ?move))\n  (<= (next (clear ?x))\n      (partOfGame1 ?x)\n      (does robot (do ?move ?u ?v ?d1 ?d2))\n      (game1Unstack ?move)\n      (true (clear ?x)))\n  (<= (next (on ?x ?y))\n      (does robot (do ?move ?d1 ?d2 ?x ?y))\n      (game2Stack ?move))\n  (<= (next (on ?x ?y))\n      (partOfGame2 ?x)\n      (partOfGame2 ?y)\n      (does robot (do ?move ?d1 ?d2 ?u ?v))\n      (game2Stack ?move)\n      (true (on ?x ?y)))\n  (<= (next (table ?x))\n      (partOfGame2 ?x)\n      (does robot (do ?move ?d1 ?d2 ?u ?v))\n      (game2Stack ?move)\n      (true (table ?x))\n      (distinct ?u ?x))\n  (<= (next (clear ?y))\n      (partOfGame2 ?y)\n      (does robot (do ?move ?d1 ?d2 ?u ?v))\n      (game2Stack ?move)\n      (true (clear ?y))\n      (distinct ?v ?y))\n  (<= (next (on ?x ?y))\n      (partOfGame2 ?x)\n      (partOfGame2 ?y)\n      (does robot (do ?move ?d1 ?d2 ?u ?v))\n      (game2Unstack ?move)\n      (true (on ?x ?y))\n      (distinct ?u ?x))\n  (<= (next (table ?x))\n      (does robot (do ?move ?d1 ?d2 ?x ?y))\n      (game2Unstack ?move))\n  (<= (next (table ?x))\n      (partOfGame2 ?x)\n      (does robot (do ?move ?d1 ?d2 ?u ?v))\n      (game2Unstack ?move)\n      (true (table ?x)))\n  (<= (next (clear ?y))\n      (does robot (do ?move ?d1 ?d2 ?x ?y))\n      (game2Unstack ?move))\n  (<= (next (clear ?x))\n      (partOfGame2 ?x)\n      (does robot (do ?move ?d1 ?d2 ?u ?v))\n      (game2Unstack ?move)\n      (true (clear ?x)))\n  (<= (next (step ?y))\n      (true (step ?x))\n      (succ ?x ?y))\n  (<= (goal robot 100)\n      game1-100\n      game2-100)\n  (<= (goal robot 50)\n      game1-100\n      game2-0)\n  (<= (goal robot 50)\n      game1-0\n      game2-100)\n  (<= (goal robot 0)\n      game1-0\n      game2-0)\n  (<= terminal\n      (true (step 4)))\n  (<= terminal\n      (true (on a1 b1))\n      (true (on b1 c1))\n      (true (on a2 b2))\n      (true (on b2 c2)))\n(<= (legalStack ?x ?y)\n    (true (clear ?x))\n    (true (table ?x))\n    (true (clear ?y))\n    (distinct ?x ?y))\n(<= (legalUnstack ?x ?y)\n    (true (clear ?x))\n    (true (on ?x ?y)))\n(<= game1-100\n    (true (on a1 b1))\n    (true (on b1 c1)))\n(<= game1-0\n    (not (true (on a1 b1))))\n(<= game1-0\n    (not (true (on b1 c1))))\n(<= game2-100\n    (true (on a2 b2))\n    (true (on b2 c2)))\n(<= game2-0\n    (not (true (on a2 b2))))\n(<= game2-0\n    (not (true (on b2 c2))))\n  (succ 1 2)\n  (succ 2 3)\n  (succ 3 4)\n  (partOfGame1 a1)\n  (partOfGame1 b1)\n  (partOfGame1 c1)\n  (partOfGame2 a2)\n  (partOfGame2 b2)\n  (partOfGame2 c2)\n  (game1Stack   ss)\n  (game1Stack   su)\n  (game1Unstack us)\n  (game1Unstack uu)\n  (game2Stack   ss)\n  (game2Unstack su)\n  (game2Stack   us)\n  (game2Unstack uu)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 5-by-5 grid with coordinates specified by row and column indices ranging from 1 to 5, where each cell can hold either a number or be blank. There is a single player role named \"robot\" who takes turns placing numbers on the board or choosing to quit. The initial state places the number 5 in cell (1,1), the number 3 in cell (5,2), and all other cells are blank. On each turn, the robot may perform one action, which is either placing a number in an empty cell or quitting the game; placing a number is only legal if the chosen cell is blank and the number does not violate any constraints that disallow duplicate numbers in the same row or column, or violate specified greater-than relationships between certain pairs of cells. The action format for placing a number is to specify the row, column, and number, while quitting is a separate action without parameters. When a number is placed, that cell's state changes from blank to the placed number, and all other cells remain as they were except the newly placed cell; if the robot quits, the game transitions to a finished state. The game enforces implicit constraints that no number may appear more than once in any row or column, and that certain specified pairs of cells must satisfy strict greater-than inequalities according to predefined constraints between adjacent or related cells, effectively limiting the values that can be assigned to maintain the ordering. The game ends either when the board is completely filled with numbers, or when the robot chooses to quit, marking the terminal condition. Scoring awards the robot 100 points if the board is fully filled without any blanks remaining; otherwise, if any blank cells remain at termination, the robot scores zero. Thus, the objective is for the robot to fill the board with numbers obeying the uniqueness and inequality constraints to achieve a fully completed grid and secure the maximum score.",
    "output": "(role robot)\n(init (cell 1 1 5))\n(init (cell 1 2 blank))\n(init (cell 1 3 blank))\n(init (cell 1 4 blank))\n(init (cell 1 5 blank))\n(init (cell 2 1 blank))\n(init (cell 2 2 blank))\n(init (cell 2 3 blank))\n(init (cell 2 4 blank))\n(init (cell 2 5 blank))\n(init (cell 3 1 blank))\n(init (cell 3 2 blank))\n(init (cell 3 3 blank))\n(init (cell 3 4 blank))\n(init (cell 3 5 blank))\n(init (cell 4 1 blank))\n(init (cell 4 2 blank))\n(init (cell 4 3 blank))\n(init (cell 4 4 blank))\n(init (cell 4 5 blank))\n(init (cell 5 1 blank))\n(init (cell 5 2 3))\n(init (cell 5 3 blank))\n(init (cell 5 4 blank))\n(init (cell 5 5 blank))\n(<= (legal robot (place ?row ?col ?n))\n    (true (cell ?row ?col blank))\n    (number ?n)\n    (not (illegal ?row ?col ?n)))\n(<= (illegal ?row ?col ?n)\n    (number ?row)\n    (true (cell ?row2 ?col ?n)))\n(<= (illegal ?row ?col ?n)\n    (number ?col)\n    (true (cell ?row ?col2 ?n)))\n(<= (illegal ?row ?col ?n)\n    (gt_constraint ?row ?col ?row2 ?col2)\n    (true (cell ?row2 ?col2 ?n2))\n    (gt ?n2 ?n))\n(<= (illegal ?row ?col ?n)\n    (gt_constraint ?row2 ?col2 ?row ?col)\n    (true (cell ?row2 ?col2 ?n2))\n    (gt ?n ?n2))\n(legal robot quit)\n(<= (next (cell ?row ?col ?n))\n    (true (cell ?row ?col ?n))\n    (number ?n))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot (place ?row2 ?col2 ?n))\n    (distinct ?row ?row2))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot (place ?row2 ?col2 ?n))\n    (distinct ?col ?col2))\n(<= (next (cell ?row ?col blank))\n    (true (cell ?row ?col blank))\n    (does robot quit))\n(<= (next (cell ?row ?col ?n))\n    (does robot (place ?row ?col ?n)))\n(<= (next finished)\n    (does robot quit))\n(<= terminal\n    filled)\n(<= filled\n    (not anyblank))\n(<= anyblank\n    (true (cell ?row ?col blank)))\n(<= terminal\n    (true finished))\n(<= (goal robot 0)\n    (true (cell ?row ?col blank)))\n(<= (goal robot 100)\n    (not (goal robot 0)))\n(<= (number ?n)\n    (succ ?n ?m))\n(<= (number ?m)\n    (succ ?n ?m))\n(<= (gt ?n1 ?n2)\n    (succ ?n2 ?n1))\n(<= (gt ?n1 ?n3)\n    (succ ?n2 ?n1)\n    (gt ?n2 ?n3))\n(<= (init (cell_gt_right ?row ?col1))\n    (succ ?col1 ?col2)\n    (gt_constraint ?row ?col1 ?row ?col2))\n(<= (init (cell_lt_right ?row ?col1))\n    (succ ?col1 ?col2)\n    (gt_constraint ?row ?col2 ?row ?col1))\n(<= (init (cell_gt_below ?row1 ?col))\n    (succ ?row1 ?row2)\n    (gt_constraint ?row1 ?col ?row2 ?col))\n(<= (init (cell_lt_below ?row1 ?col))\n    (succ ?row1 ?row2)\n    (gt_constraint ?row2 ?col ?row1 ?col))\n(<= (next (cell_gt_right ?row ?col))\n    (true (cell_gt_right ?row ?col)))\n(<= (next (cell_lt_right ?row ?col))\n    (true (cell_lt_right ?row ?col)))\n(<= (next (cell_gt_below ?row ?col))\n    (true (cell_gt_below ?row ?col)))\n(<= (next (cell_lt_below ?row ?col))\n    (true (cell_lt_below ?row ?col)))\n(succ  1  2)\n(succ  2  3)\n(succ  3  4)\n(succ  4  5)\n(gt_constraint 1 2 1 3)\n(gt_constraint 1 5 1 4)\n(gt_constraint 1 2 2 2)\n(gt_constraint 1 5 2 5)\n(gt_constraint 2 1 3 1)\n(gt_constraint 3 2 2 2)\n(gt_constraint 3 2 3 3)\n(gt_constraint 4 4 4 5)\n(gt_constraint 4 4 5 4)\n(gt_constraint 5 3 5 4)\n(gt_constraint 5 5 5 4)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a two-dimensional grid defined by indices ranging from 0 to 8 for both horizontal and vertical coordinates, creating a bounded board enclosed by walls along its edges and various internal walls positioned between cells. The coordinate system uses these indices to specify locations, with directions identified as north, south, east, west, and nowhere to indicate movement or orientation within the grid. Two player roles exist: the explorer and the mummy, with the explorer always taking the first turn followed by the mummy; turns alternate in this fixed order. At the start of the game, the explorer is located at coordinates (3,3), the mummy at (5,1), and the exit at (1,2), with the initial step count set to zero. Each turn, the explorer can perform an action to move one cell in any of the four cardinal directions, provided the movement is legal; legality requires that no wall blocks the path from the current cell in the chosen direction and that the destination lies within the board boundaries. The mummy’s move is defined by a two-step movement composed of two directional moves, each corresponding to a legal step toward the explorer's current location, again respecting walls and board limits. If a proposed move is blocked by a wall or would move an entity outside the grid, the entity remains in its current position, effectively a no-operation for that step. Actions are formatted as move commands specifying the direction to move for the explorer and a composite two-direction move for the mummy, with these actions constrained by the spatial layout and adjacency rules encoded via direction components and wall placements. After each action, the game state updates the positions of the explorer and mummy accordingly, increments the step counter, and maintains static positions for the exit and walls. The game implicitly enforces that no two entities can occupy the same cell unless it results in the explorer being \"eaten\" by the mummy, which occurs if both share the same coordinates after a move; this event triggers an immediate terminal condition. The game also ends if the explorer reaches the exit cell or when fifty steps have elapsed without either of these events occurring. Victory is determined by the final conditions: the explorer achieves a high score of 100 points by reaching the exit without being eaten, receives 50 points if neither reaching the exit nor being eaten occurs within the step limit, and scores zero if eaten. Conversely, the mummy scores zero if the explorer escapes safely, 50 points if the game ends without a definitive outcome, and 100 points if it successfully captures the explorer. This structure ensures a strategic pursuit game where the explorer aims to navigate the maze of walls to reach the exit, while the mummy attempts to intercept by moving two steps each turn toward the explorer’s position, with the game concluding upon escape, capture, or time expiration.",
    "output": "(index 0)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(direction north)\n(direction south)\n(direction east)\n(direction west)\n(direction nowhere)\n(role explorer)\n(mummy-type mummy)\n(init (location mummy 5 1))\n(init (location explorer 3 3))\n(init (location exit 1 2))\n(init (step 0))\n(init (wall 4 1 east))\n(init (wall 4 1 north))\n(init (wall 1 2 north))\n(init (wall 2 2 north))\n(init (wall 1 3 east))\n(init (wall 3 3 east))\n(init (wall 2 4 east))\n(init (wall 3 4 east))\n(init (wall 3 5 east))\n(init (wall 3 5 north))\n(init (wall 2 5 north))\n(init (wall 2 6 east))\n(init (wall 3 6 north))\n(init (wall 2 8 east))\n(init (wall 4 6 north))\n(init (wall 4 7 east))\n(init (wall 5 7 east))\n(init (wall 4 4 east))\n(init (wall 5 4 east))\n(init (wall 8 7 north))\n(init (wall 6 1 north))\n(init (wall 6 2 north))\n(init (wall 6 2 east))\n(init (wall 6 3 east))\n(init (wall 6 4 east))\n(init (wall 6 6 north))\n(init (wall 7 4 north))\n(init (wall 7 3 east))\n(init (wall 1 0 north))\n(init (wall 2 0 north))\n(init (wall 3 0 north))\n(init (wall 4 0 north))\n(init (wall 5 0 north))\n(init (wall 6 0 north))\n(init (wall 7 0 north))\n(init (wall 8 0 north))\n(init (wall 1 8 north))\n(init (wall 2 8 north))\n(init (wall 3 8 north))\n(init (wall 4 8 north))\n(init (wall 5 8 north))\n(init (wall 6 8 north))\n(init (wall 7 8 north))\n(init (wall 8 8 north))\n(init (wall 0 1 east))\n(init (wall 0 2 east))\n(init (wall 0 3 east))\n(init (wall 0 4 east))\n(init (wall 0 5 east))\n(init (wall 0 6 east))\n(init (wall 0 7 east))\n(init (wall 0 8 east))\n(init (wall 8 1 east))\n(init (wall 8 2 east))\n(init (wall 8 3 east))\n(init (wall 8 4 east))\n(init (wall 8 5 east))\n(init (wall 8 6 east))\n(init (wall 8 7 east))\n(init (wall 8 8 east))\n(<= (legal explorer (move ?dir))\n(direction ?dir))\n(<= (doesprime ?mummy (move2 ?m1 ?m2))\n(mummy-type ?mummy)\n(true (location ?mummy ?x ?y))\n(true (location explorer ?ex1 ?ey1))\n(does explorer (move ?em))\n(newlocation1 ?ex1 ?ey1 ?em ?ex ?ey)\n(movetoward ?x ?y ?ex ?ey ?m1)\n(newlocation1 ?x ?y ?m1 ?x1 ?y1)\n(movetoward ?x1 ?y1 ?ex ?ey ?m2))\n(<= (movetoward ?x ?y ?ex ?ey ?card)\n(direction-from ?x ?y ?ex ?ey ?dir)\n(pick-one ?x ?y ?dir ?card))\n(<= (pick-one ?x ?y none nowhere)\n(index ?x)\n(index ?y))\n(<= (pick-one ?x ?y ?dir ?v)\n(index ?x)\n(index ?y)\n(not (some-horiz-component ?dir))\n(vert-component ?dir ?v))\n(<= (pick-one ?x ?y ?dir ?h)\n(index ?x)\n(index ?y)\n(not (some-vert-component ?dir))\n(horiz-component ?dir ?h))\n(<= (pick-one ?x ?y ?dir ?h)\n(horiz-component ?dir ?h)\n(vert-component ?dir ?v)\n(newlocation1 ?x ?y ?h ?xnew ?y)\n(distinct ?x ?xnew))\n(<= (pick-one ?x ?y ?dir ?v)\n(horiz-component ?dir ?h)\n(vert-component ?dir ?v)\n(newlocation1 ?x ?y ?h ?x ?y))\n(<= (some-vert-component ?dir)\n(vert-component ?dir ?x))\n(<= (some-horiz-component ?dir)\n(horiz-component ?dir ?x))\n(<= (direction-from ?x1 ?y1 ?x2 ?y2 ?dir)\n(horiz-direction-from ?x1 ?x2 ?dir1)\n(vert-direction-from ?y1 ?y2 ?dir2)\n(combine-directions ?dir2 ?dir1 ?dir))\n(<= (horiz-direction-from ?x1 ?x2 east)\n(lessthan ?x1 ?x2))\n(<= (horiz-direction-from ?x1 ?x2 west)\n(lessthan ?x2 ?x1))\n(<= (horiz-direction-from ?x1 ?x2 none)\n(index ?x1)\n(index ?x2)\n(not (lessthan ?x1 ?x2))\n(not (lessthan ?x2 ?x1)))\n(<= (vert-direction-from ?y1 ?y2 north)\n(lessthan ?y1 ?y2))\n(<= (vert-direction-from ?y1 ?y2 south)\n(lessthan ?y2 ?y1))\n(<= (vert-direction-from ?y1 ?y2 none)\n(index ?y1)\n(index ?y2)\n(not (lessthan ?y1 ?y2))\n(not (lessthan ?y2 ?y1)))\n(combine-directions none none none)\n(<= (combine-directions none ?x ?x)\n(direction ?x))\n(<= (combine-directions ?x none ?x)\n(direction ?x))\n(combine-directions north east ne)\n(combine-directions north west nw)\n(combine-directions south east se)\n(combine-directions south west sw)\n(<= (lessthan ?x ?y)\n(succ ?x ?y))\n(<= (lessthan ?x ?y)\n(distinct ?x ?y)\n(succ ?x ?z)\n(lessthan ?z ?y))\n(<= (next (location explorer ?x2 ?y2))\n(true (location explorer ?x1 ?y1))\n(does explorer (move ?dir))\n(newlocation1 ?x1 ?y1 ?dir ?x2 ?y2))\n(<= (next (location ?mummy ?x2 ?y2))\n(mummy-type ?mummy)\n(true (location ?mummy ?x1 ?y1))\n(doesprime ?mummy (move2 ?dir1 ?dir2))\n(newlocation2 ?x1 ?y1 ?dir1 ?dir2 ?x2 ?y2))\n(<= (next (location exit ?x ?y))\n(true (location exit ?x ?y)))\n(<= (next (cell ?x ?y))\n(true (cell ?x ?y)))\n(<= (next (wall ?x ?y ?z))\n(true (wall ?x ?y ?z)))\n(<= (next (step ?x))\n(true (step ?y))\n(succ ?y ?x))\n(<= eaten\n(true (location explorer ?x ?y))\n(true (location ?mummy ?x ?y))\n(mummy-type ?mummy))\n(<= atexit\n(true (location explorer ?x ?y))\n(true (location exit ?x ?y)))\n(<= laststep\n(true (step 50)))\n(<= (newlocation1 ?x ?y nowhere ?x ?y)\n(index ?x)\n(index ?y))\n(<= (newlocation1 ?x ?y north ?x ?y)\n(true (wall ?x ?y north)))\n(<= (newlocation1 ?x ?y south ?x ?y)\n(succ ?down ?y)\n(true (wall ?x ?down north)))\n(<= (newlocation1 ?x ?y east ?x ?y)\n(true (wall ?x ?y east)))\n(<= (newlocation1 ?x ?y west ?x ?y)\n(succ ?left ?x)\n(true (wall ?left ?y east)))\n(<= (newlocation1 ?x ?y1 north ?x ?y2)\n(succ ?y1 ?y2)\n(index ?x)\n(not (true (wall ?x ?y1 north))))\n(<= (newlocation1 ?x ?y1 south ?x ?y2)\n(succ ?y2 ?y1)\n(index ?x)\n(not (true (wall ?x ?y2 north))))\n(<= (newlocation1 ?x1 ?y east ?x2 ?y)\n(succ ?x1 ?x2)\n(index ?y)\n(not (true (wall ?x1 ?y east))))\n(<= (newlocation1 ?x1 ?y west ?x2 ?y)\n(succ ?x2 ?x1)\n(index ?y)\n(not (true (wall ?x2 ?y east))))\n(<= (newlocation2 ?x1 ?y1 ?dir1 ?dir2 ?x3 ?y3)\n(newlocation1 ?x1 ?y1 ?dir1 ?x2 ?y2)\n(newlocation1 ?x2 ?y2 ?dir2 ?x3 ?y3))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(horiz-component nw west)\n(horiz-component ne east)\n(horiz-component sw west)\n(horiz-component se east)\n(vert-component nw north)\n(vert-component ne north)\n(vert-component sw south)\n(vert-component se south)\n(horiz-component west west)\n(horiz-component east east)\n(vert-component north north)\n(vert-component south south)\n(<= terminal laststep)\n(<= terminal eaten)\n(<= terminal atexit)\n(<= (goal explorer 100)\natexit\n(not eaten))\n(<= (goal explorer 50)\n(not atexit)\n(not eaten))\n(<= (goal explorer 0)\neaten)\n(<= (goal mummy 0)\natexit\n(not eaten))\n(<= (goal mummy 50)\n(not atexit)\n(not eaten))\n(<= (goal mummy 100)\neaten)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid defined by files labeled a through d and ranks numbered 1 through 4, establishing a coordinate system where each cell is identified by a file and a rank. Two players, designated white and black, participate by taking turns alternately, with white moving first. The initial setup places mostly blank cells with black pieces occupying most of the board except for white's king positioned at c1 and white's rook at d1; black's king starts at a4. Each turn, the player in control may perform a move action or, if it is not their turn, must execute a no-operation (noop). Moves are specified by indicating a piece type (king or rook), its current coordinates, and the target coordinates to which it moves. For white, legal moves involve moving the white king or rook to an unoccupied cell that is not restricted, following their respective movement rules: the king moves one square in any adjacent direction, and the rook moves any number of squares along a clear row or column without obstruction. Black's legal moves involve moving the black king to an unoccupied cell that is not attacked or guarded, also following king movement rules. The noop action is legal for a player only when it is not their turn to move, effectively passing control to the opponent. Pieces move according to defined adjacency and successor relationships among files and ranks, with movement legality constrained by occupancy and safety conditions; for example, a rook's path must be clear, and kings cannot move into squares attacked by opposing pieces. After a move, the game state updates by relocating the moved piece to its new cell and marking the previous cell as blank; additionally, any cell adjacent to the destination that was blank before the move and adjacent to the piece's new location is updated accordingly. Control switches to the other player, and the step counter increments by one with each move. The game terminates either when a checkmate condition occurs—where the black king is attacked and has no legal moves—or when the step counter reaches four, marking the end of the game. Scoring is binary: white receives 100 points upon achieving checkmate and zero otherwise, while black receives 100 points if checkmate has not been reached and zero if it has. Thus, victory is achieved by white delivering checkmate within four steps; otherwise, black wins.",
    "output": "(role white)\n(role black)\n(init (cell a 1 b))\n(init (cell a 2 b))\n(init (cell a 3 b))\n(init (cell a 4 bk))\n(init (cell b 1 b))\n(init (cell b 2 b))\n(init (cell b 3 b))\n(init (cell b 4 b))\n(init (cell c 1 wk))\n(init (cell c 2 b))\n(init (cell c 3 b))\n(init (cell c 4 b))\n(init (cell d 1 wr))\n(init (cell d 2 b))\n(init (cell d 3 b))\n(init (cell d 4 b))\n(init (control white))\n(init (step 1))\n    (<= (next (cell ?x ?y ?p))\n        (does ?player (move ?p ?u ?v ?x ?y)))\n    (<= (next (cell ?u ?v b))\n        (does ?player (move ?p ?u ?v ?x ?y)))\n    (<= (next (cell ?w ?z b))\n        (does ?player (move ?p ?u ?v ?x ?y))\n        (true (cell ?w ?z b))\n        (distpair ?w ?x ?y ?z))\n    (<= (next (cell ?w ?z ?q))\n        (does ?player (move ?p ?u ?v ?x ?y))\n        (true (cell ?w ?z ?q))\n        (distinct ?p ?q)\n        (distinct ?q b))\n    (<= (distpair ?w ?x ?y ?z)\n        (distinct ?w ?x)\n        (file ?w)\n        (file ?x)\n        (rank ?y)\n        (rank ?z))\n    (<= (distpair ?w ?x ?y ?z)\n        (distinct ?y ?z)\n        (file ?w)\n        (file ?x)\n        (rank ?y)\n        (rank ?z))\n    (<= (next (control white))\n        (true (control black)))\n    (<= (next (control black))\n        (true (control white)))\n    (<= (next (step ?y))\n        (true (step ?x))\n        (successor ?x ?y))\n    (successor 1 2)\n    (successor 2 3)\n    (successor 3 4)\n    (successor 4 5)\n    (successor 5 6)\n    (successor 6 7)\n    (successor 7 8)\n    (successor 8 9)\n    (successor 9 10)\n    (<= (legal white (move wk ?u ?v ?x ?y))\n        (true (control white))\n        (true (cell ?u ?v wk))\n        (kingmove ?u ?v ?x ?y)\n        (true (cell ?x ?y b))\n        (not (restricted ?x ?y)))\n    (<= (legal white (move wr ?u ?v ?x ?y))\n        (true (control white))\n        (true (cell ?u ?v wr))\n        (rookmove ?u ?v ?x ?y)\n        (true (cell ?x ?y b))\n        (not (restricted ?x ?y)))\n    (<= (legal white noop)\n        (true (control black)))\n    (<= (legal black (move bk ?u ?v ?x ?y))\n        (true (control black))\n        (true (cell ?u ?v bk))\n        (kingmove ?u ?v ?x ?y)\n        (true (cell ?x ?y b))\n        (not (attacked bk ?x ?y))\n        (not (guarded ?x ?y)))\n    (<= (legal black noop)\n        (true (control white)))\n    (<= (kingmove ?u ?v ?u ?y)\n        (adj ?v ?y)\n        (file ?u))\n    (<= (kingmove ?u ?v ?x ?v)\n        (nxt ?u ?x)\n        (rank ?v))\n    (<= (kingmove ?u ?v ?x ?y)\n        (nxt ?u ?x)\n        (adj ?v ?y))\n    (<= (adj ?x ?y)\n        (adjacent ?x ?y))\n    (<= (adj ?x ?y)\n        (adjacent ?y ?x))\n    (<= (nxt ?x ?y)\n        (nextcolumn ?x ?y))\n    (<= (nxt ?x ?y)\n        (nextcolumn ?y ?x))\n    (<= (rookmove ?u ?v ?u ?y)\n        (clearcolumn wr ?u ?v ?y))\n    (<= (rookmove ?u ?v ?u ?y)\n        (clearcolumn wr ?u ?y ?v))\n    (<= (rookmove ?u ?v ?x ?v)\n        (clearrow wr ?u ?x ?v))\n    (<= (rookmove ?u ?v ?x ?v)\n        (clearrow wr ?x ?u ?v))\n    (<= checkmate\n        check\n        stuck)\n    (<= check\n        (true (cell ?u ?v bk))\n        (attacked bk ?u ?v))\n    (<= stuck\n        (not canmove))\n    (<= canmove\n        (true (cell ?u ?v bk))\n        (kingmove ?u ?v ?x ?y)\n        (not (attacked bk ?x ?y))\n        (not (guarded ?x ?y)))\n    (<= (restricted ?x ?y)\n        (true (cell ?u ?v bk))\n        (kingmove ?u ?v ?x ?y))\n    (<= (guarded ?x ?y)\n        (true (cell ?u ?v wk))\n        (kingmove ?u ?v ?x ?y))\n    (<= (attacked ?p ?u ?w)\n        (true (cell ?u ?v wr))\n        (clearcolumn ?p ?u ?v ?w))\n    (<= (attacked ?p ?u ?v)\n        (true (cell ?u ?w wr))\n        (clearcolumn ?p ?u ?v ?w))\n    (<= (attacked ?p ?u ?v)\n        (true (cell ?x ?v wr))\n        (clearrow ?p ?u ?x ?v))\n    (<= (attacked ?p ?u ?v)\n        (true (cell ?u ?v wr))\n        (clearrow ?p ?u ?x ?v))\n    (<= (clearcolumn ?p ?x ?y1 ?y2)\n    \t(piece ?p)\n    \t(file ?x)\n        (adjacent ?y1 ?y2))\n    (<= (clearcolumn ?p ?x ?y1 ?y3)\n        (adjacent ?y1 ?y2)\n        (adjacent ?y2 ?y3)\n        (safe ?x ?y2 ?p))\n    (<= (clearcolumn ?p ?x ?y1 ?y4)\n        (adjacent ?y1 ?y2)\n        (adjacent ?y2 ?y3)\n        (adjacent ?y3 ?y4)\n        (safe ?x ?y2 ?p)\n        (safe ?x ?y3 ?p))\n    (<= (clearrow ?p ?x1 ?x2 ?y)\n    \t(piece ?p)\n    \t(rank ?y)\n        (nextcolumn ?x1 ?x2))\n    (<= (clearrow ?p ?x1 ?x3 ?y)\n        (nextcolumn ?x1 ?x2)\n        (nextcolumn ?x2 ?x3)\n        (safe ?x2 ?y ?p))\n    (<= (clearrow ?p ?x1 ?x4 ?y)\n        (nextcolumn ?x1 ?x2)\n        (nextcolumn ?x2 ?x3)\n        (nextcolumn ?x3 ?x4)\n        (safe ?x2 ?y ?p)\n        (safe ?x3 ?y ?p))\n    (<= (safe ?x ?y ?p)\n    \t(piece ?p)\n        (true (cell ?x ?y b)))\n    (<= (safe ?x ?y ?p)\n        (true (cell ?x ?y ?p)))\n    (adjacent 1 2)\n    (adjacent 2 3)\n    (adjacent 3 4)\n    (nextcolumn a b)\n    (nextcolumn b c)\n    (nextcolumn c d)\n    (file a)\n    (file b)\n    (file c)\n    (file d)\n    (rank 1)\n    (rank 2)\n    (rank 3)\n    (rank 4)\n    (piece bk)\n    (piece wk)\n    (piece wr)\n(<= (goal white 100)\n    checkmate)\n(<= (goal white 0)\n    (not checkmate))\n(<= (goal black 100)\n    (not checkmate))\n(<= (goal black 0)\n    checkmate)\n(<= terminal\n    (true (step 4)))\n(<= terminal\n    checkmate)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game takes place on a grid-based board defined by coordinates with columns labeled from x1 to x4 and rows labeled from y1 to y5, establishing a coordinate system where each cell is identified by a unique (y, x) pair. The directions north, east, south, and west are used to navigate between adjacent cells, with adjacency relationships defined such that moving north or south changes the y-coordinate by one step, while moving east or west changes the x-coordinate by one step, respecting the boundaries of the board. Initially, various pieces labeled piece1 through piece10 and blank spaces are placed on specific cells throughout the grid according to the setup, with some cells intentionally left blank. The game is played by a single player whose turn consists of making moves, and turns progress sequentially through steps numbered from s0 to s81, with each step representing a discrete turn; the player can also perform a no-operation (noop) if no legal moves are available or desired. On a given turn, the player may issue a move action specifying a piece and a direction; a move is legal only if the piece currently occupies a cell and the adjacent cell in the specified direction exists on the board and is not occupied by a different piece, ensuring no overlapping or moving outside the board boundaries. Attempting to move a piece into a blocked cell—one occupied by another distinct piece or outside the board—is illegal. When a legal move is performed, the piece moves from its current cell to the adjacent cell in the chosen direction, vacating its original cell which becomes blank; cells not involved in the move remain unchanged. The game automatically updates the board state after each move, advancing the step counter and reflecting the new piece positions. The game terminates either when the step counter reaches s81 or when a goal condition is met, which requires that four specific cells—namely those at coordinates (y4, x2), (y4, x3), (y5, x2), and (y5, x3)—are all occupied by the piece labeled piece2. Achieving this configuration results in the player receiving a score of 100, indicating victory, while failure to reach this state by step s81 results in a score of 0. Thus, the player's objective is to maneuver the pieces through legal moves within the confines of the board and adjacency rules to align piece2 in the designated goal positions before the maximum number of steps is reached, at which point the game concludes with success or failure accordingly.",
    "output": "(role player)\n(init (cell y1 x1 piece1))\n(init (cell y1 x2 piece2))\n(init (cell y1 x3 piece2))\n(init (cell y1 x4 piece3))\n(init (cell y2 x1 piece1))\n(init (cell y2 x2 piece2))\n(init (cell y2 x3 piece2))\n(init (cell y2 x4 piece3))\n(init (cell y3 x1 blank))\n(init (cell y3 x2 piece4))\n(init (cell y3 x3 piece4))\n(init (cell y3 x4 blank))\n(init (cell y4 x1 piece5))\n(init (cell y4 x2 piece6))\n(init (cell y4 x3 piece7))\n(init (cell y4 x4 piece8))\n(init (cell y5 x1 piece5))\n(init (cell y5 x2 piece9))\n(init (cell y5 x3 piece10))\n(init (cell y5 x4 piece8))\n(init (step s0))\n(direction north)\n(direction east)\n(direction south)\n(direction west)\n(xcoord x1)\n(xcoord x2)\n(xcoord x3)\n(xcoord x4)\n(ycoord y1)\n(ycoord y2)\n(ycoord y3)\n(ycoord y4)\n(ycoord y5)\n(next_x x1 x2)\n(next_x x2 x3)\n(next_x x3 x4)\n(next_y y1 y2)\n(next_y y2 y3)\n(next_y y3 y4)\n(next_y y4 y5)\n(<= (adjacent ?y ?x north ?y2 ?x)\n(xcoord ?x)\n(next_y ?y2 ?y))\n(<= (adjacent ?y ?x east ?y ?x2)\n(next_x ?x ?x2)\n(ycoord ?y))\n(<= (adjacent ?y ?x south ?y2 ?x)\n(xcoord ?x)\n(next_y ?y ?y2))\n(<= (adjacent ?y ?x west ?y ?x2)\n(next_x ?x2 ?x)\n(ycoord ?y))\n(<= (has_adjacent ?y ?x ?d)\n(adjacent ?y ?x ?d ?y2 ?x2))\n(<= (legal player (move ?p ?d))\n(true (cell ?y ?x ?p))\n(distinct ?p blank)\n(direction ?d)\n(not (blocked_cell ?p ?d)))\n(<= (blocked_cell ?p ?d)\n(true (cell ?y ?x ?p))\n(adjacent ?y ?x ?d ?yd ?xd)\n(true (cell ?yd ?xd ?p2))\n(distinct ?p2 blank)\n(distinct ?p2 ?p))\n(<= (blocked_cell ?p ?d)\n(true (cell ?y ?x ?p))\n(direction ?d)\n(not (has_adjacent ?y ?x ?d)))\n(<= (next (step ?x))\n(true (step ?y))\n(successor ?y ?x))\n(<= (next (cell ?y ?x ?p))\n(is_moved ?y1 ?x1 ?y ?x)\n(true (cell ?y1 ?x1 ?p)))\n(<= (next (cell ?y ?x blank))\n(true (cell ?y ?x ?something))\n(not (is_moved_any_to ?y ?x)))\n(<= (next (cell ?y ?x ?p))\n(true (cell ?y ?x ?p))\n(not (is_moved_anywhere ?y ?x))\n(not (is_moved_any_to ?y ?x)))\n(<= (is_moved ?y ?x ?yd ?xd)\n(does player (move ?p ?d))\n(true (cell ?y ?x ?p))\n(adjacent ?y ?x ?d ?yd ?xd))\n(<= (is_moved_any_to ?yd ?xd)\n(is_moved ?y ?x ?yd ?xd))\n(<= (is_moved_anywhere ?y ?x)\n(is_moved ?y ?x ?yd ?xd))\n(<= (goal player 100)\ngoal_reached\n)\n(<= (goal player 0)\n(not goal_reached))\n(<= terminal\n(true (step s81)))\n(<= terminal\ngoal_reached)\n(<= goal_reached\n(true (cell 4 2 piece2))\n(true (cell 4 3 piece2))\n(true (cell 5 2 piece2))\n(true (cell 5 3 piece2)))\n(successor s0 s1)\n(successor s1 s2)\n(successor s2 s3)\n(successor s3 s4)\n(successor s4 s5)\n(successor s5 s6)\n(successor s6 s7)\n(successor s7 s8)\n(successor s8 s9)\n(successor s9 s10)\n(successor s10 s11)\n(successor s11 s12)\n(successor s12 s13)\n(successor s13 s14)\n(successor s14 s15)\n(successor s15 s16)\n(successor s16 s17)\n(successor s17 s18)\n(successor s18 s19)\n(successor s19 s20)\n(successor s20 s21)\n(successor s21 s22)\n(successor s22 s23)\n(successor s23 s24)\n(successor s24 s25)\n(successor s25 s26)\n(successor s26 s27)\n(successor s27 s28)\n(successor s28 s29)\n(successor s29 s30)\n(successor s30 s31)\n(successor s31 s32)\n(successor s32 s33)\n(successor s33 s34)\n(successor s34 s35)\n(successor s35 s36)\n(successor s36 s37)\n(successor s37 s38)\n(successor s38 s39)\n(successor s39 s40)\n(successor s40 s41)\n(successor s41 s42)\n(successor s42 s43)\n(successor s43 s44)\n(successor s44 s45)\n(successor s45 s46)\n(successor s46 s47)\n(successor s47 s48)\n(successor s48 s49)\n(successor s49 s50)\n(successor s50 s51)\n(successor s51 s52)\n(successor s52 s53)\n(successor s53 s54)\n(successor s54 s55)\n(successor s55 s56)\n(successor s56 s57)\n(successor s57 s58)\n(successor s58 s59)\n(successor s59 s60)\n(successor s60 s61)\n(successor s61 s62)\n(successor s62 s63)\n(successor s63 s64)\n(successor s64 s65)\n(successor s65 s66)\n(successor s66 s67)\n(successor s67 s68)\n(successor s68 s69)\n(successor s69 s70)\n(successor s70 s71)\n(successor s71 s72)\n(successor s72 s73)\n(successor s73 s74)\n(successor s74 s75)\n(successor s75 s76)\n(successor s76 s77)\n(successor s77 s78)\n(successor s78 s79)\n(successor s79 s80)\n(successor s80 s81)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 grid with coordinates defined by x and y indices ranging from 1 to 8, where the coordinate system uses (x, y) pairs to identify each cell. There are two players, White and Black, who alternate turns with White moving first, indicated initially by control assigned to White. The initial configuration places White's pieces occupying all cells in the first two rows (y=1 and y=2) and Black's pieces occupying all cells in the last two rows (y=7 and y=8), such that each cell in these rows holds a piece of the respective player. On a player's turn, they may either make a move or pass by executing a noop action, however, a noop is only legal for White when it is Black's turn and for Black when it is White's turn, effectively forcing the player whose turn it is to make a move. A legal move for White consists of moving one of their pieces forward from (x, y1) to (x, y2) where y2 is the immediate successor of y1 (that is y2 = y1 + 1), provided the destination cell is empty; alternatively, White may move diagonally forward to either the right or left by moving from (x1, y1) to (x2, y2) where y2 = y1 + 1 and x2 is the immediate successor or predecessor of x1 (depending on board boundaries), capturing any opposing piece present there, but not onto a cell occupied by another White piece. Black's legal moves mirror White's but in the opposite direction: Black pieces move downwards from (x, y1) to (x, y2) where y2 is the predecessor of y1 (y2 = y1 - 1), either straight forward into an empty cell or diagonally forward left or right into a cell not occupied by another Black piece, potentially capturing a White piece. Moves must respect board boundaries, and pieces cannot move outside the 1-to-8 range in either coordinate or onto cells occupied by friendly pieces; diagonal moves require the destination cell to not contain a piece of the moving player. After a move, the piece is relocated accordingly, the previous cell becomes empty, and control passes to the opposing player. The game terminates when either White achieves a winning condition by having any of their pieces occupy any cell in the eighth row (y=8), or when Black achieves a winning condition by having any of their pieces occupy any cell in the first row (y=1). Additionally, a player wins if the opponent has no remaining pieces on the board. Victory is scored at 100 points for the winning player and 0 for the loser. The game enforces distinctness of cells so that moves cannot occur within the same cell, and the successor relations define allowable moves in both vertical and horizontal directions, except that certain horizontal transitions involving the fourth column are disallowed to maintain proper movement constraints. Thus, the game is a turn-based abstract strategy contest where each player attempts to advance their pieces forward to the opponent's home row or to eliminate all opposing pieces, with moves restricted to single-step forward or diagonal captures within the bounded grid, and turns alternating with forced moves or passes as dictated by the control state.",
    "output": "(role white)\n(role black)\n(init (cellHolds 1 1 white))\n(init (cellHolds 2 1 white))\n(init (cellHolds 3 1 white))\n(init (cellHolds 4 1 white))\n(init (cellHolds 5 1 white))\n(init (cellHolds 6 1 white))\n(init (cellHolds 7 1 white))\n(init (cellHolds 8 1 white))\n(init (cellHolds 1 2 white))\n(init (cellHolds 2 2 white))\n(init (cellHolds 3 2 white))\n(init (cellHolds 4 2 white))\n(init (cellHolds 5 2 white))\n(init (cellHolds 6 2 white))\n(init (cellHolds 7 2 white))\n(init (cellHolds 8 2 white))\n(init (cellHolds 1 7 black))\n(init (cellHolds 2 7 black))\n(init (cellHolds 3 7 black))\n(init (cellHolds 4 7 black))\n(init (cellHolds 5 7 black))\n(init (cellHolds 6 7 black))\n(init (cellHolds 7 7 black))\n(init (cellHolds 8 7 black))\n(init (cellHolds 1 8 black))\n(init (cellHolds 2 8 black))\n(init (cellHolds 3 8 black))\n(init (cellHolds 4 8 black))\n(init (cellHolds 5 8 black))\n(init (cellHolds 6 8 black))\n(init (cellHolds 7 8 black))\n(init (cellHolds 8 8 black))\n(init (control white))\n(<= (legal white (move ?x ?y1 ?x ?y2))\n    (true (control white))\n    (true (cellHolds ?x ?y1 white))\n    (succ ?y1 ?y2)\n    (cellEmpty ?x ?y2))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cellHolds ?x1 ?y1 white))\n    (succ ?y1 ?y2)\n    (succx ?x1 ?x2)\n    (not (true (cellHolds ?x2 ?y2 white))))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cellHolds ?x1 ?y1 white))\n    (succ ?y1 ?y2)\n    (succx ?x2 ?x1)\n    (not (true (cellHolds ?x2 ?y2 white))))\n(<= (legal black (move ?x ?y1 ?x ?y2))\n    (true (control black))\n    (true (cellHolds ?x ?y1 black))\n    (succ ?y2 ?y1)\n    (cellEmpty ?x ?y2))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cellHolds ?x1 ?y1 black))\n    (succ ?y2 ?y1)\n    (succx ?x1 ?x2)\n    (not (true (cellHolds ?x2 ?y2 black))))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cellHolds ?x1 ?y1 black))\n    (succ ?y2 ?y1)\n    (succx ?x2 ?x1)\n    (not (true (cellHolds ?x2 ?y2 black))))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black noop)\n    (true (control white)))\n(<= (next (cellHolds ?x2 ?y2 ?player))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cellHolds ?x3 ?y3 ?state))\n    (true (cellHolds ?x3 ?y3 ?state))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x3 ?y3)\n    (distinctCell ?x2 ?y2 ?x3 ?y3))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= terminal\n    whiteWin)\n(<= terminal\n    blackWin)\n(<= (goal white 100)\n    whiteWin)\n(<= (goal white 0)\n    (not whiteWin))\n(<= (goal black 100)\n    blackWin)\n(<= (goal black 0)\n    (not blackWin))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (cellEmpty ?x ?y)\n    (cell ?x ?y)\n    (not (true (cellHolds ?x ?y white)))\n    (not (true (cellHolds ?x ?y black))))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= whiteWin\n    (index ?x)\n    (true (cellHolds ?x 8 white)))\n(<= blackWin\n    (index ?x)\n    (true (cellHolds ?x 1 black)))\n(<= whiteWin\n\t(not blackCell))\n(<= blackWin\n\t(not whiteCell))\n(<= whiteCell\n\t(cell ?x ?y)\n\t(true (cellHolds ?x ?y white)))\n(<= blackCell\n\t(cell ?x ?y)\n\t(true (cellHolds ?x ?y black)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(succ 1 2)  (succ 2 3)  (succ 3 4)  (succ 4 5)  (succ 5 6)  (succ 6 7)  (succ 7 8)\n(<= (succx ?m ?n)\n\t(succ ?m ?n)\n\t(distinct ?m 4))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played in a single-player environment where the player takes on the role of a robot manipulating a three-dimensional puzzle composed of individual pieces called cubies, each identified by unique labels corresponding to their colored faces, such as \"yo,\" \"yb,\" and \"wr.\" The coordinate system is implicit in the arrangement and orientation of these cubies, which occupy positions designated as corners or edges on the puzzle. The initial state sets the step counter to zero and places each cubie in a specific starting position with an initial orientation, either 0 or 1, representing their rotational alignment. The sole player, the robot, takes turns sequentially, with only one turn per step, and has the option to perform one of several legal actions on each turn: a rotation labeled as \"turn\" with a direction parameter chosen from up, down, left, right, front, or back moves, combined with an angle of 90, 180, or 270 degrees, or to perform a noop action that results in no change. Actions are legal if the specified move direction is valid, and the turn action must be one of the specified rotation angles; the noop is always legal. When a rotation action is performed, all cubies affected by that move are repositioned according to the move's defined \"after\" relationships, which specify how cubies cycle through positions as a result of the rotation; unaffected cubies retain their positions. Additionally, the orientations of corner cubies affected by the rotation are updated by adding a move-specific orientation effect, cycling through orientation states accordingly, while edge cubie orientations flip or remain unchanged depending on the rotation angle. If the action is noop, all cubies maintain their current positions and orientations. The game automatically increments the step count after each turn. Implicit constraints ensure that cubies remain within the puzzle’s structure, and moves only cycle pieces among predefined neighboring positions without overlapping. The game terminates either when all cubies are correctly positioned and oriented, which means each cubie occupies its designated position with orientation zero, or when the step count reaches 50, whichever occurs first. The scoring system assigns a goal value equal to the count of correctly placed and oriented cubies at termination, with zero score before the game ends. The objective is to maximize the number of correctly aligned cubies within the allowed steps by applying appropriate rotations or choosing to pass with noop actions.",
    "output": "(role robot)\n(init (step 0))\n(init (cubie yo yo))\n(init (cubie yb yb))\n(init (cubie yr yr))\n(init (cubie yg yg))\n(init (cubie bo bo))\n(init (cubie br br))\n(init (cubie go go))\n(init (cubie gr gr))\n(init (cubie wo wo))\n(init (cubie wb wb))\n(init (cubie wr wr))\n(init (cubie wg wg))\n(init (cubie wbo wbo))\n(init (cubie wbr wbr))\n(init (cubie wgr wgr))\n(init (cubie wgo wgo))\n(init (cubie ybo ybo))\n(init (cubie ybr ybr))\n(init (cubie ygr ygr))\n(init (cubie ygo ygo))\n(init (cubieorient wb 1))\n(init (cubieorient wg 1))\n(init (cubieorient wo 1))\n(init (cubieorient wr 1))\n(init (cubieorient yb 1))\n(init (cubieorient yg 1))\n(init (cubieorient yo 1))\n(init (cubieorient yr 1))\n(init (cubieorient bo 1))\n(init (cubieorient br 1))\n(init (cubieorient go 1))\n(init (cubieorient gr 1))\n(init (cubieorient wbo 0))\n(init (cubieorient wbr 0))\n(init (cubieorient wgo 0))\n(init (cubieorient wgr 0))\n(init (cubieorient ybo 0))\n(init (cubieorient ybr 0))\n(init (cubieorient ygo 0))\n(init (cubieorient ygr 0))\n(<= (legal robot (turn ?dir 90))\n    (move ?dir))\n(<= (legal robot (turn ?dir 180))\n    (move ?dir))\n(<= (legal robot (turn ?dir 270))\n    (move ?dir))\n(legal robot noop)\n(<= (next (cubie ?cubie ?new))\n    (does robot (turn ?move 90))\n    (true (cubie ?cubie ?old))\n    (after ?move ?old ?new))\n(<= (next (cubie ?cubie ?new))\n    (does robot (turn ?move 180))\n    (true (cubie ?cubie ?old))\n    (after ?move ?old ?mid)\n    (after ?move ?mid ?new))\n(<= (next (cubie ?cubie ?new))\n    (does robot (turn ?move 270))\n    (true (cubie ?cubie ?old))\n    (after ?move ?old ?mid1)\n    (after ?move ?mid1 ?mid2)\n    (after ?move ?mid2 ?new))\n(<= (next (cubie ?cubie ?pos))\n    (does robot (turn ?move ?angle))\n    (true (cubie ?cubie ?pos))\n    (unaffected ?pos ?move))\n(<= (next (cubie ?cubie ?pos))\n    (does robot noop)\n    (true (cubie ?cubie ?pos)))\n(<= (next (cubieorient ?cubie ?new))\n    (does robot (turn ?move 90))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (corner ?cubie)\n    (affected ?oldpos ?move)\n    (moveorienteffect ?move ?addition)\n    (cornerorientadd ?old ?addition ?new))\n(<= (next (cubieorient ?cubie ?new))\n    (does robot (turn ?move 180))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (corner ?cubie)\n    (affected ?oldpos ?move)\n    (moveorienteffect ?move ?addition)\n    (cornerorientadd ?old ?addition ?mid)\n    (cornerorientadd ?mid ?addition ?new))\n(<= (next (cubieorient ?cubie ?new))\n    (does robot (turn ?move 270))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (corner ?cubie)\n    (affected ?oldpos ?move)\n    (moveorienteffect ?move ?addition)\n    (cornerorientadd ?old ?addition ?mid1)\n    (cornerorientadd ?mid1 ?addition ?mid2)\n    (cornerorientadd ?mid2 ?addition ?new))\n(<= (next (cubieorient ?cubie ?new))\n    (does robot (turn ?move ?angle))\n    (distinct ?angle 180)\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (edge ?cubie)\n    (affected ?oldpos ?move)\n    (flip ?old ?new))\n(<= (next (cubieorient ?cubie ?old))\n    (does robot (turn ?move 180))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?oldpos))\n    (edge ?cubie))\n(<= (next (cubieorient ?cubie ?old))\n    (does robot (turn ?move ?angle))\n    (true (cubieorient ?cubie ?old))\n    (true (cubie ?cubie ?pos))\n    (unaffected ?pos ?move))\n(<= (next (cubieorient ?cubie ?old))\n    (does robot noop)\n    (true (cubieorient ?cubie ?old)))\n(<= (next (step ?np1))\n    (true (step ?n))\n    (succ ?n ?np1))\n(flip 0 1)\n(flip 1 0)\n(after u wbo wbr)\n(after u wbr wgr)\n(after u wgr wgo)\n(after u wgo wbo)\n(after u wb wr)\n(after u wr wg)\n(after u wg wo)\n(after u wo wb)\n(after d ybr ybo)\n(after d ybo ygo)\n(after d ygo ygr)\n(after d ygr ybr)\n(after d yr yb)\n(after d yb yo)\n(after d yo yg)\n(after d yg yr)\n(after f wgr wbr)\n(after f wbr ybr)\n(after f ybr ygr)\n(after f ygr wgr)\n(after f wr br)\n(after f br yr)\n(after f yr gr)\n(after f gr wr)\n(after b wgo ygo)\n(after b ygo ybo)\n(after b ybo wbo)\n(after b wbo wgo)\n(after b wo go)\n(after b go yo)\n(after b yo bo)\n(after b bo wo)\n(after l wgo wgr)\n(after l wgr ygr)\n(after l ygr ygo)\n(after l ygo wgo)\n(after l wg gr)\n(after l gr yg)\n(after l yg go)\n(after l go wg)\n(after r wbo ybo)\n(after r ybo ybr)\n(after r ybr wbr)\n(after r wbr wbo)\n(after r wb bo)\n(after r bo yb)\n(after r yb br)\n(after r br wb)\n(moveorienteffect f wb)\n(moveorienteffect b wb)\n(moveorienteffect u br)\n(moveorienteffect d br)\n(moveorienteffect l wr)\n(moveorienteffect r wr)\n(cornerorientadd 0 wb wb)\n(cornerorientadd 0 br br)\n(cornerorientadd 0 wr wr)\n(cornerorientadd wb wb 0)\n(cornerorientadd wb br wbr)\n(cornerorientadd wb wr wrb)\n(cornerorientadd br wb wrb)\n(cornerorientadd br br 0)\n(cornerorientadd br wr wbr)\n(cornerorientadd wr wb wbr)\n(cornerorientadd wr br wrb)\n(cornerorientadd wr wr 0)\n(cornerorientadd wbr wb wr)\n(cornerorientadd wbr br wb)\n(cornerorientadd wbr wr br)\n(cornerorientadd wrb wb br)\n(cornerorientadd wrb br wr)\n(cornerorientadd wrb wr wb)\n(<= (affected ?pos ?move)\n    (after ?move ?pos ?nextpos))\n(<= (unaffected ?pos ?move)\n    (position ?pos)\n    (move ?move)\n    (not (affected ?pos ?move)))\n(move u)\n(move d)\n(move l)\n(move r)\n(move f)\n(move b)\n(corner wbo)\n(corner wbr)\n(corner wgo)\n(corner wgr)\n(corner ybo)\n(corner ybr)\n(corner ygo)\n(corner ygr)\n(edge wb)\n(edge wg)\n(edge wo)\n(edge wr)\n(edge yb)\n(edge yg)\n(edge yo)\n(edge yr)\n(edge bo)\n(edge br)\n(edge go)\n(edge gr)\n(<= (position ?p)\n    (corner ?p))\n(<= (position ?p)\n    (edge ?p))\n(csuc 0 wbo)\n(csuc wbo wbr)\n(csuc wbr wgo)\n(csuc wgo wgr)\n(csuc wgr ybo)\n(csuc ybo ybr)\n(csuc ybr ygo)\n(csuc ygo ygr)\n(csuc ygr wb)\n(csuc wb wg)\n(csuc wg wo)\n(csuc wo wr)\n(csuc wr yb)\n(csuc yb yg)\n(csuc yg yo)\n(csuc yo yr)\n(csuc yr bo)\n(csuc bo br)\n(csuc br go)\n(csuc go gr)\n(<= (correct ?cubie)\n    (true (cubie ?cubie ?cubie))\n    (true (cubieorient ?cubie 0)))\n(correctcount 0 0)\n(<= (correctcount ?next ?np5)\n    (csuc ?prev ?next)\n    (correct ?next)\n    (correctcount ?prev ?n)\n    (plus5 ?n ?np5))\n(<= (correctcount ?next ?n)\n    (csuc ?prev ?next)\n    (not (correct ?next))\n    (correctcount ?prev ?n))\n(<= (totalcorrect ?n)\n    (correctcount gr ?n))\n(<= terminal\n    (totalcorrect 100))\n(<= terminal\n    (true (step 50)))\n(<= (goal robot 0)\n    (not terminal))\n(<= (goal robot ?n)\n    terminal\n    (totalcorrect ?n))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(plus5 0 5)\n(plus5 5 10)\n(plus5 10 15)\n(plus5 15 20)\n(plus5 20 25)\n(plus5 25 30)\n(plus5 30 35)\n(plus5 35 40)\n(plus5 40 45)\n(plus5 45 50)\n(plus5 50 55)\n(plus5 55 60)\n(plus5 60 65)\n(plus5 65 70)\n(plus5 70 75)\n(plus5 75 80)\n(plus5 80 85)\n(plus5 85 90)\n(plus5 90 95)\n(plus5 95 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on an 11 by 11 grid with coordinates labeled from 1 through 11 along both the X and Y axes, defining the board's environment and coordinate system. There are two players, player1 and player2, who alternate turns throughout the game. The game begins in an initial setup phase consisting of six sequential setup steps, during which players place pieces on the board in a predetermined order: player1 places black pieces in steps 1 and 3, player1 places white pieces in step 2, player2 places white pieces in step 4, and player2 places black pieces in step 5. After the setup completes at step 6, players pick their color—either black or white—with player2 picking first at setup step 4 and player1 picking at step 6; once a player picks a color, that color is associated with them for the remainder of the game. Turn control alternates between players, starting with player1 after setup, with the control passing to the opponent each turn. On a player's turn, if they have control, they may legally place a piece of their assigned color on any empty cell of the board; placement actions must specify the coordinates of the cell to occupy, and the target cell must be unoccupied within the board boundaries defined by the indices from 1 to 11. Players may also issue a noop action, which is only legal when the player does not have control or during certain setup steps, effectively passing their turn without action. The state updates after each turn to include newly placed pieces and switch control to the other player. The game enforces implicit constraints such as forbidding placement on occupied cells and restricting moves to within the board coordinates. The game terminates either when no empty cells remain or when a player achieves a line of six consecutive pieces of their color in any horizontal, vertical, or diagonal direction; these lines must be exactly six in length, bounded on both ends by either empty space or opponent's pieces to qualify. The scoring system awards 100 points to the player who forms such a line, zero points to the opponent in that case, and if neither player has formed a line and the board is full, both players receive a score of 50. Thus, victory is achieved by being the first to form an unbroken line of six pieces of one's color, or by ending with the highest score if the board fills without such a line.",
    "output": "(role player1)\n(role player2)\n(color black)\n(color white)\n(init (setupStep 1))\n(<= (next (setupStep 2))\n    (true (setupStep 1)))\n(<= (next (setupStep 3))\n    (true (setupStep 2)))\n(<= (next (setupStep 4))\n    (true (setupStep 3)))\n(<= (next (setupStep 5))\n    (true (setupStep 4))\n    (does player2 (place ?x ?y)))\n(<= (next (setupStep 6))\n    (true (setupStep 5)))\n(<= (next (control ?player))\n    (does ?player (pick white)))\n(<= (next (control ?opponent))\n    (does ?player (pick black))\n    (opponent ?player ?opponent))\n(<= (next (isColor ?player ?color))\n    (does ?player (pick ?color)))\n(<= (next (isColor ?opponent ?otherColor))\n    (does ?player (pick ?color))\n    (opponent ?player ?opponent)\n    (otherColor ?color ?otherColor))\n(<= (next (isColor ?player ?color))\n    (true (isColor ?player ?color)))\n(<= (preplacementStep player1 black)\n    (true (setupStep 1)))\n(<= (preplacementStep player1 white)\n    (true (setupStep 2)))\n(<= (preplacementStep player1 black)\n    (true (setupStep 3)))\n(<= (preplacementStep player2 white)\n    (true (setupStep 4)))\n(<= (preplacementStep player2 black)\n    (true (setupStep 5)))\n(<= (preplacementStepForPlayer ?player)\n    (preplacementStep ?player ?color))\n(<= (legal ?player (place ?x ?y))\n    (preplacementStep ?player ?color)\n    (empty ?x ?y))\n(<= (legal player2 (pick ?color))\n    (color ?color)\n    (true (setupStep 4)))\n(<= (legal player1 (pick ?color))\n    (color ?color)\n    (true (setupStep 6)))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player)))\n    (not (true (setupStep 6)))\n    (not (preplacementStepForPlayer ?player)))\n(<= (legal player2 noop)\n    (true (setupStep 6)))\n(<= (legal ?player (place ?x ?y))\n    (true (control ?player))\n    (empty ?x ?y))\n(<= (empty ?x ?y)\n    (index ?x)\n    (index ?y)\n    (not (occupied ?x ?y)))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?color)))\n(<= anyEmptyCell\n    (empty ?x ?y))\n(<= (next (control player1))\n    (true (control player2)))\n(<= (next (control player2))\n    (true (control player1)))\n(<= (next (cell ?x ?y ?color))\n    (true (cell ?x ?y ?color)))\n(<= (next (cell ?x ?y ?color))\n    (does ?player (place ?x ?y))\n    (preplacementStep ?player ?color))\n(<= (next (cell ?x ?y ?color))\n    (does ?player (place ?x ?y))\n    (true (isColor ?player ?color)))\n(<= terminal\n    (not anyEmptyCell))\n(<= terminal\n    (hasLine ?color))\n(<= (goal ?player 100)\n    (hasLine ?color)\n    (true (isColor ?player ?color)))\n(<= (goal ?player 0)\n    (opponent ?player ?opponent)\n    (true (isColor ?opponent ?theirColor))\n    (hasLine ?theirColor))\n(<= (goal ?player 50)\n    (role ?player)\n    (not (hasLine white))\n    (not (hasLine black)))\n(<= (hasLine ?color)\n    (true (cell ?x1 ?y ?color))\n    (succ ?x0 ?x1)\n    (not (true (cell ?x0 ?y ?color)))\n    (succ ?x1 ?x2)\n    (true (cell ?x2 ?y ?color))\n    (succ ?x2 ?x3)\n    (true (cell ?x3 ?y ?color))\n    (succ ?x3 ?x4)\n    (true (cell ?x4 ?y ?color))\n    (succ ?x4 ?x5)\n    (true (cell ?x5 ?y ?color))\n    (succ ?x5 ?x6)\n    (not (true (cell ?x6 ?y ?color))))\n(<= (hasLine ?color)\n    (true (cell ?x ?y1 ?color))\n    (succ ?y0 ?y1)\n    (not (true (cell ?x ?y0 ?color)))\n    (succ ?y1 ?y2)\n    (true (cell ?x ?y2 ?color))\n    (succ ?y2 ?y3)\n    (true (cell ?x ?y3 ?color))\n    (succ ?y3 ?y4)\n    (true (cell ?x ?y4 ?color))\n    (succ ?y4 ?y5)\n    (true (cell ?x ?y5 ?color))\n    (succ ?y5 ?y6)\n    (not (true (cell ?x ?y6 ?color))))\n(<= (hasLine ?color)\n    (true (cell ?x1 ?y1 ?color))\n    (succ ?x0 ?x1)\n    (succ ?y0 ?y1)\n    (not (true (cell ?x0 ?y0 ?color)))\n    (succ ?x1 ?x2)\n    (succ ?y1 ?y2)\n    (true (cell ?x2 ?y2 ?color))\n    (succ ?x2 ?x3)\n    (succ ?y2 ?y3)\n    (true (cell ?x3 ?y3 ?color))\n    (succ ?x3 ?x4)\n    (succ ?y3 ?y4)\n    (true (cell ?x4 ?y4 ?color))\n    (succ ?x4 ?x5)\n    (succ ?y4 ?y5)\n    (true (cell ?x5 ?y5 ?color))\n    (succ ?x5 ?x6)\n    (succ ?y5 ?y6)\n    (not (true (cell ?x6 ?y6 ?color))))\n(<= (hasLine ?color)\n    (true (cell ?x1 ?y1 ?color))\n    (succ ?x0 ?x1)\n    (succ ?y1 ?y0)\n    (not (true (cell ?x0 ?y0 ?color)))\n    (succ ?x1 ?x2)\n    (succ ?y2 ?y1)\n    (true (cell ?x2 ?y2 ?color))\n    (succ ?x2 ?x3)\n    (succ ?y3 ?y2)\n    (true (cell ?x3 ?y3 ?color))\n    (succ ?x3 ?x4)\n    (succ ?y4 ?y3)\n    (true (cell ?x4 ?y4 ?color))\n    (succ ?x4 ?x5)\n    (succ ?y5 ?y4)\n    (true (cell ?x5 ?y5 ?color))\n    (succ ?x5 ?x6)\n    (succ ?y6 ?y5)\n    (not (true (cell ?x6 ?y6 ?color))))\n(opponent player1 player2)\n(opponent player2 player1)\n(otherColor white black)\n(otherColor black white)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(index 11)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a board composed of 37 distinct positions labeled from a1 through i1, arranged in an irregular grid where some rows have varying numbers of positions, creating a unique topology defined by adjacency relations. The coordinate system consists of these named positions rather than numeric coordinates, with explicit connections between them indicated by two types of directional links, termed \"car\" and \"cdr,\" which differ depending on the player's perspective (red or teal), effectively defining the neighbors and available movement paths on the board. There are two player roles, red and teal, who alternate turns starting with red as the initial controller; the initial state places red's pieces on positions a1, b1, and b2, and teal's pieces on h1, h2, and i1, with the game beginning at step 1. On each turn, the player in control may either move a piece or pass by performing a noop action, which is always legal for any role. A move action is specified by indicating the source position and the target position to which a piece is to be moved; such moves are legal only if the player controls the source cell and the move satisfies the game's movement rules. Movement legality requires a particular pattern of occupancy and adjacency: a piece may move to an empty cell reachable by traversing a chain of occupied and empty cells along the \"car\" and \"cdr\" adjacency relations in sequences of one to four steps, with the exact pattern depending on the configuration of occupied and empty positions along the path; this complex condition ensures that moves correspond to jumping over or sliding past other pieces in prescribed ways. When a move is made from a source to a target cell, the piece relocates accordingly, the source cell becomes empty, and the next player gains control for the subsequent turn, with the step count incremented by one each turn. Occupancy of cells is mutually exclusive: a position may be occupied by at most one piece at a time, and moves must remain within the bounds of the defined board positions and adjacency links. The game terminates either when a player reaches a full \"stone\" count of 100 points, which occurs if that player occupies all three special counting positions assigned to their opponent's side, or when the step count reaches 40, whichever happens first. Scoring is determined by counting the player's occupancy among three designated positions on the opponent's side of the board: if all three are occupied by the player, they earn 100 points; if two are occupied, they earn 50 points; if only one is occupied, they earn 25 points; and if none are occupied, they earn zero. The goal for each player is to maximize their stone count, with the game ending immediately if a player attains the maximum score of 100. Thus, the game challenges players to maneuver their pieces strategically across the board's complex adjacency structure to occupy key opponent positions efficiently within a limited number of turns, alternating moves or passing as needed.",
    "output": "(role red)\n(role teal)\n(index a1)\n(index b1) (index b2)\n(index c1) (index c2) (index c3) (index c4) (index c5) (index c6) (index c7)\n(index d1) (index d2) (index d3) (index d4) (index d5) (index d6)\n(index e1) (index e2) (index e3) (index e4) (index e5)\n(index f1) (index f2) (index f3) (index f4) (index f5) (index f6)\n(index g1) (index g2) (index g3) (index g4) (index g5) (index g6) (index g7)\n(index h1) (index h2)\n(index i1)\n(init (cell a1 red))\n(init (cell b1 red))\n(init (cell b2 red))\n(init (cell h1 teal))\n(init (cell h2 teal))\n(init (cell i1 teal))\n(init (control red))\n(init (step 1))\n(<= (next (cell ?e ?player))\n    (does ?player (move ?b ?e)))\n(<= (next (cell ?x ?z))\n    (true (cell ?x ?z))\n    (not (affected ?x)))\n(<= (affected ?x)\n    (does ?player (move ?x ?z)))\n(<= (next (control teal))\n    (true (control red)))\n(<= (next (control red))\n    (true (control teal)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (succ ?x ?y))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(<= (legal ?player (move ?b ?e))\n    (true (control ?player))\n    (movable ?player ?b ?e))\n(<= (legal ?player noop)\n    (role ?player))\n(<= (occupied ?c)\n    (true (cell ?c ?p)))\n(<= (empty ?c)\n    (index ?c)\n    (not (occupied ?c)))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?e)\n    (empty ?e))\n(<= (car red ?b ?e)\n    (carred ?b ?e))\n(<= (car teal ?b ?e)\n    (carred ?e ?b))\n(<= (cdr red ?b ?e)\n    (cdrred ?b ?e))\n(<= (cdr teal ?b ?e)\n    (cdrred ?e ?b))\n(carred a1 b1)\n(carred b1 c3)\n(carred b2 c4)\n(carred c3 d2)\n(carred c4 d3)\n(carred c5 d4)\n(carred d2 e1)\n(carred d3 e2)\n(carred d4 e3)\n(carred d5 e4)\n(carred e2 f2)\n(carred e3 f3)\n(carred e4 f4)\n(carred e5 f5)\n(carred f3 g3)\n(carred f4 g4)\n(carred f5 g5)\n(carred g4 h1)\n(carred g5 h2)\n(carred h2 i1)\n(cdrred a1 b2)\n(cdrred b1 c4)\n(cdrred b2 c5)\n(cdrred c3 d3)\n(cdrred c4 d4)\n(cdrred c5 d5)\n(cdrred d2 e2)\n(cdrred d3 e3)\n(cdrred d4 e4)\n(cdrred d5 e5)\n(cdrred e1 f2)\n(cdrred e2 f3)\n(cdrred e3 f4)\n(cdrred e4 f5)\n(cdrred f2 g3)\n(cdrred f3 g4)\n(cdrred f4 g5)\n(cdrred g3 h1)\n(cdrred g4 h2)\n(cdrred h1 i1)\n(<= (goal ?player ?payoff)\n    (stones ?player ?payoff))\n(toCount red h1 h2 i1)\n(toCount teal a1 b1 b2)\n(<= (stones ?player 100)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 0)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= terminal\n    (true (step 40)))\n(<= terminal\n    (stones ?player 100))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 10-by-10 grid indexed from 1 to 10 both horizontally and vertically, establishing a coordinate system where each cell is identified by an (x, y) pair with x and y ranging from 1 to 10. There are two players, designated as white and black, who alternate turns beginning with white. Initially, each player controls four pieces positioned at specific coordinates: white pieces start at (4,1), (7,1), (1,4), and (10,4), and black pieces start at (1,7), (10,7), (4,10), and (7,10). On a player's turn, if they are in control, they may choose to either perform a move action or do nothing if it is not their turn, the only legal action available is a \"noop.\" A move action consists of selecting one of the player's pieces located at (x1, y1), moving it along a queen's move (a combination of rook and bishop moves—horizontal, vertical, or diagonal) to an empty cell (x2, y2), and then optionally shooting an arrow from the piece's new position (x2, y2) along another queen's move to an empty cell (x3, y3). The arrow cannot be shot to the original position of the piece before moving, but shooting the arrow back to the piece’s original cell is not allowed either. Moves must be along valid paths with no occupied cells in between, except for the starting and ending positions as specified, ensuring no pieces or arrows block the movement or shooting paths. The board cells can be empty, occupied by white or black pieces, or occupied by an arrow, and no two pieces or arrows can occupy the same cell simultaneously. After a move, the piece's location is updated to the new cell, and an arrow is placed on the targeted cell, which becomes permanently blocked. Control then passes to the opposing player. The game ends when the player to move has no legal moves available, meaning none of their pieces can move to any empty cell along a queen's move. At that point, the player who still has legal moves is declared the winner with a score of 100, while the other player scores 0. If neither player can move, the game is also terminal. The legal move checks and movement validations ensure that all moves must stay within the board boundaries, respect occupancy constraints, and maintain the piece and arrow positions consistent with the rules, thus creating a strategic contest of mobility and obstruction.",
    "output": "(role white)\n(role black)\n(init (location  4  1 white))\n(init (location  7  1 white))\n(init (location  1  4 white))\n(init (location 10  4 white))\n(init (location  1  7 black))\n(init (location 10  7 black))\n(init (location  4 10 black))\n(init (location  7 10 black))\n(init (control white))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n    (true (control ?player))\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?x2 ?y2)\n    (emptyCell ?x2 ?y2)\n    (queenMoveIgnoring ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)\n    (emptyCell ?x3 ?y3))\n(<= (legal ?player (play ?x1 ?y1 ?x2 ?y2 ?x1 ?y1))\n    (true (control ?player))\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?x2 ?y2)\n    (emptyCell ?x2 ?y2))\n(<= (next (location ?x ?y ?state))\n    (true (location ?x ?y ?state))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3))\n    (distinctCell ?x ?y ?x1 ?y1))\n(<= (next (location ?x2 ?y2 ?player))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)))\n(<= (next (location ?x3 ?y3 arrow))\n    (does ?player (play ?x1 ?y1 ?x2 ?y2 ?x3 ?y3)))\n(<= (next (control black))\n    (true (control white)))\n(<= (next (control white))\n    (true (control black)))\n(<= terminal\n    (not (legalMove white)))\n(<= terminal\n    (not (legalMove black)))\n(<= (goal white 100)\n    (not (legalMove black)))\n(<= (goal white 0)\n    (legalMove black))\n(<= (goal black 100)\n    (not (legalMove white)))\n(<= (goal black 0)\n    (legalMove white))\n(<= (legalMove ?player)\n    (true (location ?x1 ?y1 ?player))\n    (queenMove ?x1 ?y1 ?xAny ?yAny)\n    (emptyCell ?xAny ?yAny))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (rookMove ?x1 ?y1 ?x2 ?y2))\n(<= (queenMove ?x1 ?y1 ?x2 ?y2)\n    (bishopMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (horizontalMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (horizontalMove ?x2 ?y2 ?x1 ?y1))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (verticalMove ?x1 ?y1 ?x2 ?y2))\n(<= (rookMove ?x1 ?y1 ?x2 ?y2)\n    (verticalMove ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMove ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMove ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMove ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMove ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMove ?x2 ?y2 ?x1 ?y1))\n(<= (horizontalMove ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (emptyCell ?x2 ?y)\n    (horizontalMove ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMove ?x1 ?y ?x2 ?y)\n    (++ ?x1 ?x2)\n    (index ?y))\n(<= (verticalMove ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (emptyCell ?x ?y2)\n    (verticalMove ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMove ?x ?y1 ?x ?y2)\n    (++ ?y1 ?y2)\n    (index ?x))\n(<= (diagonalUpMove ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (emptyCell ?x2 ?y2)\n    (diagonalUpMove ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMove ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2))\n(<= (diagonalDownMove ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (emptyCell ?x2 ?y2)\n    (diagonalDownMove ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMove ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1))\n(<= (queenMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (queenMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (rookMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2))\n(<= (bishopMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x1 ?y1))\n(<= (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (emptyCell ?x2 ?y)\n    (horizontalMoveIgnoring ?xIg ?yIg ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMoveIgnoring ?x2 ?y ?x1 ?y ?x3 ?y)\n    (++ ?x1 ?x2)\n    (horizontalMoveIgnoring ?x2 ?y ?x2 ?y ?x3 ?y)\n    (index ?y))\n(<= (horizontalMoveIgnoring ?xIg ?yIg ?x1 ?y ?x2 ?y)\n    (++ ?x1 ?x2)\n    (index ?y)\n    (cell ?xIg ?yIg))\n(<= (verticalMoveIgnoring ?xIg ?yIg ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (emptyCell ?x ?y2)\n    (verticalMoveIgnoring ?xIg ?yIg ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMoveIgnoring ?x ?y2 ?x ?y1 ?x ?y3)\n    (++ ?y1 ?y2)\n    (verticalMoveIgnoring ?x ?y2 ?x ?y2 ?x ?y3)\n    (index ?x))\n(<= (verticalMoveIgnoring ?xIg ?yIg ?x ?y1 ?x ?y2)\n    (++ ?y1 ?y2)\n    (index ?x)\n    (cell ?xIg ?yIg))\n(<= (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (emptyCell ?x2 ?y2)\n    (diagonalUpMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMoveIgnoring ?x2 ?y2 ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (diagonalUpMoveIgnoring ?x2 ?y2 ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalUpMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y1 ?y2)\n    (cell ?xIg ?yIg))\n(<= (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (emptyCell ?x2 ?y2)\n    (diagonalDownMoveIgnoring ?xIg ?yIg ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMoveIgnoring ?x2 ?y2 ?x1 ?y1 ?x3 ?y3)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (diagonalDownMoveIgnoring ?x2 ?y2 ?x2 ?y2 ?x3 ?y3))\n(<= (diagonalDownMoveIgnoring ?xIg ?yIg ?x1 ?y1 ?x2 ?y2)\n    (++ ?x1 ?x2)\n    (++ ?y2 ?y1)\n    (cell ?xIg ?yIg))\n(<= (emptyCell ?x ?y)\n    (cell ?x ?y)\n    (not (true (location ?x ?y white)))\n    (not (true (location ?x ?y black)))\n\t(not (true (location ?x ?y arrow))))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8) (index 9) (index 10)\n(++ 1 2)  (++ 2 3)  (++ 3 4)  (++ 4 5)  (++ 5 6)  (++ 6 7)  (++ 7 8)  (++ 8 9)  (++ 9 10)\n(<= (sameLine ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(index ?y1)\n\t(index ?y2))\n(<= (sameLine ?x1 ?y ?x2 ?y)\n\t(index ?x1)\n\t(index ?x2)\n\t(index ?y))\n(<= (sameLine ?x1 ?y1 ?x2 ?y2)\n\t(diagPos ?x1 ?y1 ?x2 ?y2))\n(<= (sameLine ?x1 ?y1 ?x2 ?y2)\n\t(diagPos ?x2 ?y2 ?x1 ?y1))\n(<= (sameLine ?x1 ?y1 ?x2 ?y2)\n\t(diagNeg ?x1 ?y1 ?x2 ?y2))\n(<= (sameLine ?x1 ?y1 ?x2 ?y2)\n\t(diagNeg ?x2 ?y2 ?x1 ?y1))\n(<= (diagPos ?x1 ?y1 ?x2 ?y2)\n\t(++ ?x1 ?x2)\n\t(++ ?y1 ?y2))\n(<= (diagPos ?x1 ?y1 ?x3 ?y3)\n\t(diagPos ?x1 ?y1 ?x2 ?y2)\n\t(++ ?x2 ?x3)\n\t(++ ?y2 ?y3))\n(<= (diagNeg ?x1 ?y1 ?x2 ?y2)\n\t(++ ?x1 ?x2)\n\t(++ ?y2 ?y1))\n(<= (diagNeg ?x1 ?y1 ?x3 ?y3)\n\t(diagNeg ?x1 ?y1 ?x2 ?y2)\n\t(++ ?x2 ?x3)\n\t(++ ?y3 ?y2))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on an 8-by-8 grid with coordinates ranging from 1 to 8 along both the x- and y-axes, where each cell is identified by an (x, y) pair. The board's squares are distinguished by parity: squares where both coordinates are odd or both even are considered even squares, which are the locations where pieces are placed and moved. There are two players, Black and Red, who take alternating turns starting with Black. The initial setup places twelve black pawns on the bottom three rows in a staggered pattern on even squares and twelve red pawns on the top three rows in a similar arrangement. Each pawn is owned by its respective player. The control alternates between Black and Red each turn, with a step count incrementing from 1 upwards each turn. On a player's turn, if they have a legal jump available, they must perform a jump; if no jump is available, they may make a valid move. If the player is not in control, their only legal action is to do nothing (noop). A move action consists of moving one of the player's pawns diagonally forward by one square to an empty square; Black pawns move diagonally upwards (increasing both x and y by 1 or decreasing x by 1 while increasing y by 1), and Red pawns move diagonally downwards (increasing or decreasing x by 1 while decreasing y by 1). A jump action involves leaping over an opponent's pawn diagonally forward by two squares, landing on an empty square immediately beyond the jumped pawn, which must be directly between the start and end squares. Black pawns jump over Red pawns diagonally forward, and Red pawns jump over Black pawns similarly but moving in the opposite vertical direction. After a jump, the player's capture count increases by one. The game enforces that a player cannot move or jump onto occupied squares, and all moves must remain within the bounds of the 8-by-8 board. The state updates each turn by moving the chosen pawn to its new location, removing any captured pieces from the board, updating the capture counts, switching control to the opponent, and incrementing the step counter. The game ends (reaches a terminal state) if either player loses all their pawns, or if the player in control has no legal moves or jumps available, or if the step count reaches 100. Scoring is based on the number of pawns captured by each player, with a predefined score mapping that assigns increasing point values to higher capture counts, culminating in a maximum score of 100 for capturing all twelve opponent pawns. The winner is determined by the player with the higher capture count at the end of the game.",
    "output": "(role black)\n(role red)\n(init (location 1 1 blackPawn))\n(init (location 3 1 blackPawn))\n(init (location 5 1 blackPawn))\n(init (location 7 1 blackPawn))\n(init (location 2 2 blackPawn))\n(init (location 4 2 blackPawn))\n(init (location 6 2 blackPawn))\n(init (location 8 2 blackPawn))\n(init (location 1 3 blackPawn))\n(init (location 3 3 blackPawn))\n(init (location 5 3 blackPawn))\n(init (location 7 3 blackPawn))\n(init (location 2 6 redPawn))\n(init (location 4 6 redPawn))\n(init (location 6 6 redPawn))\n(init (location 8 6 redPawn))\n(init (location 1 7 redPawn))\n(init (location 3 7 redPawn))\n(init (location 5 7 redPawn))\n(init (location 7 7 redPawn))\n(init (location 2 8 redPawn))\n(init (location 4 8 redPawn))\n(init (location 6 8 redPawn))\n(init (location 8 8 redPawn))\n(init (captureCount black 0))\n(init (captureCount red 0))\n(init (control black))\n(init (step 1))\n(<= (legal ?player (move ?x1 ?y1 ?x2 ?y2))\n    (true (control ?player))\n\t(not (hasJump ?player))\n\t(cellOccupiedBy ?x1 ?y1 ?player)\n\t(validMove ?x1 ?y1 ?x2 ?y2)\n\t(cellEmpty ?x2 ?y2))\n(<= (legal ?player (jump ?x1 ?y1 ?x2 ?y2))\n    (true (control ?player))\n\t(cellOccupiedBy ?x1 ?y1 ?player)\n    (validJump ?x1 ?y1 ?x2 ?y2)\n\t(cellEmpty ?x2 ?y2))\n(<= (legal ?player noop)\n    (role ?player)\n\t(not (true (control ?player))))\n(<= (next (location ?x2 ?y2 ?piece))\n    (does black (move ?x1 ?y1 ?x2 ?y2))\n\t(true (location ?x1 ?y1 ?piece)))\n(<= (next (location ?x2 ?y2 ?piece))\n    (does black (jump ?x1 ?y1 ?x2 ?y2))\n\t(true (location ?x1 ?y1 ?piece)))\n(<= (next (location ?x2 ?y2 ?piece))\n    (does red (move ?x1 ?y1 ?x2 ?y2))\n\t(true (location ?x1 ?y1 ?piece)))\n(<= (next (location ?x2 ?y2 ?piece))\n    (does red (jump ?x1 ?y1 ?x2 ?y2))\n\t(true (location ?x1 ?y1 ?piece)))\n(<= (next (location ?x ?y ?piece))\n    (true (location ?x ?y ?piece))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(distinctCell ?x ?y ?x1 ?y1)\n\t(distinctCell ?x ?y ?x2 ?y2))\n(<= (next (location ?x ?y ?piece))\n    (true (location ?x ?y ?piece))\n\t(does ?player (jump ?x1 ?y1 ?x2 ?y2))\n\t(distinctCell ?x ?y ?x1 ?y1)\n\t(distinctCell ?x ?y ?x2 ?y2)\n\t(not (cellBetween ?x1 ?y1 ?x2 ?y2 ?x ?y)))\n(<= (next (captureCount ?player ?count))\n    (true (captureCount ?player ?count))\n    (not (true (control ?player))))\n(<= (next (captureCount ?player ?count))\n    (true (captureCount ?player ?count))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (captureCount ?player ?count2))\n    (true (captureCount ?player ?count1))\n    (does ?player (jump ?x1 ?y1 ?x2 ?y2))\n    (countPlus ?count1 ?count2))\n(<= (next (control black))\n    (true (control red)))\n(<= (next (control red))\n    (true (control black)))\n(<= (next (step ?tNext))\n    (true (step ?tCurrent))\n    (pp ?tCurrent ?tNext))\n(<= terminal\n    (role ?player)\n    (not (hasPiece ?player)))\n(<= terminal\n    (true (control ?player))\n    (not (hasMove ?player))\n    (not (hasJump ?player)))\n(<= terminal\n    (true (step 100)))\n(<= (goal ?player ?goal)\n    (true (captureCount ?player ?count))\n    (scoreMap ?count ?goal))\n(<= (validMove ?x1 ?y1 ?x2 ?y2)\n    (true (location ?x1 ?y1 blackPawn))\n    (blackPawnMove ?x1 ?y1 ?x2 ?y2))\n(<= (validMove ?x1 ?y1 ?x2 ?y2)\n    (true (location ?x1 ?y1 redPawn))\n    (redPawnMove ?x1 ?y1 ?x2 ?y2))\n(<= (validJump ?x1 ?y1 ?x2 ?y2)\n    (true (location ?x1 ?y1 blackPawn))\n    (blackPawnJump ?x1 ?y1 ?x2 ?y2))\n(<= (validJump ?x1 ?y1 ?x2 ?y2)\n    (true (location ?x1 ?y1 redPawn))\n    (redPawnJump ?x1 ?y1 ?x2 ?y2))\n(<= (blackPawnMove ?x1 ?y1 ?x2 ?y2)\n    (plusX 1 ?x1 ?x2)\n    (plusY 1 ?y1 ?y2))\n(<= (blackPawnMove ?x1 ?y1 ?x2 ?y2)\n    (plusX 1 ?x2 ?x1)\n    (plusY 1 ?y1 ?y2))\n(<= (redPawnMove ?x1 ?y1 ?x2 ?y2)\n    (plusX 1 ?x1 ?x2)\n    (plusY 1 ?y2 ?y1))\n(<= (redPawnMove ?x1 ?y1 ?x2 ?y2)\n    (plusX 1 ?x2 ?x1)\n    (plusY 1 ?y2 ?y1))\n(<= (blackPawnJump ?x1 ?y1 ?x3 ?y3)\n    (plusX 1 ?x1 ?x2)\n    (plusX 1 ?x2 ?x3)\n    (plusY 1 ?y1 ?y2)\n    (plusY 1 ?y2 ?y3)\n    (cellOccupiedBy ?x2 ?y2 red))\n(<= (blackPawnJump ?x1 ?y1 ?x3 ?y3)\n    (plusX 1 ?x3 ?x2)\n    (plusX 1 ?x2 ?x1)\n    (plusY 1 ?y1 ?y2)\n    (plusY 1 ?y2 ?y3)\n    (cellOccupiedBy ?x2 ?y2 red))\n(<= (redPawnJump ?x1 ?y1 ?x3 ?y3)\n    (plusX 1 ?x1 ?x2)\n    (plusX 1 ?x2 ?x3)\n    (plusY 1 ?y3 ?y2)\n    (plusY 1 ?y2 ?y1)\n    (cellOccupiedBy ?x2 ?y2 black))\n(<= (redPawnJump ?x1 ?y1 ?x3 ?y3)\n    (plusX 1 ?x3 ?x2)\n    (plusX 1 ?x2 ?x1)\n    (plusY 1 ?y3 ?y2)\n    (plusY 1 ?y2 ?y1)\n    (cellOccupiedBy ?x2 ?y2 black))\n(<= (hasPiece ?player)\n    (true (location ?x ?y ?piece))\n    (owns ?piece ?player))\n(<= (hasJump ?player)\n\t(cellOccupiedBy ?x1 ?y1 ?player)\n    (validJump ?x1 ?y1 ?x2 ?y2)\n\t(cellEmpty ?x2 ?y2))\n(<= (hasMove ?player)\n\t(cellOccupiedBy ?x1 ?y1 ?player)\n\t(validMove ?x1 ?y1 ?x2 ?y2)\n\t(cellEmpty ?x2 ?y2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= (cellBetween ?x1 ?y1 ?x3 ?y3 ?x2 ?y2)\n    (between ?x1 ?x2 ?x3)\n    (between ?y1 ?y2 ?y3))\n(<= (cellOccupiedBy ?x ?y ?player)\n    (true (location ?x ?y ?piece))\n    (owns ?piece ?player))\n(<= (cellEmpty ?x ?y)\n    (cell ?x ?y)\n    (not (cellOccupiedBy ?x ?y black))\n    (not (cellOccupiedBy ?x ?y red)))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(plusX 1 1 2) (plusX 1 2 3) (plusX 1 3 4) (plusX 1 4 5) (plusX 1 5 6) (plusX 1 6 7) (plusX 1 7 8)\n(plusY 1 1 2) (plusY 1 2 3) (plusY 1 3 4) (plusY 1 4 5) (plusY 1 5 6) (plusY 1 6 7) (plusY 1 7 8) (plusY 1 8 1)\n(between 1 2 3) (between 2 3 4) (between 3 4 5) (between 4 5 6) (between 5 6 7) (between 6 7 8) (between 7 8 1) (between 8 1 2)\n(between 3 2 1) (between 4 3 2) (between 5 4 3) (between 6 5 4) (between 7 6 5) (between 8 7 6) (between 1 8 7) (between 2 1 8)\n(countPlus  0  1) (countPlus  1  2) (countPlus  2  3) (countPlus  3  4)\n(countPlus  4  5) (countPlus  5  6) (countPlus  6  7) (countPlus  7  8)\n(countPlus  8  9) (countPlus  9 10) (countPlus 10 11) (countPlus 11 12)\n           (pp  1  2) (pp  2  3) (pp  3  4) (pp  4  5) (pp  5  6) (pp  6  7) (pp  7  8) (pp  8  9) (pp  9  10)\n(pp 10 11) (pp 11 12) (pp 12 13) (pp 13 14) (pp 14 15) (pp 15 16) (pp 16 17) (pp 17 18) (pp 18 19) (pp 19  20)\n(pp 20 21) (pp 21 22) (pp 22 23) (pp 23 24) (pp 24 25) (pp 25 26) (pp 26 27) (pp 27 28) (pp 28 29) (pp 29  30)\n(pp 30 31) (pp 31 32) (pp 32 33) (pp 33 34) (pp 34 35) (pp 35 36) (pp 36 37) (pp 37 38) (pp 38 39) (pp 39  40)\n(pp 40 41) (pp 41 42) (pp 42 43) (pp 43 44) (pp 44 45) (pp 45 46) (pp 46 47) (pp 47 48) (pp 48 49) (pp 49  50)\n(pp 50 51) (pp 51 52) (pp 52 53) (pp 53 54) (pp 54 55) (pp 55 56) (pp 56 57) (pp 57 58) (pp 58 59) (pp 59  60)\n(pp 60 61) (pp 61 62) (pp 62 63) (pp 63 64) (pp 64 65) (pp 65 66) (pp 66 67) (pp 67 68) (pp 68 69) (pp 69  70)\n(pp 70 71) (pp 71 72) (pp 72 73) (pp 73 74) (pp 74 75) (pp 75 76) (pp 76 77) (pp 77 78) (pp 78 79) (pp 79  80)\n(pp 80 81) (pp 81 82) (pp 82 83) (pp 83 84) (pp 84 85) (pp 85 86) (pp 86 87) (pp 87 88) (pp 88 89) (pp 89  90)\n(pp 90 91) (pp 91 92) (pp 92 93) (pp 93 94) (pp 94 95) (pp 95 96) (pp 96 97) (pp 97 98) (pp 98 99) (pp 99 100)\n(scoreMap  0    0)\n(scoreMap  1    8)\n(scoreMap  2   16)\n(scoreMap  3   24)\n(scoreMap  4   32)\n(scoreMap  5   40)\n(scoreMap  6   48)\n(scoreMap  7   56)\n(scoreMap  8   64)\n(scoreMap  9   72)\n(scoreMap 10   80)\n(scoreMap 11   90)\n(scoreMap 12  100)\n(owns blackPawn black)\n(owns redPawn red)\n(odd 1) (even 2) (odd 3) (even 4) (odd 5) (even 6) (odd 7) (even 8)\n(<= (evenSquare ?x ?y)\n    (odd ?x)\n    (odd ?y))\n(<= (evenSquare ?x ?y)\n    (even ?x)\n    (even ?y))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a three-dimensional board consisting of multiple smaller 3x3 grids arranged in a 3x3 layout, effectively creating a 3x3x3x3 coordinate system where each cell is identified by four coordinates: two for the larger grid position and two for the cell within that grid. There are two players, named xplayer and oplayer, who alternate turns, with xplayer starting the game. Initially, all cells across the entire multi-grid board are empty, indicated by the state 'b' for blank. During a turn, the player in control must make a move by marking an empty cell with their respective symbol ('x' for xplayer, 'o' for oplayer) within a designated smaller grid specified by the current \"board to play.\" If the designated smaller grid still has empty cells, the active player must place their mark within that grid; if not, the player may choose any empty cell on the larger board. Players take turns marking cells following this constraint, and if it is not a player's turn, they must perform a noop (no operation) action, effectively passing control. Each action consists of the role (either xplayer or oplayer) and a move command specifying the larger grid coordinates and the cell coordinates within that grid where the mark is to be placed. A move is legal only if it is the player's turn, the cell to be marked is empty, and the move complies with the rules governing which smaller grid may be played on. Upon marking a cell, the state updates to reflect the new mark, and the \"board to play\" for the next player is set to the position of the cell just marked within the current grid. The game enforces implicit constraints such as the board boundaries: all coordinates must be within the 1 to 3 range, no cell can be marked more than once, and players must respect the designated smaller grid to play in unless it is fully occupied. The game ends when a player completes a line of three of their marks in any smaller grid horizontally, vertically, or diagonally, or when no empty cells remain on the entire board, indicating a draw. Victory is awarded to a player who forms such a line, granting them a score of 100, while the opponent receives zero. If the board is full without any completed lines, both players receive a score of 50. Throughout the game, the control alternates strictly between players, and no move can occur out of turn. This combination of nested boards and constrained move selection creates a complex strategic environment where players must consider both their current move and the implications for their opponent's next allowed moves.",
    "output": "(role xplayer)\n(role oplayer)\n(init (cell 1 1 1 1 b))\n(init (cell 1 1 1 2 b))\n(init (cell 1 1 1 3 b))\n(init (cell 1 1 2 1 b))\n(init (cell 1 1 2 2 b))\n(init (cell 1 1 2 3 b))\n(init (cell 1 1 3 1 b))\n(init (cell 1 1 3 2 b))\n(init (cell 1 1 3 3 b))\n(init (cell 1 2 1 1 b))\n(init (cell 1 2 1 2 b))\n(init (cell 1 2 1 3 b))\n(init (cell 1 2 2 1 b))\n(init (cell 1 2 2 2 b))\n(init (cell 1 2 2 3 b))\n(init (cell 1 2 3 1 b))\n(init (cell 1 2 3 2 b))\n(init (cell 1 2 3 3 b))\n(init (cell 1 3 1 1 b))\n(init (cell 1 3 1 2 b))\n(init (cell 1 3 1 3 b))\n(init (cell 1 3 2 1 b))\n(init (cell 1 3 2 2 b))\n(init (cell 1 3 2 3 b))\n(init (cell 1 3 3 1 b))\n(init (cell 1 3 3 2 b))\n(init (cell 1 3 3 3 b))\n(init (cell 2 1 1 1 b))\n(init (cell 2 1 1 2 b))\n(init (cell 2 1 1 3 b))\n(init (cell 2 1 2 1 b))\n(init (cell 2 1 2 2 b))\n(init (cell 2 1 2 3 b))\n(init (cell 2 1 3 1 b))\n(init (cell 2 1 3 2 b))\n(init (cell 2 1 3 3 b))\n(init (cell 2 2 1 1 b))\n(init (cell 2 2 1 2 b))\n(init (cell 2 2 1 3 b))\n(init (cell 2 2 2 1 b))\n(init (cell 2 2 2 2 b))\n(init (cell 2 2 2 3 b))\n(init (cell 2 2 3 1 b))\n(init (cell 2 2 3 2 b))\n(init (cell 2 2 3 3 b))\n(init (cell 2 3 1 1 b))\n(init (cell 2 3 1 2 b))\n(init (cell 2 3 1 3 b))\n(init (cell 2 3 2 1 b))\n(init (cell 2 3 2 2 b))\n(init (cell 2 3 2 3 b))\n(init (cell 2 3 3 1 b))\n(init (cell 2 3 3 2 b))\n(init (cell 2 3 3 3 b))\n(init (cell 3 1 1 1 b))\n(init (cell 3 1 1 2 b))\n(init (cell 3 1 1 3 b))\n(init (cell 3 1 2 1 b))\n(init (cell 3 1 2 2 b))\n(init (cell 3 1 2 3 b))\n(init (cell 3 1 3 1 b))\n(init (cell 3 1 3 2 b))\n(init (cell 3 1 3 3 b))\n(init (cell 3 2 1 1 b))\n(init (cell 3 2 1 2 b))\n(init (cell 3 2 1 3 b))\n(init (cell 3 2 2 1 b))\n(init (cell 3 2 2 2 b))\n(init (cell 3 2 2 3 b))\n(init (cell 3 2 3 1 b))\n(init (cell 3 2 3 2 b))\n(init (cell 3 2 3 3 b))\n(init (cell 3 3 1 1 b))\n(init (cell 3 3 1 2 b))\n(init (cell 3 3 1 3 b))\n(init (cell 3 3 2 1 b))\n(init (cell 3 3 2 2 b))\n(init (cell 3 3 2 3 b))\n(init (cell 3 3 3 1 b))\n(init (cell 3 3 3 2 b))\n(init (cell 3 3 3 3 b))\n(init (boardtoplay any any))\n(init (control xplayer))\n(<= (next (cell ?bx ?by ?m ?n x))\n(does xplayer (mark ?bx ?by ?m ?n))\n(true (cell ?bx ?by ?m ?n b)))\n(<= (next (cell ?bx ?by ?m ?n o))\n(does oplayer (mark ?bx ?by ?m ?n))\n(true (cell ?bx ?by ?m ?n b)))\n(<= (next (cell ?bx ?by ?m ?n ?w))\n(true (cell ?bx ?by ?m ?n ?w))\n(distinct ?w b))\n(<= (next (cell ?bx ?by ?m ?n b))\n(does ?w (mark ?bx1 ?by1 ?j ?k))\n(true (cell ?bx ?by ?m ?n b))\n(or (distinct ?m ?j) (distinct ?n ?k) (distinct ?bx ?bx1) (distinct ?by ?by1)))\n(<= (next (boardtoplay ?bx ?by))\n(does ?w (mark ?bx1 ?by1 ?bx ?by)))\n(<= (next (control xplayer))\n(true (control oplayer)))\n(<= (next (control oplayer))\n(true (control xplayer)))\n(<= (row ?bx ?by ?m ?x)\n(true (cell ?bx ?by ?m 1 ?x))\n(true (cell ?bx ?by ?m 2 ?x))\n(true (cell ?bx ?by ?m 3 ?x)))\n(<= (column ?bx ?by ?n ?x)\n(true (cell ?bx ?by 1 ?n ?x))\n(true (cell ?bx ?by 2 ?n ?x))\n(true (cell ?bx ?by 3 ?n ?x)))\n(<= (diagonal ?bx ?by ?x)\n(true (cell ?bx ?by 1 1 ?x))\n(true (cell ?bx ?by 2 2 ?x))\n(true (cell ?bx ?by 3 3 ?x)))\n(<= (diagonal ?bx ?by ?x)\n(true (cell ?bx ?by 1 3 ?x))\n(true (cell ?bx ?by 2 2 ?x))\n(true (cell ?bx ?by 3 1 ?x)))\n(<= (line ?x) (row ?bx ?by ?m ?x))\n(<= (line ?x) (column ?bx ?by ?m ?x))\n(<= (line ?x) (diagonal ?bx ?by ?x))\n(<= open\n(true (cell ?bx ?by ?m ?n b)))\n(<= (openboard ?bx ?by)\n(true (cell ?bx ?by ?m ?n b)))\n(<= (legal ?w (mark ?bx ?by ?x ?y))\n(true (control ?w))\n(true (boardtoplay ?bx ?by))\n(true (cell ?bx ?by ?x ?y b)))\n(<= (legal ?w (mark ?bx1 ?by1 ?x ?y))\n(true (control ?w))\n(true (boardtoplay ?bx ?by))\n(not (openboard ?bx ?by))\n(true (cell ?bx1 ?by1 ?x ?y b)))\n(<= (legal xplayer noop)\n(true (control oplayer)))\n(<= (legal oplayer noop)\n(true (control xplayer)))\n(<= (goal xplayer 100)\n(line x))\n(<= (goal xplayer 50)\n(not (line x))\n(not (line o))\n(not open))\n(<= (goal xplayer 0)\n(line o))\n(<= (goal oplayer 100)\n(line o))\n(<= (goal oplayer 50)\n(not (line x))\n(not (line o))\n(not open))\n(<= (goal oplayer 0)\n(line x))\n(<= terminal\n(line x))\n(<= terminal\n(line o))\n(<= terminal\n(not open))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 7x7 board defined by coordinates from 1 to 7 along both the x and y axes, with the edges at coordinates 1 and 7 considered boundaries and thus excluded from valid positions for pieces or moves, effectively creating a 5x5 playable area inside. There are four players named red, yellow, blue, and green who take turns in a fixed rotational order starting with red, then yellow, followed by blue, green, and back to red. Initially, each player controls a piece placed on the board at specific starting positions: red at (1,4), yellow at (4,1), blue at (7,4), and green at (4,7). The initial turn count is set to 1, and each player begins with a capture count of zero. On a player's turn, if they have no legal moves available, they may perform a no-operation action (noop); otherwise, they must make a legal move. The legal moves for a player involve moving one of their pieces from a current cell to a target cell according to specific movement patterns: the piece can move orthogonally or diagonally to an adjacent cell occupied by an opponent's piece, or it can move in an \"ell\"-shaped pattern (similar to a knight's move in chess, moving two spaces in one direction and one in the perpendicular direction) to an unoccupied cell. Moves must stay within the playable board area. A move is only legal if the starting cell contains the player's piece, the destination cell is either occupied by a different player's piece (for orthogonal and diagonal moves) or empty (for ell-shaped moves), and the movement pattern adheres to the orthogonal, diagonal, or ell criteria. After a move, the piece is relocated to the new cell, capturing any opponent's piece present there, and the capture count for the moving player increases accordingly. The game keeps track of which cells pieces came from and moved to during the current turn to manage state transitions properly. Control passes to the next player in the rotation after each move or noop, and the turn counter advances sequentially. The game ends after the 40th step, signaling termination. Scoring is based on the number of captures each player has made, with a predefined mapping from capture counts to goal points, where each capture increases the player's score in increments of 10 points up to a maximum of 100 points for ten captures. Players cannot move onto cells outside the defined board boundaries or onto cells occupied by their own pieces. The gameplay involves strategic movement and capturing of opponent pieces following the allowed movement rules until the fixed number of turns elapses, at which point players' scores determine their success.",
    "output": "(role red)\n(role yellow)\n(role blue)\n(role green)\n(init (control red))\n(init (cell 1 4 red))\n(init (cell 4 1 yellow))\n(init (cell 7 4 blue))\n(init (cell 4 7 green))\n(init (step 1))\n(init (capture red 0))\n(init (capture yellow 0))\n(init (capture blue 0))\n(init (capture green 0))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasLegalMove ?player)))\n(<= (legal ?player noop)\n\t  (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player ?move)\n\t  (legal2 ?player ?move))\n(<= (hasLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?player))\n(orthogonal ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(true (cell ?x2 ?y2 ?player2))\n(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?player))\n(diagonal ?x1 ?y1 ?x2 ?y2)\n(onboard ?x2 ?y2)\n(true (cell ?x2 ?y2 ?player2))\n(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n(true (control ?player))\n(true (cell ?x1 ?y1 ?player))\n(ell ?x1 ?y1 ?x2 ?y2)\n(opencell ?x2 ?y2))\n(<= (next (control ?p2))\n(true (control ?p1))\n(rotation ?p1 ?p2))\n(<= (next (cell ?x2 ?y2 ?player))\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?piece))\n(true (cell ?x ?y ?piece))\n(not (camefrom ?x ?y))\n(not (wentto ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n(spawns ?x ?y ?player))\n(<= (next (capture ?player ?count))\n(true (capture ?player ?count))\n(not (captured ?player)))\n(<= (next (capture ?player ?count2))\n(true (capture ?player ?count1))\n(captured ?player)\n(captureplus ?count1 ?count2))\n(<= (next (step ?t2))\n(true (step ?t1))\n(stepcount ?t1 ?t2))\n(<= terminal\n(true (step 41)))\n(<= (goal ?player ?goal)\n(true (capture ?player ?count))\n(scoremap ?count ?goal))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n(plus 1 ?x1 ?x2)\n(index ?y))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n(plus 1 ?x2 ?x1)\n(index ?y))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n(index ?x)\n(plus 1 ?y1 ?y2))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n(index ?x)\n(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x1 ?x2)\n(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x1 ?x2)\n(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x2 ?x1)\n(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x2 ?x1)\n(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 2 ?x1 ?x2)\n(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 2 ?x1 ?x2)\n(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 2 ?x2 ?x1)\n(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 2 ?x2 ?x1)\n(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x1 ?x2)\n(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x1 ?x2)\n(plus 2 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x2 ?x1)\n(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n(plus 1 ?x2 ?x1)\n(plus 2 ?y2 ?y1))\n(<= (opencell ?x ?y)\n(onboard ?x ?y)\n(not (true (cell ?x ?y red)))\n(not (true (cell ?x ?y yellow)))\n(not (true (cell ?x ?y blue)))\n(not (true (cell ?x ?y green))))\n(<= (onboard ?x ?y)\n(index ?x)\n(index ?y)\n(distinct ?x 1)\n(distinct ?x 7)\n(distinct ?y 1)\n(distinct ?y 7))\n(<= (camefrom ?x1 ?y1)\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (wentto ?x2 ?y2)\n(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (captured ?player)\n(true (control ?player))\n(wentto ?x ?y)\n(true (cell ?x ?y ?any)))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(plus 1 1 2)\n(plus 1 2 3)\n(plus 1 3 4)\n(plus 1 4 5)\n(plus 1 5 6)\n(plus 1 6 7)\n(plus 2 1 3)\n(plus 2 2 4)\n(plus 2 3 5)\n(plus 2 4 6)\n(plus 2 5 7)\n(rotation red yellow)\n(rotation yellow blue)\n(rotation blue green)\n(rotation green red)\n(spawns 1 4 red)\n(spawns 4 1 yellow)\n(spawns 7 4 blue)\n(spawns 4 7 green)\n(stepcount 1 2)\n(stepcount 2 3)\n(stepcount 3 4)\n(stepcount 4 5)\n(stepcount 5 6)\n(stepcount 6 7)\n(stepcount 7 8)\n(stepcount 8 9)\n(stepcount 9 10)\n(stepcount 10 11)\n(stepcount 11 12)\n(stepcount 12 13)\n(stepcount 13 14)\n(stepcount 14 15)\n(stepcount 15 16)\n(stepcount 16 17)\n(stepcount 17 18)\n(stepcount 18 19)\n(stepcount 19 20)\n(stepcount 20 21)\n(stepcount 21 22)\n(stepcount 22 23)\n(stepcount 23 24)\n(stepcount 24 25)\n(stepcount 25 26)\n(stepcount 26 27)\n(stepcount 27 28)\n(stepcount 28 29)\n(stepcount 29 30)\n(stepcount 30 31)\n(stepcount 31 32)\n(stepcount 32 33)\n(stepcount 33 34)\n(stepcount 34 35)\n(stepcount 35 36)\n(stepcount 36 37)\n(stepcount 37 38)\n(stepcount 38 39)\n(stepcount 39 40)\n(stepcount 40 41)\n(captureplus 0 1)\n(captureplus 1 2)\n(captureplus 2 3)\n(captureplus 3 4)\n(captureplus 4 5)\n(captureplus 5 6)\n(captureplus 6 7)\n(captureplus 7 8)\n(captureplus 8 9)\n(captureplus 9 10)\n(scoremap 0 0)\n(scoremap 1 10)\n(scoremap 2 20)\n(scoremap 3 30)\n(scoremap 4 40)\n(scoremap 5 50)\n(scoremap 6 60)\n(scoremap 7 70)\n(scoremap 8 80)\n(scoremap 9 90)\n(scoremap 10 100)\n(<= (lt ?n ?np1)\n    (distinct ?n ?np1)\n    (captureplus ?n ?np1))\n(<= (lt ?x ?z)\n    (distinct ?x ?z)\n    (captureplus ?x ?y)\n    (distinct ?x ?y)\n    (distinct ?y ?z)\n    (lt ?y ?z))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 3x3 grid with coordinates ranging from 1 to 3 along both rows and columns, though only the four cells at positions (1,1), (1,2), (2,1), and (2,2) start as green cells; these cells can change colors during gameplay. There are two player roles: blueplayer and redplayer, who alternate turns. The initial state has those four cells colored green, while the rest of the board is implicitly empty or inactive. On each turn, a player must perform an action of the form \"placead r c,\" where r and c specify the row and column of a green cell on the board; the action is legal only if that cell is currently green. Players cannot place ads on cells that are not green and must choose from the designated green cells. When an action is taken, the color of the chosen cell changes to that player's color—either blue or red—while all other cells retain their colors unless changed in future turns. The game continues as long as there is at least one green cell remaining; if no green cells remain, the game ends automatically. Players have no explicit \"noop\" move since they must place an ad on a green cell to proceed. The board's boundaries restrict all actions and effects to within the 3x3 grid, with the system tracking adjacency and distances between cells using Manhattan distance (sum of absolute differences in row and column indices). The scoring is computed by considering each green cell's influence, which depends on the proximity of blue and red ads as well as the distance-weighted contributions of other cells. Specifically, the influence score for each cell is calculated by summing weighted inverse distances to placed ads of each color, with the weights favoring closer ads. The point difference between blue and red influences determines which player \"wins\" influence over that cell, and the magnitude of this difference contributes to the cell's score. At the end of the game, the total number of cells each player controls (colored blue or red) is counted. If one player controls more cells, that player receives a base score of 100 points, while the opponent's score is calculated as four times their cell count plus the original count, reflecting a penalty or partial credit. If both players control an equal number of cells, each receives 50 points. The terminal condition occurs when no green cells remain, signaling the conclusion of the game. The player with the higher score at this point is declared the winner. Throughout the game, occupancy conflicts are prevented because only green cells may be claimed, and once claimed, a cell changes color and cannot be claimed again. Distance calculations and adjacency are strictly bounded within the defined 3x3 grid, ensuring all computations remain valid within the game environment.",
    "output": "(role blueplayer)\n(role redplayer)\n(init (cell 1 1 green))\n(init (cell 1 2 green))\n(init (cell 2 1 green))\n(init (cell 2 2 green))\n(totalboardsize 3)\n(colour blue)\n(colour green)\n(colour red)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(number 0)\n(number 1)\n(number 2)\n(number 3)\n(number 4)\n(number 5)\n(number 6)\n(number 7)\n(number 8)\n(number 9)\n(number 10)\n(number 11)\n(number 12)\n(number 13)\n(number 14)\n(number 15)\n(number 16)\n(number 17)\n(number 18)\n(number 19)\n(number 20)\n(number 21)\n(number 22)\n(number 23)\n(number 24)\n(nextcell 1 1 1 2)\n(nextcell 1 2 2 1)\n(nextcell 2 1 2 2)\n(nextcell 2 2 0 0)\n(<= (add ?x 0 ?x)\n\t(number ?x))\n(<= (add ?x ?y ?z)\n\t(succ ?x ?x1)\n\t(succ ?y1 ?y)\n\t(add ?x1 ?y1 ?z))\n(<= (subtract ?x 0 ?x)\n\t(number ?x))\n(<= (subtract ?x ?y ?z)\n\t(succ ?x1 ?x)\n\t(succ ?y1 ?y)\n\t(subtract ?x1 ?y1 ?z))\n(<= (less ?x ?y)\n\t(succ ?x ?y))\n(<= (less ?x ?y)\n\t(succ ?y1 ?y)\n\t(less ?x ?y1))\n(<= (le 0 ?x)\n\t(number ?x))\n(<= (le ?x 24)\n\t(number ?x))\n(<= (le ?x ?x)\n\t(number ?x))\n(<= (le ?x ?y)\n\t(succ ?y1 ?y)\n\t(le ?x ?y1))\n(<= (abssubtract ?x ?y ?z)\n\t(less ?x ?y)\n\t(subtract ?y ?x ?z))\n(<= (abssubtract ?x ?y ?z)\n\t(le ?y ?x)\n\t(subtract ?x ?y ?z))\n(<= (legal ?w (placead ?r ?c))\n\t(true (cell ?r ?c ?colour))\n\t(role ?w))\n(<= (dist ?r1 ?c1 ?r2 ?c2 ?d)\n\t(abssubtract ?r1 ?r2 ?d1)\n\t(abssubtract ?c1 ?c2 ?d2)\n\t(add ?d1 ?d2 ?d))\n(<= (invdist ?r1 ?c1 ?r2 ?c2 ?inv)\n\t(dist ?r1 ?c1 ?r2 ?c2 ?d)\n\t(totalboardsize ?size)\n\t(subtract ?size ?d ?inv))\n(<= (adpoints ?cellr ?cellc ?adr ?adc ?p)\n\t(invdist ?cellr ?cellc ?adr ?adc ?p1)\n\t(add ?p1 ?p1 ?p2)\n\t(add ?p2 ?p2 ?p4)\n\t(add ?p4 ?p1 ?p))\n(<= (collectmouthpoints ?cellr ?cellc 0 0 ?colour 0)\n\t(number ?cellr)\n\t(number ?cellc)\n\t(colour ?colour))\n(<= (collectmouthpoints ?cellr ?cellc ?r ?c ?colour ?p)\n\t(true (cell ?r ?c ?colour))\n\t(invdist ?cellr ?cellc ?r ?c ?p1)\n\t(nextcell ?r ?c ?nr ?nc)\n\t(collectmouthpoints ?cellr ?cellc ?nr ?nc ?colour ?p2)\n\t(add ?p1 ?p2 ?p))\n(<= (collectmouthpoints ?cellr ?cellc ?r ?c ?colour ?p)\n\t(not (true (cell ?r ?c ?colour)))\n\t(nextcell ?r ?c ?nr ?nc)\n\t(collectmouthpoints ?cellr ?cellc ?nr ?nc ?colour ?p))\n(<= (mouthpoints ?cellr ?cellc ?colour ?p)\n\t(collectmouthpoints ?cellr ?cellc 1 1 ?colour ?p))\n(<= (cellpoints ?cellr ?cellc ?adr ?adc ?colour ?p)\n\t(mouthpoints ?cellr ?cellc ?colour ?p1)\n\t(adpoints ?cellr ?cellc ?adr ?adc ?p2)\n\t(add ?p1 ?p2 ?p))\n(<= (winner ?bluepoint ?redpoint blue)\n\t(less ?bluepoint ?redpoint))\n(<= (winner ?bluepoint ?redpoint red)\n\t(less ?redpoint ?bluepoint))\n(<= (winner ?bluepoint ?bluepoint green)\n\t(number ?bluepoint))\n(<= (cellinfluencescore ?cellr ?cellc ?winnercolour ?point)\n\t(does blueplayer (placead ?blueadr ?blueadc))\n\t(does redplayer (placead ?redadr ?redadc))\n\t(cellpoints ?cellr ?cellc ?blueadr ?blueadc blue ?bluepoint)\n\t(cellpoints ?cellr ?cellc ?redadr ?redadc red ?redpoint)\n\t(winner ?bluepoint ?redpoint ?winnercolour)\n\t(abssubtract ?bluepoint ?redpoint ?point))\n(<= (takemax ?p1 ?p2 ?p1)\n\t(less ?p2 ?p1))\n(<= (takemax ?p1 ?p2 ?p2)\n\t(le ?p1 ?p2))\n(bestscoreaccumulator 0 0 0)\n(<= (bestscoreaccumulator ?r ?c ?p)\n\t(true (cell ?r ?c green))\n\t(nextcell ?r ?c ?nr ?nc)\n\t(cellinfluencescore ?r ?c ?colour ?p1)\n\t(bestscoreaccumulator ?nr ?nc ?p2)\n\t(takemax ?p1 ?p2 ?p))\n(<= (bestscoreaccumulator ?r ?c ?p)\n\t(not (true (cell ?r ?c green)))\n\t(nextcell ?r ?c ?nr ?nc)\n\t(bestscoreaccumulator ?nr ?nc ?p))\n(<= (bestscore ?point)\n\t(bestscoreaccumulator 1 1 ?point))\n(<= (takebest ?best ?cellscore ?col green)\n\t(less ?cellscore ?best)\n\t(colour ?col))\n(<= (takebest ?best ?cellscore ?col ?col)\n\t(le ?best ?cellscore)\n\t(colour ?col))\n(<= (next (cell ?r ?c blue))\n\t(true (cell ?r ?c blue)))\n(<= (next (cell ?r ?c red))\n\t(true (cell ?r ?c red)))\n(<= (next (cell ?r ?c ?colour))\n\t(bestscore ?p2)\n\t(true (cell ?r ?c green))\n\t(cellinfluencescore ?r ?c ?c1 ?p1)\n\t(takebest ?p2 ?p1 ?c1 ?colour))\n(<= (next gameend)\n\t(not open))\n(<= (next gameend)\n\t(bestscore 0))\n(<= open\n\t(true (cell ?r ?c green)))\n(<= (update green ?b ?r ?b ?r)\n\t(number ?b)\n\t(number ?r))\n(<= (update blue ?b ?r ?b1 ?r)\n\t(number ?r)\n\t(succ ?b ?b1))\n(<= (update red ?b ?r ?b ?r1)\n\t(number ?b)\n\t(succ ?r ?r1))\n(countcellaccum 0 0 0 0)\n(<= (countcellaccum ?r ?c ?bluecount ?redcount)\n\t(getcolour ?r ?c ?colour)\n\t(nextcell ?r ?c ?nc ?nr)\n\t(countcellaccum ?nr ?nc ?b1 ?r1)\n\t(update ?colour ?b1 ?r1 ?bluecount ?redcount))\n(<= (countcell ?bluecount ?redcount)\n\t(countcellaccum 1 1 ?bluecount ?redcount))\n(<= (getcolour ?r ?c green)\n\t(true (cell ?r ?c green)))\n(<= (getcolour ?r ?c red)\n\t(true (cell ?r ?c red)))\n(<= (getcolour ?r ?c blue)\n\t(true (cell ?r ?c blue)))\n(<= (goal ?player ?score)\n\t(countcell ?bluecount ?redcount)\n\t(goal2 ?bluecount ?redcount ?player ?score))\n(<= (goal2 ?bluecount ?redcount blueplayer 100)\n\t(less ?redcount ?bluecount))\n(<= (goal2 ?bluecount ?redcount redplayer ?partial)\n\t(less ?redcount ?bluecount)\n\t(add ?redcount ?redcount ?p2)\n\t(add ?p2 ?p2 ?p4)\n\t(add ?p4 ?redcount ?partial))\n(<= (goal2 ?bluecount ?redcount redplayer 100)\n\t(less ?bluecount ?redcount))\n(<= (goal2 ?bluecount ?redcount blueplayer ?partial)\n\t(less ?bluecount ?redcount)\n\t(add ?bluecount ?bluecount ?p2)\n\t(add ?p2 ?p2 ?p4)\n\t(add ?p4 ?bluecount ?partial))\n(<= (goal2 ?count ?count ?player 50)\n\t(number ?count)\n\t(role ?player))\n(<= terminal\n\t(true gameend))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 3-by-3 grid with coordinates along the x-axis numbered 1 to 3 and similarly along the y-axis numbered 1 to 3, establishing a Cartesian coordinate system for referencing each of the nine cells. There are two player roles, designated as \"x\" and \"o,\" who alternate turns in a sequence governed by the game's stage and control state. Initially, all cells are blank, each player starts with three coins, and the tiebreaker advantage is assigned to player \"x.\" The game begins in the \"bidding\" stage, during which players make bids to determine who gains control for marking cells. On a player's turn in the bidding stage, they may place a bid using some or all of their available coins, optionally indicating whether they use the tiebreaker advantage. The legality of a bid requires that the player has enough coins to cover the bid amount and that the tiebreaker usage aligns with current possession; only the player holding the tiebreaker may use it in their bid. If a player does not have control, they may perform a no-operation (noop) action, effectively passing their turn. After bidding concludes with a winner determined either by the highest bid or by usage of the tiebreaker, control passes to the winning player, who then may mark one of the blank cells on the board with their symbol during the marking stage. Marking is only legal if the chosen cell is blank and the player has control. When a player marks a cell, that cell's state updates to reflect the player's symbol; other cells remain unchanged unless acted upon. The game's state transitions include updating coin counts to reflect bids made, transferring tiebreaker possession if used, and changing control and stage accordingly to alternate between bidding and marking phases. Implicit constraints include restricting bids to the player's current coin total, ensuring marks occur only on empty cells within the 3-by-3 grid, and forbidding moves by non-controlling players except for noops. The game terminates when a player achieves a three-in-a-row line horizontally, vertically, or diagonally, or when no blank cells remain on the board. Victory is awarded to the player who successfully forms such a line, granting them a score of 100, while the opponent receives zero. If neither player achieves a line by the end of the game, both players receive a score of 50, indicating a draw. Thus, the game combines strategic bidding for control with tactical placement on a classic tic-tac-toe board, with the added complexity of resource management through coin bids and tiebreaker usage determining turn order and move privileges.",
    "output": "(role x)\n(role o)\n(other x o)\n(other o x)\n(xcoord 1)\n(xcoord 2)\n(xcoord 3)\n(ycoord 1)\n(ycoord 2)\n(ycoord 3)\n(<= (init (cell ?x ?y b))\n\t(xcoord ?x)\n\t(ycoord ?y))\n(<= (init (coins ?p 3))\n\t(role ?p))\n(init (tiebreaker x))\n(init (stage bidding))\n(<= (legal ?p (bid ?b ?tiebreaker))\n\t(true (stage bidding))\n\t(true (coins ?p ?m))\n\t(le ?b ?m)\n\t(legal_bid_tiebreaker ?p ?tiebreaker))\n(<= (legal_bid_tiebreaker ?p with_tiebreaker)\n\t(true (tiebreaker ?p)))\n(<= (legal_bid_tiebreaker ?p no_tiebreaker)\n\t(role ?p))\n(<= (legal ?p (mark ?r ?c))\n\t(true (control ?p))\n\t(true (cell ?r ?c b)))\n(<= (legal ?p noop)\n\t(true (control ?p1))\n\t(role ?p)\n\t(distinct ?p ?p1))\n(<= (next (stage bidding))\n\t(true (control ?p)))\n(<= (next (control ?p))\n\t(true (stage bidding))\n\t(winner ?p))\n(<= (next (coins ?p ?m))\n\t(true (stage bidding))\n\t(winner ?p)\n\t(does ?p (bid ?b ?t))\n\t(true (coins ?p ?m0))\n\t(add ?m ?b ?m0))\n(<= (next (coins ?p ?m))\n\t(true (stage bidding))\n\t(winner ?o)\n\t(other ?o ?p)\n\t(does ?o (bid ?b ?t))\n\t(true (coins ?p ?m0))\n\t(add ?m0 ?b ?m))\n(<= (next (coins ?p ?m))\n\t(true (control ?someone))\n\t(true (coins ?p ?m)))\n(<= (next (tiebreaker ?p))\n\t(true (stage bidding))\n\t(winner ?o)\n\t(other ?o ?p)\n\t(does ?o (bid ?b with_tiebreaker)))\n(<= (next (tiebreaker ?p))\n\t(true (stage bidding))\n\t(true (tiebreaker ?p))\n\t(winner ?w)\n\t(does ?w (bid ?b no_tiebreaker)))\n(<= (next (tiebreaker ?p))\n\t(true (control ?someone))\n\t(true (tiebreaker ?p)))\n(<= (next (cell ?r ?c ?p))\n\t(does ?p (mark ?r ?c)))\n(<= (next (cell ?r ?c ?x))\n\t(true (cell ?r ?c ?x))\n\t(true (control ?p))\n\t(not (does ?p (mark ?r ?c))))\n(<= (next (cell ?r ?c ?x))\n\t(true (stage bidding))\n\t(true (cell ?r ?c ?x)))\n(<= (winner ?p)\n\t(does ?p (bid ?bp ?tp))\n\t(other ?p ?o)\n\t(does ?o (bid ?bo ?to))\n\t(gt ?bp ?bo))\n(<= (winner ?p)\n\t(does ?p (bid ?b with_tiebreaker))\n\t(other ?p ?o)\n\t(does ?o (bid ?b no_tiebreaker)))\n(<= (winner ?p)\n\t(true (tiebreaker ?o))\n\t(does ?o (bid ?b no_tiebreaker))\n\t(other ?p ?o)\n\t(does ?p (bid ?b no_tiebreaker)))\n(<= (row ?p)\n\t(true (cell ?r 1 ?p))\n\t(true (cell ?r 2 ?p))\n\t(true (cell ?r 3 ?p)))\n(<= (column ?p)\n\t(true (cell 1 ?c ?p))\n\t(true (cell 2 ?c ?p))\n\t(true (cell 3 ?c ?p)))\n(<= (diagonal ?p)\n\t(true (cell 1 1 ?p))\n\t(true (cell 2 2 ?p))\n\t(true (cell 3 3 ?p)))\n(<= (diagonal ?p)\n\t(true (cell 1 3 ?p))\n\t(true (cell 2 2 ?p))\n\t(true (cell 3 1 ?p)))\n(<= (line ?player) (row ?player))\n(<= (line ?player) (column ?player))\n(<= (line ?player) (diagonal ?player))\n(<= open\n\t(true (cell ?r ?c b)))\n(<= terminal\n\t(role ?p)\n\t(line ?p))\n(<= terminal\n\t(not open))\n(<= (goal ?p 100)\n\t(line ?p))\n(<= (goal ?p 0)\n\t(other ?p ?o)\n\t(line ?o))\n(<= (goal ?p 50)\n\t(role ?p)\n\t(not (line x))\n\t(not (line o)))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(<= (number ?x)\n\t(succ ?x ?y))\n(<= (number ?x)\n\t(succ ?y ?x))\n(<= (gt ?x ?y)\n\t(succ ?y ?x))\n(<= (gt ?x ?y)\n\t(succ ?y ?z)\n\t(gt ?x ?z))\n(<= (le ?x ?x)\n\t(number ?x))\n(<= (le ?x ?y)\n\t(gt ?y ?x))\n(<= (add ?x 0 ?x)\n\t(number ?x))\n(<= (add ?x ?y ?sum)\n\t(succ ?y1 ?y)\n\t(succ ?x ?x1)\n\t(add ?x1 ?y1 ?sum))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a three-dimensional grid consisting of three layers, each layer composed of a 3x3 board, creating a total of 27 cells indexed by four coordinates: the first two coordinates (i and j) designate the layer (each ranging from 1 to 3), and the last two coordinates (k and l) designate the row and column within that layer (also each ranging from 1 to 3). There is a single player role named \"robot\" who takes turns performing actions; since there is only one role, the turn order is straightforward with the robot acting each turn. The initial state of the game involves certain cells pre-filled with digits from 1 to 9, while other cells are marked as blank, represented by \"b\". On each turn, the robot may choose to place a digit from 1 to 9 into any blank cell on the grid, with the action formatted as \"mark i j k l x,\" where i, j, k, and l specify the cell coordinates, and x is the digit to place. Such an action is legal only if the target cell is currently blank and if the digit to be placed does not already appear in the corresponding row k, the column l, or the 3x3 square within the specific layer i and block j, reflecting traditional Sudoku constraints extended into three dimensions. The game maintains these constraints by checking all cells within the same rows, columns, and squares across the layers to prevent duplicate digits. When the robot executes a legal mark action, the state updates by placing the specified digit in the chosen cell, replacing the blank. No explicit noop action is described, but the game terminates automatically when no legal moves remain, meaning there are no blank cells where a digit can be legally placed under the Sudoku rules. The terminal condition occurs when the puzzle is either fully and correctly filled or no valid moves are left. The scoring system awards the robot a goal value of 100 if the puzzle is completely filled with no blanks remaining (indicating successful completion) and 0 otherwise. Implicit constraints include the boundaries of the board, with indices strictly ranging from 1 to 3 for all dimensions, and the occupancy rule that a digit may only be placed in a currently blank cell. This game thus models a three-dimensional Sudoku puzzle where the single player sequentially fills in blank cells with digits, adhering to the standard Sudoku rules extended across multiple layers, aiming to complete the puzzle correctly to achieve victory.",
    "output": "(role robot)\n  (init (cell 1 1 1 1 3))\n  (init (cell 1 1 1 2 b))\n  (init (cell 1 1 1 3 2))\n  (init (cell 1 1 2 1 b))\n  (init (cell 1 1 2 2 7))\n  (init (cell 1 1 2 3 b))\n  (init (cell 1 1 3 1 5))\n  (init (cell 1 1 3 2 b))\n  (init (cell 1 1 3 3 4))\n  (init (cell 1 2 1 1 b))\n  (init (cell 1 2 1 2 b))\n  (init (cell 1 2 1 3 b))\n  (init (cell 1 2 2 1 b))\n  (init (cell 1 2 2 2 b))\n  (init (cell 1 2 2 3 b))\n  (init (cell 1 2 3 1 b))\n  (init (cell 1 2 3 2 b))\n  (init (cell 1 2 3 3 b))\n  (init (cell 1 3 1 1 b))\n  (init (cell 1 3 1 2 b))\n  (init (cell 1 3 1 3 6))\n  (init (cell 1 3 2 1 2))\n  (init (cell 1 3 2 2 5))\n  (init (cell 1 3 2 3 4))\n  (init (cell 1 3 3 1 b))\n  (init (cell 1 3 3 2 b))\n  (init (cell 1 3 3 3 b))\n  (init (cell 2 1 1 1 b))\n  (init (cell 2 1 1 2 9))\n  (init (cell 2 1 1 3 b))\n  (init (cell 2 1 2 1 b))\n  (init (cell 2 1 2 2 b))\n  (init (cell 2 1 2 3 b))\n  (init (cell 2 1 3 1 6))\n  (init (cell 2 1 3 2 b))\n  (init (cell 2 1 3 3 b))\n  (init (cell 2 2 1 1 b))\n  (init (cell 2 2 1 2 b))\n  (init (cell 2 2 1 3 8))\n  (init (cell 2 2 2 1 9))\n  (init (cell 2 2 2 2 6))\n  (init (cell 2 2 2 3 5))\n  (init (cell 2 2 3 1 1))\n  (init (cell 2 2 3 2 b))\n  (init (cell 2 2 3 3 b))\n  (init (cell 2 3 1 1 b))\n  (init (cell 2 3 1 2 b))\n  (init (cell 2 3 1 3 5))\n  (init (cell 2 3 2 1 b))\n  (init (cell 2 3 2 2 b))\n  (init (cell 2 3 2 3 b))\n  (init (cell 2 3 3 1 b))\n  (init (cell 2 3 3 2 2))\n  (init (cell 2 3 3 3 b))\n  (init (cell 3 1 1 1 b))\n  (init (cell 3 1 1 2 b))\n  (init (cell 3 1 1 3 b))\n  (init (cell 3 1 2 1 1))\n  (init (cell 3 1 2 2 9))\n  (init (cell 3 1 2 3 7))\n  (init (cell 3 1 3 1 8))\n  (init (cell 3 1 3 2 b))\n  (init (cell 3 1 3 3 b))\n  (init (cell 3 2 1 1 b))\n  (init (cell 3 2 1 2 b))\n  (init (cell 3 2 1 3 b))\n  (init (cell 3 2 2 1 b))\n  (init (cell 3 2 2 2 b))\n  (init (cell 3 2 2 3 b))\n  (init (cell 3 2 3 1 b))\n  (init (cell 3 2 3 2 b))\n  (init (cell 3 2 3 3 b))\n  (init (cell 3 3 1 1 5))\n  (init (cell 3 3 1 2 b))\n  (init (cell 3 3 1 3 7))\n  (init (cell 3 3 2 1 b))\n  (init (cell 3 3 2 2 8))\n  (init (cell 3 3 2 3 b))\n  (init (cell 3 3 3 1 2))\n  (init (cell 3 3 3 2 b))\n  (init (cell 3 3 3 3 6))\n  (<= (legal robot (mark ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l b))\n      (digit ?x)\n      (not (row ?k ?l ?x))\n      (not (col ?i ?j ?x))\n      (not (square ?i ?k ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 3 ?k ?l ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 3 ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?i ?j ?k ?l ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?s ?i))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?t ?j))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?u ?k))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?v ?l))\n  (<= (goal robot 100) (not open))\n  (<= (goal robot 0) open)\n  (<= terminal (not playable))\n  (<= (filler ?x) (digit ?x))\n  (filler b)\n  (<= open (true (cell ?i ?j ?k ?l b)))\n  (<= playable (legal robot (mark ?i ?j ?k ?l ?x)))\n  (index 1)\n  (index 2)\n  (index 3)\n  (digit 1)\n  (digit 2)\n  (digit 3)\n  (digit 4)\n  (digit 5)\n  (digit 6)\n  (digit 7)\n  (digit 8)\n  (digit 9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place in an environment defined by four interconnected cells arranged in a cycle—w, x, y, and z—where adjacency relations connect w to x, x to y, y to z, and z back to w. The temporal progression of the game is tracked by steps labeled c1 through c20, sequentially ordered so that each step is the successor of the previous one. There is a single player role called \"robot,\" which acts alone and takes turns sequentially through the steps. The initial state sets the robot's position at cell w, marks the gold as present at cell y, and establishes a set of blocks with positional relationships: block c is on a, e is on d, and f is on e; blocks a, b, and d are positioned on tables, and certain locations are clear, specifically b, c, and f.\n\nEach turn, the robot must perform an action, with the option to effectively pass by performing a \"noop\" or equivalent move, ensuring continuous turn control. Legal actions include moving to an adjacent cell, grabbing the gold if it is in the robot's current cell, dropping gold the robot is holding, stacking a clear block onto another clear block that rests on a table, unstacking a clear block from atop another block, and contemplating pairs of adjacent positions. An action is legal only if its preconditions hold: for example, moving requires adjacency, grabbing requires gold presence at the robot's cell, dropping requires possession of the gold, stacking requires both source and destination blocks to be clear with the destination on a table, and unstacking requires the source block to be clear and positioned on another block. Contemplation requires pairs of adjacent cells. The robot cannot violate implicit constraints such as moving beyond the four defined cells or stacking onto occupied or non-clear blocks.\n\nState changes occur automatically based on the robot's actions: moving updates the robot's cell to an adjacent position, grabbing transfers gold possession to the robot and removes it from the cell, dropping places the gold at the robot's current cell, stacking and unstacking update the \"on\" relationships between blocks, and contemplation does not change the board state but may represent a cognitive or planning step. The step counter increments with each turn, advancing from c1 up to c20. The game terminates if the step count reaches c20 or if the gold is at cell w, the starting position.\n\nVictory conditions depend on the arrangement of blocks forming specific towers and the location of the gold. Two towers are recognized: the \"bdftower,\" completed if block d is on f and b is on d, and the \"caetower,\" completed if a is on e and c is on a. The robot's goal score varies according to whether gold is at w and which towers are completed. The highest score of 100 is awarded if the gold is at w and both towers are completed; lesser scores are given for partial completions or gold absence, down to zero if neither tower is complete, the gold is not at w, and the step count reaches c20. Thus, the robot aims to maneuver blocks to build these towers and retrieve the gold to cell w within the given steps to maximize its score and achieve victory.",
    "output": "(role robot)\n(init (cell w))\n(init (gold y))\n(init (step c1))\n(init (clear b))\n(init (clear c))\n(init (clear f))\n(init (on c a))\n(init (on e d))\n(init (on f e))\n(init (table a))\n(init (table b))\n(init (table d))\n(<= (next (cell ?y))\n(does robot move)\n(true (cell ?x))\n(adjacent ?x ?y))\n(<= (next (cell ?x))\n(does robot grab)\n(true (cell ?x)))\n(<= (next (cell ?x))\n(does robot drop)\n(true (cell ?x)))\n(<= (next (cell ?x))\n(true (cell ?x))\n(does robot (s ?u ?v)))\n(<= (next (cell ?x))\n(true (cell ?x))\n(does robot (u ?u ?v)))\n(<= (next (cell ?x))\n(true (cell ?x))\n(does robot (contemplate ?u ?v)))\n(<= (next (gold ?x))\n(does robot move)\n(true (gold ?x)))\n(<= (next (gold i))\n(does robot grab)\n(true (cell ?x))\n(true (gold ?x)))\n(<= (next (gold i))\n(does robot grab)\n(true (gold i)))\n(<= (next (gold ?y))\n(does robot grab)\n(true (cell ?x))\n(true (gold ?y))\n(distinct ?x ?y))\n(<= (next (gold ?x))\n(does robot drop)\n(true (cell ?x))\n(true (gold i)))\n(<= (next (gold ?x))\n(does robot drop)\n(true (gold ?x))\n(distinct ?x i))\n(<= (next (gold ?x))\n(true (gold ?x))\n(does robot (s ?u ?v)))\n(<= (next (gold ?x))\n(true (gold ?x))\n(does robot (u ?u ?v)))\n(<= (next (gold ?x))\n(true (gold ?x))\n(does robot (contemplate ?u ?v)))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(<= (next (on ?x ?y))\n(does robot (s ?x ?y)))\n(<= (next (on ?x ?y))\n(does robot (s ?u ?v))\n(true (on ?x ?y)))\n(<= (next (on ?x ?y))\n(does robot (u ?u ?v))\n(true (on ?x ?y))\n(distinct ?u ?x))\n(<= (next (on ?x ?y))\n(true (on ?x ?y))\n(does robot move))\n(<= (next (on ?x ?y))\n(true (on ?x ?y))\n(does robot grab))\n(<= (next (on ?x ?y))\n(true (on ?x ?y))\n(does robot drop))\n(<= (next (on ?x ?y))\n(true (on ?x ?y))\n(does robot (contemplate ?u ?v)))\n(<= (next (table ?x))\n(does robot (s ?u ?v))\n(true (table ?x))\n(distinct ?u ?x))\n(<= (next (table ?x))\n(does robot (u ?x ?y)))\n(<= (next (table ?x))\n(does robot (u ?u ?v))\n(true (table ?x)))\n(<= (next (table ?x))\n(true (table ?x))\n(does robot move))\n(<= (next (table ?x))\n(true (table ?x))\n(does robot grab))\n(<= (next (table ?x))\n(true (table ?x))\n(does robot drop))\n(<= (next (table ?x))\n(true (table ?x))\n(does robot (contemplate ?u ?v)))\n(<= (next (clear ?y))\n(does robot (s ?u ?v))\n(true (clear ?y))\n(distinct ?v ?y))\n(<= (next (clear ?y))\n(does robot (u ?x ?y)))\n(<= (next (clear ?x))\n(does robot (u ?u ?v))\n(true (clear ?x)))\n(<= (next (clear ?x))\n(true (clear ?x))\n(does robot move))\n(<= (next (clear ?x))\n(true (clear ?x))\n(does robot grab))\n(<= (next (clear ?x))\n(true (clear ?x))\n(does robot drop))\n(<= (next (clear ?x))\n(true (clear ?x))\n(does robot (contemplate ?u ?v)))\n(adjacent w x)\n(adjacent x y)\n(adjacent y z)\n(adjacent z w)\n(succ c1 c2)\n(succ c2 c3)\n(succ c3 c4)\n(succ c4 c5)\n(succ c5 c6)\n(succ c6 c7)\n(succ c7 c8)\n(succ c8 c9)\n(succ c9 c10)\n(succ c10 c11)\n(succ c11 c12)\n(succ c12 c13)\n(succ c13 c14)\n(succ c14 c15)\n(succ c15 c16)\n(succ c16 c17)\n(succ c17 c18)\n(succ c18 c19)\n(succ c19 c20)\n(legal robot move)\n(<= (legal robot grab)\n(true (cell ?x))\n(true (gold ?x)))\n(<= (legal robot drop)\n(true (gold i)))\n(<= (legal robot (s ?x ?y))\n(true (clear ?x))\n(true (table ?x))\n(true (clear ?y))\n(distinct ?x ?y))\n(<= (legal robot (u ?x ?y))\n(true (clear ?x))\n(true (on ?x ?y)))\n(<= (legal robot (contemplate ?x ?y))\n(adjacent ?x ?x1)\n(adjacent ?y ?y1))\n(<= (completed bdftower)\n(true (on d f))\n(true (on b d)))\n(<= (completed caetower)\n(true (on a e))\n(true (on c a)))\n(<= (goal robot 100)\n(true (gold w))\n(completed bdftower)\n(completed caetower))\n(<= (goal robot 75)\n(true (gold w))\n(not (completed bdftower))\n(completed caetower))\n(<= (goal robot 70)\n(true (gold w))\n(completed bdftower)\n(not (completed caetower)))\n(<= (goal robot 55)\n(completed bdftower)\n(completed caetower)\n(not (true (gold w))))\n(<= (goal robot 45)\n(true (gold w))\n(not (completed bdftower))\n(not (completed caetower)))\n(<= (goal robot 30)\n(completed caetower)\n(not (completed bdftower))\n(not (true (gold w))))\n(<= (goal robot 25)\n(completed bdftower)\n(not (completed caetower))\n(not (true (gold w))))\n(<= (goal robot 0)\n(true (step c20))\n(not (completed caetower))\n(not (completed bdftower))\n(not (true (gold w))))\n(<= terminal\n(true (step c20)))\n(<= terminal\n(true (gold w)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid defined by columns labeled from 'a' through 'j' and rows numbered from 'r01' to 'r10', forming a 10-by-10 board. Each cell on this board is initially empty, marked by the symbol 'b'. There is a single player role who takes turns sequentially to make moves, with the initial step labeled as s1. The game progresses in discrete steps, incrementing from s1 through s11, after which the game terminates. On each turn, the player may perform an action described as placing a queen piece on any empty cell—specifically, an action formatted as \"place x y,\" where x is a column coordinate from 'a' to 'j' and y is a row coordinate from 'r01' to 'r10'. This action is legal only if the targeted cell is unoccupied, ensuring no overwriting of existing queen placements. If the player does not place a queen, the board state remains unchanged for that cell. Once a queen is placed on a cell, that cell's state updates to indicate the presence of the queen, and this placement influences the state through implicit automatic events, notably the attack calculations. The game defines adjacency relationships between rows and columns, which are used to determine legal queen moves and attacks; queens can attack cells along their row, column, and diagonals, including northeast and northwest directions, provided that these directions follow the adjacency and next-column relationships without jumping over other queens. A cell is considered attacked if it lies along a queen's line of attack, and if previously attacked, the number of times attacked increments accordingly. The game imposes implicit constraints that placements must remain within the board boundaries and that no cell may hold more than one queen. The progression of the game is controlled by a step counter that increments each turn, and the game ends automatically after step s11, marking the terminal condition. Scoring in the game is derived from the number of attacks on the board, where the value associated with attacks decreases with each successive step from 100 at s0, down incrementally to 0 at s8 and beyond; the player's goal is to maximize the number of attacks before the game terminates, with the final score reflecting the attack value mapped to the last step reached. No explicit noop (no operation) action is specified, but the player may choose to refrain from placing a queen on a turn, resulting in no change to the board state for that step.",
    "output": "(role player)\n(init (cell a r01 b))\n(init (cell a r02 b))\n(init (cell a r03 b))\n(init (cell a r04 b))\n(init (cell a r05 b))\n(init (cell a r06 b))\n(init (cell a r07 b))\n(init (cell a r08 b))\n(init (cell a r09 b))\n(init (cell a r10 b))\n(init (cell b r01 b))\n(init (cell b r02 b))\n(init (cell b r03 b))\n(init (cell b r04 b))\n(init (cell b r05 b))\n(init (cell b r06 b))\n(init (cell b r07 b))\n(init (cell b r08 b))\n(init (cell b r09 b))\n(init (cell b r10 b))\n(init (cell c r01 b))\n(init (cell c r02 b))\n(init (cell c r03 b))\n(init (cell c r04 b))\n(init (cell c r05 b))\n(init (cell c r06 b))\n(init (cell c r07 b))\n(init (cell c r08 b))\n(init (cell c r09 b))\n(init (cell c r10 b))\n(init (cell d r01 b))\n(init (cell d r02 b))\n(init (cell d r03 b))\n(init (cell d r04 b))\n(init (cell d r05 b))\n(init (cell d r06 b))\n(init (cell d r07 b))\n(init (cell d r08 b))\n(init (cell d r09 b))\n(init (cell d r10 b))\n(init (cell e r01 b))\n(init (cell e r02 b))\n(init (cell e r03 b))\n(init (cell e r04 b))\n(init (cell e r05 b))\n(init (cell e r06 b))\n(init (cell e r07 b))\n(init (cell e r08 b))\n(init (cell e r09 b))\n(init (cell e r10 b))\n(init (cell f r01 b))\n(init (cell f r02 b))\n(init (cell f r03 b))\n(init (cell f r04 b))\n(init (cell f r05 b))\n(init (cell f r06 b))\n(init (cell f r07 b))\n(init (cell f r08 b))\n(init (cell f r09 b))\n(init (cell f r10 b))\n(init (cell g r01 b))\n(init (cell g r02 b))\n(init (cell g r03 b))\n(init (cell g r04 b))\n(init (cell g r05 b))\n(init (cell g r06 b))\n(init (cell g r07 b))\n(init (cell g r08 b))\n(init (cell g r09 b))\n(init (cell g r10 b))\n(init (cell h r01 b))\n(init (cell h r02 b))\n(init (cell h r03 b))\n(init (cell h r04 b))\n(init (cell h r05 b))\n(init (cell h r06 b))\n(init (cell h r07 b))\n(init (cell h r08 b))\n(init (cell h r09 b))\n(init (cell h r10 b))\n(init (cell i r01 b))\n(init (cell i r02 b))\n(init (cell i r03 b))\n(init (cell i r04 b))\n(init (cell i r05 b))\n(init (cell i r06 b))\n(init (cell i r07 b))\n(init (cell i r08 b))\n(init (cell i r09 b))\n(init (cell i r10 b))\n(init (cell j r01 b))\n(init (cell j r02 b))\n(init (cell j r03 b))\n(init (cell j r04 b))\n(init (cell j r05 b))\n(init (cell j r06 b))\n(init (cell j r07 b))\n(init (cell j r08 b))\n(init (cell j r09 b))\n(init (cell j r10 b))\n(init (step s1))\n(<= (next (cell ?x ?y q))\n(does player (place ?x ?y)))\n(<= (next (cell ?x ?y ?c))\n(true (cell ?x ?y ?c))\n(not (does player (place ?x ?y))))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(succ s0 s1)\n(succ s1 s2)\n(succ s2 s3)\n(succ s3 s4)\n(succ s4 s5)\n(succ s5 s6)\n(succ s6 s7)\n(succ s7 s8)\n(succ s8 s9)\n(succ s9 s10)\n(succ s10 s11)\n(number s0)\n(number s1)\n(number s2)\n(number s3)\n(number s4)\n(number s5)\n(number s6)\n(number s7)\n(number s8)\n(number s9)\n(number s10)\n(number s11)\n(<= (legal player (place ?x ?y))\n(true (cell ?x ?y b)))\n(adjacent r01 r02)\n(adjacent r02 r03)\n(adjacent r03 r04)\n(adjacent r04 r05)\n(adjacent r05 r06)\n(adjacent r06 r07)\n(adjacent r07 r08)\n(adjacent r08 r09)\n(adjacent r09 r10)\n(nextcolumn a b)\n(nextcolumn b c)\n(nextcolumn c d)\n(nextcolumn d e)\n(nextcolumn e f)\n(nextcolumn f g)\n(nextcolumn g h)\n(nextcolumn h i)\n(nextcolumn i j)\n(coordinate r01)\n(coordinate r02)\n(coordinate r03)\n(coordinate r04)\n(coordinate r05)\n(coordinate r06)\n(coordinate r07)\n(coordinate r08)\n(coordinate r09)\n(coordinate r10)\n(coordinate a)\n(coordinate b)\n(coordinate c)\n(coordinate d)\n(coordinate e)\n(coordinate f)\n(coordinate g)\n(coordinate h)\n(coordinate i)\n(coordinate j)\n(<= (attacks ?n)\n(columns a s0 ?n))\n(<= (columns j ?m ?n)\n(rows j r01 ?m ?n))\n(<= (columns ?x ?m ?n)\n(nextcolumn ?x ?y)\n(rows ?x r01 ?m ?k)\n(columns ?y ?k ?n))\n(<= (rows ?x r10 ?m ?n)\n(attack ?x r10 ?m ?n))\n(<= (rows ?x ?y ?m ?n)\n(adjacent ?y ?z)\n(attack ?x ?y ?m ?k)\n(rows ?x ?z ?k ?n))\n(<= (attack ?x ?y ?n ?n)\n(true (cell ?x ?y b))\n(number ?n))\n(<= (attack ?x ?y ?n ?n)\n(true (cell ?x ?y q))\n(not (attacked ?x ?y))\n(number ?n))\n(<= (attack ?x ?y ?m ?n)\n(true (cell ?x ?y q))\n(attacked ?x ?y)\n(succ ?m ?n))\n(<= (attacked ?x ?y)\n(true (cell ?u ?v q))\n(queenmove ?u ?v ?x ?y))\n(<= (queenmove ?x ?y ?x ?z)\n(distinct ?y ?z)\n(coordinate ?x)\n(coordinate ?y)\n(coordinate ?z))\n(<= (queenmove ?x ?z ?y ?z)\n(distinct ?x ?y)\n(coordinate ?x)\n(coordinate ?y)\n(coordinate ?z))\n(<= (queenmove ?u ?v ?x ?y)\n(northeast ?u ?v ?x ?y))\n(<= (queenmove ?u ?v ?x ?y)\n(northeast ?x ?y ?u ?v))\n(<= (queenmove ?u ?v ?x ?y)\n(northwest ?u ?v ?x ?y))\n(<= (queenmove ?u ?v ?x ?y)\n(northwest ?x ?y ?u ?v))\n(<= (northeast ?u ?v ?x ?y)\n(nextcolumn ?u ?x)\n(adjacent ?v ?y))\n(<= (northeast ?u ?v ?y ?z)\n(nextcolumn ?u ?w)\n(adjacent ?v ?x)\n(northeast ?w ?x ?y ?z))\n(<= (northwest ?u ?v ?x ?y)\n(nextcolumn ?x ?u)\n(adjacent ?v ?y))\n(<= (northwest ?u ?v ?y ?z)\n(nextcolumn ?w ?u)\n(adjacent ?v ?x)\n(northwest ?w ?x ?y ?z))\n(<= (goal player ?v)\n(attacks ?n)\n(mapnum2val ?n ?v))\n(mapnum2val s0 100)\n(mapnum2val s2 90)\n(mapnum2val s3 80)\n(mapnum2val s4 70)\n(mapnum2val s5 60)\n(mapnum2val s6 50)\n(mapnum2val s7 40)\n(mapnum2val s8 0)\n(mapnum2val s9 0)\n(mapnum2val s10 0)\n(<= terminal\n(true (step s11)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 board with coordinates labeled by columns from 'a' to 'h' and rows from 1 to 8, where each cell can be occupied by a piece or be empty. There are two players, White and Black, who alternate turns starting with White. Initially, nearly all cells are empty except for White's king positioned at e1, White's rook at h1, and Black's king at d8; it is White's turn to move first, and the game step counter starts at 1. On a player's turn, they may either move a piece according to legal move rules or, if it is not their turn, perform a no-operation (noop). Moves are represented by actions specifying the piece to move, its current coordinates, and the destination coordinates; for White, legal moves include moving the king or rook to an empty cell that is not restricted, while Black can move only the king to an empty cell that is neither attacked nor guarded. The king moves one square horizontally, vertically, or diagonally to an adjacent square, whereas the rook moves any number of squares along a clear row or column without jumping over other pieces. Restrictions on Black's king movement include avoiding squares attacked by White's rook or guarded by White's king, while White's pieces cannot move into restricted squares. After a move, the piece occupies the destination cell, and the origin cell becomes empty. Control switches to the opposing player, and the step counter increments by one. The game implicitly enforces board boundaries and rules of adjacency for movement, preventing pieces from moving off the board or onto occupied squares except when capturing is not allowed here. The game ends either when a checkmate occurs—defined as Black's king being attacked and unable to move to any safe square—or when 15 steps have been completed. Scoring is binary: White wins with a score of 100 if checkmate is achieved, otherwise zero, and Black wins with 100 points if the game ends without checkmate, otherwise zero. The objective for White is to checkmate Black within 15 moves, while Black aims to avoid checkmate until the step limit is reached.",
    "output": "(role white)\n(role black)\n(init (cell a 1 b))\n(init (cell a 2 b))\n(init (cell a 3 b))\n(init (cell a 4 b))\n(init (cell a 5 b))\n(init (cell a 6 b))\n(init (cell a 7 b))\n(init (cell a 8 b))\n(init (cell b 1 b))\n(init (cell b 2 b))\n(init (cell b 3 b))\n(init (cell b 4 b))\n(init (cell b 5 b))\n(init (cell b 6 b))\n(init (cell b 7 b))\n(init (cell b 8 b))\n(init (cell c 1 b))\n(init (cell c 2 b))\n(init (cell c 3 b))\n(init (cell c 4 b))\n(init (cell c 5 b))\n(init (cell c 6 b))\n(init (cell c 7 b))\n(init (cell c 8 b))\n(init (cell d 1 b))\n(init (cell d 2 b))\n(init (cell d 3 b))\n(init (cell d 4 b))\n(init (cell d 5 b))\n(init (cell d 6 b))\n(init (cell d 7 b))\n(init (cell d 8 bk))\n(init (cell e 1 wk))\n(init (cell e 2 b))\n(init (cell e 3 b))\n(init (cell e 4 b))\n(init (cell e 5 b))\n(init (cell e 6 b))\n(init (cell e 7 b))\n(init (cell e 8 b))\n(init (cell f 1 b))\n(init (cell f 2 b))\n(init (cell f 3 b))\n(init (cell f 4 b))\n(init (cell f 5 b))\n(init (cell f 6 b))\n(init (cell f 7 b))\n(init (cell f 8 b))\n(init (cell g 1 b))\n(init (cell g 2 b))\n(init (cell g 3 b))\n(init (cell g 4 b))\n(init (cell g 5 b))\n(init (cell g 6 b))\n(init (cell g 7 b))\n(init (cell g 8 b))\n(init (cell h 1 wr))\n(init (cell h 2 b))\n(init (cell h 3 b))\n(init (cell h 4 b))\n(init (cell h 5 b))\n(init (cell h 6 b))\n(init (cell h 7 b))\n(init (cell h 8 b))\n(init (control white))\n(init (step 1))\n(<= (next (cell ?x ?y ?p))\n    (does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?u ?v b))\n    (does ?player (move ?p ?u ?v ?x ?y)))\n(<= (next (cell ?w ?z b))\n    (does ?player (move ?p ?u ?v ?x ?y))\n    (true (cell ?w ?z b))\n    (or (distinct ?w ?x) (distinct ?z ?y)))\n(<= (next (cell ?w ?z ?q))\n    (does ?player (move ?p ?u ?v ?x ?y))\n    (true (cell ?w ?z ?q))\n    (distinct ?p ?q))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (successor ?x ?y))\n(successor 1 2)\n(successor 2 3)\n(successor 3 4)\n(successor 4 5)\n(successor 5 6)\n(successor 6 7)\n(successor 7 8)\n(successor 8 9)\n(successor 9 10)\n(successor 10 11)\n(successor 11 12)\n(successor 12 13)\n(successor 13 14)\n(successor 14 15)\n(<= (legal white (move wk ?u ?v ?x ?y))\n    (true (control white))\n    (true (cell ?u ?v wk))\n    (kingmove ?u ?v ?x ?y)\n    (true (cell ?x ?y b))\n    (not (restricted ?x ?y)))\n(<= (legal white (move wr ?u ?v ?x ?y))\n    (true (control white))\n    (true (cell ?u ?v wr))\n    (rookmove ?u ?v ?x ?y)\n    (true (cell ?x ?y b))\n    (not (restricted ?x ?y)))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black (move bk ?u ?v ?x ?y))\n    (true (control black))\n    (true (cell ?u ?v bk))\n    (kingmove ?u ?v ?x ?y)\n    (true (cell ?x ?y b))\n    (not (attacked ?x ?y))\n    (not (guarded ?x ?y)))\n(<= (legal black noop)\n    (true (control white)))\n(<= (kingmove ?u ?v ?u ?y)\n    (or (adjacent ?v ?y) (adjacent ?y ?v))\n    (file ?u))\n(<= (kingmove ?u ?v ?x ?v)\n    (or (nextcolumn ?u ?x) (nextcolumn ?x ?u))\n    (rank ?v))\n(<= (kingmove ?u ?v ?x ?y)\n    (or (nextcolumn ?u ?x) (nextcolumn ?x ?u))\n    (or (adjacent ?v ?y) (adjacent ?y ?v)))\n(<= (rookmove ?u ?v ?u ?y)\n    (clearcolumn ?u ?v ?y))\n(<= (rookmove ?u ?v ?u ?y)\n    (clearcolumn ?u ?y ?v))\n(<= (rookmove ?u ?v ?x ?v)\n    (clearrow ?u ?x ?v))\n(<= (rookmove ?u ?v ?x ?v)\n    (clearrow ?x ?u ?v))\n(<= checkmate\n    check\n    stuck)\n(<= check\n    (true (cell ?u ?v bk))\n    (attacked ?u ?v))\n(<= stuck\n    (not canmove))\n(<= canmove\n    (true (cell ?u ?v bk))\n    (kingmove ?u ?v ?x ?y)\n    (not (attacked ?x ?y))\n    (not (guarded ?x ?y)))\n(<= (restricted ?x ?y)\n    (true (cell ?u ?v bk))\n    (kingmove ?u ?v ?x ?y))\n(<= (guarded ?x ?y)\n    (true (cell ?u ?v wk))\n    (kingmove ?u ?v ?x ?y))\n(<= (attacked ?u ?w)\n    (true (cell ?u ?v wr))\n    (clearcolumn ?u ?v ?w))\n(<= (attacked ?u ?v)\n    (true (cell ?u ?w wr))\n    (clearcolumn ?u ?v ?w))\n(<= (attacked ?u ?v)\n    (true (cell ?x ?v wr))\n    (clearrow ?u ?x ?v))\n(<= (attacked ?u ?v)\n    (true (cell ?u ?v wr))\n    (clearrow ?u ?x ?v))\n(<= (clearcolumn ?u ?v ?y)\n    (adjacent ?v ?y)\n    (file ?u))\n(<= (clearcolumn ?u ?v ?y)\n    (adjacent ?v ?w)\n    (true (cell ?u ?w b))\n    (clearcolumn ?u ?w ?y))\n(<= (clearrow ?u ?x ?v)\n    (nextcolumn ?u ?x)\n    (rank ?v))\n(<= (clearrow ?u ?x ?v)\n    (nextcolumn ?u ?w)\n    (true (cell ?w ?v b))\n    (clearrow ?w ?x ?v))\n(adjacent 1 2)\n(adjacent 2 3)\n(adjacent 3 4)\n(adjacent 4 5)\n(adjacent 5 6)\n(adjacent 6 7)\n(adjacent 7 8)\n(nextcolumn a b)\n(nextcolumn b c)\n(nextcolumn c d)\n(nextcolumn d e)\n(nextcolumn e f)\n(nextcolumn f g)\n(nextcolumn g h)\n(<= (rank ?y)\n\t(or (adjacent ?x ?y) (adjacent ?y ?x)))\n(<= (file ?x)\n\t(or (nextcolumn ?x ?y) (nextcolumn ?y ?x)))\n(<= (goal white 100)\n    checkmate)\n(<= (goal white 0)\n    (not checkmate))\n(<= (goal black 100)\n    (not checkmate))\n(<= (goal black 0)\n    checkmate)\n(<= terminal\n    (true (step 15)))\n(<= terminal\n    checkmate)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is a single-player puzzle played on a three-dimensional grid composed of three layers, each layer containing a 3x3 matrix of cells, resulting in a total of 27 cells arranged by three indices: the first and second indices identify the layer and its row, while the third and fourth indices specify the position within each 3x3 subgrid. The coordinate system uses integers from 1 to 3 for each dimension to denote positions precisely within this structure. The sole player, designated as \"robot,\" takes sequential turns to make moves, with the game starting from an initial state where certain cells are pre-filled with digits from 1 to 9, and others are blank, represented by 'b'. On each turn, the player can perform a single action called \"mark,\" which involves placing a digit (1 through 9) into one of the currently blank cells. Legal moves require that the chosen cell is blank and that the digit to be placed does not already appear in the corresponding row, column, or 3x3 square of the given layer and position, enforcing Sudoku-like constraints across the three-dimensional arrangement. Each action updates the game state by filling the chosen cell with the specified digit, replacing the blank status, while all other cells remain unchanged. The game proceeds until no further legal moves are available—meaning there are no blank cells where digits can be validly placed according to the rules—at which point the game ends. Since there is only one player, there is no turn order complexity or need for a no-operation (noop) action; the player must always place a digit if a legal move exists. The board's boundaries are implicitly defined by the indices ranging from 1 to 3, ensuring all placements are within the 3x3x3 grid and preventing any out-of-bounds moves. Occupancy conflicts are avoided by only allowing marks on blank cells, and distance relationships are governed by the Sudoku-like rules preventing repeated digits in the same row, column, or 3x3 square within the relevant dimensions. The goal is to fill the entire board correctly, and the player receives a perfect score of 100 upon successfully filling all cells without violating any constraints; otherwise, the score remains zero. The game terminates when no further playable moves exist, marking either successful completion or a state where no legal digit placements can be made.",
    "output": "(role robot)\n  (init (cell 1 1 1 1 b))\n  (init (cell 1 1 1 2 b))\n  (init (cell 1 1 1 3 b))\n  (init (cell 1 1 2 1 b))\n  (init (cell 1 1 2 2 4))\n  (init (cell 1 1 2 3 1))\n  (init (cell 1 1 3 1 b))\n  (init (cell 1 1 3 2 b))\n  (init (cell 1 1 3 3 b))\n  (init (cell 1 2 1 1 b))\n  (init (cell 1 2 1 2 6))\n  (init (cell 1 2 1 3 b))\n  (init (cell 1 2 2 1 b))\n  (init (cell 1 2 2 2 b))\n  (init (cell 1 2 2 3 b))\n  (init (cell 1 2 3 1 2))\n  (init (cell 1 2 3 2 b))\n  (init (cell 1 2 3 3 b))\n  (init (cell 1 3 1 1 b))\n  (init (cell 1 3 1 2 b))\n  (init (cell 1 3 1 3 b))\n  (init (cell 1 3 2 1 b))\n  (init (cell 1 3 2 2 b))\n  (init (cell 1 3 2 3 b))\n  (init (cell 1 3 3 1 b))\n  (init (cell 1 3 3 2 b))\n  (init (cell 1 3 3 3 b))\n  (init (cell 2 1 1 1 3))\n  (init (cell 2 1 1 2 2))\n  (init (cell 2 1 1 3 b))\n  (init (cell 2 1 2 1 6))\n  (init (cell 2 1 2 2 b))\n  (init (cell 2 1 2 3 b))\n  (init (cell 2 1 3 1 b))\n  (init (cell 2 1 3 2 b))\n  (init (cell 2 1 3 3 b))\n  (init (cell 2 2 1 1 b))\n  (init (cell 2 2 1 2 b))\n  (init (cell 2 2 1 3 b))\n  (init (cell 2 2 2 1 b))\n  (init (cell 2 2 2 2 5))\n  (init (cell 2 2 2 3 b))\n  (init (cell 2 2 3 1 b))\n  (init (cell 2 2 3 2 4))\n  (init (cell 2 2 3 3 1))\n  (init (cell 2 3 1 1 7))\n  (init (cell 2 3 1 2 b))\n  (init (cell 2 3 1 3 b))\n  (init (cell 2 3 2 1 b))\n  (init (cell 2 3 2 2 b))\n  (init (cell 2 3 2 3 b))\n  (init (cell 2 3 3 1 b))\n  (init (cell 2 3 3 2 b))\n  (init (cell 2 3 3 3 b))\n  (init (cell 3 1 1 1 b))\n  (init (cell 3 1 1 2 b))\n  (init (cell 3 1 1 3 b))\n  (init (cell 3 1 2 1 2))\n  (init (cell 3 1 2 2 b))\n  (init (cell 3 1 2 3 b))\n  (init (cell 3 1 3 1 3))\n  (init (cell 3 1 3 2 b))\n  (init (cell 3 1 3 3 b))\n  (init (cell 3 2 1 1 b))\n  (init (cell 3 2 1 2 4))\n  (init (cell 3 2 1 3 8))\n  (init (cell 3 2 2 1 b))\n  (init (cell 3 2 2 2 b))\n  (init (cell 3 2 2 3 b))\n  (init (cell 3 2 3 1 b))\n  (init (cell 3 2 3 2 b))\n  (init (cell 3 2 3 3 b))\n  (init (cell 3 3 1 1 5))\n  (init (cell 3 3 1 2 b))\n  (init (cell 3 3 1 3 1))\n  (init (cell 3 3 2 1 b))\n  (init (cell 3 3 2 2 b))\n  (init (cell 3 3 2 3 b))\n  (init (cell 3 3 3 1 b))\n  (init (cell 3 3 3 2 b))\n  (init (cell 3 3 3 3 b))\n  (<= (legal robot (mark ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l b))\n      (digit ?x)\n      (not (row ?k ?l ?x))\n      (not (col ?i ?j ?x))\n      (not (square ?i ?k ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 1 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 2 3 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 1 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 2 ?k ?l ?x)))\n  (<= (row ?k ?l ?x) (true (cell 3 3 ?k ?l ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 1 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 2 3 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 1 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 2 ?x)))\n  (<= (col ?i ?j ?x) (true (cell ?i ?j 3 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 1 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 2 ?k 3 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 1 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 2 ?x)))\n  (<= (square ?i ?k ?x) (true (cell ?i 3 ?k 3 ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?i ?j ?k ?l ?x)))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?s ?i))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?t ?j))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?u ?k))\n  (<= (next (cell ?i ?j ?k ?l ?x))\n      (true (cell ?i ?j ?k ?l ?x))\n      (does ?role (mark ?s ?t ?u ?v ?y))\n      (distinct ?v ?l))\n  (<= (goal robot 100) (not open))\n  (<= (goal robot 0) open)\n  (<= terminal (not playable))\n  (<= (filler ?x) (digit ?x))\n  (filler b)\n  (<= open (true (cell ?i ?j ?k ?l b)))\n  (<= playable (legal robot (mark ?i ?j ?k ?l ?x)))\n  (index 1)\n  (index 2)\n  (index 3)\n  (digit 1)\n  (digit 2)\n  (digit 3)\n  (digit 4)\n  (digit 5)\n  (digit 6)\n  (digit 7)\n  (digit 8)\n  (digit 9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on a 9-by-9 grid where each cell is identified by coordinates ranging from 1 to 9 in both the horizontal (file) and vertical (rank) directions, establishing a coordinate system with files numbered 1 through 9 and ranks numbered 1 through 9. The board initially contains a single hero character positioned at cell (5,5) and six zombies placed at specific cells: (1,3), (9,7), (7,1), (3,9), (1,1), and (9,9). The game involves only one player role, the hero, who takes turns acting alone. Turns alternate between two phases named \"move\" and \"shoot,\" beginning with the \"move\" phase at step one. During the \"move\" phase, the hero may move to an adjacent cell—one step up, down, left, or right—or choose to perform a no-operation (movenoop), effectively passing the move phase without changing position. Movement is strictly constrained to adjacent cells within the board boundaries; the hero cannot move outside the 1-to-9 coordinate range. During the \"shoot\" phase, the hero may shoot at a zombie located along a straight, unobstructed line in one of eight directions (north, northeast, east, southeast, south, southwest, west, northwest) from the hero’s current position, or opt to perform a shooting no-operation (shootnoop). A shot is legal only if a zombie occupies a cell in line with the hero’s position and the path between hero and target is unobstructed by other pieces. The hero’s actions are represented as either move commands specifying the target cell coordinates, shoot commands specifying the target zombie’s cell coordinates, or corresponding no-operation commands. After the hero moves during the move phase, the zombies automatically respond by moving one cell closer to the hero along the shortest path, advancing towards the hero’s position if the hero has just moved, or remaining stationary if the hero performed a no-op or shot. Zombies cannot occupy the same cell as other zombies, and their movement respects the board boundaries. When the hero successfully shoots a zombie, that zombie is eliminated if it is the highest-indexed zombie in that cell; otherwise, the zombie with the next higher index remains, reflecting a hierarchy among zombies. New zombies enter the board in a cyclic sequence at predetermined cells corresponding to a circular count that increments each turn. The game keeps track of the number of zombies eliminated (bodycount), incrementing it each time the hero kills a zombie. The game proceeds in steps, incrementing each turn, with step counts tracked up to a maximum of 50. The game terminates under three conditions: when all zombies (20 in total) have been killed, when the hero loses brains (which occurs if a zombie occupies the same cell as the hero), or when 50 steps have elapsed. The hero scores 100 points for eliminating all zombies without losing brains, scores zero if brains are lost at any point, and scores 50 points otherwise if neither condition is met by the end of the game. Throughout play, the hero must avoid losing brains by preventing zombie occupation of the hero’s cell, and must strategically move and shoot to eliminate zombies while managing the cyclical arrival of new zombies on the board. The turn control mechanism enforces that the hero alternates moves and shoots in this fixed order, with the option to pass phases via no-operations, enabling the hero to plan positioning and attacks while zombies autonomously advance or spawn according to the game’s rules.",
    "output": "(role hero)\n(init (cell 1 3 zombie 1))\n(init (cell 9 7 zombie 2))\n(init (cell 7 1 zombie 3))\n(init (cell 3 9 zombie 4))\n(init (cell 1 1 zombie 5))\n(init (cell 9 9 zombie 6))\n(init (cell 5 5 hero 1))\n(init (step 1))\n(init (bodycount 0))\n(init (circcount 1))\n(init move)\n(<= (next (cell ?x ?y hero 1))\n    (does hero (move ?x ?y)))\n(<= (next (cell ?x ?y hero 1))\n    (true (cell ?x ?y hero 1))\n    (or (does hero movenoop)\n        (does hero shootnoop)\n        (does hero (shoot ?m ?n))))\n(<= (next (cell ?x ?y zombie ?z))\n    (true (cell ?x ?y zombie ?z))\n    (or (does hero (move ?m ?n))\n        (does hero movenoop)))\n(<= (next (cell ?x ?y zombie ?z))\n    (true (cell ?m ?n zombie ?z))\n    (or (not (does hero (shoot ?m ?n)))\n        (lowerzombieincell ?m ?n ?z))\n    (true (cell ?j ?k hero 1))\n    (towardshero ?m ?x ?j)\n    (towardshero ?n ?y ?k)\n    (true shoot))\n(<= (next (cell ?x ?y zombie ?z))\n    (newpiece ?circcount ?x ?y)\n    (nextzombie ?z)\n    (true (circcount ?circcount))\n    (true shoot))\n(<= (next (step ?np1))\n    (true (step ?n))\n    (movesucc ?n ?np1))\n(<= (next (bodycount ?n))\n    (true (bodycount ?n))\n    (or (does hero (move ?x ?y))\n        (does hero movenoop)\n        (does hero shootnoop)))\n(<= (next (bodycount ?np1))\n    (true (bodycount ?n))\n    (bodycountsucc ?n ?np1)\n    (true (cell ?x ?y zombie ?z))\n    (does hero (shoot ?x ?y))\n    (not (lowerzombieincell ?x ?y ?z)))\n(<= (next move) (true shoot))\n(<= (next shoot) (true move))\n(<= (next (circcount ?np1))\n    (nextcirccount ?n ?np1)\n    (true (circcount ?n)))\n(<= allZombiesKilled\n    (true (bodycount 20)))\n(<= (legal hero (move ?x ?y))\n    (true (cell ?x ?y hero 1))\n    (true move))\n(<= (legal hero (move ?x ?y))\n    (true (cell ?n ?y hero 1))\n    (succ ?n ?x)\n    (true move))\n(<= (legal hero (move ?x ?y))\n    (true (cell ?n ?y hero 1))\n    (succ ?x ?n)\n    (true move))\n(<= (legal hero (move ?x ?y))\n    (true (cell ?x ?n hero 1))\n    (succ ?y ?n)\n    (true move))\n(<= (legal hero (move ?x ?y))\n    (true (cell ?x ?n hero 1))\n    (succ ?n ?y)\n    (true move))\n(<= (legal hero (shoot ?x1 ?y1))\n    (true (cell ?x2 ?y2 hero 1))\n    (true (cell ?x1 ?y1 zombie ?z))\n    (dir ?dir)\n    (openBetween ?x1 ?y1 ?x2 ?y2 ?dir)\n    (true shoot))\n(<= (legal hero movenoop)\n    (true move))\n(<= (legal hero shootnoop)\n    (true shoot))\n(<= brainslost\n    (true (cell ?x ?y zombie ?z))\n    (true (cell ?x ?y hero 1))\n    (index ?x)\n    (index ?y))\n(<= (lowerzombieincell ?m ?n ?z)\n    (true (cell ?m ?n zombie ?zother))\n    (distinct ?z ?zother)\n    (ltzombie ?zother ?z))\n(<= (openBetween ?x1 ?y1 ?x2 ?y2 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir))\n(<= (openBetween ?x1 ?y1 ?x3 ?y3 ?dir)\n    (oneInDir ?x1 ?y1 ?x2 ?y2 ?dir)\n    (openBetween ?x2 ?y2 ?x3 ?y3 ?dir))\n(<= (oneInDir ?x ?y1 ?x ?y2 n)\n    (file ?x)\n    (nextRank ?y1 ?y2))\n(<= (oneInDir ?x1 ?y1 ?x2 ?y2 ne)\n    (nextFile ?x1 ?x2)\n    (nextRank ?y1 ?y2))\n(<= (oneInDir ?x1 ?y ?x2 ?y e)\n    (nextFile ?x1 ?x2)\n    (rank ?y))\n(<= (oneInDir ?x1 ?y2 ?x2 ?y1 se)\n    (nextFile ?x1 ?x2)\n    (nextRank ?y1 ?y2))\n(<= (oneInDir ?x ?y2 ?x ?y1 s)\n    (file ?x)\n    (nextRank ?y1 ?y2))\n(<= (oneInDir ?x2 ?y2 ?x1 ?y1 sw)\n    (nextFile ?x1 ?x2)\n    (nextRank ?y1 ?y2))\n(<= (oneInDir ?x2 ?y ?x1 ?y w)\n    (nextFile ?x1 ?x2)\n    (rank ?y))\n(<= (oneInDir ?x2 ?y1 ?x1 ?y2 nw)\n    (nextFile ?x1 ?x2)\n    (nextRank ?y1 ?y2))\n(<= (towardshero ?x ?y ?z)\n    (ltbyone ?x ?y)\n    (ltsucc ?y ?z))\n(<= (towardshero ?x ?y ?z)\n    (ltsucc ?z ?y)\n    (ltbyone ?y ?x))\n(<= (towardshero ?x ?y ?y)\n    (ltbyone ?x ?y))\n(<= (towardshero ?x ?y ?y)\n    (ltbyone ?y ?x))\n(<= (towardshero ?y ?y ?y)\n    (index ?y))\n(<= (ltsucc ?a ?b)\n    (succ ?a ?b))\n(<= (ltsucc ?a ?c)\n    (succ ?a ?b)\n    (ltsucc ?b ?c))\n(<= (ltbyone ?a ?b)\n    (succ ?a ?b))\n(<= (ltzombie ?a ?b)\n    (zombieindexsucc ?a ?b))\n(<= (ltzombie ?a ?c)\n    (zombieindexsucc ?a ?b)\n    (ltzombie ?b ?c))\n(<= (nextzombie ?z)\n    (zombieindex ?z)\n    (not (zombieinuse ?z))\n    (not (lowerzombiefree ?z)))\n(<= (zombieinuse ?z)\n    (true (cell ?m ?n zombie ?z)))\n(<= (lowerzombiefree ?z)\n    (not (zombieinuse ?otherz))\n    (distinct ?z ?otherz)\n    (ltzombie ?otherz ?z))\n(<= terminal\n    allZombiesKilled)\n(<= terminal\n    brainslost)\n(<= terminal\n    (true (step 50)))\n(<= (goal hero 100)\n    allZombiesKilled\n    (not brainslost))\n(<= (goal hero 0)\n    brainslost)\n(<= (goal hero 50)\n    (not allZombiesKilled)\n    (not brainslost))\n(nextcirccount 1 2)\n(nextcirccount 2 3)\n(nextcirccount 3 4)\n(nextcirccount 4 5)\n(nextcirccount 5 6)\n(nextcirccount 6 7)\n(nextcirccount 7 8)\n(nextcirccount 8 9)\n(nextcirccount 9 1)\n(newpiece 1 1 1)\n(newpiece 2 7 1)\n(newpiece 3 9 7)\n(newpiece 4 6 9)\n(newpiece 5 1 6)\n(newpiece 6 4 1)\n(newpiece 7 9 3)\n(newpiece 8 2 9)\n(newpiece 9 1 3)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(bodycountsucc 0 1)\n(bodycountsucc 1 2)\n(bodycountsucc 2 3)\n(bodycountsucc 3 4)\n(bodycountsucc 4 5)\n(bodycountsucc 5 6)\n(bodycountsucc 6 7)\n(bodycountsucc 7 8)\n(bodycountsucc 8 9)\n(bodycountsucc 9 10)\n(bodycountsucc 10 11)\n(bodycountsucc 11 12)\n(bodycountsucc 12 13)\n(bodycountsucc 13 14)\n(bodycountsucc 14 15)\n(bodycountsucc 15 16)\n(bodycountsucc 16 17)\n(bodycountsucc 17 18)\n(bodycountsucc 18 19)\n(bodycountsucc 19 20)\n(bodycountsucc 20 21)\n(bodycountsucc 21 22)\n(bodycountsucc 22 23)\n(bodycountsucc 23 24)\n(bodycountsucc 24 25)\n(bodycountsucc 25 26)\n(bodycountsucc 26 27)\n(bodycountsucc 27 28)\n(bodycountsucc 28 29)\n(bodycountsucc 29 30)\n(dir n)\n(dir s)\n(dir e)\n(dir w)\n(dir nw)\n(dir ne)\n(dir se)\n(dir sw)\n(file 1)\n(file 2)\n(file 3)\n(file 4)\n(file 5)\n(file 6)\n(file 7)\n(file 8)\n(file 9)\n(nextFile 1 2)\n(nextFile 2 3)\n(nextFile 3 4)\n(nextFile 4 5)\n(nextFile 5 6)\n(nextFile 6 7)\n(nextFile 7 8)\n(nextFile 8 9)\n(rank 1)\n(rank 2)\n(rank 3)\n(rank 4)\n(rank 5)\n(rank 6)\n(rank 7)\n(rank 8)\n(rank 9)\n(nextRank 1 2)\n(nextRank 2 3)\n(nextRank 3 4)\n(nextRank 4 5)\n(nextRank 5 6)\n(nextRank 6 7)\n(nextRank 7 8)\n(nextRank 8 9)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(zombieindex 1)\n(zombieindex 2)\n(zombieindex 3)\n(zombieindex 4)\n(zombieindex 5)\n(zombieindex 6)\n(zombieindex 7)\n(zombieindex 8)\n(zombieindex 9)\n(zombieindex 10)\n(zombieindexsucc 1 2)\n(zombieindexsucc 2 3)\n(zombieindexsucc 3 4)\n(zombieindexsucc 4 5)\n(zombieindexsucc 5 6)\n(zombieindexsucc 6 7)\n(zombieindexsucc 7 8)\n(zombieindexsucc 8 9)\n(zombieindexsucc 9 10)\n(zombieindexsucc 10 11)\n(movesucc 0 1)\n(movesucc 1 2)\n(movesucc 2 3)\n(movesucc 3 4)\n(movesucc 4 5)\n(movesucc 5 6)\n(movesucc 6 7)\n(movesucc 7 8)\n(movesucc 8 9)\n(movesucc 9 10)\n(movesucc 10 11)\n(movesucc 11 12)\n(movesucc 12 13)\n(movesucc 13 14)\n(movesucc 14 15)\n(movesucc 15 16)\n(movesucc 16 17)\n(movesucc 17 18)\n(movesucc 18 19)\n(movesucc 19 20)\n(movesucc 20 21)\n(movesucc 21 22)\n(movesucc 22 23)\n(movesucc 23 24)\n(movesucc 24 25)\n(movesucc 25 26)\n(movesucc 26 27)\n(movesucc 27 28)\n(movesucc 28 29)\n(movesucc 29 30)\n(movesucc 30 31)\n(movesucc 31 32)\n(movesucc 32 33)\n(movesucc 33 34)\n(movesucc 34 35)\n(movesucc 35 36)\n(movesucc 36 37)\n(movesucc 37 38)\n(movesucc 38 39)\n(movesucc 39 40)\n(movesucc 40 41)\n(movesucc 41 42)\n(movesucc 42 43)\n(movesucc 43 44)\n(movesucc 44 45)\n(movesucc 45 46)\n(movesucc 46 47)\n(movesucc 47 48)\n(movesucc 48 49)\n(movesucc 49 50)\n(movesucc 50 51)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 3-by-3 grid with rows and columns indexed from 1 to 3, establishing a coordinate system where each cell is identified by a pair of indices (row, column). There are two players, named xPlayer and oPlayer, who alternate turns starting with xPlayer. At the beginning, the control is assigned to xPlayer, and the board is empty with no marks placed. On a player’s turn, if they have control, they may place their respective mark—'x' for xPlayer and 'o' for oPlayer—in any empty cell; a cell is considered empty if it has not been marked previously by either player. Alternatively, the player without control may perform a noop action, which essentially passes the turn without making a move. Actions are legal only if the acting player currently has control and the targeted cell for placement is empty; noop actions are only legal for the player who does not have control at that moment. When a player places their mark in a cell, the game state updates to reflect this new mark on the board, and control passes to the other player. If a player does not place a mark, the control still switches accordingly. The game enforces implicit constraints such that marks cannot be placed outside the 3x3 grid or on already occupied cells, and only one mark can occupy each cell at any time. The game reaches a terminal state under three conditions: when either player forms a winning line of three marks in a row, column, or diagonal; or when there are no empty cells remaining and no winning line has been formed, resulting in a draw. A winning line is defined as three identical marks aligned horizontally, vertically, or diagonally across the grid. Scoring reflects these conditions: a player receives 100 points if they have formed a winning line, 50 points if the game ends in a draw (no lines and no empty spaces), and 0 points if the opponent forms a winning line or if the game ends prematurely with empty spaces but no line. Thus, the game's objective is for each player to strategically place their marks to create a line of three while preventing the opponent from doing so, with turns alternating between players and moves constrained to empty cells within the 3x3 board.",
    "output": "(role xPlayer)\n(role oPlayer)\n(init (control xPlayer))\n(<= (legal xPlayer noop)\n    (true (control oPlayer)))\n(<= (legal xPlayer (play 1 1 x))\n    (true (control xPlayer))\n\t(emptyCell 1 1))\n(<= (legal xPlayer (play 1 2 x))\n    (true (control xPlayer))\n\t(emptyCell 1 2))\n(<= (legal xPlayer (play 1 3 x))\n    (true (control xPlayer))\n\t(emptyCell 1 3))\n(<= (legal xPlayer (play 2 1 x))\n    (true (control xPlayer))\n\t(emptyCell 2 1))\n(<= (legal xPlayer (play 2 2 x))\n    (true (control xPlayer))\n\t(emptyCell 2 2))\n(<= (legal xPlayer (play 2 3 x))\n    (true (control xPlayer))\n\t(emptyCell 2 3))\n(<= (legal xPlayer (play 3 1 x))\n    (true (control xPlayer))\n\t(emptyCell 3 1))\n(<= (legal xPlayer (play 3 2 x))\n    (true (control xPlayer))\n\t(emptyCell 3 2))\n(<= (legal xPlayer (play 3 3 x))\n    (true (control xPlayer))\n\t(emptyCell 3 3))\n(<= (legal oPlayer noop)\n    (true (control xPlayer)))\n(<= (legal oPlayer (play 1 1 o))\n    (true (control oPlayer))\n\t(emptyCell 1 1))\n(<= (legal oPlayer (play 1 2 o))\n    (true (control oPlayer))\n\t(emptyCell 1 2))\n(<= (legal oPlayer (play 1 3 o))\n    (true (control oPlayer))\n\t(emptyCell 1 3))\n(<= (legal oPlayer (play 2 1 o))\n    (true (control oPlayer))\n\t(emptyCell 2 1))\n(<= (legal oPlayer (play 2 2 o))\n    (true (control oPlayer))\n\t(emptyCell 2 2))\n(<= (legal oPlayer (play 2 3 o))\n    (true (control oPlayer))\n\t(emptyCell 2 3))\n(<= (legal oPlayer (play 3 1 o))\n    (true (control oPlayer))\n\t(emptyCell 3 1))\n(<= (legal oPlayer (play 3 2 o))\n    (true (control oPlayer))\n\t(emptyCell 3 2))\n(<= (legal oPlayer (play 3 3 o))\n    (true (control oPlayer))\n\t(emptyCell 3 3))\n(<= (next (mark 1 1 x))\n    (role xPlayer)\n    (does xPlayer (play 1 1 x)))\n(<= (next (mark 1 2 x))\n    (role xPlayer)\n    (does xPlayer (play 1 2 x)))\n(<= (next (mark 1 3 x))\n    (role xPlayer)\n    (does xPlayer (play 1 3 x)))\n(<= (next (mark 2 1 x))\n    (role xPlayer)\n    (does xPlayer (play 2 1 x)))\n(<= (next (mark 2 2 x))\n    (role xPlayer)\n    (does xPlayer (play 2 2 x)))\n(<= (next (mark 2 3 x))\n    (role xPlayer)\n    (does xPlayer (play 2 3 x)))\n(<= (next (mark 3 1 x))\n    (role xPlayer)\n    (does xPlayer (play 3 1 x)))\n(<= (next (mark 3 2 x))\n    (role xPlayer)\n    (does xPlayer (play 3 2 x)))\n(<= (next (mark 3 3 x))\n    (role xPlayer)\n    (does xPlayer (play 3 3 x)))\n(<= (next (mark 1 1 o))\n    (role oPlayer)\n    (does oPlayer (play 1 1 o)))\n(<= (next (mark 1 2 o))\n    (role oPlayer)\n    (does oPlayer (play 1 2 o)))\n(<= (next (mark 1 3 o))\n    (role oPlayer)\n    (does oPlayer (play 1 3 o)))\n(<= (next (mark 2 1 o))\n    (role oPlayer)\n    (does oPlayer (play 2 1 o)))\n(<= (next (mark 2 2 o))\n    (role oPlayer)\n    (does oPlayer (play 2 2 o)))\n(<= (next (mark 2 3 o))\n    (role oPlayer)\n    (does oPlayer (play 2 3 o)))\n(<= (next (mark 3 1 o))\n    (role oPlayer)\n    (does oPlayer (play 3 1 o)))\n(<= (next (mark 3 2 o))\n    (role oPlayer)\n    (does oPlayer (play 3 2 o)))\n(<= (next (mark 3 3 o))\n    (role oPlayer)\n    (does oPlayer (play 3 3 o)))\n(<= (next (mark 1 1 x))\n    (true (mark 1 1 x)))\n(<= (next (mark 1 2 x))\n    (true (mark 1 2 x)))\n(<= (next (mark 1 3 x))\n    (true (mark 1 3 x)))\n(<= (next (mark 2 1 x))\n    (true (mark 2 1 x)))\n(<= (next (mark 2 2 x))\n    (true (mark 2 2 x)))\n(<= (next (mark 2 3 x))\n    (true (mark 2 3 x)))\n(<= (next (mark 3 1 x))\n    (true (mark 3 1 x)))\n(<= (next (mark 3 2 x))\n    (true (mark 3 2 x)))\n(<= (next (mark 3 3 x))\n    (true (mark 3 3 x)))\n(<= (next (mark 1 1 o))\n    (true (mark 1 1 o)))\n(<= (next (mark 1 2 o))\n    (true (mark 1 2 o)))\n(<= (next (mark 1 3 o))\n    (true (mark 1 3 o)))\n(<= (next (mark 2 1 o))\n    (true (mark 2 1 o)))\n(<= (next (mark 2 2 o))\n    (true (mark 2 2 o)))\n(<= (next (mark 2 3 o))\n    (true (mark 2 3 o)))\n(<= (next (mark 3 1 o))\n    (true (mark 3 1 o)))\n(<= (next (mark 3 2 o))\n    (true (mark 3 2 o)))\n(<= (next (mark 3 3 o))\n    (true (mark 3 3 o)))\n(<= (next (control xPlayer))\n    (true (control oPlayer)))\n(<= (next (control oPlayer))\n    (true (control xPlayer)))\n(<= terminal\n    (line x))\n(<= terminal\n    (line o))\n(<= terminal\n    (not open))\n(<= (goal xPlayer 100)\n    (line x))\n(<= (goal xPlayer 50)\n    (not (line x))\n    (not (line o))\n    (not open))\n(<= (goal xPlayer 0)\n    (line o))\n(<= (goal xPlayer 0)\n    (not (line x))\n    (not (line o))\n    open)\n(<= (goal oPlayer 100)\n    (line o))\n(<= (goal oPlayer 50)\n    (not (line x))\n    (not (line o))\n    (not open))\n(<= (goal oPlayer 0)\n    (line x))\n(<= (goal oPlayer 0)\n    (not (line x))\n    (not (line o))\n    open)\n(<= (row 1 x)\n    (true (mark 1 1 x))\n    (true (mark 1 2 x))\n    (true (mark 1 3 x)))\n(<= (row 2 x)\n    (true (mark 2 1 x))\n    (true (mark 2 2 x))\n    (true (mark 2 3 x)))\n(<= (row 3 x)\n    (true (mark 3 1 x))\n    (true (mark 3 2 x))\n    (true (mark 3 3 x)))\n(<= (row 1 o)\n    (true (mark 1 1 o))\n    (true (mark 1 2 o))\n    (true (mark 1 3 o)))\n(<= (row 2 o)\n    (true (mark 2 1 o))\n    (true (mark 2 2 o))\n    (true (mark 2 3 o)))\n(<= (row 3 o)\n    (true (mark 3 1 o))\n    (true (mark 3 2 o))\n    (true (mark 3 3 o)))\n(<= (col 1 x)\n    (true (mark 1 1 x))\n    (true (mark 2 1 x))\n    (true (mark 3 1 x)))\n(<= (col 2 x)\n    (true (mark 1 2 x))\n    (true (mark 2 2 x))\n    (true (mark 3 2 x)))\n(<= (col 3 x)\n    (true (mark 1 3 x))\n    (true (mark 2 3 x))\n    (true (mark 3 3 x)))\n(<= (col 1 o)\n    (true (mark 1 1 o))\n    (true (mark 2 1 o))\n    (true (mark 3 1 o)))\n(<= (col 2 o)\n    (true (mark 1 2 o))\n    (true (mark 2 2 o))\n    (true (mark 3 2 o)))\n(<= (col 3 o)\n    (true (mark 1 3 o))\n    (true (mark 2 3 o))\n    (true (mark 3 3 o)))\n(<= (diag x)\n    (true (mark 1 1 x))\n    (true (mark 2 2 x))\n    (true (mark 3 3 x)))\n(<= (diag o)\n    (true (mark 1 1 o))\n    (true (mark 2 2 o))\n    (true (mark 3 3 o)))\n(<= (diag x)\n    (true (mark 1 3 x))\n    (true (mark 2 2 x))\n    (true (mark 3 1 x)))\n(<= (diag o)\n    (true (mark 1 3 o))\n    (true (mark 2 2 o))\n    (true (mark 3 1 o)))\n(<= (line x)\n    (index 1)\n    (row 1 x))\n(<= (line x)\n    (index 2)\n    (row 2 x))\n(<= (line x)\n    (index 3)\n    (row 3 x))\n(<= (line o)\n    (index 1)\n    (row 1 o))\n(<= (line o)\n    (index 2)\n    (row 2 o))\n(<= (line o)\n    (index 3)\n    (row 3 o))\n(<= (line x)\n    (index 1)\n    (col 1 x))\n(<= (line x)\n    (index 2)\n    (col 2 x))\n(<= (line x)\n    (index 3)\n    (col 3 x))\n(<= (line o)\n    (index 1)\n    (col 1 o))\n(<= (line o)\n    (index 2)\n    (col 2 o))\n(<= (line o)\n    (index 3)\n    (col 3 o))\n(<= (line x)\n    (diag x))\n(<= (line o)\n    (diag o))\n(<= (emptyCell 1 1)\n    (index 1)\n    (index 1)\n    (not (true (mark 1 1 x)))\n    (not (true (mark 1 1 o))))\n(<= (emptyCell 1 2)\n    (index 1)\n    (index 2)\n    (not (true (mark 1 2 x)))\n    (not (true (mark 1 2 o))))\n(<= (emptyCell 1 3)\n    (index 1)\n    (index 3)\n    (not (true (mark 1 3 x)))\n    (not (true (mark 1 3 o))))\n(<= (emptyCell 2 1)\n    (index 2)\n    (index 1)\n    (not (true (mark 2 1 x)))\n    (not (true (mark 2 1 o))))\n(<= (emptyCell 2 2)\n    (index 2)\n    (index 2)\n    (not (true (mark 2 2 x)))\n    (not (true (mark 2 2 o))))\n(<= (emptyCell 2 3)\n    (index 2)\n    (index 3)\n    (not (true (mark 2 3 x)))\n    (not (true (mark 2 3 o))))\n(<= (emptyCell 3 1)\n    (index 3)\n    (index 1)\n    (not (true (mark 3 1 x)))\n    (not (true (mark 3 1 o))))\n(<= (emptyCell 3 2)\n    (index 3)\n    (index 2)\n    (not (true (mark 3 2 x)))\n    (not (true (mark 3 2 o))))\n(<= (emptyCell 3 3)\n    (index 3)\n    (index 3)\n    (not (true (mark 3 3 x)))\n    (not (true (mark 3 3 o))))\n(<= open\n    (emptyCell 1 1))\n(<= open\n    (emptyCell 1 2))\n(<= open\n    (emptyCell 1 3))\n(<= open\n    (emptyCell 2 1))\n(<= open\n    (emptyCell 2 2))\n(<= open\n    (emptyCell 2 3))\n(<= open\n    (emptyCell 3 1))\n(<= open\n    (emptyCell 3 2))\n(<= open\n    (emptyCell 3 3))\n(index 1) (index 2) (index 3)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 15-by-15 grid where coordinates are defined by integer indices from 1 to 15 along both the horizontal (x) and vertical (y) axes. Two players, named player1 and player2, participate in the game, taking turns alternately. The game begins with a series of setup steps, progressing sequentially through six distinct phases before entering the main play phase. Initially, player1 places black stones during the first and third setup steps, while player1 also places white stones in the second step. Player2 places white stones in the fourth step and black stones in the fifth step. After these preplacement steps, player2 chooses a color during the fourth setup step and player1 chooses a color in the sixth setup step, thereby determining each player's assigned color for the remainder of the game. Control of the turn passes between the players, with player1 and player2 alternating moves once the main phase begins. On a player's turn, if it is their control phase, they may place a stone of their assigned color onto an empty cell on the board; an empty cell is one that is within the 1 to 15 index range on both axes and is not currently occupied by any stone. If it is not their turn or if they are not involved in a preplacement step, a player may perform a noop action, which effectively passes their turn without making a move, though noop is illegal during the players' control phases except for player2 during the sixth setup step. Actions take the form of either placing a stone at specific coordinates or choosing a color during setup; placement is legal only when the targeted cell is empty and it is the player's turn to place a stone. After a placement, the cell's state updates to reflect occupation by that player's color, and control switches to the opponent player. The game automatically tracks and preserves the state of occupied cells and the color assignments of players throughout play. The game concludes when either the board is completely filled with stones or a player achieves a winning condition. A winning condition is met when a player forms an unbroken line of six stones of their color in any horizontal, vertical, or diagonal direction, where the line of six stones is bounded on both ends by either empty cells or the board edge to ensure it is not part of a longer contiguous line. If a player achieves such a six-stone line, they receive a perfect score of 100, while their opponent receives 0. If the board fills without either player forming such a line, both players receive a draw score of 50. The game enforces implicit constraints such as board boundaries defined by indices 1 through 15, no overlapping stones on any cell, and the requirement that stones must be placed only on empty cells. The turn order strictly alternates between player1 and player2 after each stone placement, ensuring fair and sequential play. Overall, the game challenges players to strategically place stones to create a consecutive line of six while preventing their opponent from doing the same on a bounded 15x15 grid.",
    "output": "(role player1)\n(role player2)\n(color black)\n(color white)\n(init (setupStep 1))\n(<= (next (setupStep 2))\n    (true (setupStep 1)))\n(<= (next (setupStep 3))\n    (true (setupStep 2)))\n(<= (next (setupStep 4))\n    (true (setupStep 3)))\n(<= (next (setupStep 5))\n    (true (setupStep 4))\n    (does player2 (place ?x ?y)))\n(<= (next (setupStep 6))\n    (true (setupStep 5)))\n(<= (next (control ?player))\n    (does ?player (pick white)))\n(<= (next (control ?opponent))\n    (does ?player (pick black))\n    (opponent ?player ?opponent))\n(<= (next (isColor ?player ?color))\n    (does ?player (pick ?color)))\n(<= (next (isColor ?opponent ?otherColor))\n    (does ?player (pick ?color))\n    (opponent ?player ?opponent)\n    (otherColor ?color ?otherColor))\n(<= (next (isColor ?player ?color))\n    (true (isColor ?player ?color)))\n(<= (preplacementStep player1 black)\n    (true (setupStep 1)))\n(<= (preplacementStep player1 white)\n    (true (setupStep 2)))\n(<= (preplacementStep player1 black)\n    (true (setupStep 3)))\n(<= (preplacementStep player2 white)\n    (true (setupStep 4)))\n(<= (preplacementStep player2 black)\n    (true (setupStep 5)))\n(<= (preplacementStepForPlayer ?player)\n    (preplacementStep ?player ?color))\n(<= (legal ?player (place ?x ?y))\n    (preplacementStep ?player ?color)\n    (empty ?x ?y))\n(<= (legal player2 (pick ?color))\n    (color ?color)\n    (true (setupStep 4)))\n(<= (legal player1 (pick ?color))\n    (color ?color)\n    (true (setupStep 6)))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player)))\n    (not (true (setupStep 6)))\n    (not (preplacementStepForPlayer ?player)))\n(<= (legal player2 noop)\n    (true (setupStep 6)))\n(<= (legal ?player (place ?x ?y))\n    (true (control ?player))\n    (empty ?x ?y))\n(<= (empty ?x ?y)\n    (index ?x)\n    (index ?y)\n    (not (occupied ?x ?y)))\n(<= (occupied ?x ?y)\n    (true (cell ?x ?y ?color)))\n(<= anyEmptyCell\n    (empty ?x ?y))\n(<= (next (control player1))\n    (true (control player2)))\n(<= (next (control player2))\n    (true (control player1)))\n(<= (next (cell ?x ?y ?color))\n    (true (cell ?x ?y ?color)))\n(<= (next (cell ?x ?y ?color))\n    (does ?player (place ?x ?y))\n    (preplacementStep ?player ?color))\n(<= (next (cell ?x ?y ?color))\n    (does ?player (place ?x ?y))\n    (true (isColor ?player ?color)))\n(<= terminal\n    (not anyEmptyCell))\n(<= terminal\n    (hasLine ?color))\n(<= (goal ?player 100)\n    (hasLine ?color)\n    (true (isColor ?player ?color)))\n(<= (goal ?player 0)\n    (opponent ?player ?opponent)\n    (true (isColor ?opponent ?theirColor))\n    (hasLine ?theirColor))\n(<= (goal ?player 50)\n    (role ?player)\n    (not (hasLine white))\n    (not (hasLine black)))\n(<= (hasLine ?color)\n    (true (cell ?x1 ?y ?color))\n    (succ ?x0 ?x1)\n    (not (true (cell ?x0 ?y ?color)))\n    (succ ?x1 ?x2)\n    (true (cell ?x2 ?y ?color))\n    (succ ?x2 ?x3)\n    (true (cell ?x3 ?y ?color))\n    (succ ?x3 ?x4)\n    (true (cell ?x4 ?y ?color))\n    (succ ?x4 ?x5)\n    (true (cell ?x5 ?y ?color))\n    (succ ?x5 ?x6)\n    (not (true (cell ?x6 ?y ?color))))\n(<= (hasLine ?color)\n    (true (cell ?x ?y1 ?color))\n    (succ ?y0 ?y1)\n    (not (true (cell ?x ?y0 ?color)))\n    (succ ?y1 ?y2)\n    (true (cell ?x ?y2 ?color))\n    (succ ?y2 ?y3)\n    (true (cell ?x ?y3 ?color))\n    (succ ?y3 ?y4)\n    (true (cell ?x ?y4 ?color))\n    (succ ?y4 ?y5)\n    (true (cell ?x ?y5 ?color))\n    (succ ?y5 ?y6)\n    (not (true (cell ?x ?y6 ?color))))\n(<= (hasLine ?color)\n    (true (cell ?x1 ?y1 ?color))\n    (succ ?x0 ?x1)\n    (succ ?y0 ?y1)\n    (not (true (cell ?x0 ?y0 ?color)))\n    (succ ?x1 ?x2)\n    (succ ?y1 ?y2)\n    (true (cell ?x2 ?y2 ?color))\n    (succ ?x2 ?x3)\n    (succ ?y2 ?y3)\n    (true (cell ?x3 ?y3 ?color))\n    (succ ?x3 ?x4)\n    (succ ?y3 ?y4)\n    (true (cell ?x4 ?y4 ?color))\n    (succ ?x4 ?x5)\n    (succ ?y4 ?y5)\n    (true (cell ?x5 ?y5 ?color))\n    (succ ?x5 ?x6)\n    (succ ?y5 ?y6)\n    (not (true (cell ?x6 ?y6 ?color))))\n(<= (hasLine ?color)\n    (true (cell ?x1 ?y1 ?color))\n    (succ ?x0 ?x1)\n    (succ ?y1 ?y0)\n    (not (true (cell ?x0 ?y0 ?color)))\n    (succ ?x1 ?x2)\n    (succ ?y2 ?y1)\n    (true (cell ?x2 ?y2 ?color))\n    (succ ?x2 ?x3)\n    (succ ?y3 ?y2)\n    (true (cell ?x3 ?y3 ?color))\n    (succ ?x3 ?x4)\n    (succ ?y4 ?y3)\n    (true (cell ?x4 ?y4 ?color))\n    (succ ?x4 ?x5)\n    (succ ?y5 ?y4)\n    (true (cell ?x5 ?y5 ?color))\n    (succ ?x5 ?x6)\n    (succ ?y6 ?y5)\n    (not (true (cell ?x6 ?y6 ?color))))\n(opponent player1 player2)\n(opponent player2 player1)\n(otherColor white black)\n(otherColor black white)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(index 11)\n(index 12)\n(index 13)\n(index 14)\n(index 15)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game is played on an 8-by-8 grid with coordinates ranging from 1 to 8 along both the horizontal (x) and vertical (y) axes. The game features two players: White and Black, who alternate turns starting with White. Initially, White pieces occupy all cells in the first two rows, specifically rows 1 and 2 across all columns from 1 to 8, while Black pieces occupy all cells in the last two rows, rows 7 and 8, similarly across all columns. Certain cells at coordinates (3,3), (3,6), (6,3), and (6,6) are designated as holes and are off-limits to any piece throughout the game. On a player’s turn, they may either move one of their pieces or pass with a noop action, but a player can only pass when it is not their turn, effectively enforcing that only the player currently in control can make a move; otherwise, noop is the only legal action. Moves involve shifting a piece one step forward or diagonally forward by one cell: for White, forward means increasing the row number by one; for Black, forward means decreasing the row number by one. A piece can move straight forward into an empty cell or diagonally forward to capture an opponent’s piece, provided the destination is not occupied by a friendly piece and is not an off-limits hole cell. Moves that would place a piece outside the board boundaries, onto a hole cell, or onto a cell occupied by the player’s own piece are illegal. The game automatically updates the board state by moving the chosen piece to the new cell and removing it from its former location, while all hole cells remain permanently off-limits. After each move, control passes to the opposing player. The game ends when a White piece reaches the back row of the Black side (row 8), when a Black piece reaches the back row of the White side (row 1), or when one player has no remaining pieces on the board. Upon termination, if White has won, White receives 100 points and Black 0; if Black has won, Black receives 100 points and White 0. The primary objective for each player is to either advance a piece to the opponent’s home row or eliminate all opposing pieces to secure victory.",
    "output": "(role white)\n(role black)\n(init (cellHolds 1 1 white))\n(init (cellHolds 2 1 white))\n(init (cellHolds 3 1 white))\n(init (cellHolds 4 1 white))\n(init (cellHolds 5 1 white))\n(init (cellHolds 6 1 white))\n(init (cellHolds 7 1 white))\n(init (cellHolds 8 1 white))\n(init (cellHolds 1 2 white))\n(init (cellHolds 2 2 white))\n(init (cellHolds 3 2 white))\n(init (cellHolds 4 2 white))\n(init (cellHolds 5 2 white))\n(init (cellHolds 6 2 white))\n(init (cellHolds 7 2 white))\n(init (cellHolds 8 2 white))\n(init (cellHolds 1 7 black))\n(init (cellHolds 2 7 black))\n(init (cellHolds 3 7 black))\n(init (cellHolds 4 7 black))\n(init (cellHolds 5 7 black))\n(init (cellHolds 6 7 black))\n(init (cellHolds 7 7 black))\n(init (cellHolds 8 7 black))\n(init (cellHolds 1 8 black))\n(init (cellHolds 2 8 black))\n(init (cellHolds 3 8 black))\n(init (cellHolds 4 8 black))\n(init (cellHolds 5 8 black))\n(init (cellHolds 6 8 black))\n(init (cellHolds 7 8 black))\n(init (cellHolds 8 8 black))\n(<= (init (cellOffLimits ?x ?y))\n    (holeCell ?x ?y))\n(init (control white))\n(<= (legal white (move ?x ?y1 ?x ?y2))\n    (true (control white))\n    (true (cellHolds ?x ?y1 white))\n    (plusplus ?y1 ?y2)\n    (cellEmpty ?x ?y2)\n    (not (true (cellOffLimits ?x ?y2))))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cellHolds ?x1 ?y1 white))\n    (plusplus ?y1 ?y2)\n    (plusplus ?x1 ?x2)\n    (not (true (cellHolds ?x2 ?y2 white)))\n    (not (true (cellOffLimits ?x2 ?y2))))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cellHolds ?x1 ?y1 white))\n    (plusplus ?y1 ?y2)\n    (plusplus ?x2 ?x1)\n    (not (true (cellHolds ?x2 ?y2 white)))\n    (not (true (cellOffLimits ?x2 ?y2))))\n(<= (legal black (move ?x ?y1 ?x ?y2))\n    (true (control black))\n    (true (cellHolds ?x ?y1 black))\n    (plusplus ?y2 ?y1)\n    (cellEmpty ?x ?y2)\n    (not (true (cellOffLimits ?x ?y2))))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cellHolds ?x1 ?y1 black))\n    (plusplus ?y2 ?y1)\n    (plusplus ?x1 ?x2)\n    (not (true (cellHolds ?x2 ?y2 black)))\n    (not (true (cellOffLimits ?x2 ?y2))))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cellHolds ?x1 ?y1 black))\n    (plusplus ?y2 ?y1)\n    (plusplus ?x2 ?x1)\n    (not (true (cellHolds ?x2 ?y2 black)))\n    (not (true (cellOffLimits ?x2 ?y2))))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black noop)\n    (true (control white)))\n(<= (next (cellHolds ?x2 ?y2 ?player))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cellHolds ?x3 ?y3 ?state))\n    (true (cellHolds ?x3 ?y3 ?state))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x3 ?y3)\n    (distinctCell ?x2 ?y2 ?x3 ?y3))\n(<= (next (cellOffLimits ?x ?y))\n    (true (cellOffLimits ?x ?y)))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= terminal\n    whiteWin)\n(<= terminal\n    blackWin)\n(<= (goal white 100)\n    whiteWin)\n(<= (goal white 0)\n    (not whiteWin))\n(<= (goal black 100)\n    blackWin)\n(<= (goal black 0)\n    (not blackWin))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (cellEmpty ?x ?y)\n    (cell ?x ?y)\n    (not (true (cellHolds ?x ?y white)))\n    (not (true (cellHolds ?x ?y black))))\n(<= (hasPiece ?player)\n    (true (cellHolds ?x ?y ?player)))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= whiteWin\n    (index ?x)\n    (true (cellHolds ?x 8 white)))\n(<= blackWin\n    (index ?x)\n    (true (cellHolds ?x 1 black)))\n(<= whiteWin\n    (not (hasPiece black)))\n(<= blackWin\n    (not (hasPiece white)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(plusplus 1 2)  (plusplus 2 3)  (plusplus 3 4)  (plusplus 4 5)  (plusplus 5 6)  (plusplus 6 7)  (plusplus 7 8)\n(holeCell 3 3)\n(holeCell 3 6)\n(holeCell 6 3)\n(holeCell 6 6)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set in a two-dimensional coordinate system with discrete positions defined by integers ranging from negative values up to positive values, with a succession relation defining the ordering of these numbers. The environment includes a predefined set of valid positions or tracks on the board, which impose implicit boundaries and movement constraints. There are four players in the game, identified by the roles red, blue, green, and yellow, who take turns in an unspecified but fixed order. The initial state sets a counter to fifty and places each player at specific positions with initial velocities: yellow at position (1,0) moving at velocity (0,1), red at (2,0) with velocity (0,1), blue at (3,0) at velocity (0,1), and green at (4,0) at velocity (0,1). On each turn, a player may choose an action that either changes their velocity by at most one unit in each direction (x and y) within the permissible speed range of -8 to +8, or they may resign if no legal speed changes are available or if they have already resigned. Legal velocity changes are restricted to increments or decrements of at most one unit per axis, and the resulting position after applying the new velocity must lie on a valid track, ensuring players cannot move outside the defined paths. If a player resigns, their velocity resets to zero and their position remains unchanged. The game automatically updates each player's position by adding the current velocity components to their coordinates on the board and increments the turn counter after each player’s move. Players cannot remain stationary unless they resign; at least one component of velocity must be non-zero when changing speed. The game ends when the counter reaches fifty, when any player’s y-coordinate becomes negative (indicating they have landed), or when no players remain active (i.e., all have resigned). Scoring is based on whether players have landed within a defined landing zone, which requires their y-coordinate to be less than zero and their x-coordinate to be greater than twenty. Players who land alone in the landing zone score 100 points, those who land with others in this zone score 75 points, players still active but not landed score 25 points, and those who have resigned score zero. The game enforces that players move only along tracks marked as valid positions, preventing illegal moves and collisions. The turn control ensures that each player acts in sequence, with the noop mechanism implicitly handled by the resign action, which players can invoke if no legal speed changes exist, effectively passing their turn without movement. Thus, the game blends strategic velocity control within spatial constraints, encouraging players to maneuver towards the landing zone efficiently while managing limited turn counts and avoiding resignation.",
    "output": "(role red)\n(role blue)\n(role green)\n(role yellow)\n(init (counter n50))\n(init (posx yellow p1))\n(init (posy yellow p0))\n(init (velx yellow p0))\n(init (vely yellow p1))\n(init (posx red p2))\n(init (posy red p0))\n(init (velx red p0))\n(init (vely red p1))\n(init (posx blue p3))\n(init (posy blue p0))\n(init (velx blue p0))\n(init (vely blue p1))\n(init (posx green p4))\n(init (posy green p0))\n(init (velx green p0))\n(init (vely green p1))\n(<= (next (counter ?nc))\n    (true (counter ?c))\n    (succ ?c ?nc))\n(<= (next (posx ?player ?nx))\n    (does ?player (speed ?dx ?dy))\n    (true (posx ?player ?x))\n    (add ?x ?dx ?nx))\n(<= (next (posx ?player ?x))\n    (does ?player resign)\n    (true (posx ?player ?x)))\n(<= (next (posy ?player ?ny))\n    (does ?player (speed ?dx ?dy))\n    (true (posy ?player ?y))\n    (add ?y ?dy ?ny))\n(<= (next (posy ?player ?y))\n    (does ?player resign)\n    (true (posy ?player ?y)))\n(<= (next (velx ?player ?dx))\n    (does ?player (speed ?dx ?dy)))\n(<= (next (velx ?player p0))\n    (does ?player resign))\n(<= (next (vely ?player ?dy))\n    (does ?player (speed ?dx ?dy)))\n(<= (next (vely ?player p0))\n    (does ?player resign))\n(<= (next (resigned ?player))\n    (does ?player resign))\n(<= (pmone ?x ?x)\n    (number ?x))\n(<= (pmone ?x ?y)\n    (succ ?y ?x))\n(<= (pmone ?x ?y)\n    (succ ?x ?y))\n(<= (legal ?player (speed ?ndx ?ndy))\n    (legal_speed ?player ?ndx ?ndy)\n    (not (true (resigned ?player))))\n(<= (legal_speed ?player ?ndx ?ndy)\n    (true (velx ?player ?dx))\n    (true (vely ?player ?dy))\n    (pmone ?dx ?ndx)\n    (pmone ?dy ?ndy)\n    (or (distinct ?ndx p0)\n        (distinct ?ndy p0))\n    (smaller n2 ?ndx)\n    (true (posx ?player ?px))\n    (true (posy ?player ?py))\n    (add ?px ?ndx ?x)\n    (add ?py ?ndy ?y)\n    (track ?x ?y))\n(<= (legal ?player resign)\n    (role ?player)\n    (not (any_legal_speed ?player)))\n(<= (legal ?player resign)\n    (true (resigned ?player)))\n(<= (any_legal_speed ?player)\n    (legal_speed ?player ?dx ?dy))\n(<= (goal ?player 100)\n    (in_landing_zone ?player)\n    (not many_in_landing_zone))\n(<= (goal ?player 75)\n    (in_landing_zone ?player)\n    many_in_landing_zone)\n(<= (goal ?player 25)\n    (role ?player)\n    (not (in_landing_zone ?player))\n    (not (true (resigned ?player))))\n(<= (goal ?player 0)\n    (true (resigned ?player)))\n(<= (in_landing_zone ?player)\n    (true (posy ?player ?y))\n    (smaller ?y p0)\n    (true (posx ?player ?x))\n    (smaller p20 ?x))\n(<= many_in_landing_zone\n    (in_landing_zone ?player)\n    (in_landing_zone ?other_player)\n    (distinct ?player ?other_player))\n(<= terminal\n    (not running))\n(<= terminal\n    (true (posy ?player ?y))\n    (smaller ?y p0))\n(<= terminal\n    (true (counter p50)))\n(<= running\n    (role ?player)\n    (not (true (resigned ?player))))\n(track p0 p4)\n(track p0 p5)\n(track p0 p6)\n(track p0 p7)\n(track p1 p0)\n(track p1 p1)\n(track p1 p2)\n(track p1 p3)\n(track p1 p4)\n(track p1 p5)\n(track p1 p6)\n(track p1 p7)\n(track p1 p8)\n(track p2 p0)\n(track p2 p1)\n(track p2 p2)\n(track p2 p3)\n(track p2 p4)\n(track p2 p5)\n(track p2 p6)\n(track p2 p7)\n(track p2 p8)\n(track p2 p9)\n(track p2 p10)\n(track p3 p0)\n(track p3 p1)\n(track p3 p2)\n(track p3 p3)\n(track p3 p4)\n(track p3 p5)\n(track p3 p6)\n(track p3 p7)\n(track p3 p8)\n(track p3 p9)\n(track p3 p10)\n(track p3 p11)\n(track p3 p12)\n(track p4 p0)\n(track p4 p1)\n(track p4 p2)\n(track p4 p3)\n(track p4 p4)\n(track p4 p5)\n(track p4 p6)\n(track p4 p7)\n(track p4 p8)\n(track p4 p9)\n(track p4 p10)\n(track p4 p11)\n(track p4 p12)\n(track p4 p13)\n(track p5 p6)\n(track p5 p7)\n(track p5 p8)\n(track p5 p9)\n(track p5 p10)\n(track p5 p11)\n(track p5 p12)\n(track p5 p13)\n(track p5 p14)\n(track p6 p7)\n(track p6 p8)\n(track p6 p9)\n(track p6 p10)\n(track p6 p11)\n(track p6 p12)\n(track p6 p13)\n(track p6 p14)\n(track p6 p15)\n(track p7 p8)\n(track p7 p9)\n(track p7 p10)\n(track p7 p11)\n(track p7 p12)\n(track p7 p13)\n(track p7 p14)\n(track p7 p15)\n(track p7 p16)\n(track p8 p10)\n(track p8 p11)\n(track p8 p12)\n(track p8 p13)\n(track p8 p14)\n(track p8 p15)\n(track p8 p16)\n(track p8 p17)\n(track p9 p10)\n(track p9 p11)\n(track p9 p12)\n(track p9 p13)\n(track p9 p14)\n(track p9 p15)\n(track p9 p16)\n(track p9 p17)\n(track p10 p7)\n(track p10 p8)\n(track p10 p9)\n(track p10 p10)\n(track p10 p11)\n(track p10 p12)\n(track p10 p13)\n(track p10 p14)\n(track p10 p15)\n(track p10 p16)\n(track p11 p7)\n(track p11 p8)\n(track p11 p9)\n(track p11 p10)\n(track p11 p11)\n(track p11 p12)\n(track p11 p13)\n(track p11 p14)\n(track p11 p15)\n(track p12 p6)\n(track p12 p7)\n(track p12 p8)\n(track p12 p9)\n(track p12 p10)\n(track p12 p11)\n(track p13 p6)\n(track p13 p7)\n(track p13 p8)\n(track p13 p9)\n(track p13 p10)\n(track p14 p6)\n(track p14 p7)\n(track p14 p8)\n(track p14 p9)\n(track p14 p10)\n(track p15 p5)\n(track p15 p6)\n(track p15 p7)\n(track p15 p8)\n(track p15 p9)\n(track p15 p10)\n(track p16 p5)\n(track p16 p6)\n(track p16 p7)\n(track p16 p8)\n(track p16 p9)\n(track p16 p10)\n(track p17 p6)\n(track p17 p7)\n(track p17 p8)\n(track p17 p9)\n(track p17 p10)\n(track p17 p11)\n(track p18 p7)\n(track p18 p8)\n(track p18 p9)\n(track p18 p10)\n(track p18 p11)\n(track p19 p8)\n(track p19 p9)\n(track p19 p10)\n(track p19 p11)\n(track p19 p12)\n(track p20 p8)\n(track p20 p9)\n(track p20 p10)\n(track p20 p11)\n(track p20 p12)\n(track p20 p13)\n(track p21 n4)\n(track p21 n3)\n(track p21 n2)\n(track p21 n1)\n(track p21 p0)\n(track p21 p1)\n(track p21 p2)\n(track p21 p3)\n(track p21 p4)\n(track p21 p5)\n(track p21 p6)\n(track p21 p7)\n(track p21 p8)\n(track p21 p9)\n(track p21 p10)\n(track p21 p11)\n(track p21 p12)\n(track p21 p13)\n(track p22 n4)\n(track p22 n3)\n(track p22 n2)\n(track p22 n1)\n(track p22 p0)\n(track p22 p1)\n(track p22 p2)\n(track p22 p3)\n(track p22 p4)\n(track p22 p5)\n(track p22 p6)\n(track p22 p7)\n(track p22 p8)\n(track p22 p9)\n(track p22 p10)\n(track p22 p11)\n(track p22 p12)\n(track p23 n4)\n(track p23 n3)\n(track p23 n2)\n(track p23 n1)\n(track p23 p0)\n(track p23 p1)\n(track p23 p2)\n(track p23 p3)\n(track p23 p4)\n(track p23 p5)\n(track p23 p6)\n(track p23 p7)\n(track p23 p8)\n(track p23 p9)\n(track p23 p10)\n(track p23 p11)\n(track p24 n4)\n(track p24 n3)\n(track p24 n2)\n(track p24 n1)\n(track p24 p0)\n(track p24 p1)\n(track p24 p2)\n(track p24 p3)\n(track p24 p4)\n(track p24 p5)\n(track p24 p6)\n(track p24 p7)\n(track p24 p8)\n(track p24 p9)\n(track p24 p10)\n(succ n50 n49)\n(succ n49 n48)\n(succ n48 n47)\n(succ n47 n46)\n(succ n46 n45)\n(succ n45 n44)\n(succ n44 n43)\n(succ n43 n42)\n(succ n42 n41)\n(succ n41 n40)\n(succ n40 n39)\n(succ n39 n38)\n(succ n38 n37)\n(succ n37 n36)\n(succ n36 n35)\n(succ n35 n34)\n(succ n34 n33)\n(succ n33 n32)\n(succ n32 n31)\n(succ n31 n30)\n(succ n30 n29)\n(succ n29 n28)\n(succ n28 n27)\n(succ n27 n26)\n(succ n26 n25)\n(succ n25 n24)\n(succ n24 n23)\n(succ n23 n22)\n(succ n22 n21)\n(succ n21 n20)\n(succ n20 n19)\n(succ n19 n18)\n(succ n18 n17)\n(succ n17 n16)\n(succ n16 n15)\n(succ n15 n14)\n(succ n14 n13)\n(succ n13 n12)\n(succ n12 n11)\n(succ n11 n10)\n(succ n10 n9)\n(succ n9 n8)\n(succ n8 n7)\n(succ n7 n6)\n(succ n6 n5)\n(succ n5 n4)\n(succ n4 n3)\n(succ n3 n2)\n(succ n2 n1)\n(succ n1 p0)\n(succ p0 p1)\n(succ p1 p2)\n(succ p2 p3)\n(succ p3 p4)\n(succ p4 p5)\n(succ p5 p6)\n(succ p6 p7)\n(succ p7 p8)\n(succ p8 p9)\n(succ p9 p10)\n(succ p10 p11)\n(succ p11 p12)\n(succ p12 p13)\n(succ p13 p14)\n(succ p14 p15)\n(succ p15 p16)\n(succ p16 p17)\n(succ p17 p18)\n(succ p18 p19)\n(succ p19 p20)\n(succ p20 p21)\n(succ p21 p22)\n(succ p22 p23)\n(succ p23 p24)\n(succ p24 p25)\n(succ p25 p26)\n(succ p26 p27)\n(succ p27 p28)\n(succ p28 p29)\n(succ p29 p30)\n(succ p30 p31)\n(succ p31 p32)\n(succ p32 p33)\n(succ p33 p34)\n(succ p34 p35)\n(succ p35 p36)\n(succ p36 p37)\n(succ p37 p38)\n(succ p38 p39)\n(succ p39 p40)\n(succ p40 p41)\n(succ p41 p42)\n(succ p42 p43)\n(succ p43 p44)\n(succ p44 p45)\n(succ p45 p46)\n(succ p46 p47)\n(succ p47 p48)\n(succ p48 p49)\n(succ p49 p50)\n(number n50)\n(number n49)\n(number n48)\n(number n47)\n(number n46)\n(number n45)\n(number n44)\n(number n43)\n(number n42)\n(number n41)\n(number n40)\n(number n39)\n(number n38)\n(number n37)\n(number n36)\n(number n35)\n(number n34)\n(number n33)\n(number n32)\n(number n31)\n(number n30)\n(number n29)\n(number n28)\n(number n27)\n(number n26)\n(number n25)\n(number n24)\n(number n23)\n(number n22)\n(number n21)\n(number n20)\n(number n19)\n(number n18)\n(number n17)\n(number n16)\n(number n15)\n(number n14)\n(number n13)\n(number n12)\n(number n11)\n(number n10)\n(number n9)\n(number n8)\n(number n7)\n(number n6)\n(number n5)\n(number n4)\n(number n3)\n(number n2)\n(number n1)\n(number p0)\n(number p1)\n(number p2)\n(number p3)\n(number p4)\n(number p5)\n(number p6)\n(number p7)\n(number p8)\n(number p9)\n(number p10)\n(number p11)\n(number p12)\n(number p13)\n(number p14)\n(number p15)\n(number p16)\n(number p17)\n(number p18)\n(number p19)\n(number p20)\n(number p21)\n(number p22)\n(number p23)\n(number p24)\n(number p25)\n(number p26)\n(number p27)\n(number p28)\n(number p29)\n(number p30)\n(number p31)\n(number p32)\n(number p33)\n(number p34)\n(number p35)\n(number p36)\n(number p37)\n(number p38)\n(number p39)\n(number p40)\n(number p41)\n(number p42)\n(number p43)\n(number p44)\n(number p45)\n(number p46)\n(number p47)\n(number p48)\n(number p49)\n(number p50)\n(<= (smaller ?x ?y)\n    (succ ?x ?y))\n(<= (smaller ?x ?z)\n    (succ ?x ?y)\n    (smaller ?y ?z))\n(<= (add ?x p0 ?x)\n    (number ?x))\n(<= (add ?x ?y ?z)\n    (smaller p0 ?y)\n    (add_positive ?x ?y ?z))\n(<= (add ?x ?y ?z)\n    (smaller ?y p0)\n    (add_negative ?x ?y ?z))\n(<= (add_positive ?x p0 ?x)\n    (number ?x))\n(<= (add_positive ?x ?y ?z)\n    (distinct ?y p0)\n    (succ ?y1 ?y)\n    (succ ?x ?x1)\n    (add_positive ?x1 ?y1 ?z))\n(<= (add_negative ?x p0 ?x)\n    (number ?x))\n(<= (add_negative ?x ?y ?z)\n    (distinct ?y p0)\n    (succ ?y ?y1)\n    (succ ?x1 ?x)\n    (add_negative ?x1 ?y1 ?z))\n(<= (possible_speed ?v)\n    (smaller n8 ?v)\n    (smaller ?v p8))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a two-dimensional 9-by-9 grid defined by rows numbered from 1 to 9 and columns numbered from 1 to 9, establishing the coordinate system for the board. There is a single player role called \"robot,\" who takes turns alone, implying a turn-based game with only one participant controlling the moves. At the start of the game, the move count is initialized to zero, and a single knight piece is positioned at the cell with coordinates (1,1). The state of the board comprises cells that may contain either a knight or a hole; initially, only the knight is placed, while holes may appear subsequently as a consequence of moves. Each turn, the robot may perform exactly one action, which is either moving the knight or implicitly doing nothing if no legal moves are available; this noop mechanism is not explicitly described but implied by the single-player turn progression and legal move conditions. An action consists of a move command specifying the knight's current coordinates (x1, y1) and its destination coordinates (x2, y2). Such a move is legal if and only if the piece at the starting cell is indeed the knight, and the movement conforms to the knight's characteristic L-shaped pattern on the board, moving two cells in one direction and one cell perpendicular to that, with all variants of this pattern allowed as long as the destination remains within the 9x9 boundaries. There are implicit constraints that the destination cell must be within the board limits, and presumably must be a hole cell, as the knight moves into holes, replacing them, while the previous cell becomes a hole after the move. When the robot performs a move action, the state updates by incrementing the move count by one, relocating the knight from its original cell to the destination cell, and turning the original cell into a hole. The holes persist on the board once created and do not move. The game reaches a terminal state when there exists at least one cell containing a knight and at least one cell containing a hole simultaneously, which occurs naturally after the knight has moved at least once. The scoring or goal for the robot is to maximize the move count, which reflects the number of successful knight moves made during the game. Thus, the player aims to prolong the game by moving the knight legally according to its movement rules, incrementing the move count with each move, until no further legal moves are possible or the terminal condition is met.",
    "output": "(role robot)\n(row 1)\n(row 2)\n(row 3)\n(row 4)\n(row 5)\n(row 6)\n(row 7)\n(row 8)\n(row 9)\n(col 1)\n(col 2)\n(col 3)\n(col 4)\n(col 5)\n(col 6)\n(col 7)\n(col 8)\n(col 9)\n(piece knight)\n(piece hole)\n(init (moveCount 0))\n(init (cell 1 1 knight))\n(<= (next (moveCount ?newCount))\n\t(true (moveCount ?oldCount))\n\t(plus 1 count ?oldCount ?newCount))\n(<= (next (cell ?x ?y hole))\n\t(true (cell ?x ?y hole)))\n(<= (next (cell ?x1 ?y1 hole))\n\t(does robot (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x2 ?y2 knight))\n\t(does robot (move ?x1 ?y1 ?x2 ?y2)))\n(<= (legal robot (move ?x1 ?y1 ?x2 ?y2))\n\t(true (cell ?x1 ?y1 knight))\n\t(knightMove ?x1 ?y1 ?x2 ?y2))\n(<= (goal robot ?count)\n\t(true (moveCount ?count)))\n(<= terminal\n\t(true (cell ?x ?y knight))\n\t(true (cell ?x ?y hole)))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 x ?x1 ?x2)\n\t(plus 2 y ?y1 ?y2))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 x ?x1 ?x2)\n\t(plus 2 y ?y2 ?y1))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 x ?x2 ?x1)\n\t(plus 2 y ?y1 ?y2))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 x ?x2 ?x1)\n\t(plus 2 y ?y2 ?y1))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 x ?x1 ?x2)\n\t(plus 1 y ?y1 ?y2))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 x ?x1 ?x2)\n\t(plus 1 y ?y2 ?y1))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 x ?x2 ?x1)\n\t(plus 1 y ?y1 ?y2))\n(<= (knightMove ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 x ?x2 ?x1)\n\t(plus 1 y ?y2 ?y1))\n(plus 1 count  0  1)\n(plus 1 count  1  2)\n(plus 1 count  2  3)\n(plus 1 count  3  4)\n(plus 1 count  4  5)\n(plus 1 count  5  6)\n(plus 1 count  6  7)\n(plus 1 count  7  8)\n(plus 1 count  8  9)\n(plus 1 count  9 10)\n(plus 1 count 10 11)\n(plus 1 count 11 12)\n(plus 1 count 12 13)\n(plus 1 count 13 14)\n(plus 1 count 14 15)\n(plus 1 count 15 16)\n(plus 1 count 16 17)\n(plus 1 count 17 18)\n(plus 1 count 18 19)\n(plus 1 count 19 20)\n(plus 1 count 20 21)\n(plus 1 count 21 22)\n(plus 1 count 22 23)\n(plus 1 count 23 24)\n(plus 1 count 24 25)\n(plus 1 count 25 26)\n(plus 1 count 26 27)\n(plus 1 count 27 28)\n(plus 1 count 28 29)\n(plus 1 count 29 30)\n(plus 1 count 30 31)\n(plus 1 count 31 32)\n(plus 1 count 32 33)\n(plus 1 count 33 34)\n(plus 1 count 34 35)\n(plus 1 count 35 36)\n(plus 1 count 36 37)\n(plus 1 count 37 38)\n(plus 1 count 38 39)\n(plus 1 count 39 40)\n(plus 1 count 40 41)\n(plus 1 count 41 42)\n(plus 1 count 42 43)\n(plus 1 count 43 44)\n(plus 1 count 44 45)\n(plus 1 count 45 46)\n(plus 1 count 46 47)\n(plus 1 count 47 48)\n(plus 1 count 48 49)\n(plus 1 count 49 50)\n(plus 1 count 50 51)\n(plus 1 count 51 52)\n(plus 1 count 52 53)\n(plus 1 count 53 54)\n(plus 1 count 54 55)\n(plus 1 count 55 56)\n(plus 1 count 56 57)\n(plus 1 count 57 58)\n(plus 1 count 58 59)\n(plus 1 count 59 60)\n(plus 1 count 60 61)\n(plus 1 count 61 62)\n(plus 1 count 62 63)\n(plus 1 count 63 64)\n(plus 1 count 64 65)\n(plus 1 count 65 66)\n(plus 1 count 66 67)\n(plus 1 count 67 68)\n(plus 1 count 68 69)\n(plus 1 count 69 70)\n(plus 1 count 70 71)\n(plus 1 count 71 72)\n(plus 1 count 72 73)\n(plus 1 count 73 74)\n(plus 1 count 74 75)\n(plus 1 count 75 76)\n(plus 1 count 76 77)\n(plus 1 count 77 78)\n(plus 1 count 78 79)\n(plus 1 count 79 80)\n(plus 1 count 80 100)\n(plus 1     x  1  2)\n(plus 1     x  2  3)\n(plus 1     x  3  4)\n(plus 1     x  4  5)\n(plus 1     x  5  6)\n(plus 1     x  6  7)\n(plus 1     x  7  8)\n(plus 1     x  8  9)\n(plus 1     y  1  2)\n(plus 1     y  2  3)\n(plus 1     y  3  4)\n(plus 1     y  4  5)\n(plus 1     y  5  6)\n(plus 1     y  6  7)\n(plus 1     y  7  8)\n(plus 1     y  8  9)\n(plus 2     x  1  3)\n(plus 2     x  2  4)\n(plus 2     x  3  5)\n(plus 2     x  4  6)\n(plus 2     x  5  7)\n(plus 2     x  6  8)\n(plus 2     x  7  9)\n(plus 2     y  1  3)\n(plus 2     y  2  4)\n(plus 2     y  3  5)\n(plus 2     y  4  6)\n(plus 2     y  5  7)\n(plus 2     y  6  8)\n(plus 2     y  7  9)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a board with coordinates labeled from 1 to 8 arranged in a circular manner where each index is adjacent to the next, and 8 loops back to 1, creating a wrap-around effect for both rows and columns. There are two players, Light and Dark, each controlling a single ship initially placed at coordinates (3,3) for Light and (6,6) for Dark. The game progresses in alternating turns split into two phases: a \"fire\" phase and a \"move\" phase. Initially, the game starts in the \"fire\" phase, and on each turn, only one player acts, alternating between Light and Dark. During the firing phase, a player may choose to fire a bullet in one of eight compass directions (N, NE, E, SE, S, SW, W, NW). During the moving phase, a player may either move their ship one step in any of these eight directions or pass by performing a noop action; however, moving is only legal if the destination square is not occupied by a bullet traveling in the opposite direction of the intended movement. The turn automatically switches from the firing phase to the moving phase and back after each action, ensuring players alternate between firing and moving each turn. Ships and bullets move according to directional rules that wrap around the board edges, maintaining the circular coordinate system. Movement of ships is constrained so that ships cannot move into squares threatened by opposing bullets, and ships cannot occupy the same square simultaneously; if they do, both ships are considered destroyed. Firing creates a bullet that appears adjacent to the firing ship in the chosen direction and continues moving forward in subsequent turns until it either destroys a ship by occupying the same square or the game ends otherwise. A ship is destroyed if it occupies the same coordinate as a bullet or if both ships end up on the same square. The game ends when either ship is destroyed. Scoring depends on the final state: if one player's ship is destroyed and the other survives, the surviving player scores 100 points and the destroyed player scores zero. If both ships are destroyed simultaneously, both players score 50 points. If neither ship is destroyed by the end of play, both players also score 50 points. The coordinate system's adjacency and directional movement rules ensure that all moves and shots respect the circular board layout, and implicit constraints prevent ships from moving into bullets coming from the opposite direction or overlapping each other except when destruction occurs. Thus, the game revolves around strategic firing and movement within a limited and cyclic 8x8 coordinate space, with players alternating firing and moving actions to outmaneuver and eliminate their opponent's ship.",
    "output": "(role light)\n(role dark)\n(init (ship light 3 3))\n(init (ship dark 6 6))\n(init (turn fire))\n(<= (legal ?player (fire ?dir))\n\t(role ?player)\n\t(true (turn fire))\n\t(dir ?dir))\n(<= (legal ?player noop)\n\t(role ?player)\n\t(true (turn move)))\n(<= (legal ?player (move ?dir))\n\t(role ?player)\n    (true (turn move))\n\t(dir ?dir)\n\t(true (ship ?player ?x ?y))\n\t(dirX ?dir ?x ?x2)\n    (dirY ?dir ?y ?y2)\n\t(oppDir ?dir ?oppDir)\n\t(not (true (bullet ?x2 ?y2 ?oppDir))))\n(dir N) (northward N)\n(dir NE) (northward NE) (eastward NE)\n(dir E) (eastward E)\n(dir SE) (eastward SE) (southward SE)\n(dir S) (southward S)\n(dir SW) (southward SW) (westward SW)\n(dir W) (westward W)\n(dir NW) (westward NW) (northward NW)\n(oppDir N S)\n(oppDir NE SW)\n(oppDir E W)\n(oppDir SE NW)\n(oppDir S N)\n(oppDir SW NE)\n(oppDir W E)\n(oppDir NW SE)\n(<= (next (ship ?player ?x ?y))\n\t(true (ship ?player ?x ?y))\n\t(or adjacentDestinations\n        (does ?player (fire ?dir))\n\t\t(does ?player noop)))\n(<= (next (ship ?player ?x2 ?y2))\n\t(true (ship ?player ?x1 ?y1))\n\t(does ?player (move ?dir))\n    (not adjacentDestinations)\n\t(dirX ?dir ?x1 ?x2)\n\t(dirY ?dir ?y1 ?y2))\n(<= (next (bullet ?x2 ?y2 ?dir))\n\t(does ?player (fire ?dir))\n\t(true (ship ?player ?x1 ?y1))\n\t(dirX ?dir ?x1 ?x2)\n\t(dirY ?dir ?y1 ?y2))\n(<= (next (bullet ?x2 ?y2 ?dir))\n\t(true (bullet ?x1 ?y1 ?dir))\n\t(dirX ?dir ?x1 ?x2)\n\t(dirY ?dir ?y1 ?y2))\n(<= adjacentDestinations\n    (moveDestination light ?x1 ?y1)\n    (moveDestination dark ?x2 ?y2)\n    (sameOrAdjacent ?x1 ?x2)\n    (sameOrAdjacent ?y1 ?y2))\n(<= (moveDestination ?player ?x2 ?y2)\n    (does ?player (move ?dir))\n    (true (ship ?player ?x1 ?y1))\n    (dirX ?dir ?x1 ?x2)\n    (dirY ?dir ?y1 ?y2))\n(<= (next (turn move))\n    (true (turn fire)))\n(<= (next (turn fire))\n    (true (turn move)))\n(<= (dirX ?dir ?x1 ?x2)\n\t(nextTo ?x1 ?x2)\n\t(eastward ?dir))\n(<= (dirX ?dir ?x1 ?x2)\n\t(nextTo ?x2 ?x1)\n\t(westward ?dir))\n(<= (dirX N ?x ?x)\n\t(index ?x))\n(<= (dirX S ?x ?x)\n\t(index ?x))\n(<= (dirY ?dir ?y1 ?y2)\n\t(nextTo ?y1 ?y2)\n\t(southward ?dir))\n(<= (dirY ?dir ?y1 ?y2)\n\t(nextTo ?y2 ?y1)\n\t(northward ?dir))\n(<= (dirY W ?x ?x)\n\t(index ?x))\n(<= (dirY E ?x ?x)\n\t(index ?x))\n(<= (destroyed ?player)\n\t(true (ship ?player ?x ?y))\n\t(true (bullet ?x ?y ?dir)))\n(<= (destroyed ?player)\n\t(true (ship ?player ?x ?y))\n\t(true (ship ?opp ?x ?y))\n\t(distinct ?player ?opp))\n(<= terminal\n\t(destroyed ?player))\n(<= (goal light 100)\n\t(destroyed dark)\n\t(not (destroyed light)))\n(<= (goal light 50)\n\t(destroyed dark)\n\t(destroyed light))\n(<= (goal light 50)\n\t(not (destroyed dark))\n\t(not (destroyed light)))\n(<= (goal light 0)\n\t(destroyed light)\n\t(not (destroyed dark)))\n(<= (goal dark 100)\n\t(destroyed light)\n\t(not (destroyed dark)))\n(<= (goal dark 50)\n\t(destroyed dark)\n\t(destroyed light))\n(<= (goal dark 50)\n\t(not (destroyed dark))\n\t(not (destroyed light)))\n(<= (goal dark 0)\n\t(destroyed dark)\n\t(not (destroyed light)))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(nextTo 1 2)\n(nextTo 2 3)\n(nextTo 3 4)\n(nextTo 4 5)\n(nextTo 5 6)\n(nextTo 6 7)\n(nextTo 7 8)\n(nextTo 8 1)\n(<= (sameOrAdjacent ?x ?x)\n    (index ?x))\n(<= (sameOrAdjacent ?x ?y)\n    (nextTo ?x ?y))\n(<= (sameOrAdjacent ?x ?y)\n    (nextTo ?y ?x))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid with rows labeled from 'a' to 'i' and columns numbered from 1 to 9, forming a 9-by-9 board where each position is identified by a row-column pair. The adjacency relations between cells are defined both orthogonally and diagonally, considering neighboring rows and columns. There are two players, red and blue, who alternate turns starting with red, as the initial control is set to red and the step counter starts at 1. On a player's turn, that player may place a piece of their color on any unoccupied cell of the board; a move placing a piece is legal only if it is that player's turn to move and the chosen cell is currently empty. The other player may perform a noop action, which is only legal when it is not their turn. After each move, the control switches to the opposing player, and the step counter increments by one. When a player places a piece, that cell becomes occupied by that player's color on the next state. Additionally, the game tracks ownership of certain connected components on the board, which are updated when a player places a piece adjacent to a cell belonging to their owned connected component, causing a transfer of ownership to the new position. The connected components are sets of cells connected through adjacency, and only those owned by a player can be expanded by placing pieces adjacent to them. The game ends when either player achieves a path condition: for red, this requires there to exist a connected component owned by red that includes at least one cell in the leftmost column (column 1, specifically row 'a') and one cell in the rightmost column (column 9, specifically row 'i'); for blue, the winning path condition is similar but involves connected components spanning from the top row (row 'a') to the bottom row (row 'i'). Upon reaching such a terminal state where a player's path condition is fulfilled, that player receives a goal value of 100, signifying victory, while the other player receives 0. Throughout gameplay, no piece can be placed outside the defined rows and columns, and no cell may be occupied by more than one piece. The game proceeds until one player forms the required connected path across the board, and the victory is determined solely by the fulfillment of these path conditions.",
    "output": "(role red)\n  (role blue)\n  (init (control red))\n  (init (step 1))\n  (<= (legal ?role (place ?m ?n))\n      (true (control ?role))\n      (row ?m)\n      (col ?n)\n      (not (true (cell ?m ?n red)))\n      (not (true (cell ?m ?n blue))))\n  (<= (legal red noop)\n      (true (control blue)))\n  (<= (legal blue noop)\n      (true (control red)))\n  (<= (next (cell ?m ?n ?role))\n      (does ?role (place ?m ?n)))\n  (<= (next (cell ?m ?n ?role))\n      (true (cell ?m ?n ?role)))\n  (<= (next (step ?n))\n      (true (step ?m))\n      (succ ?m ?n))\n  (<= (next (owner ?k ?role))\n      (true (step ?k))\n      (true (control ?role)))\n  (<= (next (owner ?k ?role))\n      (true (owner ?k ?role)))\n  (<= (next (connected ?k ?m ?n))\n      (does ?role (place ?m ?n))\n      (true (step ?k)))\n  (<= (next (connected ?k ?m ?n))\n      (transfer ?e)\n      (true (connected ?e ?m ?n))\n      (true (step ?k)))\n  (<= (next (connected ?k ?m ?n))\n      (true (connected ?k ?m ?n))\n      (not (transfer ?k)))\n  (<= (next (control red))\n      (true (control blue)))\n  (<= (next (control blue))\n      (true (control red)))\n  (<= (transfer ?k)\n      (does ?role (place ?x ?y))\n      (true (owner ?k ?role))\n      (true (connected ?k ?m ?n))\n      (adjacent ?x ?y ?m ?n))\n  (<= (goal red 100) redpath)\n  (<= (goal red 0) (not redpath))\n  (<= (goal blue 100) bluepath)\n  (<= (goal blue 0) (not bluepath))\n  (<= terminal redpath)\n  (<= terminal bluepath)\n  (<= (adjacent ?j ?k ?j ?n)\n      (nextcol ?k ?n)\n      (row ?j))\n  (<= (adjacent ?j ?k ?j ?n)\n      (nextcol ?n ?k)\n      (row ?j))\n  (<= (adjacent ?j ?k ?m ?k)\n      (nextrow ?j ?m)\n      (col ?k))\n  (<= (adjacent ?j ?k ?m ?k)\n      (nextrow ?m ?j)\n      (col ?k))\n  (<= (adjacent ?j ?k ?m ?n)\n      (nextrow ?m ?j)\n      (nextcol ?k ?n))\n  (<= (adjacent ?j ?k ?m ?n)\n      (nextrow ?j ?m)\n      (nextcol ?n ?k))\n  (<= redpath\n      (true (connected ?k a ?i))\n      (true (connected ?k i ?j))\n      (true (owner ?k red)))\n  (<= bluepath\n      (true (connected ?k ?i 1))\n      (true (connected ?k ?j 9))\n      (true (owner ?k blue)))\n  (row a)\n  (row b)\n  (row c)\n  (row d)\n  (row e)\n  (row f)\n  (row g)\n  (row h)\n  (row i)\n  (col 1)\n  (col 2)\n  (col 3)\n  (col 4)\n  (col 5)\n  (col 6)\n  (col 7)\n  (col 8)\n  (col 9)\n  (nextrow a b)\n  (nextrow b c)\n  (nextrow c d)\n  (nextrow d e)\n  (nextrow e f)\n  (nextrow f g)\n  (nextrow g h)\n  (nextrow h i)\n  (nextcol 1 2)\n  (nextcol 2 3)\n  (nextcol 3 4)\n  (nextcol 4 5)\n  (nextcol 5 6)\n  (nextcol 6 7)\n  (nextcol 7 8)\n  (nextcol 8 9)\n  (succ 1 2)\n  (succ 2 3)\n  (succ 3 4)\n  (succ 4 5)\n  (succ 5 6)\n  (succ 6 7)\n  (succ 7 8)\n  (succ 8 9)\n  (succ 9 10)\n  (succ 10 11)\n  (succ 11 12)\n  (succ 12 13)\n  (succ 13 14)\n  (succ 14 15)\n  (succ 15 16)\n  (succ 16 17)\n  (succ 17 18)\n  (succ 18 19)\n  (succ 19 20)\n  (succ 20 21)\n  (succ 21 22)\n  (succ 22 23)\n  (succ 23 24)\n  (succ 24 25)\n  (succ 25 26)\n  (succ 26 27)\n  (succ 27 28)\n  (succ 28 29)\n  (succ 29 30)\n  (succ 30 31)\n  (succ 31 32)\n  (succ 32 33)\n  (succ 33 34)\n  (succ 34 35)\n  (succ 35 36)\n  (succ 36 37)\n  (succ 37 38)\n  (succ 38 39)\n  (succ 39 40)\n  (succ 40 41)\n  (succ 41 42)\n  (succ 42 43)\n  (succ 43 44)\n  (succ 44 45)\n  (succ 45 46)\n  (succ 46 47)\n  (succ 47 48)\n  (succ 48 49)\n  (succ 49 50)\n  (succ 50 51)\n  (succ 51 52)\n  (succ 52 53)\n  (succ 53 54)\n  (succ 54 55)\n  (succ 55 56)\n  (succ 56 57)\n  (succ 57 58)\n  (succ 58 59)\n  (succ 59 60)\n  (succ 60 61)\n  (succ 61 62)\n  (succ 62 63)\n  (succ 63 64)\n  (succ 64 65)\n  (succ 65 66)\n  (succ 66 67)\n  (succ 67 68)\n  (succ 68 69)\n  (succ 69 70)\n  (succ 70 71)\n  (succ 71 72)\n  (succ 72 73)\n  (succ 73 74)\n  (succ 74 75)\n  (succ 75 76)\n  (succ 76 77)\n  (succ 77 78)\n  (succ 78 79)\n  (succ 79 80)\n  (succ 80 81)\n  (succ 81 82)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a coordinate system with positions defined by x and y coordinates represented by symbolic points such as p0, p1, p2, and so forth, extending across a grid that includes both positive and negative values. The environment includes a defined set of traversable positions indicated by the \"track\" relation, constraining valid locations where players may move. There are two players in this game, identified as red and blue, who alternate turns. Initially, the red player starts at position x = p2 and y = p0 with a velocity vector of (0,1), while the blue player begins at position x = p3 and y = p0 with the same initial velocity (0,1). The game also starts with a counter set to 50, which decrements with each turn, serving as a temporal limit.\n\nDuring each turn, the current player must choose an action from a legal set. Legal actions include specifying a speed change, where the player selects a new velocity vector (dx, dy) subject to the constraint that each component differs from the current velocity component by at most one unit in either direction (i.e., the new velocity components must be either the same, increased by one, or decreased by one relative to the current velocity), and at least one component must be nonzero to avoid a no-move action. Furthermore, the speed adjustment is only legal if the resulting new position, calculated by adding the new velocity vector to the current position, lies on the defined track, ensuring players move along valid paths. If a player has no legal speed adjustments available or has already resigned, they may perform a resign action, which sets their velocity to zero and marks them as resigned. This resign action is the only legal move in such circumstances.\n\nAfter each action, the game state updates automatically: the counter decreases by one, each player's position is updated by adding their current velocity components to their x and y coordinates, and the velocity itself updates to the newly chosen velocity unless the player resigned, in which case it resets to zero. Resignation status is recorded and persists. The game enforces implicit constraints such as staying within track boundaries and moving only to positions validated as part of the track. The y-coordinate must not fall below zero to remain within the playable area; crossing below this threshold or the counter reaching zero signals the game's end, establishing terminal conditions. Additionally, the game ends if any player's y-coordinate becomes less than zero or the counter hits 50, indicating the game is no longer running.\n\nScoring is determined based on players' positions and resignation status at termination. A player scores 100 points if they are in the landing zone—defined as positions with y less than zero and x greater than 20—while their opponent is not. If both players are in the landing zone, each receives 75 points. Players not in the landing zone and not resigned score 25 points, while any resigned player scores zero. The landing zone thus represents a goal area, and the scoring incentivizes reaching it while the opponent fails to do so. Throughout the game, the turn order alternates strictly between red and blue players, with no skipping of turns except by resignation. The game does not support a no-operation move other than resigning when no legal moves exist. This framework creates a strategic race along the defined track, balancing velocity adjustments and spatial positioning under time constraints to achieve victory by reaching the landing zone first or outlasting the opponent.",
    "output": "(role red)\n(role blue)\n(init (counter n50))\n(init (posx red p2))\n(init (posy red p0))\n(init (velx red p0))\n(init (vely red p1))\n(init (posx blue p3))\n(init (posy blue p0))\n(init (velx blue p0))\n(init (vely blue p1))\n(<= (next (counter ?nc))\n(true (counter ?c))\n(succ ?c ?nc))\n(<= (next (posx ?player ?nx))\n(does ?player (speed ?dx ?dy))\n(true (posx ?player ?x))\n(add ?x ?dx ?nx))\n(<= (next (posx ?player ?x))\n(true (posx ?player ?x))\n(does ?player resign))\n(<= (next (posy ?player ?ny))\n(does ?player (speed ?dx ?dy))\n(true (posy ?player ?y))\n(add ?y ?dy ?ny))\n(<= (next (posy ?player ?y))\n(true (posy ?player ?y))\n(does ?player resign))\n(<= (next (velx ?player ?dx))\n(does ?player (speed ?dx ?dy)))\n(<= (next (velx ?player p0))\n(does ?player resign))\n(<= (next (vely ?player ?dy))\n(does ?player (speed ?dx ?dy)))\n(<= (next (vely ?player p0))\n(does ?player resign))\n(<= (next (resigned ?player)) (does ?player resign))\n(<= (pmone ?x ?x)\n(number ?x))\n(<= (pmone ?x ?y) (succ ?y ?x))\n(<= (pmone ?x ?y) (succ ?x ?y))\n(<= (legal ?player (speed ?ndx ?ndy))\n(legal_speed ?player ?ndx ?ndy)\n(not (true (resigned ?player))))\n(<= (legal_speed ?player ?ndx ?ndy)\n(true (velx ?player ?dx))\n(true (vely ?player ?dy))\n(true (posx ?player ?px))\n(true (posy ?player ?py))\n(pmone ?dx ?ndx)\n(pmone ?dy ?ndy)\n(or (distinct ?ndx p0) (distinct ?ndy p0))\n(smaller n1 ?ndx)\n(add ?px ?ndx ?x)\n(add ?py ?ndy ?y)\n(track ?x ?y))\n(<= (legal ?player resign)\n(role ?player)\n(not (any_legal_speed ?player)))\n(<= (legal ?player resign)\n(true (resigned ?player)))\n(<= (any_legal_speed ?player)\n(legal_speed ?player ?dx ?dy))\n(<= (goal ?player 100)\n(in_landing_zone ?player)\n(role ?otherplayer)\n(distinct ?player ?otherplayer)\n(not (in_landing_zone ?otherplayer)))\n(<= (goal ?player 75)\n(in_landing_zone ?player)\n(in_landing_zone ?otherplayer)\n(distinct ?player ?otherplayer))\n(<= (goal ?player 25)\n(role ?player)\n(not (in_landing_zone ?player))\n(not (true (resigned ?player))))\n(<= (goal ?player 0)\n(true (resigned ?player)))\n(<= (in_landing_zone ?player)\n(true (posx ?player ?x))\n(true (posy ?player ?y))\n(smaller ?y p0)\n(smaller p20 ?x))\n(<= terminal\n(not running))\n(<= terminal\n(true (posy ?player ?y))\n(smaller ?y p0))\n(<= terminal\n(true (counter p50)))\n(<= running\n(role ?player)\n(not (true (resigned ?player))))\n(track p0 p4) (track p0 p5) (track p0 p6) (track p0 p7)\n(track p1 p0) (track p1 p1) (track p1 p2) (track p1 p3) (track p1 p4) (track p1 p5) (track p1 p6) (track p1 p7) (track p1 p8)\n(track p2 p0) (track p2 p1) (track p2 p2) (track p2 p3) (track p2 p4) (track p2 p5) (track p2 p6) (track p2 p7) (track p2 p8) (track p2 p9) (track p2 p10)\n(track p3 p0) (track p3 p1) (track p3 p2) (track p3 p3) (track p3 p4) (track p3 p5) (track p3 p6) (track p3 p7) (track p3 p8) (track p3 p9) (track p3 p10) (track p3 p11) (track p3 p12)\n(track p4 p0) (track p4 p1) (track p4 p2) (track p4 p3) (track p4 p4) (track p4 p5) (track p4 p6) (track p4 p7) (track p4 p8) (track p4 p9) (track p4 p10) (track p4 p11) (track p4 p12) (track p4 p13)\n(track p5 p6) (track p5 p7) (track p5 p8) (track p5 p9) (track p5 p10) (track p5 p11) (track p5 p12) (track p5 p13) (track p5 p14)\n(track p6 p7) (track p6 p8) (track p6 p9) (track p6 p10) (track p6 p11) (track p6 p12) (track p6 p13) (track p6 p14) (track p6 p15)\n(track p7 p8) (track p7 p9) (track p7 p10) (track p7 p11) (track p7 p12) (track p7 p13) (track p7 p14) (track p7 p15) (track p7 p16)\n(track p8 p10) (track p8 p11) (track p8 p12) (track p8 p13) (track p8 p14) (track p8 p15) (track p8 p16) (track p8 p17)\n(track p9 p10) (track p9 p11) (track p9 p12) (track p9 p13) (track p9 p14) (track p9 p15) (track p9 p16) (track p9 p17)\n(track p10 p7) (track p10 p8) (track p10 p9) (track p10 p10) (track p10 p11) (track p10 p12) (track p10 p13) (track p10 p14) (track p10 p15) (track p10 p16)\n(track p11 p7) (track p11 p8) (track p11 p9) (track p11 p10) (track p11 p11) (track p11 p12) (track p11 p13) (track p11 p14) (track p11 p15)\n(track p12 p6) (track p12 p7) (track p12 p8) (track p12 p9) (track p12 p10) (track p12 p11)\n(track p13 p6) (track p13 p7) (track p13 p8) (track p13 p9) (track p13 p10)\n(track p14 p6) (track p14 p7) (track p14 p8) (track p14 p9) (track p14 p10)\n(track p15 p5) (track p15 p6) (track p15 p7) (track p15 p8) (track p15 p9) (track p15 p10)\n(track p16 p5) (track p16 p6) (track p16 p7) (track p16 p8) (track p16 p9) (track p16 p10)\n(track p17 p6) (track p17 p7) (track p17 p8) (track p17 p9) (track p17 p10) (track p17 p11)\n(track p18 p7) (track p18 p8) (track p18 p9) (track p18 p10) (track p18 p11)\n(track p19 p8) (track p19 p9) (track p19 p10) (track p19 p11) (track p19 p12)\n(track p20 p8) (track p20 p9) (track p20 p10) (track p20 p11) (track p20 p12) (track p20 p13)\n(track p21 n4) (track p21 n3) (track p21 n2) (track p21 n1) (track p21 p0) (track p21 p1) (track p21 p2) (track p21 p3) (track p21 p4) (track p21 p5) (track p21 p6) (track p21 p7) (track p21 p8) (track p21 p9) (track p21 p10) (track p21 p11) (track p21 p12) (track p21 p13)\n(track p22 n4) (track p22 n3) (track p22 n2) (track p22 n1) (track p22 p0) (track p22 p1) (track p22 p2) (track p22 p3) (track p22 p4) (track p22 p5) (track p22 p6) (track p22 p7) (track p22 p8) (track p22 p9) (track p22 p10) (track p22 p11) (track p22 p12)\n(track p23 n4) (track p23 n3) (track p23 n2) (track p23 n1) (track p23 p0) (track p23 p1) (track p23 p2) (track p23 p3) (track p23 p4) (track p23 p5) (track p23 p6) (track p23 p7) (track p23 p8) (track p23 p9) (track p23 p10) (track p23 p11)\n(track p24 n4) (track p24 n3) (track p24 n2) (track p24 n1) (track p24 p0) (track p24 p1) (track p24 p2) (track p24 p3) (track p24 p4) (track p24 p5) (track p24 p6) (track p24 p7) (track p24 p8) (track p24 p9) (track p24 p10)\n(succ n50 n49)\n(succ n49 n48)\n(succ n48 n47)\n(succ n47 n46)\n(succ n46 n45)\n(succ n45 n44)\n(succ n44 n43)\n(succ n43 n42)\n(succ n42 n41)\n(succ n41 n40)\n(succ n40 n39)\n(succ n39 n38)\n(succ n38 n37)\n(succ n37 n36)\n(succ n36 n35)\n(succ n35 n34)\n(succ n34 n33)\n(succ n33 n32)\n(succ n32 n31)\n(succ n31 n30)\n(succ n30 n29)\n(succ n29 n28)\n(succ n28 n27)\n(succ n27 n26)\n(succ n26 n25)\n(succ n25 n24)\n(succ n24 n23)\n(succ n23 n22)\n(succ n22 n21)\n(succ n21 n20)\n(succ n20 n19)\n(succ n19 n18)\n(succ n18 n17)\n(succ n17 n16)\n(succ n16 n15)\n(succ n15 n14)\n(succ n14 n13)\n(succ n13 n12)\n(succ n12 n11)\n(succ n11 n10)\n(succ n10 n9)\n(succ n9 n8)\n(succ n8 n7)\n(succ n7 n6)\n(succ n6 n5)\n(succ n5 n4)\n(succ n4 n3)\n(succ n3 n2)\n(succ n2 n1)\n(succ n1 p0)\n(succ p0 p1)\n(succ p1 p2)\n(succ p2 p3)\n(succ p3 p4)\n(succ p4 p5)\n(succ p5 p6)\n(succ p6 p7)\n(succ p7 p8)\n(succ p8 p9)\n(succ p9 p10)\n(succ p10 p11)\n(succ p11 p12)\n(succ p12 p13)\n(succ p13 p14)\n(succ p14 p15)\n(succ p15 p16)\n(succ p16 p17)\n(succ p17 p18)\n(succ p18 p19)\n(succ p19 p20)\n(succ p20 p21)\n(succ p21 p22)\n(succ p22 p23)\n(succ p23 p24)\n(succ p24 p25)\n(succ p25 p26)\n(succ p26 p27)\n(succ p27 p28)\n(succ p28 p29)\n(succ p29 p30)\n(succ p30 p31)\n(succ p31 p32)\n(succ p32 p33)\n(succ p33 p34)\n(succ p34 p35)\n(succ p35 p36)\n(succ p36 p37)\n(succ p37 p38)\n(succ p38 p39)\n(succ p39 p40)\n(succ p40 p41)\n(succ p41 p42)\n(succ p42 p43)\n(succ p43 p44)\n(succ p44 p45)\n(succ p45 p46)\n(succ p46 p47)\n(succ p47 p48)\n(succ p48 p49)\n(succ p49 p50)\n(<= (number ?x)\n(succ ?x ?y))\n(<= (number ?x)\n(succ ?y ?x))\n(<= (smaller ?x ?y)\n(succ ?x ?y))\n(<= (smaller ?x ?z)\n(succ ?y ?z)\n(smaller ?x ?y))\n(<= (add ?x p0 ?x)\n(number ?x))\n(<= (add ?x ?y ?z)\n(smaller p0 ?y)\n(succ ?y1 ?y)\n(succ ?x ?x1)\n(add ?x1 ?y1 ?z))\n(<= (add ?x ?y ?z)\n(smaller ?y p0)\n(succ ?y ?y1)\n(succ ?x1 ?x)\n(add ?x1 ?y1 ?z))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 board using a coordinate system where both the x and y coordinates range from 1 to 8. There are two players, white and black, who alternate turns with white moving first. Initially, each player places three pieces of their color—specifically knights and pawns—on predetermined rows: white pieces occupy rows 1 and 2, while black pieces occupy rows 7 and 8. This placement phase occurs only on the first step, governed by a step counter initialized to 1. During this initial step, each player’s legal move is to place three of their own pieces simultaneously in their respective starting rows. After this setup, the step counter increments and normal play begins. In normal turns, players alternate control, with white moving first, then black, and so forth, as indicated by a control predicate switching between them each turn. Each turn, a player may either perform a move action or, if allowed, a noop (no operation) action; white may perform noop only when it is black’s turn, and black may perform noop only after the initial placement step has passed and it is white’s turn, thus preventing a skip of moves before the game properly starts. Moves consist of moving a single piece from one cell to another and must be legal according to the piece’s movement rules and occupancy constraints. Specifically, a piece can move only if it belongs to the player controlling the turn, the source cell contains that piece, and the destination cell is either empty or occupied by an opponent’s piece, but never by a piece of the same color. Movement rules vary by piece type: pawns move forward one cell or diagonally forward by one cell, with the exact direction depending on color (white pawns move upward in y, black pawns downward), and knights move in an “L” shape consistent with chess knight moves, again adjusted for player color and direction. After a move, the piece vacates its original cell and occupies the new cell, while all other cells remain unchanged unless specifically moved. The step counter automatically increments each turn, tracking the number of turns elapsed. The game imposes implicit constraints including the 8x8 board boundary, ensuring coordinates remain within index 1 through 8, and that no two pieces of the same color occupy the same cell. Terminal conditions arise in three ways: if white has any piece on the eighth row (y=8), white wins; if black has any piece on the first row (y=1), black wins; or when 60 steps have passed, the game ends. Additionally, if after the initial placement step has passed there are no white pieces on the board, black wins; similarly, if no black pieces remain, white wins. Victory is binary: the winning player receives a score of 100, and the losing player receives 0. Thus, the objective is to advance one’s pieces to the opponent’s home row or eliminate all opponent pieces after the initial placement, within the 60-turn limit, while abiding by movement and placement rules on an 8x8 grid.",
    "output": "(role white)\n(role black)\n(init (control white))\n(init (stepcounter 1))\n(<= (legal white (put ?piece1 ?piece2 ?piece3))\n\t\t(true (stepcounter 1))\n\t\t(piece ?piece1 ?type1 white)\n\t\t(piece ?piece2 ?type2 white)\n\t\t(piece ?piece3 ?type3 white))\n(<= (legal black (put ?piece1 ?piece2 ?piece3))\n\t\t(true (stepcounter 1))\n\t\t(piece ?piece1 ?type1 black)\n\t\t(piece ?piece2 ?type2 black)\n\t\t(piece ?piece3 ?type3 black))\n(<= (next (cell 1 1 ?piece1))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 2 1 ?piece1))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 3 1 ?piece1))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 4 1 ?piece1))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 5 1 ?piece1))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 6 1 ?piece1))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 7 1 ?piece1))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 8 1 ?piece1))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 1 2 ?piece2))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 2 2 ?piece2))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 3 2 ?piece2))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 4 2 ?piece2))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 5 2 ?piece3))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 6 2 ?piece3))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 7 2 ?piece3))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 8 2 ?piece3))\n\t(does white (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 1 7 ?piece1))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 2 7 ?piece1))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 3 7 ?piece1))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 4 7 ?piece1))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 5 7 ?piece1))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 6 7 ?piece1))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 7 7 ?piece1))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 8 7 ?piece1))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 1 8 ?piece2))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 2 8 ?piece2))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 3 8 ?piece2))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 4 8 ?piece2))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 5 8 ?piece3))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 6 8 ?piece3))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 7 8 ?piece3))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (next (cell 8 8 ?piece3))\n\t(does black (put ?piece1 ?piece2 ?piece3)))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black noop)\n\t(not (true (stepcounter 1)))\n    (true (control white)))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cell ?x1 ?y1 ?piece))\n    (piece ?piece ?type white)\n    (piecemove ?x1 ?y1 ?x2 ?y2 ?piece)\n    (not (samecoloron ?x2 ?y2 white)))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cell ?x1 ?y1 ?piece))\n    (piece ?piece ?type black)\n    (piecemove ?x1 ?y1 ?x2 ?y2 ?piece)\n    (not (samecoloron ?x2 ?y2 black)))\n(<= (next (cell ?x ?y ?state))\n    (true (cell ?x ?y ?state))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2))\n    (distinctcell ?x ?y ?x1 ?y1)\n    (distinctcell ?x ?y ?x2 ?y2))\n(<= (next (stepcounter ?x))\n\t(true (stepcounter ?x1))\n\t(++ ?x1 ?x))\n(<= (next (cell ?x2 ?y2 ?piece))\n\t(true (cell ?x1 ?y1 ?piece))\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (control black))\n    (true (control white)))\n(<= (next (control white))\n    (true (control black)))\n(<= terminal\n    whitewin)\n(<= terminal\n\t(true (stepcounter 60)))\n(<= terminal\n    blackwin)\n(<= (goal white 100)\n    whitewin)\n(<= (goal white 0)\n    (not whitewin))\n(<= (goal black 100)\n    blackwin)\n(<= (goal black 0)\n\t(not blackwin))\n(<= whitewin\n    (index ?x)\n    (true (cell ?x 8 ?piece))\n    (piece ?piece ?type white))\n(<= blackwin\n    (index ?x)\n    (true (cell ?x 1 ?piece))\n    (piece ?piece ?type black))\n(<= blackwin\n\t(not (true (stepcounter 1)))\n\t(not whitecell))\n(<= whitewin\n\t(not (true (stepcounter 1)))\n\t(not blackcell))\n(<= whitecell\n\t(index ?x)\n\t(index ?y)\n\t(true (cell ?x ?y ?piece))\n\t(piece ?piece ?type white))\n(<= blackcell\n\t(index ?x)\n\t(index ?y)\n\t(true (cell ?x ?y ?piece))\n\t(piece ?piece ?type black))\n(<= (piecemove ?x1 ?y1 ?x2 ?y2 ?type)\n\t(piece ?type knight white)\n\t(whiteknightmove ?x1 ?y1 ?x2 ?y2))\n(<= (piecemove ?x1 ?y1 ?x2 ?y2 ?type)\n\t(piece ?type pawn white)\n\t(whitepawnmove ?x1 ?y1 ?x2 ?y2))\n(<= (piecemove ?x1 ?y1 ?x2 ?y2 ?type)\n\t(piece ?type knight black)\n\t(blackknightmove ?x1 ?y1 ?x2 ?y2))\n(<= (piecemove ?x1 ?y1 ?x2 ?y2 ?type)\n\t(piece ?type pawn black)\n\t(blackpawnmove ?x1 ?y1 ?x2 ?y2))\n(<= (whitepawnmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (whitepawnmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (whitepawnmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 0 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (blackpawnmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (blackpawnmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (blackpawnmove ?x1 ?y1 ?x2 ?y2)\n\t(plus 0 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (whiteknightmove ?x1 ?y1 ?x2 ?y2)\n    (plus 1 ?x1 ?x2)\n    (plus 2 ?y1 ?y2))\n(<= (whiteknightmove ?x1 ?y1 ?x2 ?y2)\n    (plus 1 ?x2 ?x1)\n    (plus 2 ?y1 ?y2))\n(<= (whiteknightmove ?x1 ?y1 ?x2 ?y2)\n    (plus 2 ?x1 ?x2)\n    (plus 1 ?y1 ?y2))\n(<= (whiteknightmove ?x1 ?y1 ?x2 ?y2)\n    (plus 2 ?x2 ?x1)\n    (plus 1 ?y1 ?y2))\n(<= (blackknightmove ?x1 ?y1 ?x2 ?y2)\n    (plus 1 ?x1 ?x2)\n    (plus 2 ?y2 ?y1))\n(<= (blackknightmove ?x1 ?y1 ?x2 ?y2)\n    (plus 1 ?x2 ?x1)\n    (plus 2 ?y2 ?y1))\n(<= (blackknightmove ?x1 ?y1 ?x2 ?y2)\n    (plus 2 ?x1 ?x2)\n    (plus 1 ?y2 ?y1))\n(<= (blackknightmove ?x1 ?y1 ?x2 ?y2)\n    (plus 2 ?x2 ?x1)\n    (plus 1 ?y2 ?y1))\n(<= (samecoloron ?x ?y ?color)\n\t(true (cell ?x ?y ?piece))\n\t(piece ?piece ?type ?color))\n(<= (cell ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (distinctcell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctcell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= (emptyCell ?x ?y)\n\t(index ?x)\n\t(index ?y)\n\t(not (true (cell ?x ?y whitepawn)))\n\t(not (true (cell ?x ?y whiteknight)))\n\t(not (true (cell ?x ?y blackpawn)))\n\t(not (true (cell ?x ?y blackknight))))\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(plus 0 1 1)\n(plus 0 2 2)\n(plus 0 3 3)\n(plus 0 4 4)\n(plus 0 5 5)\n(plus 0 6 6)\n(plus 0 7 7)\n(plus 0 8 8)\n(plus 1 1 2)\n(plus 1 2 3)\n(plus 1 3 4)\n(plus 1 4 5)\n(plus 1 5 6)\n(plus 1 6 7)\n(plus 1 7 8)\n(plus 2 1 3)\n(plus 2 2 4)\n(plus 2 3 5)\n(plus 2 4 6)\n(plus 2 5 7)\n(plus 2 6 8)\n(++ 1 2)\n(++ 2 3)\n(++ 3 4)\n(++ 4 5)\n(++ 5 6)\n(++ 6 7)\n(++ 7 8)\n(++ 8 9)\n(++ 9 10)\n(++ 10 11)\n(++ 11 12)\n(++ 12 13)\n(++ 13 14)\n(++ 14 15)\n(++ 15 16)\n(++ 16 17)\n(++ 17 18)\n(++ 18 19)\n(++ 19 20)\n(++ 20 21)\n(++ 21 22)\n(++ 22 23)\n(++ 23 24)\n(++ 24 25)\n(++ 25 26)\n(++ 26 27)\n(++ 27 28)\n(++ 28 29)\n(++ 29 30)\n(++ 30 31)\n(++ 31 32)\n(++ 32 33)\n(++ 33 34)\n(++ 34 35)\n(++ 35 36)\n(++ 36 37)\n(++ 37 38)\n(++ 38 39)\n(++ 39 40)\n(++ 40 41)\n(++ 41 42)\n(++ 42 43)\n(++ 43 44)\n(++ 44 45)\n(++ 45 46)\n(++ 46 47)\n(++ 47 48)\n(++ 48 49)\n(++ 49 50)\n(++ 50 51)\n(++ 51 52)\n(++ 52 53)\n(++ 53 54)\n(++ 54 55)\n(++ 55 56)\n(++ 56 57)\n(++ 57 58)\n(++ 58 59)\n(++ 59 60)\n(piece whiteknight knight white) (piece whitepawn pawn white)\n(piece blackknight knight black) (piece blackpawn pawn black)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a grid-based board with columns numbered from 1 to 7 and rows numbered from 0 to 6, forming a coordinate system where each cell is identified by its column and row indices. Initially, the bottom row (row 0) from columns 1 through 7 is filled with dirt cells, while all other cells above (rows 1 to 6) in columns 1 through 7 contain blank spaces denoted by 'b'. There are two players, red and yellow, who alternate turns with red taking the first move. On a player's turn, if it is their control phase, they may perform an action called \"mark\" by selecting a cell that currently contains dirt; this action is legal only if the player controls the turn and the targeted cell is dirt. The \"mark\" action updates the chosen cell to the player's color—red or yellow—depending on who marked it. Additionally, the dirt cell immediately above the marked cell (i.e., the cell in the same column but one row higher, provided it is within the board boundaries up to row 7) is converted from dirt to blank space 'b', simulating the clearing of dirt from beneath. All other cells remain unchanged unless affected by these rules. If it is not a player's turn to move, that player may only perform a no-operation (\"noop\") action, which is legal only when there is at least one dirt cell remaining on the board, ensuring turns continue until no dirt remains or a winning condition is met. Control alternates strictly between red and yellow after each action, with red starting the game. The game terminates when either player forms a rectangle composed of four cells of their color arranged at the corners of a rectangle within the board, or when there are no dirt cells left to mark. The rectangle must span at least four columns and four rows as defined by the checkDist and checkRect predicates, ensuring the rectangle is of minimum size and properly aligned on the grid. At termination, the player who has successfully formed such a rectangle is declared the winner with a score of 100, while the opponent scores 0. If the game ends without any player forming a rectangle and no dirt cells remain, yellow is considered the winner and scores 100, while red scores 0. Implicit constraints include that all cell coordinates must lie within the defined board boundaries, actions can only be performed on dirt cells, and the succession relations govern the vertical adjacency for the dirt clearing mechanic. Thus, the game revolves around strategic marking of dirt cells to build a rectangle of one's color while removing dirt above, with players alternating moves and the possibility of passing via noops when it is not their turn.",
    "output": "(role red)\n  (role yellow)\n  (init (cell 1 0 dirt))\n  (init (cell 2 0 dirt))\n  (init (cell 3 0 dirt))\n  (init (cell 4 0 dirt))\n  (init (cell 5 0 dirt))\n  (init (cell 6 0 dirt))\n  (init (cell 7 0 dirt))\n  (init (cell 1 1 b))\n  (init (cell 1 2 b))\n  (init (cell 1 3 b))\n  (init (cell 1 4 b))\n  (init (cell 1 5 b))\n  (init (cell 1 6 b))\n  (init (cell 2 1 b))\n  (init (cell 2 2 b))\n  (init (cell 2 3 b))\n  (init (cell 2 4 b))\n  (init (cell 2 5 b))\n  (init (cell 2 6 b))\n  (init (cell 3 1 b))\n  (init (cell 3 2 b))\n  (init (cell 3 3 b))\n  (init (cell 3 4 b))\n  (init (cell 3 5 b))\n  (init (cell 3 6 b))\n  (init (cell 4 1 b))\n  (init (cell 4 2 b))\n  (init (cell 4 3 b))\n  (init (cell 4 4 b))\n  (init (cell 4 5 b))\n  (init (cell 4 6 b))\n  (init (cell 5 1 b))\n  (init (cell 5 2 b))\n  (init (cell 5 3 b))\n  (init (cell 5 4 b))\n  (init (cell 5 5 b))\n  (init (cell 5 6 b))\n  (init (cell 6 1 b))\n  (init (cell 6 2 b))\n  (init (cell 6 3 b))\n  (init (cell 6 4 b))\n  (init (cell 6 5 b))\n  (init (cell 6 6 b))\n  (init (cell 7 1 b))\n  (init (cell 7 2 b))\n  (init (cell 7 3 b))\n  (init (cell 7 4 b))\n  (init (cell 7 5 b))\n  (init (cell 7 6 b))\n  (init (control red))\n(<= (legal ?p (mark ?x ?y) )\n\t(true(cell ?x ?y dirt ))\n\t(true(control ?p)) )\n(<= (legal red noop)\n\t(true(cell ?x ?y dirt))\n\t(true(control yellow)) )\n(<= (legal yellow noop)\n\t(true(cell ?x ?y dirt))\n\t(true (control red)) )\n(<= (next (cell ?m ?n y))\n\t(does yellow (mark ?m ?n)) )\n(<= (next (cell ?m ?n r))\n\t(does red (mark ?m ?n)) )\n(<= (next (cell ?m ?p dirt))\n\t(does ?player (mark ?m ?n))\n\t(succ ?n ?p)\n\t(lte ?p 7) )\n(<= (next (cell ?m ?n ?w))\n\t(true (cell ?m ?n ?w))\n\t(distinct ?w b)\n\t(distinct ?w dirt) )\n(<= (next (cell ?m ?n dirt))\n\t(true (cell ?m ?n dirt))\n\t(does ?player (mark ?j ?k))\n\t(distinct ?n ?k) )\n(<= (next (cell ?m ?n dirt))\n\t(true (cell ?m ?n dirt))\n\t(does ?player (mark ?j ?k))\n\t(distinct ?m ?j) )\n(<= (next (cell ?m ?n b))\n\t(true (cell ?m ?n b))\n\t(does ?player (mark ?j ?k))\n\t(distinct ?m ?j) )\n(<= (next (cell ?m ?n b))\n\t(true (cell ?m ?n b))\n\t(does ?player (mark ?j ?k))\n\t(succ ?k ?x)\n\t(distinct ?n ?x) )\n(<= (next (control yellow))\n\t(true (control red)) )\n(<= (next (control red))\n\t(true (control yellow)) )\n(<= (checkDist ?m ?n)\n\t(lte ?z ?n)\n\t(succ ?m ?x)\n\t(succ ?x ?y)\n\t(succ ?y ?z) )\n(<= (checkRect ?ax ?ay ?ax ?by ?cx ?ay ?cx ?by)\n\t(checkDist ?ax ?cx)\n\t(checkDist ?ay ?by))\n(<= (rectangle ?player)\n\t(checkRect ?ax ?ay ?bx ?by ?cx ?cy ?dx ?dy)\n\t(true (cell ?ax ?ay ?player))\n\t(true (cell ?bx ?by ?player))\n\t(true (cell ?cx ?cy ?player))\n\t(true (cell ?dx ?dy ?player)) )\n(<= open\n\t(true(cell ?m ?n dirt)) )\n(<= terminal\n\t(rectangle y) )\n(<= terminal\n\t(rectangle r) )\n(<= terminal\n\t(not open) )\n(<= (goal red 100)\n\t(rectangle r) )\n(<= (goal red 0)\n\t(rectangle y)  )\n(<= (goal red 0)\n\t(not open)\n\t(not (rectangle r))\n\t(not (rectangle y)) )\n(<= (goal yellow 100)\n\t(rectangle y) )\n(<= (goal yellow 0)\n\t(rectangle r)  )\n(<= (goal yellow 100)\n\t(not open)\n\t(not (rectangle r))\n\t(not (rectangle y)) )\n(<= (lte 0 ?x)\n        (number ?x))\n(<= (lte ?x ?x)\n        (number ?x))\n(<= (lte ?x ?z)\n    (succ ?y ?z)\n    (lte ?x ?y))\n(<= (lte ?x ?y)\n    (succ ?x ?y))\n(number 0)\n(number 1)\n(number 2)\n(number 3)\n(number 4)\n(number 5)\n(number 6)\n(number 7)\n(number 8)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(<= (column ?x)\n    (number ?x)\n    (distinct ?x 0)\n    (distinct ?x 8))\n(<= (row ?y)\n    (number ?y)\n    (distinct ?y 8))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is set on a toroidal grid with seven rows labeled r1 through r7 and eleven columns labeled c01 through c11, where rows and columns wrap around cyclically such that moving off one edge re-enters on the opposite side. Each cell in this grid can be one of several types: blank (b), wall, point, or exit. The player assumes the sole role of the snake, which occupies a position on the board defined by coordinates (column and row), along with a tail position that moves according to the snake's motion. The initial state places various cells with predefined types—most are blank, some are walls or points, and one cell is the exit—with the snake starting at position c06 r4 and its tail also at this cell, holding zero points and with the game step counter at zero. During play, the snake takes turns making moves in one of four directions: up, down, left, or right, which correspond to moving to the adjacent cell in the respective direction, with the wraparound on rows and columns ensuring continuous movement across the board edges. On each turn, the snake must choose a legal move, which is defined as moving from its current head position to a next cell that is either blank, contains a point, or is the exit, and must not be a wall; the snake cannot move into walls or invalid cells. If no legal moves are available, the game terminates. The move action updates the snake's head position to the new cell and advances the game step counter by one. The snake's tail position updates every other move, alternating based on an internal even-move flag: on moves when this flag is false, the tail position remains; when true, the tail moves forward to follow the snake's body, effectively simulating snake growth and movement. The cells update accordingly, with the previous tail cell becoming blank when the tail moves. When the snake enters a cell containing a point, it scores a point, incrementing its total points by one, and the point is considered consumed. The scoring system maps the number of points collected to a score value, increasing in discrete increments. The game terminates either when the snake reaches the exit cell, when fifty steps have elapsed, or when there are no legal moves possible. The player's goal is to maximize their score, which depends on how many points the snake has collected upon reaching the exit or before termination if the exit is not reached. Overall, the gameplay simulates navigating a snake through a grid with obstacles and collectible points, moving stepwise with turn-based control, wrapping around the grid edges, and tracking growth and scoring until a terminal condition ends the game.",
    "output": "(role snake)\n(init (cell c01 r1 b))\n(init (cell c02 r1 b))\n(init (cell c03 r1 b))\n(init (cell c04 r1 wall))\n(init (cell c05 r1 b))\n(init (cell c06 r1 b))\n(init (cell c07 r1 wall))\n(init (cell c08 r1 point))\n(init (cell c09 r1 b))\n(init (cell c10 r1 b))\n(init (cell c11 r1 b))\n(init (cell c01 r2 wall))\n(init (cell c02 r2 wall))\n(init (cell c03 r2 point))\n(init (cell c04 r2 wall))\n(init (cell c05 r2 b))\n(init (cell c06 r2 b))\n(init (cell c07 r2 b))\n(init (cell c08 r2 b))\n(init (cell c09 r2 b))\n(init (cell c10 r2 b))\n(init (cell c11 r2 wall))\n(init (cell c01 r3 b))\n(init (cell c02 r3 b))\n(init (cell c03 r3 b))\n(init (cell c04 r3 wall))\n(init (cell c05 r3 wall))\n(init (cell c06 r3 wall))\n(init (cell c07 r3 point))\n(init (cell c08 r3 wall))\n(init (cell c09 r3 wall))\n(init (cell c10 r3 b))\n(init (cell c11 r3 b))\n(init (cell c01 r4 point))\n(init (cell c02 r4 wall))\n(init (cell c03 r4 b))\n(init (cell c04 r4 b))\n(init (cell c05 r4 b))\n(init (cell c06 r4 b))\n(init (cell c07 r4 b))\n(init (cell c08 r4 b))\n(init (cell c09 r4 wall))\n(init (cell c10 r4 b))\n(init (cell c11 r4 b))\n(init (cell c01 r5 wall))\n(init (cell c02 r5 wall))\n(init (cell c03 r5 b))\n(init (cell c04 r5 b))\n(init (cell c05 r5 b))\n(init (cell c06 r5 b))\n(init (cell c07 r5 wall))\n(init (cell c08 r5 b))\n(init (cell c09 r5 wall))\n(init (cell c10 r5 wall))\n(init (cell c11 r5 wall))\n(init (cell c01 r6 b))\n(init (cell c02 r6 wall))\n(init (cell c03 r6 exit))\n(init (cell c04 r6 b))\n(init (cell c05 r6 b))\n(init (cell c06 r6 point))\n(init (cell c07 r6 wall))\n(init (cell c08 r6 b))\n(init (cell c09 r6 b))\n(init (cell c10 r6 wall))\n(init (cell c11 r6 point))\n(init (cell c01 r7 b))\n(init (cell c02 r7 wall))\n(init (cell c03 r7 wall))\n(init (cell c04 r7 wall))\n(init (cell c05 r7 wall))\n(init (cell c06 r7 b))\n(init (cell c07 r7 wall))\n(init (cell c08 r7 b))\n(init (cell c09 r7 b))\n(init (cell c10 r7 wall))\n(init (cell c11 r7 b))\n(init (step 0))\n(init (pos c06 r4))\n(init (tailpos c06 r4))\n(init (points 0))\n(<= (nextcell ?x ?y1 mov_up ?x ?y2)\n(rowinc ?y2 ?y1)\n(column ?x))\n(<= (nextcell ?x ?y1 mov_down ?x ?y2)\n(rowinc ?y1 ?y2)\n(column ?x))\n(<= (nextcell ?x1 ?y mov_left ?x2 ?y)\n(colinc ?x2 ?x1)\n(row ?y))\n(<= (nextcell ?x1 ?y mov_right ?x2 ?y)\n(colinc ?x1 ?x2)\n(row ?y))\n(rowinc r1 r2) (rowinc r2 r3) (rowinc r3 r4) (rowinc r4 r5) (rowinc r5 r6) (rowinc r6 r7) (rowinc r7 r1)\n(row r1) (row r2) (row r3) (row r4) (row r5) (row r6) (row r7)\n(colinc c01 c02) (colinc c02 c03) (colinc c03 c04) (colinc c04 c05) (colinc c05 c06) (colinc c06 c07) (colinc c07 c08) (colinc c08 c09) (colinc c09 c10) (colinc c10 c11) (colinc c11 c01)\n(column c01) (column c02) (column c03) (column c04) (column c05) (column c06) (column c07) (column c08) (column c09) (column c10) (column c11)\n(<= (legal snake ?move)\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn)\n(maymove ?xn ?yn))\n(<= (maymove ?x ?y)\n(true (cell ?x ?y b)))\n(<= (maymove ?x ?y)\n(true (cell ?x ?y point)))\n(<= (maymove ?x ?y)\n(true (cell ?x ?y exit)))\n(<= (next (step ?y))\n(true (step ?x))\n(succ ?x ?y))\n(<= (next (cell ?x ?y ?move))\n(does snake ?move)\n(true (pos ?x ?y)))\n(<= (next (pos ?xn ?yn))\n(does snake ?move)\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn))\n(<= (next evenmove) (not (true evenmove)))\n(<= (next (tailpos ?x ?y))\n(not (true evenmove))\n(true (tailpos ?x ?y)))\n(<= (next (tailpos ?xn ?yn))\n(true evenmove)\n(true (tailpos ?x ?y))\n(true (cell ?x ?y ?move))\n(nextcell ?x ?y ?move ?xn ?yn))\n(<= (next (cell ?x ?y b))\n(true evenmove)\n(true (tailpos ?x ?y)))\n(<= (next (cell ?x ?y ?sym))\n(true (cell ?x ?y ?sym))\n(not (true (pos ?x ?y)))\n(not (true evenmove)))\n(<= (next (cell ?x ?y ?sym))\n(true (cell ?x ?y ?sym))\n(not (true (pos ?x ?y)))\n(not (true (tailpos ?x ?y))))\n(<= (next (points ?n1))\n(true (points ?n))\ndoscore\n(succ ?n ?n1))\n(<= (next (points ?n))\n(true (points ?n))\n(not doscore))\n(<= doscore\n(true (pos ?x ?y))\n(true (cell ?x ?y point)))\n(score 0 0 0)\n(score 1 8 58)\n(score 2 16 66)\n(score 3 24 74)\n(score 4 32 82)\n(score 5 40 90)\n(score 6 50 100)\n(<= (goal snake ?s)\n(true (points ?n))\n(true (pos ?x ?y))\n(true (cell ?x ?y exit))\n(score ?n ?s1 ?s))\n(<= (goal snake ?s)\n(true (points ?n))\n(true (pos ?x ?y))\n(not (true (cell ?x ?y exit)))\n(score ?n ?s ?s1))\n(<= terminal\n(true (pos ?x ?y))\n(true (cell ?x ?y exit)))\n(<= terminal\n(true (step 50)))\n(<= terminal\n(not exists_legal))\n(<= exists_legal\n(true (pos ?x ?y))\n(nextcell ?x ?y ?move ?xn ?yn)\n(maymove ?xn ?yn))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 grid with coordinates ranging from 1 to 8 along both the x (horizontal) and y (vertical) axes. There are two players, Black and Red, who alternate turns with Black having the initial control. The initial setup places four pieces in the center of the board: Black pieces at positions (4,4) and (5,5), and Red pieces at (4,5) and (5,4). On a player's turn, they may either place a piece of their color on an empty cell or perform a no-operation (noop) if no legal moves are available; a player may also noop if it is not their turn. A move consists of specifying the coordinates (x,y) where the player wishes to mark a piece. A move is legal only if it is the player's turn, the target cell is empty, and placing a piece there would flip at least one of the opponent’s pieces by bracketing them in a straight line—horizontally, vertically, or diagonally—between the newly placed piece and another piece of the player's color. If no such legal moves exist, the player must choose noop. When a piece is placed, all opponent's pieces that are flanked in any direction by the player's new piece and another piece of the player’s color are flipped to the player's color. If the opponent chooses noop while the player retains control over a cell, that cell remains unchanged. The game's state updates accordingly each turn, switching control between Black and Red. The board boundaries restrict placement to cells within the 8x8 grid. Occupied cells cannot be chosen for placement, and moves must adhere to the flipping rules to be legal. The game ends when neither player has any legal moves remaining. Scoring is determined by counting the number of pieces each player has on the board at termination. The player with the higher count wins and receives a score of 100, the loser receives 0, and in case of a tie, both players score 50. If the game is not over, both players have a score of 0. Thus, the game proceeds via alternating moves or noops, with piece placement that flips opponent pieces according to adjacency rules within the bounded 8x8 board, concluding when no further moves are possible and scoring based on piece majority.",
    "output": "(role black)\n(role red)\n(init (cell 4 4 black))\n(init (cell 4 5 red))\n(init (cell 5 4 red))\n(init (cell 5 5 black))\n(init (control black))\n(<= (legal ?player (mark ?x ?y))\n    (true (control ?player))\n    (hasLegalMoveAt ?player ?x ?y))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasAnyLegalMove ?player)))\n(<= (legal ?player noop)\n    (opponent ?player ?opponent)\n    (true (control ?opponent)))\n(<= (next (cell ?x ?y ?player))\n    (does ?player (mark ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n    (true (cell ?x ?y ?player))\n    (opponent ?player ?opponent)\n    (does ?opponent noop))\n(<= (next (cell ?xP ?yP ?player))\n    (true (cell ?xP ?yP ?player))\n    (opponent ?player ?opponent)\n    (does ?opponent (mark ?xO ?yO))\n    (not (playWillFlip ?opponent ?xO ?yO ?player ?xP ?yP)))\n(<= (next (cell ?xP ?yP ?opponent))\n    (true (cell ?xP ?yP ?player))\n    (opponent ?player ?opponent)\n    (does ?opponent (mark ?xO ?yO))\n    (playWillFlip ?opponent ?xO ?yO ?player ?xP ?yP))\n(<= (next (control black))\n    (true (control red)))\n(<= (next (control red))\n    (true (control black)))\n(<= terminal\n    gameOver)\n(<= (goal black 0)\n    (not gameOver))\n(<= (goal black 0)\n    gameOver\n    (tally ?black ?red)\n    (lessThan ?red ?black))\n(<= (goal black 50)\n    gameOver\n    (tally ?tied ?tied))\n(<= (goal black 100)\n    gameOver\n    (tally ?black ?red)\n    (lessThan ?black ?red))\n(<= (goal red 0)\n    (not gameOver))\n(<= (goal red 0)\n    gameOver\n    (tally ?black ?red)\n    (lessThan ?black ?red))\n(<= (goal red 50)\n    gameOver\n    (tally ?tied ?tied))\n(<= (goal red 100)\n    gameOver\n    (tally ?black ?red)\n    (lessThan ?red ?black))\n(<= (cellOpen ?x ?y)\n    (index ?x)\n    (index ?y)\n    (not (true (cell ?x ?y black)))\n    (not (true (cell ?x ?y red))))\n(<= (nextCell N ?x ?y1 ?x ?y2)\n    (index ?x)\n    (indexpp ?y1 ?y2))\n(<= (nextCell S ?x ?y1 ?x ?y2)\n    (index ?x)\n    (indexpp ?y2 ?y1))\n(<= (nextCell E ?x1 ?y ?x2 ?y)\n    (indexpp ?x1 ?x2)\n    (index ?y))\n(<= (nextCell W ?x1 ?y ?x2 ?y)\n    (indexpp ?x2 ?x1)\n    (index ?y))\n(<= (nextCell NE ?x1 ?y1 ?x2 ?y2)\n    (indexpp ?x1 ?x2)\n    (indexpp ?y1 ?y2))\n(<= (nextCell NW ?x1 ?y1 ?x2 ?y2)\n    (indexpp ?x2 ?x1)\n    (indexpp ?y1 ?y2))\n(<= (nextCell SE ?x1 ?y1 ?x2 ?y2)\n    (indexpp ?x1 ?x2)\n    (indexpp ?y2 ?y1))\n(<= (nextCell SW ?x1 ?y1 ?x2 ?y2)\n    (indexpp ?x2 ?x1)\n    (indexpp ?y2 ?y1))\n(<= (openPieceString ?player ?x0 ?y0 ?dir ?xF ?yF)\n    (true (cell ?x0 ?y0 ?player))\n    (nextCell ?dir ?x0 ?y0 ?xNext ?yNext)\n    (openPieceString ?player ?xNext ?yNext ?dir ?xF ?yF))\n(<= (openPieceString ?player ?x0 ?y0 ?dir ?xF ?yF)\n    (true (cell ?x0 ?y0 ?player))\n    (nextCell ?dir ?x0 ?y0 ?xF ?yF))\n(<= (closedPieceString ?player ?x0 ?y0 ?dir ?xF ?yF)\n    (true (cell ?x0 ?y0 ?player))\n    (nextCell ?dir ?x0 ?y0 ?xNext ?yNext)\n    (closedPieceString ?player ?xNext ?yNext ?dir ?xF ?yF))\n(<= (closedPieceString ?player ?x0 ?y0 ?dir ?xF ?yF)\n    (true (cell ?x0 ?y0 ?player))\n    (nextCell ?dir ?x0 ?y0 ?xF ?yF)\n    (opponent ?player ?opponent)\n    (true (cell ?xF ?yF ?opponent)))\n(<= (playWillFlip ?player ?xP ?yP ?opponent ?xO ?yO)\n    (role ?player)\n    (openPieceString ?opponent ?xO ?yO ?dir ?xP ?yP)\n    (opposite ?dir ?oppDir)\n    (closedPieceString ?opponent ?xO ?yO ?oppDir ?xAny ?yAny))\n(<= (hasLegalMoveAt ?player ?xP ?yP)\n    (cellOpen ?xP ?yP)\n    (opponent ?player ?opponent)\n    (true (cell ?xO ?yO ?opponent))\n    (playWillFlip ?player ?xP ?yP ?opponent ?xO ?yO))\n(<= (hasAnyLegalMove ?player)\n    (hasLegalMoveAt ?player ?x ?y))\n(<= (tally ?black ?red)\n    (pieceCount 1 1 ?black ?red))\n(<= (pieceCount ?x ?y ?blackCountpp ?redCount)\n\t(index ?y)\n    (distinct ?y 8)\n    (indexpp ?y ?ypp)\n    (true (cell ?x ?y black))\n    (pieceCount ?x ?ypp ?blackCount ?redCount)\n    (pp ?blackCount ?blackCountpp))\n(<= (pieceCount ?x ?y ?blackCount ?redCountpp)\n\t(index ?y)\n    (distinct ?y 8)\n    (indexpp ?y ?ypp)\n    (true (cell ?x ?y red))\n    (pieceCount ?x ?ypp ?blackCount ?redCount)\n    (pp ?redCount ?redCountpp))\n(<= (pieceCount ?x ?y ?blackCount ?redCount)\n\t(index ?y)\n    (distinct ?y 8)\n    (indexpp ?y ?ypp)\n    (cellOpen ?x ?y)\n    (pieceCount ?x ?ypp ?blackCount ?redCount))\n(<= (pieceCount ?x 8 ?blackCountpp ?redCount)\n\t(index ?x)\n    (distinct ?x 8)\n    (indexpp ?x ?xpp)\n    (true (cell ?x 8 black))\n    (pieceCount ?xpp 1 ?blackCount ?redCount)\n    (pp ?blackCount ?blackCountpp))\n(<= (pieceCount ?x 8 ?blackCount ?redCountpp)\n\t(index ?x)\n    (distinct ?x 8)\n    (indexpp ?x ?xpp)\n    (true (cell ?x 8 red))\n    (pieceCount ?xpp 1 ?blackCount ?redCount)\n    (pp ?redCount ?redCountpp))\n(<= (pieceCount ?x 8 ?blackCount ?redCount)\n\t(index ?x)\n    (distinct ?x 8)\n    (indexpp ?x ?xpp)\n    (cellOpen ?x 8)\n    (pieceCount ?xpp 1 ?blackCount ?redCount))\n(<= (pieceCount 8 8 1 0)\n    (true (cell 8 8 black)))\n(<= (pieceCount 8 8 0 1)\n    (true (cell 8 8 red)))\n(<= (pieceCount 8 8 0 0)\n    (cellOpen 8 8))\n(<= (lessThan ?x ?y)\n    (pp ?x ?xpp)\n    (lessThan ?xpp ?y))\n(<= (lessThan ?x ?y)\n    (pp ?x ?y))\n(<= gameOver\n    (not (hasAnyLegalMove black))\n    (not (hasAnyLegalMove red)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(indexpp 1 2) (indexpp 2 3) (indexpp 3 4) (indexpp 4 5) (indexpp 5 6) (indexpp 6 7) (indexpp 7 8)\n(opponent red black)\n(opponent black red)\n(direction  N)  (direction S) (direction  E) (direction  W)\n(direction NE) (direction NW) (direction SE) (direction SW)\n(opposite  N  S) (opposite  S  N) (opposite  E  W) (opposite  W  E)\n(opposite NE SW) (opposite SW NE) (opposite NW SE) (opposite SE NW)\n(int  0) (int  1) (int  2) (int  3) (int  4) (int  5) (int  6) (int  7) (int  8) (int  9)\n(int 10) (int 11) (int 12) (int 13) (int 14) (int 15) (int 16) (int 17) (int 18) (int 19)\n(int 20) (int 21) (int 22) (int 23) (int 24) (int 25) (int 26) (int 27) (int 28) (int 29)\n(int 30) (int 31) (int 32) (int 33) (int 34) (int 35) (int 36) (int 37) (int 38) (int 39)\n(int 40) (int 41) (int 42) (int 43) (int 44) (int 45) (int 46) (int 47) (int 48) (int 49)\n(int 50) (int 51) (int 52) (int 53) (int 54) (int 55) (int 56) (int 57) (int 58) (int 59)\n(int 60) (int 61) (int 62) (int 63) (int 64)\n(pp  0  1) (pp  1  2) (pp  2  3) (pp  3  4) (pp  4  5) (pp  5  6) (pp  6  7) (pp  7  8) (pp  8  9) (pp  9 10)\n(pp 10 11) (pp 11 12) (pp 12 13) (pp 13 14) (pp 14 15) (pp 15 16) (pp 16 17) (pp 17 18) (pp 18 19) (pp 19 20)\n(pp 20 21) (pp 21 22) (pp 22 23) (pp 23 24) (pp 24 25) (pp 25 26) (pp 26 27) (pp 27 28) (pp 28 29) (pp 29 30)\n(pp 30 31) (pp 31 32) (pp 32 33) (pp 33 34) (pp 34 35) (pp 35 36) (pp 36 37) (pp 37 38) (pp 38 39) (pp 39 40)\n(pp 40 41) (pp 41 42) (pp 42 43) (pp 43 44) (pp 44 45) (pp 45 46) (pp 46 47) (pp 47 48) (pp 48 49) (pp 49 50)\n(pp 50 51) (pp 51 52) (pp 52 53) (pp 53 54) (pp 54 55) (pp 55 56) (pp 56 57) (pp 57 58) (pp 58 59) (pp 59 60)\n(pp 60 61) (pp 61 62) (pp 62 63) (pp 63 64)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a uniquely shaped board consisting of 37 distinct positions labeled with coordinates such as a1, b1, b2, up to i1, arranged in an irregular hex-like pattern. Six players participate in the game, each assigned a color role: red, yellow, green, teal, blue, and magenta. Turns proceed in a fixed cyclical order starting with red, followed by yellow, then green, teal, blue, magenta, and looping back to red again. Initially, various cells on the board are occupied by stones belonging to the players, with specific starting locations such as red occupying a1, b1, b2; magenta on c1, c2, d1; yellow on c6, c7, d6; blue on f1, g1, g2; green on f6, g6, g7; and teal on h1, h2, i1. At the start, red has control and the game step count begins at one.\n\nEach turn, the player in control may choose to perform a move or a no-operation (noop). The noop action is always legal for any player, allowing them to pass their turn without effect. A legal move action consists of moving a stone from one position on the board to another, denoted by the move from a starting cell to a destination cell. The legality of a move depends on strict movement rules defined by adjacency relationships specific to each player’s perspective, expressed through \"car\" and \"cdr\" relations which represent directed connections between cells. A player may move a stone from a cell they occupy to a destination cell only if a particular path of up to three steps exists through occupied and empty cells following these adjacency relations, ensuring that the move \"jumps\" over occupied cells in a pattern unique to the player's color and the board topology. Moves cannot be performed into occupied cells, and the stone being moved must belong to the player making the move. These movement constraints implicitly impose board boundaries and occupancy restrictions.\n\nWhen a move is made, the cell from which the stone moves becomes empty, and the destination cell becomes occupied by that player's stone in the next state. Cells not affected by a move remain occupied by their current stones. Control passes automatically to the next player in the fixed turn order after each action, and the step count increments by one. The game ends when either a player achieves a maximum score of 100 points or when the step count reaches 61, whichever occurs first.\n\nScoring is determined by evaluating specific triplets of cells assigned to each player, referred to as \"toCount\" sets, unique to each color. For each triplet, a player earns 100 points if all three cells are occupied by their stones; 50 points if exactly two of the three cells are occupied by their stones; 25 points if exactly one cell is occupied by their stones; and 0 points if none of the cells in the triplet are occupied by them. The player's total score is the sum of points accumulated from these triplets. Victory is achieved by the player who first reaches 100 points or by the state of the game at step 61 if no player has reached 100 points.\n\nIn summary, the game involves six players moving stones across a complex board according to strict adjacency-based movement rules, taking turns in a fixed order, with scoring based on controlling specific triplets of board positions. The game concludes either when a player fully controls a triplet scoring 100 points or when the turn count expires, with the highest scoring player prevailing.",
    "output": "(role red)\n(role yellow)\n(role green)\n(role teal)\n(role blue)\n(role magenta)\n(index a1)\n(index b1) (index b2)\n(index c1) (index c2) (index c3) (index c4) (index c5) (index c6) (index c7)\n(index d1) (index d2) (index d3) (index d4) (index d5) (index d6)\n(index e1) (index e2) (index e3) (index e4) (index e5)\n(index f1) (index f2) (index f3) (index f4) (index f5) (index f6)\n(index g1) (index g2) (index g3) (index g4) (index g5) (index g6) (index g7)\n(index h1) (index h2)\n(index i1)\n(init (cell a1 red))\n(init (cell b1 red))\n(init (cell b2 red))\n(init (cell c1 magenta))\n(init (cell c2 magenta))\n(init (cell c6 yellow))\n(init (cell c7 yellow))\n(init (cell d1 magenta))\n(init (cell d6 yellow))\n(init (cell f1 blue))\n(init (cell f6 green))\n(init (cell g1 blue))\n(init (cell g2 blue))\n(init (cell g6 green))\n(init (cell g7 green))\n(init (cell h1 teal))\n(init (cell h2 teal))\n(init (cell i1 teal))\n(init (control red))\n(init (step 1))\n(<= (next (cell ?e ?player))\n    (does ?player (move ?b ?e)))\n(<= (next (cell ?x ?z))\n    (true (cell ?x ?z))\n    (not (affected ?x)))\n(<= (affected ?x)\n    (does ?player (move ?x ?z)))\n(<= (next (control yellow))\n    (true (control red)))\n(<= (next (control green))\n    (true (control yellow)))\n(<= (next (control teal))\n    (true (control green)))\n(<= (next (control blue))\n    (true (control teal)))\n(<= (next (control magenta))\n    (true (control blue)))\n(<= (next (control red))\n    (true (control magenta)))\n(<= (next (step ?y))\n    (true (step ?x))\n    (succ ?x ?y))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(<= (legal ?player (move ?b ?e))\n    (true (control ?player))\n    (movable ?player ?b ?e))\n(<= (legal ?player noop)\n    (role ?player))\n(<= (occupied ?c)\n    (true (cell ?c ?p)))\n(<= (empty ?c)\n    (index ?c)\n    (not (occupied ?c)))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (car ?player ?x ?d)\n    (occupied ?d)\n    (car ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?x)\n    (empty ?x)\n    (cdr ?player ?x ?d)\n    (occupied ?d)\n    (cdr ?player ?d ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?c)\n    (occupied ?c)\n    (car ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?c)\n    (occupied ?c)\n    (cdr ?player ?c ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (car ?player ?b ?e)\n    (empty ?e))\n(<= (movable ?player ?b ?e)\n    (true (cell ?b ?player))\n    (cdr ?player ?b ?e)\n    (empty ?e))\n(<= (car red ?b ?e)\n    (carred ?b ?e))\n(<= (car yellow ?b ?e)\n    (caryellow ?b ?e))\n(<= (car green ?b ?e)\n    (carmagenta ?e ?b))\n(<= (car teal ?b ?e)\n    (carred ?e ?b))\n(<= (car blue ?b ?e)\n    (caryellow ?e ?b))\n(<= (car magenta ?b ?e)\n    (carmagenta ?b ?e))\n(<= (cdr red ?b ?e)\n    (cdrred ?b ?e))\n(<= (cdr yellow ?b ?e)\n    (cdryellow ?b ?e))\n(<= (cdr green ?b ?e)\n    (cdrmagenta ?e ?b))\n(<= (cdr teal ?b ?e)\n    (cdrred ?e ?b))\n(<= (cdr blue ?b ?e)\n    (cdryellow ?e ?b))\n(<= (cdr magenta ?b ?e)\n    (cdrmagenta ?b ?e))\n(carmagenta c1 d1)\n(carmagenta d1 e1)\n(carmagenta c2 d2)\n(carmagenta e1 f2)\n(carmagenta d2 e2)\n(carmagenta c3 d3)\n(carmagenta f2 g3)\n(carmagenta e2 f3)\n(carmagenta d3 e3)\n(carmagenta c4 d4)\n(carmagenta f3 g4)\n(carmagenta e3 f4)\n(carmagenta d4 e4)\n(carmagenta c5 d5)\n(carmagenta f4 g5)\n(carmagenta e4 f5)\n(carmagenta d5 e5)\n(carmagenta f5 g6)\n(carmagenta e5 f6)\n(carmagenta f6 g7)\n(cdrmagenta c1 c2)\n(cdrmagenta d1 d2)\n(cdrmagenta c2 c3)\n(cdrmagenta e1 e2)\n(cdrmagenta d2 d3)\n(cdrmagenta c3 c4)\n(cdrmagenta f2 f3)\n(cdrmagenta e2 e3)\n(cdrmagenta d3 d4)\n(cdrmagenta c4 c5)\n(cdrmagenta g3 g4)\n(cdrmagenta f3 f4)\n(cdrmagenta e3 e4)\n(cdrmagenta d4 d5)\n(cdrmagenta g4 g5)\n(cdrmagenta f4 f5)\n(cdrmagenta e4 e5)\n(cdrmagenta g5 g6)\n(cdrmagenta f5 f6)\n(cdrmagenta g6 g7)\n(carred a1 b1)\n(carred b1 c3)\n(carred b2 c4)\n(carred c3 d2)\n(carred c4 d3)\n(carred c5 d4)\n(carred d2 e1)\n(carred d3 e2)\n(carred d4 e3)\n(carred d5 e4)\n(carred e2 f2)\n(carred e3 f3)\n(carred e4 f4)\n(carred e5 f5)\n(carred f3 g3)\n(carred f4 g4)\n(carred f5 g5)\n(carred g4 h1)\n(carred g5 h2)\n(carred h2 i1)\n(cdrred a1 b2)\n(cdrred b1 c4)\n(cdrred b2 c5)\n(cdrred c3 d3)\n(cdrred c4 d4)\n(cdrred c5 d5)\n(cdrred d2 e2)\n(cdrred d3 e3)\n(cdrred d4 e4)\n(cdrred d5 e5)\n(cdrred e1 f2)\n(cdrred e2 f3)\n(cdrred e3 f4)\n(cdrred e4 f5)\n(cdrred f2 g3)\n(cdrred f3 g4)\n(cdrred f4 g5)\n(cdrred g3 h1)\n(cdrred g4 h2)\n(cdrred h1 i1)\n(caryellow c7 c6)\n(caryellow c6 c5)\n(caryellow d6 d5)\n(caryellow c5 c4)\n(caryellow d5 d4)\n(caryellow e5 e4)\n(caryellow c4 c3)\n(caryellow d4 d3)\n(caryellow e4 e3)\n(caryellow f5 f4)\n(caryellow g5 g4)\n(caryellow d3 d2)\n(caryellow e3 e2)\n(caryellow f4 f3)\n(caryellow e2 e1)\n(caryellow f3 f2)\n(caryellow g4 g3)\n(caryellow f2 f1)\n(caryellow g3 g2)\n(caryellow g2 g1)\n(cdryellow c7 d6)\n(cdryellow c6 d5)\n(cdryellow d6 e5)\n(cdryellow c5 d4)\n(cdryellow d5 e4)\n(cdryellow e5 f5)\n(cdryellow c4 d3)\n(cdryellow d4 e3)\n(cdryellow e4 f4)\n(cdryellow f5 g5)\n(cdryellow c3 d2)\n(cdryellow d3 e2)\n(cdryellow e3 f3)\n(cdryellow f4 g4)\n(cdryellow d2 e1)\n(cdryellow e2 f2)\n(cdryellow f3 g3)\n(cdryellow e1 f1)\n(cdryellow f2 g2)\n(cdryellow f1 g1)\n(<= (goal ?player ?payoff)\n    (stones ?player ?payoff))\n(toCount red h1 h2 i1)\n(toCount yellow f1 g1 g2)\n(toCount green c1 c2 d1)\n(toCount teal a1 b1 b2)\n(toCount blue c6 c7 d6)\n(toCount magenta f6 g6 g7)\n(<= (stones ?player 100)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 50)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (true (cell ?z ?player)))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (true (cell ?x ?player))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (true (cell ?y ?player))\n    (not (true (cell ?z ?player))))\n(<= (stones ?player 25)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (true (cell ?z ?player)))\n(<= (stones ?player 0)\n    (toCount ?player ?x ?y ?z)\n    (not (true (cell ?x ?player)))\n    (not (true (cell ?y ?player)))\n    (not (true (cell ?z ?player))))\n(<= terminal\n    (true (step 61)))\n(<= terminal\n    (stones ?player 100))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a standard 8-by-8 board with files labeled from a to h and ranks numbered from 1 to 8, forming a coordinate system where each cell is identified by a file and a rank. The entire board initially consists of empty cells, each marked as blank. There is a single player role named white who takes turns sequentially, and on each turn, the white player may perform exactly one action or choose to do nothing; however, the provided rules only specify actions for the white player. The initial state places all cells as blank and sets the points score to zero, with a special initial marker indicating the start of the game. On each turn, the white player may place a knight piece on any blank cell by specifying its coordinates; this action is legal only if the targeted cell is currently blank. When a knight is placed on a cell, that cell's state changes from blank to occupied by a white knight, while all other cells retain their previous state unless directly affected by this placement. The game maintains a points counter that increments by one after each placement action, starting from zero at the initial state. The game enforces implicit board boundaries by restricting placements strictly within the defined coordinates from a to h and 1 to 8, and no cell can be occupied by more than one piece at any time; thus, the placement action must target an unoccupied cell. A key automatic event is the detection of whether any two knights on the board can attack each other following the movement pattern of a knight in chess: moving two squares in one direction and one square perpendicular to that, defined by adjacency relations between files and ranks. The terminal condition occurs when there exists at least one pair of knights on the board such that one can move to the other's position using a valid knight move, meaning the knights threaten each other. The scoring or victory condition corresponds to the current points value, which reflects the number of knights successfully placed without conflict; the goal for the white player is to maximize this count. Throughout, the game enforces that knight moves and placements respect the adjacency and distance relationships inherent to knight movement, as well as ensuring no overlap of pieces, preserving the integrity of the board state and the progression of play until the terminal condition is met.",
    "output": "(role white)\n(init (cell a 1 b))\n(init (cell a 2 b))\n(init (cell a 3 b))\n(init (cell a 4 b))\n(init (cell a 5 b))\n(init (cell a 6 b))\n(init (cell a 7 b))\n(init (cell a 8 b))\n(init (cell b 1 b))\n(init (cell b 2 b))\n(init (cell b 3 b))\n(init (cell b 4 b))\n(init (cell b 5 b))\n(init (cell b 6 b))\n(init (cell b 7 b))\n(init (cell b 8 b))\n(init (cell c 1 b))\n(init (cell c 2 b))\n(init (cell c 3 b))\n(init (cell c 4 b))\n(init (cell c 5 b))\n(init (cell c 6 b))\n(init (cell c 7 b))\n(init (cell c 8 b))\n(init (cell d 1 b))\n(init (cell d 2 b))\n(init (cell d 3 b))\n(init (cell d 4 b))\n(init (cell d 5 b))\n(init (cell d 6 b))\n(init (cell d 7 b))\n(init (cell d 8 b))\n(init (cell e 1 b))\n(init (cell e 2 b))\n(init (cell e 3 b))\n(init (cell e 4 b))\n(init (cell e 5 b))\n(init (cell e 6 b))\n(init (cell e 7 b))\n(init (cell e 8 b))\n(init (cell f 1 b))\n(init (cell f 2 b))\n(init (cell f 3 b))\n(init (cell f 4 b))\n(init (cell f 5 b))\n(init (cell f 6 b))\n(init (cell f 7 b))\n(init (cell f 8 b))\n(init (cell g 1 b))\n(init (cell g 2 b))\n(init (cell g 3 b))\n(init (cell g 4 b))\n(init (cell g 5 b))\n(init (cell g 6 b))\n(init (cell g 7 b))\n(init (cell g 8 b))\n(init (cell h 1 b))\n(init (cell h 2 b))\n(init (cell h 3 b))\n(init (cell h 4 b))\n(init (cell h 5 b))\n(init (cell h 6 b))\n(init (cell h 7 b))\n(init (cell h 8 b))\n(init (points 0))\n(init initial)\n(<= (next (cell ?u ?v b))\n    (true (cell ?u ?v b))\n    (does white (place ?x ?y))\n    (distinct ?u ?x))\n(<= (next (cell ?u ?v b))\n    (true (cell ?u ?v b))\n    (does white (place ?x ?y))\n    (distinct ?v ?y))\n(<= (next (cell ?u ?v wn))\n    (does white (place ?u ?v)))\n(<= (next (cell ?u ?v wn))\n    (true (cell ?u ?v wn)))\n(<= (legal white (place ?u ?v))\n    (true (cell ?u ?v b)))\n(<= terminal\n    (true (cell ?x ?y wn))\n    (true (cell ?u ?v wn))\n    (knight_move ?u ?v ?x ?y))\n(<= (goal white ?p)\n    (true (points ?p)))\n(<= (next (points ?y))\n    (true (points ?x))\n    (not (true initial))\n    (succ ?x ?y))\n(<= (next (points 0))\n    (true initial))\n(<= (knight_move ?u ?v ?x ?y)\n    (adjacent_two ?v ?y)\n    (adjacent ?u ?x))\n(<= (knight_move ?u ?v ?x ?y)\n    (adjacent_two ?u ?x)\n    (adjacent ?v ?y))\n(<= (adjacent ?x1 ?x2)\n    (next_file ?x1 ?x2))\n(<= (adjacent ?x1 ?x2)\n    (next_file ?x2 ?x1))\n(<= (adjacent ?y1 ?y2)\n    (next_rank ?y1 ?y2))\n(<= (adjacent ?y1 ?y2)\n    (next_rank ?y2 ?y1))\n(<= (adjacent_two ?a ?b)\n    (adjacent ?a ?mid)\n    (adjacent ?mid ?b)\n    (distinct ?a ?b))\n(<= (clear_column ?u ?v ?y)\n    (next_rank ?v ?y)\n    (coordinate ?u))\n(<= (clear_column ?u ?v ?y)\n    (next_rank ?v ?w)\n    (true (cell ?u ?w b))\n    (clear_column ?u ?w ?y))\n(<= (clear_row ?u ?x ?v)\n    (next_file ?u ?x)\n    (coordinate ?v))\n(<= (clear_row ?u ?x ?v)\n    (next_file ?u ?w)\n    (true (cell ?w ?v b))\n    (clear_row ?w ?x ?v))\n(<= (different_cells ?x1 ?y1 ?x2 ?y2)\n    (coordinate ?x1)\n    (coordinate ?x2)\n    (coordinate ?y1)\n    (coordinate ?y2)\n    (distinct ?x1 ?x2))\n(<= (different_cells ?x1 ?y1 ?x2 ?y2)\n    (coordinate ?x1)\n    (coordinate ?x2)\n    (coordinate ?y1)\n    (coordinate ?y2)\n    (distinct ?y1 ?y2))\n(next_rank 1 2)\n(next_rank 2 3)\n(next_rank 3 4)\n(next_rank 4 5)\n(next_rank 5 6)\n(next_rank 6 7)\n(next_rank 7 8)\n(next_file a b)\n(next_file b c)\n(next_file c d)\n(next_file d e)\n(next_file e f)\n(next_file f g)\n(next_file g h)\n(coordinate 1)\n(coordinate 2)\n(coordinate 3)\n(coordinate 4)\n(coordinate 5)\n(coordinate 6)\n(coordinate 7)\n(coordinate 8)\n(coordinate a)\n(coordinate b)\n(coordinate c)\n(coordinate d)\n(coordinate e)\n(coordinate f)\n(coordinate g)\n(coordinate h)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 12)\n(succ 12 14)\n(succ 14 16)\n(succ 16 18)\n(succ 18 20)\n(succ 20 22)\n(succ 22 24)\n(succ 24 26)\n(succ 26 28)\n(succ 28 30)\n(succ 30 35)\n(succ 35 40)\n(succ 40 45)\n(succ 45 50)\n(succ 50 55)\n(succ 55 60)\n(succ 60 65)\n(succ 65 70)\n(succ 70 75)\n(succ 75 80)\n(succ 80 90)\n(succ 90 100)\n(square a 1 black)\n(square a 3 black)\n(square a 5 black)\n(square a 7 black)\n(square b 2 black)\n(square b 4 black)\n(square b 6 black)\n(square b 8 black)\n(square c 1 black)\n(square c 3 black)\n(square c 5 black)\n(square c 7 black)\n(square d 2 black)\n(square d 4 black)\n(square d 6 black)\n(square d 8 black)\n(square e 1 black)\n(square e 3 black)\n(square e 5 black)\n(square e 7 black)\n(square f 2 black)\n(square f 4 black)\n(square f 6 black)\n(square f 8 black)\n(square g 1 black)\n(square g 3 black)\n(square g 5 black)\n(square g 7 black)\n(square h 2 black)\n(square h 4 black)\n(square h 6 black)\n(square h 8 black)\n(square h 1 white)\n(square h 3 white)\n(square h 5 white)\n(square h 7 white)\n(square g 2 white)\n(square g 4 white)\n(square g 6 white)\n(square g 8 white)\n(square f 1 white)\n(square f 3 white)\n(square f 5 white)\n(square f 7 white)\n(square e 2 white)\n(square e 4 white)\n(square e 6 white)\n(square e 8 white)\n(square d 1 white)\n(square d 3 white)\n(square d 5 white)\n(square d 7 white)\n(square c 2 white)\n(square c 4 white)\n(square c 6 white)\n(square c 8 white)\n(square b 1 white)\n(square b 3 white)\n(square b 5 white)\n(square b 7 white)\n(square a 2 white)\n(square a 4 white)\n(square a 6 white)\n(square a 8 white)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid with coordinates ranging from 1 to 13 along the horizontal axis and 1 to 9 along the vertical axis, establishing a rectangular board environment. There are two players, designated as white and black, who alternate turns sequentially. The initial board state is defined by various cells occupied by different markers: many cells are occupied by neutral or fixed markers denoted as \"w\" or \"o,\" while the white player controls a single \"a\" marker initially located at coordinate (2,5), and the black player controls a single \"b\" marker initially at coordinate (12,5). Each turn, a player may either choose to perform a move action or opt for a no-operation (noop), which is always legal for both players. Moves consist of transferring their respective marker (\"a\" for white, \"b\" for black) from its current cell to an orthogonally adjacent cell that contains the neutral marker \"o.\" Moves are only legal if the target cell is adjacent either horizontally or vertically, and if the player's marker is not already occupying a certain restricted coordinate—specifically, the white player may not move if their marker is already at (12,5), and the black player may not move if their marker is at (2,5). Attempting to move onto a cell occupied by the opponent’s marker during the same turn results in a collision, in which case the cell contents remain unchanged. The step counter increments by one after each turn, starting from 1 and progressing up to a maximum of 30, which also serves as a terminal condition. The game can also end when both players have their markers positioned simultaneously at the opponent’s starting coordinates, i.e., white at (12,5) and black at (2,5). Throughout the game, two counters track the steps at which each player reaches their respective opposite corners: white reaching (12,5) and black reaching (2,5). The scoring system is based on these events: if white has reached (12,5) and black has not reached (2,5), white wins with a score of 100 and black scores 0; conversely, if black has reached (2,5) and white has not reached (12,5), black scores 100 and white 0. If both have reached the other's starting positions, the scores depend on who arrived first, with the earlier arrival earning a higher score (75 for the faster player and 25 for the slower), and if both arrive simultaneously, both players score 50. Throughout, the board boundaries and adjacency constraints govern valid moves, and the occupancy of cells prevents overlapping markers except in cases resulting in collision, which does not alter the state. The game terminates either when 30 steps have elapsed or when both players have simultaneously occupied the opponent's starting positions. The player with the higher score according to these conditions is deemed the winner.",
    "output": "(role white)\n(role black)\n(init (cell 1 1 w))\n(init (cell 2 1 w))\n(init (cell 3 1 w))\n(init (cell 4 1 w))\n(init (cell 5 1 w))\n(init (cell 6 1 w))\n(init (cell 7 1 w))\n(init (cell 8 1 w))\n(init (cell 9 1 w))\n(init (cell 10 1 w))\n(init (cell 11 1 w))\n(init (cell 12 1 w))\n(init (cell 13 1 w))\n(init (cell 1 2 w))\n(init (cell 2 2 w))\n(init (cell 3 2 w))\n(init (cell 4 2 o))\n(init (cell 5 2 o))\n(init (cell 6 2 o))\n(init (cell 7 2 o))\n(init (cell 8 2 o))\n(init (cell 9 2 o))\n(init (cell 10 2 o))\n(init (cell 11 2 w))\n(init (cell 12 2 w))\n(init (cell 13 2 w))\n(init (cell 1 3 w))\n(init (cell 2 3 w))\n(init (cell 3 3 w))\n(init (cell 4 3 o))\n(init (cell 5 3 w))\n(init (cell 6 3 w))\n(init (cell 7 3 w))\n(init (cell 8 3 w))\n(init (cell 9 3 w))\n(init (cell 10 3 o))\n(init (cell 11 3 w))\n(init (cell 12 3 w))\n(init (cell 13 3 w))\n(init (cell 1 4 w))\n(init (cell 2 4 w))\n(init (cell 3 4 w))\n(init (cell 4 4 o))\n(init (cell 5 4 w))\n(init (cell 6 4 w))\n(init (cell 7 4 o))\n(init (cell 8 4 w))\n(init (cell 9 4 w))\n(init (cell 10 4 o))\n(init (cell 11 4 w))\n(init (cell 12 4 w))\n(init (cell 13 4 w))\n(init (cell 1 5 w))\n(init (cell 2 5 a))\n(init (cell 3 5 o))\n(init (cell 4 5 o))\n(init (cell 5 5 o))\n(init (cell 6 5 o))\n(init (cell 7 5 o))\n(init (cell 8 5 o))\n(init (cell 9 5 o))\n(init (cell 10 5 o))\n(init (cell 11 5 o))\n(init (cell 12 5 b))\n(init (cell 13 5 w))\n(init (cell 1 6 w))\n(init (cell 2 6 w))\n(init (cell 3 6 w))\n(init (cell 4 6 o))\n(init (cell 5 6 w))\n(init (cell 6 6 w))\n(init (cell 7 6 o))\n(init (cell 8 6 w))\n(init (cell 9 6 w))\n(init (cell 10 6 o))\n(init (cell 11 6 w))\n(init (cell 12 6 w))\n(init (cell 13 6 w))\n(init (cell 1 7 w))\n(init (cell 2 7 w))\n(init (cell 3 7 w))\n(init (cell 4 7 o))\n(init (cell 5 7 w))\n(init (cell 6 7 w))\n(init (cell 7 7 w))\n(init (cell 8 7 w))\n(init (cell 9 7 w))\n(init (cell 10 7 o))\n(init (cell 11 7 w))\n(init (cell 12 7 w))\n(init (cell 13 7 w))\n(init (cell 1 8 w))\n(init (cell 2 8 w))\n(init (cell 3 8 w))\n(init (cell 4 8 o))\n(init (cell 5 8 o))\n(init (cell 6 8 o))\n(init (cell 7 8 o))\n(init (cell 8 8 o))\n(init (cell 9 8 o))\n(init (cell 10 8 o))\n(init (cell 11 8 w))\n(init (cell 12 8 w))\n(init (cell 13 8 w))\n(init (cell 1 9 w))\n(init (cell 2 9 w))\n(init (cell 3 9 w))\n(init (cell 4 9 w))\n(init (cell 5 9 w))\n(init (cell 6 9 w))\n(init (cell 7 9 w))\n(init (cell 8 9 w))\n(init (cell 9 9 w))\n(init (cell 10 9 w))\n(init (cell 11 9 w))\n(init (cell 12 9 w))\n(init (cell 13 9 w))\n(init (step 1))\n(init (whitedone 30))\n(init (blackdone 30))\n(legal white noop)\n(legal black noop)\n(<= (legal white (move ?x1 ?y ?x2 ?y))\n\t(true (cell ?x1 ?y a))\n\t(true (cell ?x2 ?y o))\n\t(not (true (cell 12 5 a)))\n\t(or (succ ?x1 ?x2)\n\t\t(succ ?x2 ?x1)))\n(<= (legal white (move ?x ?y1 ?x ?y2))\n\t(true (cell ?x ?y1 a))\n\t(true (cell ?x ?y2 o))\n\t(not (true (cell 12 5 a)))\n\t(or (succ ?y1 ?y2)\n\t\t(succ ?y2 ?y1)))\n(<= (legal black (move ?x1 ?y ?x2 ?y))\n\t(true (cell ?x1 ?y b))\n\t(true (cell ?x2 ?y o))\n\t(not (true (cell 2 5 b)))\n\t(or (succ ?x1 ?x2)\n\t\t(succ ?x2 ?x1)))\n(<= (legal black (move ?x ?y1 ?x ?y2))\n\t(true (cell ?x ?y1 b))\n\t(true (cell ?x ?y2 o))\n\t(not (true (cell 2 5 b)))\n\t(or (succ ?y1 ?y2)\n\t\t(succ ?y2 ?y1)))\n(<= (next (step ?y))\n\t(true (step ?x))\n\t(succ ?x ?y))\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(coordinate 1)\n(coordinate 2)\n(coordinate 3)\n(coordinate 4)\n(coordinate 5)\n(coordinate 6)\n(coordinate 7)\n(coordinate 8)\n(coordinate 9)\n(coordinate 10)\n(coordinate 11)\n(coordinate 12)\n(coordinate 13)\n(<= (greaterthan ?x ?y)\n\t(succ ?y ?x))\n(<= (greaterthan ?x ?y)\n\t(succ ?z ?x)\n\t(greaterthan ?z ?y))\n(<= (next (cell ?x1 ?y1 o))\n\t(does ?p (move ?x1 ?y1 ?x2 ?y2))\n\t(not collision))\n(<= (next (cell ?x ?y o))\n\t(true (cell ?x ?y o))\n\t(not (moved_to ?x ?y)))\n(<= (moved_to ?x ?y)\n\t(does ?p (move ?x1 ?y1 ?x ?y)))\n(<= (next (cell ?x ?y a))\n\t(does white (move ?x1 ?y1 ?x ?y))\n\t(not collision))\n(<= (next (cell ?x ?y a))\n\t(true (cell ?x ?y a))\n\t(does white noop))\n(<= (next (cell ?x ?y b))\n\t(does black (move ?x1 ?y1 ?x ?y))\n\t(not collision))\n(<= (next (cell ?x ?y b))\n\t(true (cell ?x ?y b))\n\t(does black noop))\n(<= (next (cell ?z ?w ?c))\n\tcollision\n\t(true (cell ?z ?w ?c)))\n(<= (next (cell ?x ?y w))\n\t(true (cell ?x ?y w)))\n(<= collision\n\t(does white (move ?x1 ?y1 ?x ?y))\n\t(does black (move ?x2 ?y2 ?x ?y)))\n(<= (next (whitedone ?x))\n\t(true (cell 12 5 a))\n\t(true (whitedone 30))\n\t(true (step ?x)))\n(<= (next (whitedone 30)) (not (true (cell 12 5 a))))\n(<= (next (whitedone ?x))\n\t(true (cell 12 5 a))\n\t(not (true (whitedone 30)))\n\t(true (whitedone ?x)))\n(<= (next (blackdone ?x))\n\t(true (cell 2 5 b))\n\t(true (blackdone 30))\n\t(true (step ?x)))\n(<= (next (blackdone 30)) (not (true (cell  2 5 b))))\n(<= (next (blackdone ?x))\n\t(true (cell 2 5 b))\n\t(not (true (blackdone 30)))\n\t(true (blackdone ?x)))\n(<= (goal white 100)\n\t(true (cell 12 5 a))\n\t(not (true (cell 2 5 b))))\n(<= (goal black 0)\n\t(not (true (cell 2 5 b))))\n(<= (goal black 100)\n\t(true (cell 2 5 b))\n\t(not (true (cell 12 5 a))))\n(<= (goal white 0)\n\t(not (true (cell 12 5 a))))\n(<= (goal white 75)\n\t(true (cell 2 5 b))\n\t(true (cell 12 5 a))\n\t(true (blackdone ?x))\n\t(true (whitedone ?y))\n\t(greaterthan ?x ?y))\n(<= (goal black 25)\n\t(true (cell 2 5 b))\n\t(true (cell 12 5 a))\n\t(true (blackdone ?x))\n\t(true (whitedone ?y))\n\t(greaterthan ?x ?y))\n(<= (goal white 25)\n\t(true (cell 2 5 b))\n\t(true (cell 12 5 a))\n\t(true (blackdone ?x))\n\t(true (whitedone ?y))\n\t(greaterthan ?y ?x))\n(<= (goal black 75)\n\t(true (cell 2 5 b))\n\t(true (cell 12 5 a))\n\t(true (blackdone ?x))\n\t(true (whitedone ?y))\n\t(greaterthan ?y ?x))\n(<= (goal black 50)\n\t(true (cell 2 5 b))\n\t(true (cell 12 5 a))\n\t(true (blackdone ?x))\n\t(true (whitedone ?x)))\n(<= (goal white 50)\n\t(true (cell 2 5 b))\n\t(true (cell 12 5 a))\n\t(true (blackdone ?x))\n\t(true (whitedone ?x)))\n(<= terminal (true (step 30)))\n(<= terminal\n\t(true (cell 2 5 b))\n\t(true (cell 12 5 a)))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place in an abstract programming environment where the state is defined by lines of code indexed by line numbers and register values indexed by register numbers; line numbers range up to a maximum of 10, and registers up to 5, with a maximum of 50 execution steps allowed. There are two player roles: the coder and the debugger, who take turns acting, with the coder initiating actions when in the coding phase and the debugger responding by testing instructions. Initially, the coder begins with the line to add set to 1 and all registers initialized to zero. During the coder's turn, when coding is active, they may legally write an instruction or signal done to end coding; if coding is not active, the coder can perform a noop, which is a no-operation action. Each action from the coder is formatted either as done or write followed by a valid instruction, where valid instructions include zeroing a register, incrementing a register, moving a value from one register to another, or performing a conditional branch if two registers are equal to a specified line. The debugger's action consists of testing pairs of line numbers to trigger code execution. Actions cause state changes such as adding lines of code at the current line number, incrementing the line-to-add counter, updating the program counter (pc), modifying register values according to the current instruction, and advancing the step count by one. Automatic events include the evaluation of instructions during execution: zeroing sets a register to zero, incrementing increases a register's value by one, moving copies a value between registers, and branching alters the program counter based on register comparisons, with the program counter advancing sequentially unless a branch is taken. Implicit constraints enforce that line numbers and registers remain within their defined maximums; the program counter must refer to existing lines of code, and instructions operate only on valid registers and lines. The game terminates either when the program counter reaches beyond the last line of code (indicating the program ran to completion) or the maximum number of steps (50) is reached. Victory is determined by the correctness of the program run: the coder scores 100 points if the program halts correctly with register 1 holding the expected correct value, and zero points otherwise. Thus, the coder's objective is to write a valid program within the line and register limits that executes correctly within the step limit, while the debugger tests the code execution through interactions that advance the program state.",
    "output": "(role coder)\n(role debugger)\n(goal debugger 100)\n(maxLines 10)\n(maxRegisters 5)\n(numSteps 50)\n(lineNumber 1)\n(registerNumber 1)\n(<= (lineNumber ?np1)\n\t(succ ?n ?np1)\n\t(not (maxLines ?n))\n\t(lineNumber ?n))\n(<= (registerNumber ?np1)\n\t(succ ?n ?np1)\n\t(not (maxRegisters ?n))\n\t(registerNumber ?n))\n(init (lineToAdd 1))\n(<= (init (rv ?reg 0))\n\t(registerNumber ?reg))\n(<= (legal coder done)\n\tcoding)\n(<= (legal coder (write ?instruction))\n\t(validInstruction ?instruction)\n\tcoding)\n(<= (legal coder noop)\n\t(not coding))\n(<= coding\n\t(true (lineToAdd ?n)))\n(<= running\n\t(true (step ?n)))\n(<= (toReplace 1 ?n1)\n\t(does debugger (test ?n1 ?n2)))\n(<= (toReplace 2 ?n2)\n\t(does debugger (test ?n1 ?n2)))\n(<= (next (step 1))\n\t(does debugger (test ?n1 ?n2)))\n(<= (next (pc 1))\n\t(does debugger (test ?n1 ?n2)))\n(<= (next (lineToAdd ?np1))\n\t(not (does coder done))\n\t(true (lineToAdd ?n))\n\t(not (maxLines ?n))\n\t(succ ?n ?np1))\n(<= (validInstruction (zero ?reg))\n\t(registerNumber ?reg))\n(<= (validInstruction (incr ?reg))\n\t(registerNumber ?reg))\n(<= (validInstruction (move ?r1 ?r2))\n\t(registerNumber ?r1)\n\t(registerNumber ?r2))\n(<= (validInstruction (beq ?r1 ?r2 ?line))\n\t(registerNumber ?r1)\n\t(registerNumber ?r2)\n\t(lineNumber ?line))\n(<= (next (line ?lineNum ?instruction))\n\t(does coder (write ?instruction))\n\t(true (lineToAdd ?lineNum)))\n(<= (next (line ?lineNum ?instruction))\n\t(true (line ?lineNum ?instruction)))\n(<= (next (step ?np1))\n\t(true (step ?n))\n\t(succ ?n ?np1))\n(<= (curInstruction ?instruction)\n\t(true (pc ?n))\n\t(true (line ?n ?instruction)))\n(<= (toReplace ?reg 0)\n\t(curInstruction (zero ?reg)))\n(<= (toReplace ?reg ?np1)\n\t(curInstruction (incr ?reg))\n\t(true (rv ?reg ?n))\n\t(succ ?n ?np1))\n(<= (toReplace ?r2 ?n1)\n\t(curInstruction (move ?r1 ?r2))\n\t(true (rv ?r1 ?n1)))\n(<= branching\n\t(curInstruction (beq ?r1 ?r2 ?line)))\n(<= (next (pc ?np1))\n\t(true (pc ?n))\n\t(succ ?n ?np1)\n\t(not branching))\n(<= (next (pc ?np1))\n\t(true (pc ?n))\n\t(succ ?n ?np1)\n\t(curInstruction (beq ?r1 ?r2 ?line))\n\t(true (rv ?r1 ?n1))\n\t(true (rv ?r2 ?n2))\n\t(distinct ?n1 ?n2))\n(<= (next (pc ?line))\n\t(curInstruction (beq ?r1 ?r2 ?line))\n\t(true (rv ?r1 ?n))\n\t(true (rv ?r2 ?n)))\n(<= (next (rv ?reg ?n))\n\t(toReplace ?reg ?n))\n(<= (replaced ?reg)\n\t(toReplace ?reg ?n))\n(<= (next (rv ?reg ?n))\n\t(true (rv ?reg ?n))\n\t(not (replaced ?reg)))\n(<= (hasCode ?lineNum)\n\t(true (line ?lineNum ?instruction)))\n(<= ranToEnd\n\trunning\n\t(true (pc ?n))\n\t(not (hasCode ?n)))\n(<= terminal\n\tranToEnd)\n(<= terminal\n\t(true (step ?n))\n\t(numSteps ?n))\n(<= correct\n\tranToEnd\n\t(correctValue ?n)\n\t(true (rv 1 ?n)))\n(<= (goal coder 100)\n\tcorrect)\n(<= (goal coder 0)\n\t(not correct))\n(sum 0 0 0)\n(<= (sum 0 ?n ?n)\n\t(succ ?m ?n))\n(<= (sum ?mp1 ?n ?sp1)\n\t(succ ?m ?mp1)\n\t(succ ?s ?sp1)\n\t(sum ?m ?n ?s))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a 3-by-3 grid defined by coordinates where the horizontal (x) and vertical (y) axes both range from 1 to 3, creating nine distinct cells initially all empty. There are two players, designated as \"x\" and \"o,\" who alternate turns. The game begins in a \"bidding\" stage where each player starts with 10 coins. During this stage, players take turns placing bids, which are integer amounts no greater than the number of coins they currently possess, and each bid may optionally include a tiebreaker flag; the player who holds the current tiebreaker may bid with it, whereas the other player may bid without it. Legal bids must respect these constraints, and the bidding stage continues until a winner is determined by comparing bids: the player with the higher bid wins, or if bids tie, the one using the tiebreaker prevails; if both bids tie and neither uses the tiebreaker, then the player without the tiebreaker wins. After the bidding concludes, control passes to the winning player who then plays the marking stage. In this stage, the controlling player may place their mark (either \"x\" or \"o\") on any empty cell, with the legal action requiring that the chosen cell is currently blank. The other player may choose to perform a no-operation action (noop) only when it is not their turn to move. The game's state updates reflect coins being adjusted by adding the bid amounts to the players' coin counts after bidding, the tiebreaker status potentially transferring depending on the bid details, and cells being marked as players place their marks. The board constraints ensure marks can only be placed within the 3-by-3 grid and cannot overwrite occupied cells. The game ends when either a player forms a complete line of three marks horizontally, vertically, or diagonally, or when no empty cells remain, indicating a draw. Victory is awarded 100 points to a player who completes such a line, zero points to the opponent if the opposing player wins, and in the absence of a winning line for either player, both receive 50 points. Turn control cycles between bidding and marking stages appropriately, and the noop action serves as a legal pass for the non-controlling player to maintain turn order without disrupting the game flow.",
    "output": "(role x)\n(role o)\n(other x o)\n(other o x)\n(xcoord 1)\n(xcoord 2)\n(xcoord 3)\n(ycoord 1)\n(ycoord 2)\n(ycoord 3)\n(<= (init (cell ?x ?y b))\n\t(xcoord ?x)\n\t(ycoord ?y))\n(<= (init (coins ?p 10))\n\t(role ?p))\n(init (tiebreaker x))\n(init (stage bidding))\n(<= (legal ?p (bid ?b ?tiebreaker))\n\t(true (stage bidding))\n\t(true (coins ?p ?m))\n\t(le ?b ?m)\n\t(legal_bid_tiebreaker ?p ?tiebreaker))\n(<= (legal_bid_tiebreaker ?p with_tiebreaker)\n\t(true (tiebreaker ?p)))\n(<= (legal_bid_tiebreaker ?p no_tiebreaker)\n\t(role ?p))\n(<= (legal ?p (mark ?r ?c))\n\t(true (control ?p))\n\t(true (cell ?r ?c b)))\n(<= (legal ?p noop)\n\t(true (control ?p1))\n\t(role ?p)\n\t(distinct ?p ?p1))\n(<= (next (stage bidding))\n\t(true (control ?p)))\n(<= (next (control ?p))\n\t(true (stage bidding))\n\t(winner ?p))\n(<= (next (coins ?p ?m))\n\t(true (stage bidding))\n\t(winner ?p)\n\t(does ?p (bid ?b ?t))\n\t(true (coins ?p ?m0))\n\t(add ?m ?b ?m0))\n(<= (next (coins ?p ?m))\n\t(true (stage bidding))\n\t(winner ?o)\n\t(other ?o ?p)\n\t(does ?o (bid ?b ?t))\n\t(true (coins ?p ?m0))\n\t(add ?m0 ?b ?m))\n(<= (next (coins ?p ?m))\n\t(true (control ?someone))\n\t(true (coins ?p ?m)))\n(<= (next (tiebreaker ?p))\n\t(true (stage bidding))\n\t(winner ?o)\n\t(other ?o ?p)\n\t(does ?o (bid ?b with_tiebreaker)))\n(<= (next (tiebreaker ?p))\n\t(true (stage bidding))\n\t(true (tiebreaker ?p))\n\t(winner ?w)\n\t(does ?w (bid ?b no_tiebreaker)))\n(<= (next (tiebreaker ?p))\n\t(true (control ?someone))\n\t(true (tiebreaker ?p)))\n(<= (next (cell ?r ?c ?p))\n\t(does ?p (mark ?r ?c)))\n(<= (next (cell ?r ?c ?x))\n\t(true (cell ?r ?c ?x))\n\t(true (control ?p))\n\t(not (does ?p (mark ?r ?c))))\n(<= (next (cell ?r ?c ?x))\n\t(true (stage bidding))\n\t(true (cell ?r ?c ?x)))\n(<= (winner ?p)\n\t(does ?p (bid ?bp ?tp))\n\t(other ?p ?o)\n\t(does ?o (bid ?bo ?to))\n\t(gt ?bp ?bo))\n(<= (winner ?p)\n\t(does ?p (bid ?b with_tiebreaker))\n\t(other ?p ?o)\n\t(does ?o (bid ?b no_tiebreaker)))\n(<= (winner ?p)\n\t(true (tiebreaker ?o))\n\t(does ?o (bid ?b no_tiebreaker))\n\t(other ?p ?o)\n\t(does ?p (bid ?b no_tiebreaker)))\n(<= (row ?p)\n\t(true (cell ?r 1 ?p))\n\t(true (cell ?r 2 ?p))\n\t(true (cell ?r 3 ?p)))\n(<= (column ?p)\n\t(true (cell 1 ?c ?p))\n\t(true (cell 2 ?c ?p))\n\t(true (cell 3 ?c ?p)))\n(<= (diagonal ?p)\n\t(true (cell 1 1 ?p))\n\t(true (cell 2 2 ?p))\n\t(true (cell 3 3 ?p)))\n(<= (diagonal ?p)\n\t(true (cell 1 3 ?p))\n\t(true (cell 2 2 ?p))\n\t(true (cell 3 1 ?p)))\n(<= (line ?player) (row ?player))\n(<= (line ?player) (column ?player))\n(<= (line ?player) (diagonal ?player))\n(<= open\n\t(true (cell ?r ?c b)))\n(<= terminal\n\t(role ?p)\n\t(line ?p))\n(<= terminal\n\t(not open))\n(<= (goal ?p 100)\n\t(line ?p))\n(<= (goal ?p 0)\n\t(other ?p ?o)\n\t(line ?o))\n(<= (goal ?p 50)\n\t(role ?p)\n\t(not (line x))\n\t(not (line o)))\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(<= (number ?x)\n\t(succ ?x ?y))\n(<= (number ?x)\n\t(succ ?y ?x))\n(<= (gt ?x ?y)\n\t(succ ?y ?x))\n(<= (gt ?x ?y)\n\t(succ ?y ?z)\n\t(gt ?x ?z))\n(<= (le ?x ?x)\n\t(number ?x))\n(<= (le ?x ?y)\n\t(gt ?y ?x))\n(<= (add ?x 0 ?x)\n\t(number ?x))\n(<= (add ?x ?y ?sum)\n\t(succ ?y1 ?y)\n\t(succ ?x ?x1)\n\t(add ?x1 ?y1 ?sum))"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on an 8-by-8 grid where cells are numbered from 1 to 8 along both the x (horizontal) and y (vertical) axes, with coordinates increasing upwards and to the right. There are two players, Bomberman and Bomberwoman, who alternate turns, each able to perform one action per turn. Initially, Bomberman starts at position (1,1) and Bomberwoman at position (8,8). Certain edges between cells are blocked either to the north or east, preventing movement or effects across those boundaries, and these blockades are fixed throughout the game. On each turn, a player may choose to move one step in one of the four cardinal directions—north, south, east, or west—provided the destination cell exists within the grid, is not blocked by a barrier, and is reachable by a legal step, or alternatively choose to drop a bomb at their current location. Movement actions are legal only if the step is within boundaries and not obstructed; dropping a bomb is always a legal action. After an action is taken, player locations update accordingly: moving changes the player's position to the adjacent cell in the chosen direction, while dropping a bomb leaves the player in place but places a new bomb at their current coordinates. Bombs progress through four states labeled bomb3, bomb2, bomb1, and bomb0 in successive turns, representing the countdown to explosion. When a bomb reaches the bomb0 state, it triggers a fire event that affects the bomb's own cell and extends to adjacent cells to the north and east, unless blocked by the fixed barriers. If either Bomberman or Bomberwoman occupies a cell with fire, that player is considered burned and loses. The game also automatically increments a step counter each turn, and the game ends either if a player is burned or if 50 steps have elapsed, constituting a timeout. Scoring is based on the state at termination: a player who is not burned but whose opponent is burned wins with a score of 100, a burned player receives 0, and if both are burned or the game times out without any player burned, both receive 50 points. Players may also choose a \"nowhere\" move that results in no positional change, effectively serving as a noop action. The game terminates immediately upon a player being burned or when the timeout step limit is reached. Thus, the strategic interplay revolves around navigating the grid, avoiding barriers and fire, and tactically dropping bombs to eliminate the opponent before the step limit is reached.",
    "output": "(role bomberman)\n(role bomberwoman)\n(init (location bomberman   1 1))\n(init (location bomberwoman 8 8))\n(init (blockedNorth 2 1))\n(init (blockedNorth 4 1))\n(init (blockedNorth 5 1))\n(init (blockedNorth 7 1))\n(init (blockedNorth 2 2))\n(init (blockedNorth 4 2))\n(init (blockedNorth 5 2))\n(init (blockedNorth 7 2))\n(init (blockedNorth 2 3))\n(init (blockedNorth 4 3))\n(init (blockedNorth 5 3))\n(init (blockedNorth 7 3))\n(init (blockedNorth 2 5))\n(init (blockedNorth 4 5))\n(init (blockedNorth 5 5))\n(init (blockedNorth 7 5))\n(init (blockedNorth 2 6))\n(init (blockedNorth 4 6))\n(init (blockedNorth 5 6))\n(init (blockedNorth 7 6))\n(init (blockedNorth 2 7))\n(init (blockedNorth 4 7))\n(init (blockedNorth 5 7))\n(init (blockedNorth 7 7))\n(init (blockedNorth 1 8))\n(init (blockedNorth 2 8))\n(init (blockedNorth 3 8))\n(init (blockedNorth 4 8))\n(init (blockedNorth 5 8))\n(init (blockedNorth 6 8))\n(init (blockedNorth 7 8))\n(init (blockedNorth 8 8))\n(init (blockedEast 1 2))\n(init (blockedEast 1 4))\n(init (blockedEast 1 5))\n(init (blockedEast 1 7))\n(init (blockedEast 2 2))\n(init (blockedEast 2 4))\n(init (blockedEast 2 5))\n(init (blockedEast 2 7))\n(init (blockedEast 3 2))\n(init (blockedEast 3 4))\n(init (blockedEast 3 5))\n(init (blockedEast 3 7))\n(init (blockedEast 5 2))\n(init (blockedEast 5 4))\n(init (blockedEast 5 5))\n(init (blockedEast 5 7))\n(init (blockedEast 6 2))\n(init (blockedEast 6 4))\n(init (blockedEast 6 5))\n(init (blockedEast 6 7))\n(init (blockedEast 7 2))\n(init (blockedEast 7 4))\n(init (blockedEast 7 5))\n(init (blockedEast 7 7))\n(init (blockedEast 8 1))\n(init (blockedEast 8 2))\n(init (blockedEast 8 3))\n(init (blockedEast 8 4))\n(init (blockedEast 8 5))\n(init (blockedEast 8 6))\n(init (blockedEast 8 7))\n(init (blockedEast 8 8))\n(init (step 1))\n(<= (legal ?char (move ?dir))\n    (role ?char)\n\t(true (location ?char ?x ?y))\n\t(legalStep ?dir ?x ?y))\n(<= (legal ?char dropBomb)\n    (role ?char))\n(<= (next (blockedNorth ?x ?y))\n    (true (blockedNorth ?x ?y)))\n(<= (next (blockedEast ?x ?y))\n    (true (blockedEast ?x ?y)))\n(<= (next (location ?char ?x2 ?y2))\n    (role ?char)\n    (true (location ?char ?x1 ?y1))\n    (does ?char (move ?dir))\n    (nextCell ?dir ?x1 ?y1 ?x2 ?y2))\n(<= (next (location ?char ?x ?y))\n    (role ?char)\n    (true (location ?char ?x ?y))\n    (does ?char dropBomb))\n(<= (next (location bomb3 ?x ?y))\n\t(role ?char)\n\t(true (location ?char ?x ?y))\n\t(does ?char dropBomb))\n(<= (next (location bomb2 ?x ?y))\n    (true (location bomb3 ?x ?y)))\n(<= (next (location bomb1 ?x ?y))\n    (true (location bomb2 ?x ?y)))\n(<= (next (location bomb0 ?x ?y))\n    (true (location bomb1 ?x ?y)))\n(<= (next (location fire ?xF ?y))\n    (true (location bomb0 ?xB ?y))\n    (not (true (blockedEast ?xB ?y)))\n    (index ?xF))\n(<= (next (location fire ?x ?yF))\n    (true (location bomb0 ?x ?yB))\n    (not (true (blockedNorth ?x ?yB)))\n    (index ?yF))\n(<= (next (step ?nplusplus))\n    (true (step ?n))\n    (succ ?n ?nplusplus))\n(<= terminal\n    bombermanBurned)\n(<= terminal\n    bomberwomanBurned)\n(<= terminal\n    timeout)\n(<= (goal bomberman 0)\n    (not timeout)\n    (not bombermanBurned)\n    (not bomberwomanBurned))\n(<= (goal bomberman 0)\n    bombermanBurned\n    (not bomberwomanBurned))\n(<= (goal bomberman 50)\n    bombermanBurned\n    bomberwomanBurned)\n(<= (goal bomberman 50)\n    timeout\n    (not bombermanBurned)\n    (not bomberwomanBurned))\n(<= (goal bomberman 100)\n    (not bombermanBurned)\n    bomberwomanBurned)\n(<= (goal bomberwoman 0)\n    (not timeout)\n    (not bombermanBurned)\n    (not bomberwomanBurned))\n(<= (goal bomberwoman 0)\n\t(not bombermanBurned)\n\tbomberwomanBurned)\n(<= (goal bomberwoman 50)\n    bombermanBurned\n    bomberwomanBurned)\n(<= (goal bomberwoman 50)\n    timeout\n    (not bombermanBurned)\n    (not bomberwomanBurned))\n(<= (goal bomberwoman 100)\n    bombermanBurned\n    (not bomberwomanBurned))\n(<= (legalStep north ?x ?y)\n    (plusplus ?y ?yNew)\n    (cell ?x ?yNew)\n    (not (blocked ?x ?y ?x ?yNew)))\n(<= (legalStep south ?x ?y)\n    (minusminus ?y ?yNew)\n    (cell ?x ?yNew)\n    (not (blocked ?x ?y ?x ?yNew)))\n(<= (legalStep east ?x ?y)\n    (plusplus ?x ?xNew)\n    (cell ?xNew ?y)\n    (not (blocked ?x ?y ?xNew ?y)))\n(<= (legalStep west ?x ?y)\n    (minusminus ?x ?xNew)\n    (cell ?xNew ?y)\n    (not (blocked ?x ?y ?xNew ?y)))\n(<= (legalStep nowhere ?x ?y)\n    (cell ?x ?y))\n(<= (nextCell north ?x ?y ?x ?yNew)\n    (index ?x)\n    (plusplus ?y ?yNew))\n(<= (nextCell south ?x ?y ?x ?yNew)\n    (index ?x)\n    (minusminus ?y ?yNew))\n(<= (nextCell east ?x ?y ?xNew ?y)\n    (index ?y)\n    (plusplus ?x ?xNew))\n(<= (nextCell west ?x ?y ?xNew ?y)\n    (index ?y)\n    (minusminus ?x ?xNew))\n(<= (nextCell nowhere ?x ?y ?x ?y)\n    (cell ?x ?y))\n(<= (blocked ?x ?y1 ?x ?y2)\n    (true (blockedNorth ?x ?y1))\n    (plusplus ?y1 ?y2))\n(<= (blocked ?x ?y2 ?x ?y1)\n    (true (blockedNorth ?x ?y1))\n    (plusplus ?y1 ?y2))\n(<= (blocked ?x1 ?y ?x2 ?y)\n    (true (blockedEast ?x1 ?y))\n    (plusplus ?x1 ?x2))\n(<= (blocked ?x2 ?y ?x1 ?y)\n    (true (blockedEast ?x1 ?y))\n    (plusplus ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n\t(cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n\t(cell ?x1 ?y1)\n\t(cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= bombermanBurned\n    (true (location bomberman ?x ?y))\n    (true (location fire ?x ?y)))\n(<= bomberwomanBurned\n    (true (location bomberwoman ?x ?y))\n    (true (location fire ?x ?y)))\n(<= timeout\n    (true (step 50)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7) (index 8)\n(cell 1 8) (cell 2 8) (cell 3 8) (cell 4 8) (cell 5 8) (cell 6 8) (cell 7 8) (cell 8 8)\n(cell 1 7) (cell 2 7) (cell 3 7) (cell 4 7) (cell 5 7) (cell 6 7) (cell 7 7) (cell 8 7)\n(cell 1 6) (cell 2 6) (cell 3 6) (cell 4 6) (cell 5 6) (cell 6 6) (cell 7 6) (cell 8 6)\n(cell 1 5) (cell 2 5) (cell 3 5) (cell 4 5) (cell 5 5) (cell 6 5) (cell 7 5) (cell 8 5)\n(cell 1 4) (cell 2 4) (cell 3 4) (cell 4 4) (cell 5 4) (cell 6 4) (cell 7 4) (cell 8 4)\n(cell 1 3) (cell 2 3) (cell 3 3) (cell 4 3) (cell 5 3) (cell 6 3) (cell 7 3) (cell 8 3)\n(cell 1 2) (cell 2 2) (cell 3 2) (cell 4 2) (cell 5 2) (cell 6 2) (cell 7 2) (cell 8 2)\n(cell 1 1) (cell 2 1) (cell 3 1) (cell 4 1) (cell 5 1) (cell 6 1) (cell 7 1) (cell 8 1)\n(plusplus 1 2) (plusplus 2 3) (plusplus 3 4) (plusplus 4 5) (plusplus 5 6) (plusplus 6 7) (plusplus 7 8)\n(minusminus 8 7) (minusminus 7 6) (minusminus 6 5) (minusminus 5 4) (minusminus 4 3) (minusminus 3 2) (minusminus 2 1)\n(succ  1  2) (succ  2  3) (succ  3  4) (succ  4  5) (succ  5  6)\n(succ  6  7) (succ  7  8) (succ  8  9) (succ  9 10) (succ 10 11)\n(succ 11 12) (succ 12 13) (succ 13 14) (succ 14 15) (succ 15 16)\n(succ 16 17) (succ 17 18) (succ 18 19) (succ 19 20) (succ 20 21)\n(succ 21 22) (succ 22 23) (succ 23 24) (succ 24 25) (succ 25 26)\n(succ 26 27) (succ 27 28) (succ 28 29) (succ 29 30) (succ 30 31)\n(succ 31 32) (succ 32 33) (succ 33 34) (succ 34 35) (succ 35 36)\n(succ 36 37) (succ 37 38) (succ 38 39) (succ 39 40) (succ 40 41)\n(succ 41 42) (succ 42 43) (succ 43 44) (succ 44 45) (succ 45 46)\n(succ 46 47) (succ 47 48) (succ 48 49) (succ 49 50)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on a grid defined by coordinates from 1 to 7 along both the x and y axes, with the playable area excluding the outermost rows and columns so that valid positions have x and y indices strictly between 1 and 7. There are two players, red and blue, who alternate turns with red moving first. Initially, the red player controls the game and has a piece positioned at cell (1,4), while the blue player has a piece at cell (7,4). Game progression is tracked by a step counter starting at 1 and incrementing by one each turn. On a player's turn, if they have legal moves available, they must perform one; otherwise, they may choose a noop action, which is only legal if it is that player's turn and they have no legal moves. Legal moves consist of moving one of the player's pieces from its current square to a new location on the board according to specific movement rules: the destination cell must either be occupied by an opponent's piece and be orthogonally or diagonally adjacent, or be an unoccupied cell reachable by an \"ell\"-shaped move akin to a knight's move in chess, where the move covers two squares in one direction and one square in the perpendicular direction. Moves must start from a cell currently occupied by the player's piece and end on a cell within the playable board area. When a player makes a move, control passes to the other player. Moving onto a cell occupied by an opponent's piece appears to capture or replace that piece, as the moved piece occupies the new cell. The state updates accordingly, with the piece's new location recorded and the previous location vacated. The game ends when either player achieves a winning condition defined as forming a line of three of their pieces in a row, column, or diagonal specifically within the central 3x3 area of the board — namely, any of the rows 3 to 5 in columns 3 to 5, any of the columns 3 to 5 in rows 3 to 5, or the two main diagonals spanning from (3,3) to (5,5) or (3,5) to (5,3). Alternatively, the game also terminates automatically if the turn counter reaches 31 steps, indicating a maximum number of turns. At termination, the player who has formed such a line is awarded a score of 100, while the other player receives 0; if no line is formed by a player by the end of the game, that player scores 0 as well. The coordinate system and all movement relations are defined precisely to ensure valid orthogonal, diagonal, and ell moves only between cells within the board boundaries and respecting occupancy constraints. The game's turn control rotates strictly between the two players, with the next player determined by a fixed rotation rule. Overall, the game involves strategic placement and movement of pieces by red and blue players on a central 5x5 area within a 7x7 grid, aiming to form a three-in-a-row line to win before the step limit is reached.",
    "output": "(role red)\n(role blue)\n(init (control red))\n(init (cell 1 4 red))\n(init (cell 7 4 blue))\n(init (step 1))\n(<= (legal ?player noop)\n    (role ?player)\n    (not (true (control ?player))))\n(<= (legal ?player ?move)\n    (legal2 ?player ?move))\n(<= (hasLegalMove ?player)\n    (legal2 ?player ?move))\n(<= (legal ?player noop)\n    (true (control ?player))\n    (not (hasLegalMove ?player)))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(orthogonal ?x1 ?y1 ?x2 ?y2)\n\t(onBoard ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?player2))\n\t(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(diagonal ?x1 ?y1 ?x2 ?y2)\n\t(onBoard ?x2 ?y2)\n\t(true (cell ?x2 ?y2 ?player2))\n\t(distinct ?player ?player2))\n(<= (legal2 ?player (move ?x1 ?y1 ?x2 ?y2))\n\t(true (control ?player))\n\t(true (cell ?x1 ?y1 ?player))\n\t(ell ?x1 ?y1 ?x2 ?y2)\n\t(openCell ?x2 ?y2))\n(<= (next (control ?p2))\n    (true (control ?p1))\n    (rotation ?p1 ?p2))\n(<= (next (cell ?x2 ?y2 ?player))\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x ?y ?piece))\n    (true (cell ?x ?y ?piece))\n    (not (cameFrom ?x ?y))\n    (not (wentTo ?x ?y)))\n(<= (next (cell ?x ?y ?player))\n\t(spawns ?x ?y ?player))\n(<= (next (step ?t2))\n\t(true (step ?t1))\n\t(stepCount ?t1 ?t2))\n(<= terminal\n\t(role ?player)\n\t(line ?player))\n(<= terminal\n\t(true (step 31)))\n(<= (goal ?player 0)\n\t(role ?player)\n\t(not (line ?player)))\n(<= (goal ?player 100)\n\t(role ?player)\n\t(line ?player))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x1 ?x2)\n\t(index ?y))\n(<= (orthogonal ?x1 ?y ?x2 ?y)\n\t(plus 1 ?x2 ?x1)\n\t(index ?y))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y1 ?y2))\n(<= (orthogonal ?x ?y1 ?x ?y2)\n\t(index ?x)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (diagonal ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x1 ?x2)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 2 ?x2 ?x1)\n\t(plus 1 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x1 ?x2)\n\t(plus 2 ?y2 ?y1))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y1 ?y2))\n(<= (ell ?x1 ?y1 ?x2 ?y2)\n\t(plus 1 ?x2 ?x1)\n\t(plus 2 ?y2 ?y1))\n(<= (openCell ?x ?y)\n\t(onBoard ?x ?y)\n\t(not (true (cell ?x ?y red)))\n\t(not (true (cell ?x ?y blue))))\n(<= (onBoard ?x ?y)\n\t(index ?x)\n\t(index ?y)\n\t(distinct ?x 1)\n\t(distinct ?x 7)\n\t(distinct ?y 1)\n\t(distinct ?y 7))\n(<= (cameFrom ?x1 ?y1)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (wentTo ?x2 ?y2)\n\t(does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (line ?player)\n\t(row ?player))\n(<= (line ?player)\n\t(column ?player))\n(<= (line ?player)\n\t(diag ?player))\n(<= (row ?player)\n\t(true (cell 3 3 ?player))\n\t(true (cell 4 3 ?player))\n\t(true (cell 5 3 ?player)))\n(<= (row ?player)\n\t(true (cell 3 4 ?player))\n\t(true (cell 4 4 ?player))\n\t(true (cell 5 4 ?player)))\n(<= (row ?player)\n\t(true (cell 3 5 ?player))\n\t(true (cell 4 5 ?player))\n\t(true (cell 5 5 ?player)))\n(<= (column ?player)\n\t(true (cell 3 3 ?player))\n\t(true (cell 3 4 ?player))\n\t(true (cell 3 5 ?player)))\n(<= (column ?player)\n\t(true (cell 4 3 ?player))\n\t(true (cell 4 4 ?player))\n\t(true (cell 4 5 ?player)))\n(<= (column ?player)\n\t(true (cell 5 3 ?player))\n\t(true (cell 5 4 ?player))\n\t(true (cell 5 5 ?player)))\n(<= (diag ?player)\n\t(true (cell 3 3 ?player))\n\t(true (cell 4 4 ?player))\n\t(true (cell 5 5 ?player)))\n(<= (diag ?player)\n\t(true (cell 3 5 ?player))\n\t(true (cell 4 4 ?player))\n\t(true (cell 5 3 ?player)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6) (index 7)\n(plus 1 1 2) (plus 1 2 3) (plus 1 3 4) (plus 1 4 5) (plus 1 5 6) (plus 1 6 7)\n(plus 2 1 3) (plus 2 2 4) (plus 2 3 5) (plus 2 4 6) (plus 2 5 7)\n(rotation red blue) (rotation blue red)\n(spawns 1 4 red) (spawns 7 4 blue)\n(stepCount  1  2) (stepCount  2  3) (stepCount  3  4) (stepCount  4  5) (stepCount  5  6) (stepCount  6  7) (stepCount  7  8) (stepCount  8  9) (stepCount  9 10) (stepCount 10 11)\n(stepCount 11 12) (stepCount 12 13) (stepCount 13 14) (stepCount 14 15) (stepCount 15 16) (stepCount 16 17) (stepCount 17 18) (stepCount 18 19) (stepCount 19 20) (stepCount 20 21)\n(stepCount 21 22) (stepCount 22 23) (stepCount 23 24) (stepCount 24 25) (stepCount 25 26) (stepCount 26 27) (stepCount 27 28) (stepCount 28 29) (stepCount 29 30) (stepCount 30 31)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "This game involves two players, white and black, who take alternating turns in a competitive environment defined by a simple numeric coordinate system representing counts from zero to a maximum of one hundred, though the coordinates serve primarily as numerical indices rather than spatial positions. The initial state sets both white and black players with a score of zero and twenty armies each, with the game round counter starting at zero and a maximum of ten rounds allowed. On each turn, players simultaneously select an action to commit a certain number of their armies, specified as an integer between zero and their current army count, reflecting the amount of forces they choose to deploy or stake that round. The legality of an action depends on the player having at least as many armies as they intend to commit, ensuring actions cannot exceed available resources. Noop actions are implicitly represented by committing zero armies, allowing players to pass or refrain from increasing their stake. After both players commit their armies for the round, the game state updates by incrementing the round count by one, adding the committed armies to each player's total armies, and updating each player's score based on the outcome of that round. The scoring mechanism awards two points to the player who commits more armies in a round, zero points to the player who commits fewer, and one point each if both commit equal amounts, reflecting a direct comparison of commitment sizes. This process repeats until the rounds counter reaches the maximum number of ten, at which point the game terminates. Throughout gameplay, implicit constraints ensure that army commitments do not surpass the players' current armies and that the rounds progress sequentially without skipping. The final victory criteria are based on the accumulated scores: each player’s goal value equals their total score, and the player with the higher cumulative points after ten rounds is considered the winner. The game thus models a strategic bidding contest where players balance preserving their armies and maximizing their score over a fixed number of rounds, with all actions and state changes governed by straightforward arithmetic and turn-based updates.",
    "output": "(role white)\n(role black)\n(init (whiteScore 0))\n(init (blackScore 0))\n(init (whiteArmies 20))\n(init (blackArmies 20))\n(init (rounds 0))\n(init (maxRounds 10))\n(<= (legal white (commit ?x1))\n    (true (whiteArmies ?x2))\n    (gte ?x2 ?x1))\n(<= (legal black (commit ?x1))\n    (true (blackArmies ?x2))\n    (gte ?x2 ?x1))\n(<= (next (maxRounds ?x))\n    (true (maxRounds ?x)))\n(<= (next (rounds ?x1))\n    (true (rounds ?x))\n    (succ ?x ?x1))\n(<= (next (whiteScore ?xNext))\n    (true (whiteScore ?x))\n    (w1 ?score)\n    (sum ?x ?score ?xNext))\n(<= (next (blackScore ?xNext))\n    (true (blackScore ?x))\n    (b1 ?score)\n    (sum ?x ?score ?xNext))\n(<= (next (whiteArmies ?xNext))\n    (true (whiteArmies ?x))\n    (does white (commit ?x1))\n    (sum ?xNext ?x1 ?x))\n(<= (next (blackArmies ?xNext))\n    (true (blackArmies ?x))\n    (does black (commit ?x1))\n    (sum ?xNext ?x1 ?x))\n(<= terminal\n    (true (rounds ?x))\n    (true (maxRounds ?x)))\n(<= (goal white ?x)\n    (true (whiteScore ?x)))\n(<= (goal black ?x)\n    (true (blackScore ?x)))\n(<= (w1 2)\n    (does white (commit ?x1))\n    (does black (commit ?y1))\n    (gt ?x1 ?y1))\n(<= (b1 0)\n    (does white (commit ?x1))\n    (does black (commit ?y1))\n    (gt ?x1 ?y1))\n(<= (w1 0)\n    (does black (commit ?x1))\n    (does white (commit ?y1))\n    (gt ?x1 ?y1))\n(<= (b1 2)\n    (does black (commit ?x1))\n    (does white (commit ?y1))\n    (gt ?x1 ?y1))\n(<= (w1 1)\n    (does white (commit ?x1))\n    (does black (commit ?x1)))\n(<= (b1 1)\n    (does white (commit ?x1))\n    (does black (commit ?x1)))\n(<= (sum ?x 0 ?x)\n    (or (succ ?x ?y) (succ ?y ?x)))\n(<= (sum ?x ?y ?z)\n    (succ ?y0 ?y)\n    (succ ?z0 ?z)\n    (sum ?x ?y0 ?z0))\n(<= (gt ?a ?b)\n    (index ?x)\n    (not (succ ?x 1))\n    (sum ?b ?x ?a))\n(<= (gte ?a ?b)\n    (index ?x)\n    (sum ?b ?x ?a))\n(index 0)\n(index 1)\n(index 2)\n(index 3)\n(index 4)\n(index 5)\n(index 6)\n(index 7)\n(index 8)\n(index 9)\n(index 10)\n(index 11)\n(index 12)\n(index 13)\n(index 14)\n(index 15)\n(index 16)\n(index 17)\n(index 18)\n(index 19)\n(index 20)\n(succ 0 1)\n(succ 1 2)\n(succ 2 3)\n(succ 3 4)\n(succ 4 5)\n(succ 5 6)\n(succ 6 7)\n(succ 7 8)\n(succ 8 9)\n(succ 9 10)\n(succ 10 11)\n(succ 11 12)\n(succ 12 13)\n(succ 13 14)\n(succ 14 15)\n(succ 15 16)\n(succ 16 17)\n(succ 17 18)\n(succ 18 19)\n(succ 19 20)\n(succ 20 21)\n(succ 21 22)\n(succ 22 23)\n(succ 23 24)\n(succ 24 25)\n(succ 25 26)\n(succ 26 27)\n(succ 27 28)\n(succ 28 29)\n(succ 29 30)\n(succ 30 31)\n(succ 31 32)\n(succ 32 33)\n(succ 33 34)\n(succ 34 35)\n(succ 35 36)\n(succ 36 37)\n(succ 37 38)\n(succ 38 39)\n(succ 39 40)\n(succ 40 41)\n(succ 41 42)\n(succ 42 43)\n(succ 43 44)\n(succ 44 45)\n(succ 45 46)\n(succ 46 47)\n(succ 47 48)\n(succ 48 49)\n(succ 49 50)\n(succ 50 51)\n(succ 51 52)\n(succ 52 53)\n(succ 53 54)\n(succ 54 55)\n(succ 55 56)\n(succ 56 57)\n(succ 57 58)\n(succ 58 59)\n(succ 59 60)\n(succ 60 61)\n(succ 61 62)\n(succ 62 63)\n(succ 63 64)\n(succ 64 65)\n(succ 65 66)\n(succ 66 67)\n(succ 67 68)\n(succ 68 69)\n(succ 69 70)\n(succ 70 71)\n(succ 71 72)\n(succ 72 73)\n(succ 73 74)\n(succ 74 75)\n(succ 75 76)\n(succ 76 77)\n(succ 77 78)\n(succ 78 79)\n(succ 79 80)\n(succ 80 81)\n(succ 81 82)\n(succ 82 83)\n(succ 83 84)\n(succ 84 85)\n(succ 85 86)\n(succ 86 87)\n(succ 87 88)\n(succ 88 89)\n(succ 89 90)\n(succ 90 91)\n(succ 91 92)\n(succ 92 93)\n(succ 93 94)\n(succ 94 95)\n(succ 95 96)\n(succ 96 97)\n(succ 97 98)\n(succ 98 99)\n(succ 99 100)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game is played on two separate 3-by-3 grids, each with cells identified by coordinates (x, y) where x and y range from 1 to 3, forming the game environment's coordinate system. There are two players, designated as xplayer and oplayer, who alternate turns. Initially, all cells on both grids are blank. The player in control can make a move by marking one blank cell on the first grid and simultaneously marking one blank cell on the second grid with their respective symbol—'x' for xplayer and 'o' for oplayer. On a player's turn, they must specify an action of the form \"mark x1 y1 x2 y2,\" where (x1, y1) is a blank cell on the first grid and (x2, y2) is a blank cell on the second grid; this action is legal only if the player currently controls the turn and both chosen cells are unoccupied. If it is not a player's turn, the only legal action they may take is a noop, effectively passing without altering the state. When a player marks a cell, that cell becomes occupied by their mark, while all other cells retain their previous states. Control then passes to the opposing player. The game enforces implicit constraints such that the cells chosen for marking must be distinct, and all cell coordinates must fall within the 3x3 grid boundaries. The game terminates when either player achieves a \"line\" on either grid—this line is defined as any complete row, column, or diagonal filled entirely with that player's mark—or when no blank cells remain on a grid, i.e., the grid is \"not open.\" Scoring depends on the state of both grids at termination: a player scores 100 points if they have formed a line on both grids, 75 or 50 points if they have formed a line on one grid with the other grid either open or closed without a line, 25 points if neither grid contains a line but certain conditions are met, and 0 points if the opponent has formed lines or other conditions apply. Victory is determined based on these scores, rewarding players who successfully create lines on one or both grids while considering board occupancy and openness.",
    "output": "(role xplayer)\n(role oplayer)\n(init (cell1 1 1 b))\n(init (cell1 1 2 b))\n(init (cell1 1 3 b))\n(init (cell1 2 1 b))\n(init (cell1 2 2 b))\n(init (cell1 2 3 b))\n(init (cell1 3 1 b))\n(init (cell1 3 2 b))\n(init (cell1 3 3 b))\n(init (cell2 1 1 b))\n(init (cell2 1 2 b))\n(init (cell2 1 3 b))\n(init (cell2 2 1 b))\n(init (cell2 2 2 b))\n(init (cell2 2 3 b))\n(init (cell2 3 1 b))\n(init (cell2 3 2 b))\n(init (cell2 3 3 b))\n(init (control xplayer))\n(<= (legal ?player (mark ?x1 ?y1 ?x2 ?y2))\n    (true (control ?player))\n    (true (cell1 ?x1 ?y1 b))\n    (true (cell2 ?x2 ?y2 b)))\n(<= (legal xplayer noop)\n    (true (control oplayer)))\n(<= (legal oplayer noop)\n    (true (control xplayer)))\n(<= (next (cell1 ?x1 ?y1 x))\n    (does xplayer (mark ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell1 ?x1 ?y1 o))\n    (does oplayer (mark ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell1 ?x ?y ?mark))\n    (true (cell1 ?x ?y ?mark))\n    (does xplayer (mark ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x ?y ?x1 ?y1))\n(<= (next (cell1 ?x ?y ?mark))\n    (true (cell1 ?x ?y ?mark))\n    (does oplayer (mark ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x ?y ?x1 ?y1))\n(<= (next (cell2 ?x2 ?y2 x))\n    (does xplayer (mark ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell2 ?x2 ?y2 o))\n    (does oplayer (mark ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell2 ?x ?y ?mark))\n    (true (cell2 ?x ?y ?mark))\n    (does xplayer (mark ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x ?y ?x2 ?y2))\n(<= (next (cell2 ?x ?y ?mark))\n    (true (cell2 ?x ?y ?mark))\n    (does oplayer (mark ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x ?y ?x2 ?y2))\n(<= (next (control xplayer))\n    (true (control oplayer)))\n(<= (next (control oplayer))\n    (true (control xplayer)))\n(<= terminal\n    (line1 x))\n(<= terminal\n    (line1 o))\n(<= terminal\n    (not open1))\n(<= terminal\n    (line2 x))\n(<= terminal\n    (line2 o))\n(<= terminal\n    (not open2))\n(<= (goal xplayer 100)\n    goalXPlayer1100\n    goalXPlayer2100)\n(<= (goal xplayer 75)\n    goalXPlayer1100\n    goalXPlayer250)\n(<= (goal xplayer 75)\n    goalXPlayer150\n    goalXPlayer2100)\n(<= (goal xplayer 50)\n    goalXPlayer1100\n    goalXPlayer20)\n(<= (goal xplayer 50)\n    goalXPlayer150\n    goalXPlayer250)\n(<= (goal xplayer 50)\n    goalXPlayer10\n    goalXPlayer2100)\n(<= (goal xplayer 25)\n    goalXPlayer150\n    goalXPlayer20)\n(<= (goal xplayer 25)\n    goalXPlayer10\n    goalXPlayer250)\n(<= (goal xplayer 0)\n    goalXPlayer10\n    goalXPlayer20)\n(<= (goal oplayer 100)\n    goalOPlayer1100\n    goalOPlayer2100)\n(<= (goal oplayer 75)\n    goalOPlayer1100\n    goalOPlayer250)\n(<= (goal oplayer 75)\n    goalOPlayer150\n    goalOPlayer2100)\n(<= (goal oplayer 50)\n    goalOPlayer1100\n    goalOPlayer20)\n(<= (goal oplayer 50)\n    goalOPlayer150\n    goalOPlayer250)\n(<= (goal oplayer 50)\n    goalOPlayer10\n    goalOPlayer2100)\n(<= (goal oplayer 25)\n    goalOPlayer150\n    goalOPlayer20)\n(<= (goal oplayer 25)\n    goalOPlayer10\n    goalOPlayer250)\n(<= (goal oplayer 0)\n    goalOPlayer10\n    goalOPlayer20)\n(<= goalXPlayer1100\n    (line1 x))\n(<= goalXPlayer150\n    (not (line1 x))\n    (not (line1 o))\n    (not open1))\n(<= goalXPlayer10\n    (line1 o))\n(<= goalXPlayer10\n    (not (line1 x))\n    (not (line1 o))\n    open1)\n(<= goalOPlayer1100\n    (line1 o))\n(<= goalOPlayer150\n    (not (line1 x))\n    (not (line1 o))\n    (not open1))\n(<= goalOPlayer10\n    (line1 x))\n(<= goalOPlayer10\n    (not (line1 x))\n    (not (line1 o))\n    open1)\n(<= goalXPlayer2100\n    (line2 x))\n(<= goalXPlayer250\n    (not (line2 x))\n    (not (line2 o))\n    (not open2))\n(<= goalXPlayer20\n    (line2 o))\n(<= goalXPlayer20\n    (not (line2 x))\n    (not (line2 o))\n    open2)\n(<= goalOPlayer2100\n    (line2 o))\n(<= goalOPlayer250\n    (not (line2 x))\n    (not (line2 o))\n    (not open2))\n(<= goalOPlayer20\n    (line2 x))\n(<= goalOPlayer20\n    (not (line2 x))\n    (not (line2 o))\n    open2)\n(<= (row1 ?x ?mark)\n    (true (cell1 ?x 1 ?mark))\n    (true (cell1 ?x 2 ?mark))\n    (true (cell1 ?x 3 ?mark)))\n(<= (column1 ?y ?mark)\n    (true (cell1 1 ?y ?mark))\n    (true (cell1 2 ?y ?mark))\n    (true (cell1 3 ?y ?mark)))\n(<= (diagonal1 ?mark)\n    (true (cell1 1 1 ?mark))\n    (true (cell1 2 2 ?mark))\n    (true (cell1 3 3 ?mark)))\n(<= (diagonal1 ?mark)\n    (true (cell1 1 3 ?mark))\n    (true (cell1 2 2 ?mark))\n    (true (cell1 3 1 ?mark)))\n(<= (line1 ?mark)\n    (row1 ?x ?mark))\n(<= (line1 ?mark)\n    (column1 ?y ?mark))\n(<= (line1 ?mark)\n    (diagonal1 ?mark))\n(<= open1\n    (true (cell1 ?x ?y b)))\n(<= (row2 ?x ?mark)\n    (true (cell2 ?x 1 ?mark))\n    (true (cell2 ?x 2 ?mark))\n    (true (cell2 ?x 3 ?mark)))\n(<= (column2 ?y ?mark)\n    (true (cell2 1 ?y ?mark))\n    (true (cell2 2 ?y ?mark))\n    (true (cell2 3 ?y ?mark)))\n(<= (diagonal2 ?mark)\n    (true (cell2 1 1 ?mark))\n    (true (cell2 2 2 ?mark))\n    (true (cell2 3 3 ?mark)))\n(<= (diagonal2 ?mark)\n    (true (cell2 1 3 ?mark))\n    (true (cell2 2 2 ?mark))\n    (true (cell2 3 1 ?mark)))\n(<= (line2 ?mark)\n    (row2 ?x ?mark))\n(<= (line2 ?mark)\n    (column2 ?y ?mark))\n(<= (line2 ?mark)\n    (diagonal2 ?mark))\n(<= open2\n    (true (cell2 ?x ?y b)))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (cell ?x1 ?y1)\n    (cell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(cell 1 1) (cell 1 2) (cell 1 3)\n(cell 2 1) (cell 2 2) (cell 2 3)\n(cell 3 1) (cell 3 2) (cell 3 3)\n(markType x) (markType o) (markType b)"
  },
  {
    "instruction": "You are an expert in the Game Description Language (GDL) used by the General Game Playing community. Your task is to translate the provided natural-language rules into GDL.",
    "input": "The game takes place on a 6-by-6 grid with coordinates labeled from 1 to 6 along both the x (horizontal) and y (vertical) axes. There are two players, named white and black, who alternate turns starting with white. Initially, white occupies all cells in the first and second rows, while black occupies all cells in the fifth and sixth rows, with control set to white to begin the game. On a player's turn, they may either move one of their pieces or perform a noop action, which is only allowed when it is not their turn, effectively passing control. Moves consist of relocating a piece from one cell to another adjacent cell that is one step forward in the y-direction (toward the opponent's side), either directly forward or diagonally one cell to the left or right. For white, this means moving from row y to y+1; for black, moving from y to y-1. Moves are only legal if the destination cell is within the board boundaries, unoccupied by the player's own pieces (captures are not explicitly defined, so moving onto an opponent's piece is disallowed), and must not result in overlapping pieces. After a move, the piece's position updates to the new cell, and the previous cell becomes empty. Control then switches to the opposing player. The game ends when either a white piece reaches the sixth row or a black piece reaches the first row, or if a player loses all their pieces. Upon termination, the player who fulfilled these winning conditions is declared the winner, earning a score of 100, while the loser scores 0. If the game is ongoing, both players have a score of 100. This setup enforces boundaries on movement, prohibits overlapping or moving backward, and ensures strict alternation of turns with the possibility of noop moves when out of turn.",
    "output": "(role white)\n(role black)\n(init (cell 1 1 white))\n(init (cell 2 1 white))\n(init (cell 3 1 white))\n(init (cell 4 1 white))\n(init (cell 5 1 white))\n(init (cell 6 1 white))\n(init (cell 1 2 white))\n(init (cell 2 2 white))\n(init (cell 3 2 white))\n(init (cell 4 2 white))\n(init (cell 5 2 white))\n(init (cell 6 2 white))\n(init (cell 1 5 black))\n(init (cell 2 5 black))\n(init (cell 3 5 black))\n(init (cell 4 5 black))\n(init (cell 5 5 black))\n(init (cell 6 5 black))\n(init (cell 1 6 black))\n(init (cell 2 6 black))\n(init (cell 3 6 black))\n(init (cell 4 6 black))\n(init (cell 5 6 black))\n(init (cell 6 6 black))\n(init (control white))\n(<= (legal white (move ?x ?y1 ?x ?y2))\n    (true (control white))\n    (true (cell ?x ?y1 white))\n    (plusplus ?y1 ?y2)\n    (cellEmpty ?x ?y2))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cell ?x1 ?y1 white))\n    (plusplus ?y1 ?y2)\n    (plusplus ?x1 ?x2)\n    (not (true (cell ?x2 ?y2 white))))\n(<= (legal white (move ?x1 ?y1 ?x2 ?y2))\n    (true (control white))\n    (true (cell ?x1 ?y1 white))\n    (plusplus ?y1 ?y2)\n    (plusplus ?x2 ?x1)\n    (not (true (cell ?x2 ?y2 white))))\n(<= (legal black (move ?x ?y1 ?x ?y2))\n    (true (control black))\n    (true (cell ?x ?y1 black))\n    (plusplus ?y2 ?y1)\n    (cellEmpty ?x ?y2))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cell ?x1 ?y1 black))\n    (plusplus ?y2 ?y1)\n    (plusplus ?x1 ?x2)\n    (not (true (cell ?x2 ?y2 black))))\n(<= (legal black (move ?x1 ?y1 ?x2 ?y2))\n    (true (control black))\n    (true (cell ?x1 ?y1 black))\n    (plusplus ?y2 ?y1)\n    (plusplus ?x2 ?x1)\n    (not (true (cell ?x2 ?y2 black))))\n(<= (legal white noop)\n    (true (control black)))\n(<= (legal black noop)\n    (true (control white)))\n(<= (next (cell ?x2 ?y2 ?player))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2)))\n(<= (next (cell ?x3 ?y3 ?state))\n    (true (cell ?x3 ?y3 ?state))\n    (role ?player)\n    (does ?player (move ?x1 ?y1 ?x2 ?y2))\n    (distinctCell ?x1 ?y1 ?x3 ?y3)\n    (distinctCell ?x2 ?y2 ?x3 ?y3))\n(<= (next (control white))\n    (true (control black)))\n(<= (next (control black))\n    (true (control white)))\n(<= terminal\n    whiteWin)\n(<= terminal\n    blackWin)\n(<= (goal white 0)\n    whiteWin)\n(<= (goal white 100)\n    (not whiteWin))\n(<= (goal black 0)\n    blackWin)\n(<= (goal black 100)\n    (not blackWin))\n(<= (validCell ?x ?y)\n    (index ?x)\n    (index ?y))\n(<= (cellEmpty ?x ?y)\n    (validCell ?x ?y)\n    (not (true (cell ?x ?y white)))\n    (not (true (cell ?x ?y black))))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (validCell ?x1 ?y1)\n    (validCell ?x2 ?y2)\n    (distinct ?x1 ?x2))\n(<= (distinctCell ?x1 ?y1 ?x2 ?y2)\n    (validCell ?x1 ?y1)\n    (validCell ?x2 ?y2)\n    (distinct ?y1 ?y2))\n(<= whiteWin\n    (index ?x)\n    (true (cell ?x 6 white)))\n(<= blackWin\n    (index ?x)\n    (true (cell ?x 1 black)))\n(<= whiteWin\n\t(not blackCell))\n(<= blackWin\n\t(not whiteCell))\n(<= whiteCell\n\t(validCell ?x ?y)\n\t(true (cell ?x ?y white)))\n(<= blackCell\n\t(validCell ?x ?y)\n\t(true (cell ?x ?y black)))\n(index 1) (index 2) (index 3) (index 4) (index 5) (index 6)\n(plusplus 1 2)  (plusplus 2 3)  (plusplus 3 4)  (plusplus 4 5)  (plusplus 5 6)"
  }
]